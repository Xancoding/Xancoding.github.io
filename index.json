[{"content":"链表\n线性表的链式存储结构 单向链表\n有头结点\nL 为头指针，当 L == NULL 时，链表为空 无头结点\n头指针 L 指向的结点为头结点，头结点的直接后继是第一个结点 当 L-\u0026gt;next == NULL 时，链表为空 单向循环链表\n带头指针的单向循环链表\n有头结点 当 L-\u0026gt;next == L 时，链表为空 无头结点 当 L == NULL 时，链表为空 带尾指针的单向循环链表\n有头结点 R-\u0026gt;next 为头结点 当 R-\u0026gt;next == R 时，链表为空 无头结点 R-\u0026gt;next 为第一个结点 当 R == NULL 时，链表为空 双向循环链表\n有头结点 当 L-\u0026gt;next == L＆＆ L-\u0026gt;pre == L 时，链表为空 填空题 顺序表结构适宜于进行随机存取，而链表适宜于进行顺序存取 链队列删除操作时，如果删除的是最后一个元素，则需要将 Q.rear = Q.front ","permalink":"https://zagxuy.github.io/posts/table/","summary":"链表\n线性表的链式存储结构 单向链表\n有头结点\nL 为头指针，当 L == NULL 时，链表为空 无头结点\n头指针 L 指向的结点为头结点，头结点的直接后继是第一个结点 当 L-\u0026gt;next == NULL 时，链表为空 单向循环链表\n带头指针的单向循环链表\n有头结点 当 L-\u0026gt;next == L 时，链表为空 无头结点 当 L == NULL 时，链表为空 带尾指针的单向循环链表\n有头结点 R-\u0026gt;next 为头结点 当 R-\u0026gt;next == R 时，链表为空 无头结点 R-\u0026gt;next 为第一个结点 当 R == NULL 时，链表为空 双向循环链表\n有头结点 当 L-\u0026gt;next == L＆＆ L-\u0026gt;pre == L 时，链表为空 填空题 顺序表结构适宜于进行随机存取，而链表适宜于进行顺序存取 链队列删除操作时，如果删除的是最后一个元素，则需要将 Q.rear = Q.front ","title":"Table"},{"content":"图\n邻接矩阵 typedef struct { char vexs[MAX][NUM];; //顶点信息 int arcs[MAX][MAX]; //边或弧上的权值 int vex; //顶点数 int arc; //弧数 }graph, *graphlink; 邻接表 #define MAX 20 //最大顶点数 #define NUM 20 //最大字符串长度 //边结点 typedef struct arcnode { int adjvex; //弧所指向顶点下标 struct arcnode *next; //指向下一条弧 int weight; //边结点类型（权重） }arcnode; //表头结点 typedef struct vexnode { char vertex[NUM]; //存放结点值 arcnode *head; //存放边链表头指针 }vexnode; //邻接表 typedef struct graph{ vexnode adjlist[MAX]; int vex; //顶点数 int arc; //边数 }graph, *graphlink; 最小生成树 Prim 稠密图 设 G = (V, {E}) 是连通图，最小生成树 T 的顶点集合为 U，边的集合是 TE 初始：U = { u0 } ( u0∈V ) ， TE = Ø 重复执行下述操作：在所有 u ∈U， v∈W 的边 (u，v) ∈E 中找一条代价最小的边 (ui ，v0) 并入集合 TE，同时 v0 并入 U，直到 U = V 为止 设置一个辅助数组 (最小代价数组)，对当前 V－U 集合 中的每个顶点，记录与顶点集 U 中顶点相连接的代价最小的边 void crt_graph(graphlink G) { printf(\u0026#34;输入顶点数和边数（空格隔开）\\n\u0026#34;); scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;G-\u0026gt;vex, \u0026amp;G-\u0026gt;arc); //顶点数和边数 printf(\u0026#34;输入顶点信息\\n\u0026#34;); for (int i = 1; i \u0026lt;= G-\u0026gt;vex; i++) scanf(\u0026#34;%s\u0026#34;, G-\u0026gt;vexs[i]); //顶点信息 for (int i = 1; i \u0026lt;= G-\u0026gt;vex; i++) for (int j = 1; j \u0026lt;= G-\u0026gt;vex; j++) G-\u0026gt;arcs[i][j] = INF; //邻接矩阵初始化 printf(\u0026#34;输入边和权值（空格隔开）\\n\u0026#34;); for (int k = 1; k \u0026lt;= G-\u0026gt;arc; k++) { //读入边 int i, j, w; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;i, \u0026amp;j, \u0026amp;w); G-\u0026gt;arcs[i][j] = w; G-\u0026gt;arcs[j][i] = w; } } void prim(graphlink G, int v, lowcost lc[]) { int total = 0; //边权总和 int st[MAX] = {0}; //存储每个点是否已经在生成树中 st[v] = 1; for (int i = 1; i \u0026lt;= G-\u0026gt;vex; i++) { //初始化 lc[i].weight = G-\u0026gt;arcs[v][i]; if (lc[i].weight == INF) lc[i].adjnode = -1; else lc[i].adjnode = v; } for (int i = 1; i \u0026lt;= G-\u0026gt;vex - 1; i++) { //循环 G-\u0026gt;vex - 1 次 int min = INF; //其他点到当前最小生成树的最短距离 int pos = -1; //到当前最小生成树的最短距离的点 for (int k = 1; k \u0026lt;= G-\u0026gt;vex; k++) //选出权值最小的边 if (st[k] == 0 \u0026amp;\u0026amp; lc[k].weight \u0026lt; min) { min = lc[k].weight; pos = k; } total += min; st[pos] = 1; //已在最小生成树中的点 //更新其他点到当前最小生成树的距离 for (int k = 1; k \u0026lt;= G-\u0026gt;vex; k++) if (st[k] == 0 \u0026amp;\u0026amp; G-\u0026gt;arcs[pos][k] \u0026lt; lc[k].weight) { lc[k].weight = G-\u0026gt;arcs[pos][k]; lc[k].adjnode = pos; } } printf(\u0026#34;边权总和为：%d\\n\u0026#34;, total); print_MST(G, lc); } Kruskal 稀疏图 先构造一个只含 n 个顶点的子图 SG，然后从权值最小的 边 (u, v) 开始 (u, v 不在同一个连通图)，若它的添加不使 SG 中产生回路，则在 SG 中加上这条边，如此重复，直至加上 n-1 条边为止 void crt_graph(graphlink G) { printf(\u0026#34;输入顶点数和边数（空格隔开）\\n\u0026#34;); scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;G-\u0026gt;vex, \u0026amp;G-\u0026gt;arc); //顶点数和边数 printf(\u0026#34;输入顶点信息\\n\u0026#34;); for (int i = 1; i \u0026lt;= G-\u0026gt;vex; i++) scanf(\u0026#34;%s\u0026#34;, G-\u0026gt;vexs[i]); //顶点信息 for (int i = 1; i \u0026lt;= G-\u0026gt;vex; i++) for (int j = 1; j \u0026lt;= G-\u0026gt;vex; j++) G-\u0026gt;arcs[i][j] = INF; //邻接矩阵初始化 printf(\u0026#34;输入边和权值（空格隔开）\\n\u0026#34;); for (int k = 1; k \u0026lt;= G-\u0026gt;arc; k++) { //读入边 int i, j, w; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;i, \u0026amp;j, \u0026amp;w); G-\u0026gt;arcs[i][j] = w; G-\u0026gt;arcs[j][i] = w; } } void Kruskal(graphlink G, edge edges[], int fa[]) { init(G, edges, fa); //初始化 int cnt = 0; //合并次数 int k = 0; //边的下标 int total = 0; //边权总和 while (cnt \u0026lt; G-\u0026gt;vex - 1) { int x = get_father(edges[k].a, fa); int y = get_father(edges[k].b, fa); if (x != y) { fa[x] = y; //合并到一棵生成树 total += edges[k].w; edges[k].flag = 1; cnt++; } k++; } printf(\u0026#34;边权总和为：%d\\n\u0026#34;, total); print_MST(G, edges, k); } 最短路径 Dijkstra 稠密图\n从源点到其余各点的最短路径\n首先将网中的所有顶点分成两个集合S和T：\nS：凡以v0为源点，已经确定了最短路径的终点并入集合S。S的初始状态只包含v0。\nT：尚未确定最短路径的顶点的集合。其初始状态包含除源点外的所有顶点\n引进两个辅助数组来记源点 (设其编号为 v0) 到其它顶点的最短路径长度和路径集合\nDist[i]：表示 v0 到顶点 vi 的最短路径的长度 Path[i]: 表示以上路径中所经过的顶点集合 重复执行下述操作，直到选够 n-1 条路径：\n设下一条所选路径的终点为 vk ，则：dist[k]= min{dist[i]︱i∈T}，将 k 加入到 S 中 修改 dist[i] {i∈T}， dist[i]=min{dist[i]，dist[k] + arcs[k][i]︱k∈S，i∈T} void crt_graph(graphlink G) { printf(\u0026#34;输入顶点数和边数（空格隔开）\\n\u0026#34;); scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;G-\u0026gt;vex, \u0026amp;G-\u0026gt;arc); //顶点数和边数 printf(\u0026#34;输入顶点信息\\n\u0026#34;); for (int i = 1; i \u0026lt;= G-\u0026gt;vex; i++) scanf(\u0026#34;%s\u0026#34;, G-\u0026gt;vexs[i]); //顶点信息 for (int i = 1; i \u0026lt;= G-\u0026gt;vex; i++) for (int j = 1; j \u0026lt;= G-\u0026gt;vex; j++) { G-\u0026gt;arcs[i][j] = INF; //邻接矩阵初始化 if (i == j) G-\u0026gt;arcs[i][j] = 0; } printf(\u0026#34;输入边和权值（空格隔开）\\n\u0026#34;); for (int k = 1; k \u0026lt;= G-\u0026gt;arc; k++) { //读入边 int i, j, w; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;i, \u0026amp;j, \u0026amp;w); G-\u0026gt;arcs[i][j] = w; } } void dijkstra(graphlink G, int v, shortdist dist[]) { int flag[MAX] = {0}; flag[v] = 1; for (int i = 1; i \u0026lt;= G-\u0026gt;vex; i++) { //dist数组初始化 dist[i].distance = G-\u0026gt;arcs[v][i]; if (G-\u0026gt;arcs[v][i] != INF) dist[i].path = v; else dist[i].path = -1; } while (1) { //按距离递增顺序找出从v出发到其余各顶点的最短路径 int pos = v; int min = INF; //距离最小值 for (int i = 1; i \u0026lt;= G-\u0026gt;vex; i++) if(flag[i] == 0 \u0026amp;\u0026amp; dist[i].distance \u0026lt; min) { min = dist[i].distance; pos = i; } if (min == INF) break; //算法结束 flag[pos] = 1; //对已完成的顶点做标记 for (int i = 1; i \u0026lt;= G-\u0026gt;vex; i++) //更新dist if (flag[i] == 0 \u0026amp;\u0026amp; dist[pos].distance + G-\u0026gt;arcs[pos][i] \u0026lt; dist[i].distance) { dist[i].distance = dist[pos].distance + G-\u0026gt;arcs[pos][i]; dist[i].path = pos; } } print_path(G ,dist, v); } Floyd 稠密图 每一对顶点之间的最短路径 dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]) void crt_graph(graphlink G) { printf(\u0026#34;输入顶点数和边数（空格隔开）\\n\u0026#34;); scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;G-\u0026gt;vex, \u0026amp;G-\u0026gt;arc); //顶点数和边数 printf(\u0026#34;输入顶点信息\\n\u0026#34;); for (int i = 1; i \u0026lt;= G-\u0026gt;vex; i++) scanf(\u0026#34;%s\u0026#34;, G-\u0026gt;vexs[i]); //顶点信息 for (int i = 1; i \u0026lt;= G-\u0026gt;vex; i++) for (int j = 1; j \u0026lt;= G-\u0026gt;vex; j++) { G-\u0026gt;arcs[i][j] = INF; //邻接矩阵初始化 if (i == j) G-\u0026gt;arcs[i][j] = 0; } printf(\u0026#34;输入边和权值（空格隔开）\\n\u0026#34;); for (int k = 1; k \u0026lt;= G-\u0026gt;arc; k++) { //读入边 int i, j, w; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;i, \u0026amp;j, \u0026amp;w); G-\u0026gt;arcs[i][j] = w; } } \u001b[Ovoid floyd(graphlink G, int dist[][MAX], int path[][MAX]) { for (int i = 1; i \u0026lt;= G-\u0026gt;vex; i++) //初始化 for (int j = 1; j \u0026lt;= G-\u0026gt;vex; j++) { dist[i][j] = G-\u0026gt;arcs[i][j]; path[i][j] = i; if (dist[i][j] == 0 || dist[i][j] == INF) path[i][j] = -1; \u001b[I } for (int k = 1; k \u0026lt;= G-\u0026gt;vex; k++) //对每一个顶点做一次迭代 for (int i = 1; i \u0026lt;= G-\u0026gt;vex; i++) for (int j = 1; j \u0026lt;= G-\u0026gt;vex; j++) if (dist[i][k] + dist[k][j] \u0026lt; dist[i][j]) { dist[i][j] = dist[i][k] + dist[k][j]; path[i][j] = k; } print_path(G, dist, path); } 拓扑排序 特点 一个有向图的拓扑序列一般不唯一 有向无环图一定存在拓扑序列 算法描述 如果顶点没有全部输出，则说明有向图中存在环 在有向图中选一个 入度为零的顶点 且输出 将图中与该顶点有关的边的 弧头顶点的入度减 1 重复上述两步，直至所有满足条件的顶点均已输出 AOE 网络关键路径 AOE 网络：以顶点表示事件，弧表示活动，权表示活动持续的时间的带权有向无环图\n只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始\n只有在指向某一顶点的各有向边所代表的活动都己经结束后，该顶点所代表的事件才能发生\n假设 AOE 网络表示施工流程图，弧上权值表示完成该子工程所需时间\n关键活动：关键路径上的所有活动 关键路径：整个工程完成的最短时间（从 AOE 网络的 源点 到 汇点 的最长路径长度） 如何求关键活动\n假设活动 a(i) 是弧 \u0026lt;j,k\u0026gt; 上的活动，j 为弧尾顶点，k 为弧头 事件（顶点）最早发生时间ve[j]：从 源点 开始到 顶点 j 的最大路径长度 事件（顶点）最迟发生时间vl[k]：从 顶点 k 到 汇点 的最大路径长度 活动 ai（弧）最早开始时间ee[i] ：ee[i] = ve[j] 活动 ai（弧）最迟开始时间el[i] ：el[i] = vl[k] - w (\u0026lt;j, k\u0026gt;) el [i] - ee [i]： 完成活动 ai 的余量 当 el [i] = ee [i]时，ai 为关键活动 事件发生时间计算公式\n初始化每个点 Ve (i) = 0 Vl (i) = Ve (汇点) 求 Ve (j) 和 Vl (j) 需分两步进行 从 Ve(i) = 0 开始向前递推: Ve(j) = max{Ve(i) + weight (\u0026lt;i，j\u0026gt;)} i∈P (j)\n其中：P(j) 是以 j 为弧头的弧尾顶点的集合，计算时按拓扑顺序进行 从 Vl (i) = Ve (汇点) 起向后递推: **Vl (j) = min{Vl (k) - weight (\u0026lt;j，k\u0026gt;}**k∈S (j)\n其中：S (j) 是以 j 为弧尾的弧头顶点的集合，计算时按逆拓扑顺序进行 填空题 n 个顶点 e 条边的图，若采用邻接矩阵存储，则空间复杂度为 O (n2) n 个顶点 e 条边的图，若采用 邻接表 存储，则空间复杂度为 O (n + e) n 个顶点 e 条边的图采用 邻接矩阵 存储，深度优先遍历算法和广度优先遍历算法的时间复杂度都为 O (n2)；若采用 邻接表 存储时，算法的时间复杂度为 O (n + e) 用 普里姆 (Prim) 算法求具有 n 个顶点 e 条边的图的最小生成树的时间复杂度为 O (n2) ；用 克鲁斯卡尔 (Kruskal) 算法的时间复杂度是 O (elog2e) 若要求一个稀疏图 G 的最小生成树，最好用 克鲁斯卡尔 (Kruskal) 算法来求解 若要求一个稠密图 G 的最小生成树，最好用 普里姆 (Prim) 算法来求解 图的深度优先等价于树的先序遍历 AOV 网中, 结点表示活动，边表示活动间的优先关系。AOE 网中, 结点表示事件，边表示活动 下列 AOE 网表示一项包含 8 个活动的工程。通过同时加快若干活动的进度可以缩短整个工程的工期。下列选项中，加快其进度就可以缩短工程工期的是（ ） 用有向无环图描述表达式 (A+B)*((A+B)/A), 至少需要顶点的数目为 ( ) 若无向图 G = (V, E) 中含 7 个顶点，则保证图 G 在任何连边方式下都是连通的，则需要的边数最少是（ ）\n","permalink":"https://zagxuy.github.io/posts/search/","summary":"图\n邻接矩阵 typedef struct { char vexs[MAX][NUM];; //顶点信息 int arcs[MAX][MAX]; //边或弧上的权值 int vex; //顶点数 int arc; //弧数 }graph, *graphlink; 邻接表 #define MAX 20 //最大顶点数 #define NUM 20 //最大字符串长度 //边结点 typedef struct arcnode { int adjvex; //弧所指向顶点下标 struct arcnode *next; //指向下一条弧 int weight; //边结点类型（权重） }arcnode; //表头结点 typedef struct vexnode { char vertex[NUM]; //存放结点值 arcnode *head; //存放边链表头指针 }vexnode; //邻接表 typedef struct graph{ vexnode adjlist[MAX]; int vex; //顶点数 int arc; //边数 }graph, *graphlink; 最小生成树 Prim 稠密图 设 G = (V, {E}) 是连通图，最小生成树 T 的顶点集合为 U，边的集合是 TE 初始：U = { u0 } ( u0∈V ) ， TE = Ø 重复执行下述操作：在所有 u ∈U， v∈W 的边 (u，v) ∈E 中找一条代价最小的边 (ui ，v0) 并入集合 TE，同时 v0 并入 U，直到 U = V 为止 设置一个辅助数组 (最小代价数组)，对当前 V－U 集合 中的每个顶点，记录与顶点集 U 中顶点相连接的代价最小的边 void crt_graph(graphlink G) { printf(\u0026#34;输入顶点数和边数（空格隔开）\\n\u0026#34;); scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;G-\u0026gt;vex, \u0026amp;G-\u0026gt;arc); //顶点数和边数 printf(\u0026#34;输入顶点信息\\n\u0026#34;); for (int i = 1; i \u0026lt;= G-\u0026gt;vex; i++) scanf(\u0026#34;%s\u0026#34;, G-\u0026gt;vexs[i]); //顶点信息 for (int i = 1; i \u0026lt;= G-\u0026gt;vex; i++) for (int j = 1; j \u0026lt;= G-\u0026gt;vex; j++) G-\u0026gt;arcs[i][j] = INF; //邻接矩阵初始化 printf(\u0026#34;输入边和权值（空格隔开）\\n\u0026#34;); for (int k = 1; k \u0026lt;= G-\u0026gt;arc; k++) { //读入边 int i, j, w; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;i, \u0026amp;j, \u0026amp;w); G-\u0026gt;arcs[i][j] = w; G-\u0026gt;arcs[j][i] = w; } } void prim(graphlink G, int v, lowcost lc[]) { int total = 0; //边权总和 int st[MAX] = {0}; //存储每个点是否已经在生成树中 st[v] = 1; for (int i = 1; i \u0026lt;= G-\u0026gt;vex; i++) { //初始化 lc[i].","title":"Search"},{"content":"排序\n插入排序 直接插入排序 稳定 将 a[i]插入前面已经排好序的 a[1]~a[i - 1]中 在 a[0] 处设置岗哨，使 a[0] == a[i] 避免查找插入位置时对下标越界的检查 将 a[i]依次与 a[i - 1]，a[i - 2]，\u0026hellip; ，a[1]比较，直到 a[j] \u0026lt;= a[i]，再将 a[i]插到 a[j]之后 希尔排序 不稳定 基本思想：先取一个正整数 d1 \u0026lt; n，把所有相隔 d1 的记录放一组，组内进行直接插入排序；然后取 d2 \u0026lt; d1，重复上述分组和排序操作；直至 di = 1，即所有记录放进一个组中进行一趟直接插入排序为止 具体做法： 取 d1 = ⌊n / 2⌋ 每一趟 d i = ⌊d i - 1 / 2⌋ 直至 d k = 1结束 void shell_pass(int a[], int step) { for (int i = step + 1; i \u0026lt;= n; i++) { int tmp = a[i]; int j = i - step; while(j \u0026gt;= 1 \u0026amp;\u0026amp; tmp \u0026lt; a[j]) { a[j + step] = a[j]; j = j - step; } a[j + step] = tmp; } } void shell_sort(int a[], int d[]) {\t//需t趟完成排序 for (int k = 0; k \u0026lt; t; k++) shell_pass (a, d[k]); } 交换排序 冒泡排序 稳定 沉底法 快速排序 不稳定\n时间性能\n最坏（基本有序时）：O ( n 2 ) 最好（每次划分恰好两个子序列长度相等）：O (nlogn) 空间性能\n递归调用，存储开销 最好：O (logn) 最坏：O ( n ) 将 a[0] 设为哨兵，存储每次选中的关键字\n基本思想：在待排序列中选一个关键字，按某一规律进行多次比较交换后，它移到某一位置，此元素将记录分割成独立的两部分，它左边的关键字都小于或等于它，右边的关键字都大于或等于它。之后对这两部分分别进行快速排序\nint partition(SqList L, int low, int high) { L.r[0] = L.r[low]; while (low \u0026lt; high) { while (low \u0026lt; high \u0026amp;\u0026amp; L.r[0] \u0026lt;= L.r[high]) high--; L.r[low] = L.r[high]; while (low \u0026lt; high \u0026amp;\u0026amp; L.r[0] \u0026gt;= L.r[low]) low++; L.r[high] = L.r[low]; } L.r[low] = L.r[0]; return low; } void quick_sort (SqList L, int low, int high) { if (low \u0026lt; high) { int pos = partition(L, low, high); quick_sort(L, low, pos - 1); quick_sort(L, pos + 1, high); } } 选择排序 简单选择排序 不稳定 第 i 趟排序从待排序记录里选出最小关键字值的记录与第 i 个记录交换（1 \u0026lt;= i \u0026lt;= n - 1） 堆排序 不稳定 初始建堆：将 n 个元素的序列看成是一个完全二叉树，则最后一个非叶子结点是第 ⌊n / 2⌋ 个元素. 从第 ⌊n / 2⌋ 个元素开始 down，一直 down 到第 1 个元素，就建立了堆 二路归并排序 稳定 时间性能：O (nlogn) 空间性能：O (n) 基本思想：设初始序列含有 n 个记录，归并排序把此序列看成是由 n 个只包含一个记录的有序表组成，然后进行两两归并，最后形成包含 n 个记录的有序表 开始时取 L = 1，第一趟归并排序后，L = L * 2，以此类推，直到排序结束 ","permalink":"https://zagxuy.github.io/posts/sort/","summary":"排序\n插入排序 直接插入排序 稳定 将 a[i]插入前面已经排好序的 a[1]~a[i - 1]中 在 a[0] 处设置岗哨，使 a[0] == a[i] 避免查找插入位置时对下标越界的检查 将 a[i]依次与 a[i - 1]，a[i - 2]，\u0026hellip; ，a[1]比较，直到 a[j] \u0026lt;= a[i]，再将 a[i]插到 a[j]之后 希尔排序 不稳定 基本思想：先取一个正整数 d1 \u0026lt; n，把所有相隔 d1 的记录放一组，组内进行直接插入排序；然后取 d2 \u0026lt; d1，重复上述分组和排序操作；直至 di = 1，即所有记录放进一个组中进行一趟直接插入排序为止 具体做法： 取 d1 = ⌊n / 2⌋ 每一趟 d i = ⌊d i - 1 / 2⌋ 直至 d k = 1结束 void shell_pass(int a[], int step) { for (int i = step + 1; i \u0026lt;= n; i++) { int tmp = a[i]; int j = i - step; while(j \u0026gt;= 1 \u0026amp;\u0026amp; tmp \u0026lt; a[j]) { a[j + step] = a[j]; j = j - step; } a[j + step] = tmp; } } void shell_sort(int a[], int d[]) {\t//需t趟完成排序 for (int k = 0; k \u0026lt; t; k++) shell_pass (a, d[k]); } 交换排序 冒泡排序 稳定 沉底法 快速排序 不稳定","title":"Sort"},{"content":"Xan 一名 NCEPU CS 大二在读学生，喜欢跑步、徒步\n","permalink":"https://zagxuy.github.io/about/","summary":"Xan 一名 NCEPU CS 大二在读学生，喜欢跑步、徒步","title":""},{"content":"博客 Owen 的博客 程序员的喵 阮一峰的网络日志 工具 Obsidian 知识管理工具 划词翻译 浏览器翻译插件 ","permalink":"https://zagxuy.github.io/links/","summary":"博客 Owen 的博客 程序员的喵 阮一峰的网络日志 工具 Obsidian 知识管理工具 划词翻译 浏览器翻译插件 ","title":""}]