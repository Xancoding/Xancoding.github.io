[{"content":" 从今天开始，为自己种下一棵树 🌳\n2025届毕业生 学习路线 算法（每天都看） 针对性刷题 C++ （2个月） 《C++ Primer》、《Effective C++》、《程序员的自我修养》、侯捷老师的视频 《C++ Primer》--\u0026gt; 《Effective C++》--\u0026gt;《深度探索 C++ 对象模型》--\u0026gt;《STL 源码剖析》--\u0026gt;《Effective STL》--\u0026gt;《C++ 并发编程实战》 操作系统（2个月） 《操作系统真象还原》 《操作系统导论》--\u0026gt;《现代操作系统》--\u0026gt;《操作系统：精髓与设计原理》 数据库（2个月） 《MySQL必知必会》、《MySQL是怎样运行的》、《Redis设计与实现》 《MySQL是怎样运行的》--\u0026gt;《MySQL必知必会》--\u0026gt;《MySQL45讲》 《Redis设计与实现》--\u0026gt;《Redis实战》 Linux 网络编程（2个月） 《TCP/IP 网络编程》--\u0026gt;《Linux高性能服务器编程》--\u0026gt;《UNIX环境高级编程》--\u0026gt;《Unix网络编程》 计算机网络 《TCP/IP网络编程》、《Linux高性能服务器》 《计算机网络：自顶向下方法》\u0026amp;\u0026amp;《TCP/IP详解 卷1：协议》 项目（2个月）\nMyTinySTL Stanford CS144 Lab Assignment 学习笔记 | ViXbob的博客 TinyWebServer 其他（2个月）\n《深入理解计算机系统》\u0026amp;\u0026amp;《计算机程序的构造和解释》 时间规划 大二上：2022年9月初\u0026ndash;2023年1月初 四个月 2022年12月16日之前，蓝桥杯报名 大二寒假：2023年1月\u0026ndash;2023年2月 一个月 C++ 操作系统 数据库 项目 大二下：2023年2月底\u0026ndash;2023年7月初 四个月 去老师实验室试试 2023年4月，蓝桥杯省赛 2024年3月\u0026ndash;5月，实习生招聘 春招 大二暑假：2023年7月\u0026ndash;2023年9月 两个月 大三上：2023年9月初\u0026ndash;2024年1月初 2023年9月\u0026ndash;12月 ACM 网络赛 \u0026amp;\u0026amp; 区域赛 大三寒假：2024年1月\u0026ndash;2024年2月 了解保研流程和通识知识，初步做个保研的个人定位 大三下：2024年2月底\u0026ndash;2024年7月初 2024年3月\u0026ndash;5月，实习生招聘 春招 2024年3月\u0026ndash;4月，夏令营信息搜集 2024年4月\u0026ndash;6月，准备夏令营材料并投递 2024年2月\u0026ndash;5月，密切关注研究生入学考试分数线信息、复试和调剂信息 2024年6月中旬，开始备考 大三暑假：2024年7月\u0026ndash;2024年9月 2024年7月\u0026ndash;8月，参加夏令营，争取预录取资格 整个暑假，留校备考 2024年8月下\u0026ndash;9月上旬，全国招生简章正式公布。关注全国研究生招生最新政策变化，目标院校及目标专业研究生招生计划、考试科目、指定参考教材有否发生变化 大四上：2024年9月初\u0026ndash;2025年1月初 秋招 2024年9月\u0026ndash;11月，正式招聘（提前批7月开始） 2024年9月上旬，根据本校的你所在系的综合排名，最终确定在本校获得推免资格 2024年9月\u0026ndash;10月，投递九月推免，准备九推复试，参加九推复试 2024年9月\u0026ndash;10月，填报志愿并确认复试和待录取通知 2024年11月下旬，查看录取名单 2025年6月下旬，收到硕士录取通知书 2024年9月中上旬，硕士研究生入学考试考试大纲正式发行。及时购买考试大纲及大纲解析，并针对大纲及时调整自己的复习计划 2024年10月中上旬—10月底，全国硕士研究生入学考试网上正式报名 2024年11月中上旬，全国硕士研究生入学考试报名信息现场确认 2024年11月下旬，全国硕士研究生入学考试非统考专业课命题工作正式开展，各个研招单位自主命制该硕士生招生点的专业课试题 2024年12月中旬，考生可凭网报用户名和密码登录“研招网”下载打印《准考证》 2024年12月底，参加全国硕士研究生入学考试\u0026ndash;初试 大四寒假：2025年1月\u0026ndash;2025年2月 大四下：2025年2月底\u0026ndash;2025年7月初 2025年3月\u0026ndash;5月，实习生招聘 春招 2025年春季，各院校将公布考生分数，考生可以通过热线电话、网络等途径查询自己的考分 2025年2月中旬，34所自定义分数线的研究生招生单位陆续公布自己的复试分线 2025年3月中上旬，国家复试分数线公布 2025年3月中旬，全国各研招单位复试工作陆续进行 2025年3月中下旬，调剂工作开始 2025年4月底，体检 2025年5月初，政审 2025年5月中旬，招生单位确定录取名单 如何看项目源码 运行，跑起来，用起来，知道这个项目有什么功能，满足什么需求 找到项目入口 main函数 拆解项目模块，都有哪些功能，哪些模块 一个模块一个模块去看代码，而不是 囫囵吞枣 修改部分代码，重新跑项目，看看有哪些变动 完成这个项目代码的阅读 项目复盘 为什么做这个项目 这个项目整体架构是什么样子的 这个项目由哪几个模块组成 这些模块是怎么协同工作的 所有模块可能涉及到的操作系统、数据结构的知识 考证时间表 ","permalink":"https://xancoding.cn/posts/2022-11-20-22-11-28/","summary":"从今天开始，为自己种下一棵树 🌳 2025届毕业生 学习路线 算法（每天都看） 针对性刷题 C++ （2个月） 《C++ Primer》、《Effective C+","title":"年度计划"},{"content":"入门学习 # Anaconda+Pycharm+CUDA+CUdnn+PyTorch+Tensorflow # [双语字幕]吴恩达深度学习deeplearning.ai p1 \u0026ndash; p51 # Python 数据科学入门教程：NLTK # Pytorch 入门学习 第一课 1.6 Dropout 正则化_哔哩哔哩_bilibili 学习思路 找时间熟悉编程语言和神经网络模型 然后再看论文 再想想如何改进 然后编程实现你的想法，做实验验证 最后写论文 一步一步来 深度学习 前向传播和后向传播 偏差bias 和 方差variance 偏差是指模型在不同的训练数据上产生的误差的期望值与真实值之间的偏离程度，它度量了模型的拟合能力。如果一个模型的偏差很大，那么它的预测结果可能会偏离真实值，表现为欠拟合。\n方差是指模型在不同的训练数据上产生的误差的方差，即模型的预测结果在不同数据集上的变化情况。它度量了模型的泛化能力。如果一个模型的方差很大，那么它的预测结果可能会对训练数据的变化很敏感，表现为过拟合。\n在机器学习中，我们通常希望找到一个偏差和方差都较小的模型，以达到更好的性能。因此，在模型选择和调参时，需要根据具体情况调整模型的结构和超参数，以平衡偏差和方差的影响，以获得更好的泛化能力和性能。\n如果模型在训练集和测试集上的性能都很差，那么可能存在欠拟合，即模型的偏差很大。如果模型在训练集上的性能很好，但在测试集上的性能很差，那么可能存在过拟合，即模型的方差很大。\n减少方差而不影响偏差的方法：\n增加数据量：增加训练数据可以减少模型在训练集上的方差，从而提高模型的泛化能力。 使用正则化：正则化可以减少模型的复杂度，从而降低模型的方差。 使用集成方法：集成方法通过组合多个模型，可以降低模型的方差，提高模型的泛化能力。 减少偏差而不影响方差的方法：\n增加模型复杂度：增加模型的复杂度可以减少模型在训练集上的偏差，提高模型的拟合能力。 使用更好的特征：使用更好的特征可以提高模型的表达能力，从而减少模型的偏差。 使用集成方法：集成方法通过组合多个模型，可以降低模型的偏差，提高模型的泛化能力。 需要注意的是，减少偏差和减少方差是一种 trade-off（权衡），通常无法同时达到最佳状态。我们需要根据具体问题和数据集，平衡偏差和方差的影响，选择适合的模型和方法。通常，我们可以通过交叉验证等技术来选择最佳的模型和超参数，以达到平衡偏差和方差的目的。\n","permalink":"https://xancoding.cn/posts/2023-03-25-08-24-56/","summary":"入门学习 # Anaconda+Pycharm+CUDA+CUdnn+PyTorch+Tensorflow # [双语字幕]吴恩达深度学习deeplearning.ai p1 \u0026ndash; p51 # Python 数据科学入门教程：NLTK # Pytorch 入门学习 第一课 1.6 Dropout 正则化_哔哩","title":"GNN"},{"content":"第一章 概述 操作系统的 4 大资源管理功能是 处理机管理功能、存储器管理功能、设备管理功能、文件管理功能\n现代操作系统的两个最基本特征是 并发性、共享性\n用户和操作系统之间的接口主要分为 命令行界面（CLI）、图形用户界面(GUI)、系统调用\n第二章 进程管理 P（S）：将信号量S的值减1，即S=S-1；\n如果S\u0026gt;=0，则该进程继续执行；否则该进程置为等待状态，排入等待队列。\nV（S）：将信号量S的值加1，即S=S+1；\n如果S\u0026gt;0，则该进程继续执行；否则释放队列中第一个等待信号量的进程。\n每个进程中访问临界资源的那段程序称为 临界区\n引起创建进程的事件：\n1、用户登录\n2、作业调度\n3、提供服务（用户程序提出请求）\n4、应用请求（基于应用进程的需求）\n设备分配 只需要分配相应的端口，有事件发生时进行中断即可，不需要额外的进程管理。\n创建进程所必须的步骤：\n申请空白PCB（进程控制块）； 为新进程分派资源； 初始化PCB； 将新进程插入就绪队列； 进程状态包括就绪，运行，等待；有进程处于就绪状态，则必有进程处于运行状态，不一定有进程处于等待状态。故10个进程处于就绪状态，则至少有1个进程处于运行状态。\n在为多道程序所提供的可共享的系统资源不足时，可能出现死锁。但是，不适当的 进程推进顺序 也 可能产生死锁。\n在分时操作系统中,进程调度经常采用 时间片轮转 算法\n产生系统死锁的四个必要条件是：互斥、 请求与保持 、循环等待和不剥夺\n银行家算法在解决死锁问题中是用于 避免死锁 的\n进程主要由 PCB、数据段、程序段 三部分内容组成，其中 PCB 是进程存在的唯一标志，而 代码段 也可以为其他进程共享\n第三章 存储器管理 把作业地址空间使用的逻辑地址变成 内存的物理地址称为 重定位\n可重入码是一种允许多个进程同时访问的代码。为了使各进程访问的代码相同，故不允许对其进行修改！\n如果一个程序为多个程序所共享，那么该程序的代码在执行的过程中不能被修改，即程序应该是 可重入码。\n采用交换技术获得的好处是以牺牲 处理器时间 为代价的\n把作业装入内存时进行地址变换的方式称为 静态重定位 ；而在作业执行期间，当访问到指令或数据时才进行地址变换的方式称为 动态重定位\n如果IO花费的时间比CPU处理时间短的多,则缓冲区 几乎无效\n这里的意思指，在处理器处理完成之前，数据已经传入，即 IO 与 CPU 的速度差距被消除了，无需缓冲\n","permalink":"https://xancoding.cn/posts/2023-06-01-13-33-45/","summary":"第一章 概述 操作系统的 4 大资源管理功能是 处理机管理功能、存储器管理功能、设备管理功能、文件管理功能 现代操作系统的两个最基本特征是 并发性、共享性","title":"操作系统--期末复习"},{"content":" 学习：\nSchool\n《概率论与数理统计》结课\n《电路》结课\n《操作系统原理与实践》结课\n《模拟电子技术基础》结课\nPycharm+Anaconda+CUDA+cudnn+Pytorch ，深度学习环境配置完成\nGDB\nhttps://www.cprogramming.com/gdb.html googletest\nhttps://www.bilibili.com/video/BV1BB4y147Nv/?spm_id_from=333.788\u0026amp;vd_source=ae16ff6478eb15c1b87880540263910b ICS-PA\nSICP\njyy-OS\nRead 别像弱智一样提问 \u0026amp; 提问的智慧\nRead 英语文献、资料，英语能力Up Up\n书籍：\nLife:\nTech:\n《现代操作系统》2\u0026ndash;6章\n《操作系统\u0026ndash;精髓与设计原理》3\u0026ndash;9、11\u0026ndash;12章\n《操作系统导论》\n2023唐山马拉松（0521）（041905）\n0522 前几天沉迷刷抖刷B刷贴吧\n0530 前几天期末复习考试（怎么还有这么多课呀！！！\n五月后半段的作息不太规律，经常是凌晨一点左右至白天九点左右，慢慢调整回来\n大概规划一下考完之后，有空的时候做些什么（按优先级排列）：\n学习 deep-learning （情感分析） 学习 SICP （对编程语言有更深的理解，有更强的掌握感） 学习 算法 （晚上去 ACM 社团跟着他们一起练习）（提升自己的编程思维） 学习 ICS-PA （通过 NEMU 构建简单完整的计算机系统）（获得了处理大型项目的能力） 学习 jyy-OS （配合着《操作系统导论》） 注：4、5 可以放到大三上与 计算机组成原理、数字逻辑、Linux（如果这门专选课可以选上的话🤗） 联系起来，可以形成一个完整的知识体系 ","permalink":"https://xancoding.cn/posts/2023-05-31-09-00-39/","summary":"学习： School 《概率论与数理统计》结课 《电路》结课 《操作系统原理与实践》结课 《模拟电子技术基础》结课 Pycharm+Anaconda+CUDA+cudnn+Pytorch ，深度学习环境配置完成 GDB https://www.cprogramming.com/gdb.html googletest https://www.bilibili.com/video/BV1BB4y147Nv/?spm_id_from=333.788\u0026amp;vd_source=ae16ff6478eb15c1b87880540263910b ICS-PA SICP jyy-OS Read 别像弱","title":"5 月总结"},{"content":" # C/C++项目实战（前置知识） 单例模式 工厂模式' # C/C++刷题常用技巧 # C/C++项目实战（数据库） # 数据库原理 大纲 1. 开发环境 - Git # 版本管理工具 - Cmake # 代码构建工具，管理源文件和依赖 - Gcc # 编译器 - Clion # 编辑器 - Postman # 模拟客户端 - MySQL(navicat) # 在 docker Container 中起一个 mySQL 数据库，并可以在 navicat 中进行可视化操作 - Docker # 部署 1. 目录结构 - build # 项目编译目录 - debug - release - include # .h 头文件目录 - src # .cpp 源文件目录 - docs # 需求设计文档 - others 2. 设计模式 - 单例模式 - 构造函数私有 - 实例只有一份 - 工厂模式 - 一个类别对应一个工厂 - 不需要亲自创建对象，只需要从工厂中去取 3. 数据库 - MySQL - 关系型 - 支持事务 - 行锁 - 支持种存储引擎InnoDB，MyISAM，Memory - B+树索引 init-project build 添加 Release 模块，并将 Debug 和 Release 模块移至 build 目录下 include User.h\n// // Created by 24398 on 2023/5/29. // #ifndef NEW_PROJECT_USER_H #define NEW_PROJECT_USER_H # include \u0026lt;string\u0026gt; class User { private: int age{}; std::string name{}; public: std::string get_name(); User(std::string name_); }; #endif //NEW_PROJECT_USER_H src main.cpp\n#include \u0026lt;iostream\u0026gt; #include \u0026#34;User.h\u0026#34; int main() { auto *user = new User(\u0026#34;John\u0026#34;); std::cout \u0026lt;\u0026lt; user-\u0026gt;get_name() \u0026lt;\u0026lt; std::endl; return 0; } User.cpp\n// // Created by 24398 on 2023/5/29. // #include \u0026#34;User.h\u0026#34; User::User(std::string name_): name(name_){}; std::string User::get_name() { return this-\u0026gt;name; } CMakelists.txt cmake_minimum_required(VERSION 3.25) project(new_project) # C++ 17 set(CMAKE_CXX_STANDARD 17) # 添加头文件 include_directories(include) # 添加源文件 aux_source_directory(./src DIR_SRCS) # 所有需要编译的可执行文件 add_executable(new_project ${DIR_SRCS}) include_directories([AFTER|BEFORE] [SYSTEM] directory1 [directory2 ...])\n在这个例子中，命令include_directories(include)表示你想将include目录添加到包含路径中。这意味着编译器在编译源文件时会在include目录中搜索头文件。\naux_source_directory(\u0026lt;dir\u0026gt; \u0026lt;variable\u0026gt;)\n在这个例子中，命令aux_source_directory(src DIR_SRCS)表示你想从./src目录收集所有的源文件，并将它们赋值给变量DIR_SRCS。\n","permalink":"https://xancoding.cn/posts/2023-05-29-17-24-38/","summary":"# C/C++项目实战（前置知识） 单例模式 工厂模式' # C/C++刷题常用技巧 # C/C++项目实战（数据库） # 数据库原理 大纲 1. 开发环境 - Git # 版本","title":"C++ Project"},{"content":"大一上 2021年 7 月，开始我高考完后最轻松的暑假，光顾着玩了，没怎么学习（当然也没去考驾照啦） 2021 年 9 月 \u0026ndash; 2022 年 1 月（大一上），这段时间没怎么花时间在专业技术的学习上的，花比较多的时间在 高等数学 上，结果发现最后的考试并不难（不过考的也不高，拿了个 90）。闲暇的时间，日常的跑步（9月 \u0026ndash; 12月 共跑了 $369 km$） \u0026amp; 周末跟凌云社的小伙伴们出去玩（东灵山、三峰连穿\u0026hellip;），这个学期学了 C语言 和 离散数学 两门专业课。离散的老师讲的实在不行，只能自己看书学，感觉掌握的不是很扎实\u0026ndash;不过考试还是依旧比较水，C语言 95 和 离散数学 94 拿下。 其他的课中，依旧是被英语折磨，最后也就考了个 83（感觉也挺高的了🤣），还有就是 思想道德修养与法律，还是上课水过，考前几天背的死去活来，82 考过。还有就是，C 语言那个 管理系统 的课设，当时的我都还是只是磕磕绊绊的写出，以及参考教材，没有去网上检索信息的意识，可见对专业相关的自主学习意识还是比较薄弱的🥴。\n这学期也有两门拿的比较低，一门是 军事技能，是按军训的表现来算的（打靶全部脱靶，还能高到哪去，这个我认了😅）。另外一门就是 计算机导论，虽然是开卷，还是考了个 78。现在想想，这门当时应该好好学的，可以构建对计算机的基本认知来说，还是有必要的，对后面的学习也是有所裨益的。\n这个期间的生活费，大部分花在买跑鞋和我的高驰表上了\u0026hellip;\n至此，2021 年 7 月 \u0026ndash; 2022 年 1 月 $Over$。\n大一下 从 2022 年 1 月 \u0026ndash; 3月时间（1 月 \u0026ndash; 2 月 寒假）主要花在了 代码随想录 上(还付费进入知识星球一年)，对应着在力扣上刷题，对算法算是稍稍入了门，期间花时间把 黑马程序员 C++ 的 B 站视频刷了（当时只是硬着头皮刷，没想过要针对性的学习，其实后面刷算法题其实这里面语法特性是用不上的，比如：模板、虚函数\u0026hellip;导致学了忘得也很快，而在算法中需要掌握使用的 STL，却还是没怎么熟悉）（现在看来，还是走了挺多弯路的吧🤔）。发两个月时间刷完后，又转战 AcWing，先后购入 算法基础课（2022-03-28）、Linux基础课（2022-03-31）、Django框架课（2022-04-30）、Web 应用课（2022-05-06）。之后整个学期，也是因为疫情封校，平时周末无法外出，只能是在学校里，我也就把大部分的时间花在这些东西的学习上，刷这些视频课，并对应着进行一些实践。（现在反思反思，当时的实践还是少了，有点太过急了，视频刷的很快，能自己吸收消化的却不算多，还是有点可惜）。\n这个期间的生活费，大部分花在 买课 上了\u0026hellip;\n2022 年 4 月 \u0026ndash; 7月，这段时间也是停了力扣的刷题，时间着重花在 AcWing 上的算法题，以及 AcWing 工程课 的学习。这个学期 学了 数据结构 一门专业课，因为有了算法学习的底子，学的还是比较轻松，还做了一下知识点的整理，最后的期末考了个 92，不满意，狠奇怪😅。再说说考的不算好的几门好了，大学物理(1) 考了 78（确实不怎么会，认了），还有就是 学术英语，78，（不行，我要好好学英语！！！）这段时间主要还是花在 算法基础课 上，在 算法基础课 差不多学完的时候，插入了 Linux 基础课 的学习。\n至此，2022 年 2 月 \u0026ndash; 2022 年 7 月 $Over$。\n大二上 2022 年 8 月 \u0026ndash; 9 月（大一至大二的暑假），又在力扣上刷了大概一个半月的题，是因为报了 暑假每日一题2022，在这之前，算法基础课已经刷完（4 月 \u0026ndash; 7月），我又开始了 算法提高课 的 刷课刷视频（这个我并没有购买，而是跟另一个人作了交换，他上我的号看 Web 应用课，我上他的号看 算法提高课）。前前后后刷了 5 个月 算法后，开始疲惫，就不再看了。不看算法后，开始看 Django 框架课 和 Web 应用课，并写出对应的项目（还是过于急，并没有吃透，也没有花时间去Debug，碰到错误想的是对着源码去找哪里没有抄对🤣这样能学好才怪嘞）。还花了时间把 数据结构的课设 搞定，也是没什么技术含量，没什么系统性的长进\n这个期间的生活费，大部分花在 买户外装备 上了\u0026hellip;（虽然因为疫情封校没怎么出去过😭\n2022年 9 月 \u0026ndash; 2023 年 1月（大二上），开始觉得看视频的学习效果不够好（现在想想是因为自己在看视频的时候没有花足够的时间去思考），开始回归书本，买了不少 计算机相关的 经典书籍，开始啃书。这个学期学的是专业课是 计算机网络 和 Java，两门都考了 95，还算满意。其余的必修课，最差的也是考到了 88，是 马克思主义基本原理，个人感觉还是很好的了。这段时间也是花了大把大把的时间去啃书，并于 2022-10-12 搭建了自己的博客，并逐渐进行完善，以及对使用的笔记软件 Obsidian 不断打磨，使之可以完美符合我的使用习惯，时至今日，经过多次\u0026quot;迭代升级\u0026quot;，已经是我的形状了😋。除此之外，也看了很多人文社科相关的书籍，读了很多很多书，感觉还是有所长进的（但是！！还是缺乏对代码的实践，这是唯一美中不足的地方）\n2022 年全年 跑步量 781 km\n至此，2022 年 8 月 \u0026ndash; 2023 年 1 月 $Over$。\n大二下 2023 年 2 月 \u0026ndash; 3 月（寒假），还是花时间在啃书，这部分时间啃的主要是 操作系统 的书，还有就是写博客，把自己之前的 Linux 基础课 \u0026amp; Django 框架课 \u0026amp; Web 应用课 做了整理，写成博客。还有的就是，浏览别人博客的一些共鸣，以及感悟，也做了一些浅薄的记录。（从 2022 年 9 月 开始，阅读别人博客的时间也是花了很多，只是到 2023 年 4 月左右，已经是把想看的博主的内容都看完了，开始比较少的输入新的博客信息）。整个寒假，也是花了比较多的时间🏃‍，是按 每天 6 km 来跑的（在 2023 年 1 月的时候，想着每天跑 6 km，结果也是 理想很丰满，现实很骨感，在开学后，繁重的课业加上受伤的脚踝也是让我开摆，放弃这个想法🤧）（ 1 月 159 km，2 月 120 km，3月 48 km..看来也就坚持一个多月，不过也没办法，力量不够，我 2 月 后半时间 伤了，再加上 🐏了，实在是跑不了\u0026hellip;）\n！！！终于，在我接触 ICS-PA 和 OS 和 SICP（好吧，这个接触的比较早，只不过认真开始学习是近期的时候），我深刻的意识到 实践！！！ 的重要意义，看和做，做是更重要的。想想自己之前为什么总是收不到正反馈，很简单呀，光看不练怎么会有很大的提升呢。虽说走了挺多弯路，但前面的学习，也是给我现在打下了不错的基础，相信只要我花时间思考，不断实践 RTFM、RTFSC、RTFW，独立完成这几个项目，可以让我的 计算机能力有不错的提升，让我可以对自己更为满意💪。还有就是，培养自己阅读英文资料的习惯，毕竟外国的 技术资料和技术社区讨论氛围，还是国内所比不上的。再者，学习英语也是蛮有意思的嘛。\n关于英语，再补充一点，2023 年 3 月往前 大概有 7 \u0026ndash; 8 个月的时间，我坚持着每天背单词，不过到了后面也是放弃了，没有足够的正反馈，效果也不是很好，也是 操之过急 带来的不好的影响。不过，背单词带着我在大二上把 大一下延期考试的 六级 给过了（虽然也不高，471，准备大三上再去刷一刷，如果能刷到 520 及以上，我就很满意啦🥰）也还是不错的。\n现在看看，也是因为自己的目标没有足够明确，前面大一上没想这么多，课内学习也没有足够上心，专业课也没有自己去摸索着学习，使得大一上花了比较多在社团上（其实也不错，收获了开心😊）\n大一下的话，只埋头去 all in 算法了，同时学习方法没到位，也并没有到达自己希望的水平，从而陷入了自我内耗，再加上疫情只能在学校，整个人还是一个比较 emo 的状态的。现在想想还是有点可惜，当时应该硬着头皮参加 ACM 社团的，只是当时总对自己过分的不自信，其实有句话讲的挺好 不要把别人看的很好，也不要把别人看的很差，我当时就是犯了错（不过也是因为大一不知道我们学校还有 ACM 社团啦🥴在大一下暑假的时候知道，又因为怂了，同时觉得没时间搞（还是因为太内耗啦🤧）没去参加大二上的选拔（基本去考了都让你进，除去根本一点都不会的，不过也是因为去考的人也不多啦🤣）\n大二上，开始去读一些经典的书籍，算是步入正轨了，但也还是缺乏实践，同时缺少整体的一个规划，应该不只是读 计网 的书的，最佳的做法是 多一点涉猎，多一点实践，不过也不该苛责太多。那时候的我，也是做的不错的啦😁。\n大二下，课很多\u0026hellip;可能花在真正我觉得有意义上的事上的时间不多，更多的是 电路 和 模电 这两门 我认为日后对自己没什么帮助的课上。不过，既来之则安之，至少，我在学习自己想学的东西都时候，收获了快乐，我是在进步的！！况且，我对那两门课也没有很反感，这不就也很好嘛。只能说，慢慢来吧，勿在浮沙筑高台💪。\n这个学期剩下的时间就还是先准备准备期末考试，再穿插着去重拾一下算法好了🤗\n对下个学期的课还是蛮期待的，都是专业课，喜欢🥰，总算不用上一些搭不上什么边的课啦😴\n至此，2022 年 2 月 \u0026ndash; 2023 年 5 月 $Over$。\n最后，写一写自己的职业规划好了，以后大的方向还是有两个选择，一是 考个 985，走定向选调生；二是 本科 考公，考虑 在职研究生这一条路（不过还没有充分了解，我了解了解，再做打算（尽快尽快😴\n等了解完之后，我再写篇博客具体讲讲各自的优劣好了（确信，尽快🤗\n$写于 2023 年 5 月 29 日$\n","permalink":"https://xancoding.cn/posts/2023-05-29-12-54-17/","summary":"大一上 2021年 7 月，开始我高考完后最轻松的暑假，光顾着玩了，没怎么学习（当然也没去考驾照啦） 2021 年 9 月 \u0026ndash; 2022 年 1 月（大一上），这段时间没怎么花","title":"大一\u0026大二 总结"},{"content":"\u003c!DOCTYPE html\u003e ","permalink":"https://xancoding.cn/posts/2023-05-28-18-28-55/","summary":"\u003c!DOCTYPE html\u003e","title":"2023 黄草梁🏕️"},{"content":"\u003c!DOCTYPE html\u003e ","permalink":"https://xancoding.cn/posts/2023-05-28-18-20-45/","summary":"\u003c!DOCTYPE html\u003e","title":"2023 第五十三届公园半程马拉松北京公开赛“北京·亦庄”南海子公园站"},{"content":"\u003c!DOCTYPE html\u003e ","permalink":"https://xancoding.cn/posts/2023-05-28-18-16-39/","summary":"\u003c!DOCTYPE html\u003e","title":"2023 首都高校第九届徒步大会"},{"content":"\u003c!DOCTYPE html\u003e ","permalink":"https://xancoding.cn/posts/2023-05-28-17-57-01/","summary":"\u003c!DOCTYPE html\u003e","title":"2023 “拉卡拉杯”北京大学第十五届 5+2 半程马拉松接力赛"},{"content":"\u003c!DOCTYPE html\u003e ","permalink":"https://xancoding.cn/posts/2023-05-28-17-50-50/","summary":"\u003c!DOCTYPE html\u003e","title":"2022贝壳北京马拉松志愿者"},{"content":"\u003c!DOCTYPE html\u003e ","permalink":"https://xancoding.cn/posts/2023-05-28-17-13-05/","summary":"\u003c!DOCTYPE html\u003e","title":"2022 adidas ADIZERO SUMMIT 北马训练营"},{"content":"开始的 10 km状态还行（毕竟跑的也不快😜），在 11 km左右的时候，旧伤复发，脚踝开始隐隐作痛，速度往下掉，在 6分配左右徘徊。目标是安全完赛，脚痛速度也加不起来，完赛预计时间也从开跑前的 4h 一路降到 4h20min。心率一直是保持在一个比较低的水平，配速还有到过 7 分配。不过整体还是满意的啦，可以顺利完赛已经很棒了🥰。（PS:刚跑完就走路的时候就已经是一瘸一拐的，接下来几天就慢慢修养生息好了😴） \u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE html\u003e ","permalink":"https://xancoding.cn/posts/2023-05-21-07-27-22/","summary":"开始的 10 km状态还行（毕竟跑的也不快😜），在 11 km左右的时候，旧伤复发，脚踝开始隐隐作痛，速度往下掉，在 6分配左右徘徊。目标是安全完赛，脚痛","title":"2023 唐山马拉松"},{"content":"本文是为了我在完成 ICS-PA 的过程中，踩的一些坑（当然，绝大部分是没有 RTFM \u0026amp; RTFW 造成的🤣\n计算机系统基础 PA0 - 世界诞生的前夜: 开发环境配置 在执行下述命令：\napt-get install libsdl2-dev # a library used later apt-get install llvm llvm-dev # llvm project, which contains libraries used later 发现缺少依赖\n执行下述命令，仍然没有效果\napt-get update 在 RTFM 后，发现是镜像源的问题，更改镜像源后，再次进行操作，发现可以成功安装\nPA1 - 开天辟地的篇章：最简单的计算机 在开始愉快的PA之旅之前 开头简简单单的运行一个已经完成的 红白机模拟器项目FCEUX ，前前后后就搞了一个多小时，出师未捷身先死了属于是。果然还是没有 RTFM 的锅。问题是这样的：我在 PA0 里配置的环境变量是 bash 的，而之后我又将我的 Shell 从 bash 更换到了 zsh，却没有重新配置环境变量。而 Makefile 中的 AM_HOME 实际上使用了 系统环境变量，所以我无法将程序跑起来。\n解决方法：在 .zshrc 下手动加入环境变量的配置\nexport NEMU_HOME=/home/xan/Desktop/ics2022/nemu export AM_HOME=/home/xan/Desktop/ics2022/abstract-machine 然后，在命令行界面运行命令 source ./.zshrc 即可\n最后再放一下成功运行马里奥的界面😁 在配置 ccache 的时候又粗心了，.zshrc 中的 export PATH=\u0026quot;/usr/lib/ccache:$PATH\u0026quot;，楞是写成了 export PATH=\u0026quot;/usr/lib/cache:$PATH，怪不得总是不行。好在折腾了一个来小时后，终于成功发现，修改后果然成功 RTFSC 在解决上述问题的时候，偷了下懒，直接去网上🔍思路，看别人找问题看源码的过程，感觉还是挺妙的。下次还得是自己去解决，这样才会有更多的收获，相信自己能做到的💪。下文是出问题的地方的修改\u0026amp;\u0026amp;解决完后的界面。 ","permalink":"https://xancoding.cn/posts/2023-05-08-17-40-45/","summary":"本文是为了我在完成 ICS-PA 的过程中，踩的一些坑（当然，绝大部分是没有 RTFM \u0026amp; RTFW 造成的🤣 计算机系统基础 PA0 - 世界诞生的前夜: 开发环境配置 在执行下述命令： apt-get","title":"ICS-PA"},{"content":"运动损伤 创口贴 9片：小创口的止血处理 云南白药 2罐：跌打损伤，淤血肿痛，肌肉酸痛及风湿疼痛 麝香壮骨膏 5贴：扭伤 挫伤 双氯芬酸二乙胺乳胶剂：缓解肌肉、软组织和关节的轻至中度疼痛。如：缓解肌肉、软组织的扭伤、拉伤、挫伤、劳损、腰背部损伤引起的疼痛以及关节疼痛等，也可用于骨关节炎的对症治疗\n外用。按照痛处面积大小，使用本品适量，轻轻揉搓，使本品渗透皮肤，一日3-4 次 胃痛 乳酶生片 100片：促进消化和止泻\n一次2-3片，一日3次，饭前服 健脾颗粒 12袋：健脾开胃 一次1袋，一日2次 三九胃泰颗粒 1袋：上腹隐痛，饱胀，反酸，恶心，呕吐，纳减，心口嘈杂\n开水冲服。一次1袋，一日2次 午时茶颗粒 3袋：恶寒发热、头痛身楚、胸脘满闷、恶心呕吐、腹痛腹泻\n开水冲服。一次1袋，一日1~2次 上火 桂林西瓜霜：急、慢性咽炎，扁桃体炎，口腔炎，口腔溃疡，牙龈炎 外用。敷于患处，每次适量，一日数次 金喉健喷雾剂：风热所致咽痛、咽干、咽喉红肿、牙龈肿痛、口腔溃疡 喷患处。每次适量，一日数次 维生素B2片：口腔溃疡 口服。一次1-2片，一日3次 口炎清颗粒 4袋：阴虚火旺所致的口腔炎症 口服。一次2袋，一日1～2次 皮肤感染 丁酸氢化可的松软膏 2管：过敏性皮炎、脂溢性皮炎、湿疹、瘙痒症和神经性皮炎\n局部外用。取适量本品涂于患处，每日2次。 莫匹罗星软膏 2管：局部外用抗生素，适用于革兰阳性球菌引起的皮肤感染，例如：脓疱病、疖肿、毛囊炎等原发性皮肤感染及湿疹合并感染、溃疡合并感染、创伤合并感染等继发性皮肤感染 外用。局部涂于患处，必要时，患处可用敷料包扎或敷盖，每日3次，5天一疗程。必要时可重复一疗程 感冒 阿奇霉素片 6片：支气管炎、肺炎等下呼吸道感染，鼻窦炎、咽炎、扁桃体炎等上呼吸道感染 每日口服给药一次，整片吞服 三九感冒灵胶囊 10粒：感冒引起的头痛，发热，鼻塞，流涕，咽痛等 口服。一次2粒，一日3次 酚麻美敏片 20片：普通感冒或流行性感冒引起的发热、头痛、四肢酸痛、喷嚏、流鼻涕、鼻塞、咳嗽、咽痛等症状 口服。一次1~2片，每6小时服1次。 24小时内不超过4次 对乙酰氨基酚释缓片：普通感冒或流行感冒引起的发热，轻中度疼痛如头痛、关节痛、偏头痛、牙痛、肌肉痛、神经痛、痛经 口服。成人一次1～2片，若持续发热或疼痛，每8小时一次，24小时不超过3次 盐酸阿比多尔颗粒 12袋：A、B型流感病毒等引起的上呼吸道感染 口服。一次2袋，一日3次，服用5日 ","permalink":"https://xancoding.cn/posts/2023-04-30-09-48-57/","summary":"运动损伤 创口贴 9片：小创口的止血处理 云南白药 2罐：跌打损伤，淤血肿痛，肌肉酸痛及风湿疼痛 麝香壮骨膏 5贴：扭伤 挫伤 双氯芬酸二乙胺乳胶剂：缓解肌","title":"宿舍备药"},{"content":"Blog 搭建工具 Hugo \u0026amp; GitHub Pages \u0026amp; GitHub Action \u0026amp; Twikoo Theme：PaperMod Tool：Obsidian \u0026amp; Git Bash Tool 常用操作 Obsidian 打开 Obsidian 编辑器，通过 ctrl + s 快捷键创建新博客 ctrl + d：删除当前文件 ctrl + t：打开新标签页 ctrl + w：关闭当前标签页 ctrl + o：切换或创建文件 ctrl + e：切换预览与编辑模式 各页面简介 Home：联系方式 \u0026amp; 文章 Tags：文章标签 Archives：文章归档 About：作者简介 \u0026amp; 博客简介 Search：搜索文章 自定义 shortcodes bilibili 视频 \u003c!DOCTYPE HTML\u003e douban 卡片 \u003c!DOCTYPE HTML\u003e 相册 \u003c!DOCTYPE html\u003e 香克斯 参考资料 Sulv\u0026rsquo;s Blog # Hugo博客添加相册功能 # Hugo博客自定义shortcodes # Hugo博客目录放在侧边 | PaperMod主题 # Hugo博客时间轴中文化 # Hugo博客添加Twikoo评论 # Hugo博客seo优化 3rd\u0026rsquo;s Blog # Hugo侧边目录 田少晗的个人博客 # Hugo博客添加LaTeX语法支持 Hugo 博客写作最佳实践 Hugo + GitHub Action，搭建你的博客自动发布系统 ","permalink":"https://xancoding.cn/posts/2023-04-30-09-43-31/","summary":"Blog 搭建工具 Hugo \u0026amp; GitHub Pages \u0026amp; GitHub Action \u0026amp; Twikoo Theme：PaperMod Tool：Obsidian \u0026amp; Git Bash Tool 常用操作 Obsidian 打开 Obsidian 编辑器，通过 ctrl + s 快捷键创建新博客","title":"Blog"},{"content":" 三星SAMSUNG 64G U盘 —— 京东 88元 联想拯救者 R7000 —— 京东 6199元 微星 MSI 23.8英寸显示器 —— 京东 833 元 微软便携触摸显示器 —— 淘宝 499 元 漫步者 W820NB 头戴式蓝牙耳机 —— 京东 299 元 小米显示器挂灯 —— 京东 199元 RK100 有线/蓝牙/无线2.4G三模机械键盘 —— 京东 229元 SAMSUNG 64GB U盘 —— 京东 87 元 小米充电宝 20000mAh 22.5W —— 京东 149元 小米 原装二合一数据线 1m —— 京东 27元 ","permalink":"https://xancoding.cn/posts/2023-04-30-09-39-00/","summary":"三星SAMSUNG 64G U盘 —— 京东 88元 联想拯救者 R7000 —— 京东 6199元 微星 MSI 23.8英寸显示器 —— 京东 833 元 微软便携触摸显示器 —— 淘宝 499 元 漫步者","title":"Electronic product"},{"content":" 采取三分化训练模式，意思是三天以内训练全身，中间也可以比较自由的加入休息日\nDay 1：Chest \u0026amp; Triceps 热身：着重注意胸部肩部颈部以及下背部，热身时间不要超过5分钟。 钻石俯卧撑：每组数量20，做不到20的就做到极限。一共3组。组间休息90秒。 作为最经典的徒手练胸动作，钻石俯卧撑可以在一开始给予胸肌很好的充血感。 动作要点： 注意双脚并拢，脚尖稳定怼地面。 注意髋关节的稳定，尽量保证腿部以及身体呈一条直线。 腹部核心肌群需要全程用力，尽量保证脊柱的中立。 整体动作需要尽量放慢，下降时要抵抗万有引力，上升时要抵抗身体的惯性。重点是胸部肌肉的感受度。 下降到极限时下巴离地面距离要尽可能小。但是千万不要勉强，要保证肩部以及手肘动作不要变形。 火箭俯卧撑：每组数量15，做不到15的就做到极限。一共3组。组间休息90秒。 这是普通俯卧撑的升级强化版，额外强化了对于上胸部的刺激。 动作要点： 注意双脚并拢，双腿伸直，前脚掌稳定怼地面。 髋关节的角度需要固定在120度左右，需要借助下背及核心力量保证腰部和臀部全程稳定避免受伤。（可以参考罗马尼亚硬拉时腰部以及脊椎的位置） 整体动作需要尽量放慢，仔细感受上胸的收缩。（如果动作过快可能会磕歪门牙） 下降到极限时下巴离地面距离也要尽可能小，但同样不可勉强。 推荐在双拳下垫上两块绞干的小毛巾，增加水平方向上的摩擦力，可以更好的发力。 臂屈伸：每组数量12，做不到12的就做到极限。一共4组。组间休息90秒。 动作要点： 这个动作需要保证肩关节的稳定，不可耸肩。 挺胸抬头。 下降时一定要放慢动作，且不可过分下降，不然会给肩关节过大的压力。 Day 2：Back \u0026amp; Biceps 热身：着重注意背部，肩部以及颈部。热身时间不超过5分钟。 仰卧夹背：每组数量12，做不到12的就做到极限。一共3组。组间休息90秒。 这个动作主要训练上背部。 动作要点： 想要充分发挥训练效果的话，推荐在肌肉收缩到顶峰的时候停留2秒。 双腿弯曲，双脚稳定踩在地面。 仅仅利用上背部肌肉发力使身体抬起，腹部核心肌群需要出力保持脊柱不弯曲。 直臂下拉徒手版：每组数量12，做不到12的就做到极限。一共3组。组间休息90秒。 这个动作可以训练到中背部以及背阔肌。 动作要点： 做这个动作有一个前提是地板必须光滑。个人经验是双脚各踩半张A4纸，可以大大减少摩擦力。同时双手洗一下并擦干，再做这个动作可以大大增加手掌和地面的摩擦力。 双臂需要伸直以避免二头肌借力。 肩关节需要稳定住，不然在收缩至顶峰的时候肩膀容易拉伤。 Superman：每组数量12，做不到12的就做到极限。一共3组。组间休息90秒。 这个动作对于下背部的刺激十分到位，而且避免了卷腹。 和仰卧夹背一样，推荐在肌肉收缩到顶峰的时候停留2秒。让超人多飞一会。 Day 3：Hips \u0026amp; Legs \u0026amp; Shoulders 热身：着重注意大腿，腰部，肩膀，斜方肌以及颈部。 无负重深蹲：主要看臀腿肌群的感受度，不超过20次下蹲。一共3组，组间休息90秒。 动作要点： 两脚距离稍比臀宽，脚尖稍稍朝外，身体重量平均分配在两脚掌，保持后背挺直 身体下降时，膝盖不超过脚尖的垂直高度，臀部的往下就像是往板凳上坐一样 与此同时将双手打直往前，维持在胸部的高度 往下时尽全力，注意保持挺胸，后背挺直，逐渐检查自己的膝盖不超过脚尖 臀桥：每组15下，一共3组，组间休息90秒。 动作要点： 注意双臂贴合地面，脚后跟怼地。 同样注意下背部及脊椎的位置，尽量保持中立位（不要驼背）。 肩膀保持稳定不参与发力。 最高点躯干与大腿在同一直线。 顶峰停留2秒。 箭蹲跳：每组90秒，一共三组，休息30秒。 动作要点： 注意膝盖不要触及地面。 动作不宜过快，标准至上。 注意“跳”和“蹲”是两个分开但是连贯的动作。不要混淆了。 单臂侧平举：每侧 RM 8-12，一共4组（两侧算一组） 这个动作可以用到哑铃或者弹力带，也可以请出我们的书包，或者一大包垃圾。 动作要点： 手臂不需要完全伸直，运动过程中手肘朝向后上方，这样可以增加运动路径。 由于是单侧动作，核心肌群需要发力以稳定身体平衡。 动作不宜过快，特别当你拿的重物是书包，过快容易晃来晃去。 Diet BreakFast 6：30 三个鸡蛋 + 馒头 + 豆浆 Extra meal 9：00 牛奶 + 咖啡 + 坚果 Lunch 11：00 三两米饭 + 蔬菜（西兰花）+ 鱼肉 or 鸡胸肉 or 牛肉 Extra meal 2：30 燕麦 + 玉米 or 红薯 + 香蕉 Dinner 5：00 三两米饭 + 蔬菜（西兰花）+ 鱼肉 or 鸡胸肉 or 牛肉 Extra meal 9：00 燕麦 + 全麦面包 + 香蕉 Vedio 【街健之路1】街头健身全攻略！新手怎么开始街健？如何变成街健大神？！ ","permalink":"https://xancoding.cn/posts/2023-04-30-09-33-09/","summary":"采取三分化训练模式，意思是三天以内训练全身，中间也可以比较自由的加入休息日 Day 1：Chest \u0026amp; Triceps 热身：着重注意胸部肩部颈部以及下背部，热身时间","title":"Fitness program"},{"content":"我的装备 手表 COROS高驰 PACE2 竞技运动手表 —— 闲鱼 1200元 跑鞋 飞影PB 国庆配色 260mm —— 闲鱼 450元 Nike React Infinity Run 白蓝 260mm —— 闲鱼 271元 锐步 Energy3 260mm —— 闲鱼 450元 冬季装备 QINKUNG长袖 M码 —— 闲鱼 78元 必迈 V4热能紧身压缩衣 L码 —— 闲鱼 329元 必迈 防风保暖夹克 恒星蓝 L码 —— 闲鱼 259元 夏季装备 特步国人竞速 短裤、背心 —— 闲鱼 259元 QINKUNG短袖 M码 —— 官网 169元 BMAI 必迈跑步竞速压缩短裤 3.5寸 黑练黑 —— 淘宝 173元 帽子🧢 Nike运动帽 679421 —— 闲鱼 110元 QINKUNG轻功 秋冬跑步高弹针织帽 —— 淘宝 99元 ","permalink":"https://xancoding.cn/posts/2023-04-30-09-25-28/","summary":"我的装备 手表 COROS高驰 PACE2 竞技运动手表 —— 闲鱼 1200元 跑鞋 飞影PB 国庆配色 260mm —— 闲鱼 450元 Nike React Infinity Run 白蓝 260mm —— 闲鱼 271元 锐步 Energy3 260mm —— 闲","title":"Run"},{"content":"入门指南 登山者Black\n户外运动安全手册（上） 户外运动安全手册（下） 洋葱式穿着/户外运动穿什么 户外必备10要素\u0026ndash;可能拯救你生命的十件户外必需品 户外装备选购终极指南 户外急救/户外医疗包 烛逢\n户外运动三层穿衣法 | 烛逢 在野外找路-六只脚｜烛逢 六只脚进阶篇 | 烛逢 两步路使用教学｜烛逢 两步路路网\n访问🔗https://www.wandoujia.com/apps/514093/history 下载 6.6.1 版本 在应用商店中关闭自动更新 GOOGLE地球简易操作制作轨迹，配合六只脚户外导航\n登山装备清单 我的装备 三峰出雨衣 15D —— 闲鱼 112元 BLACK ICE 黑冰 户外运动P棉服 F8001 S码 —— 淘宝 543元 闲鱼 499元 THERMOS 膳魔师 JNL-502-PRW 珠光白 500mL —— 京东 80元 Snow monster 雪地野人户外手套 —— 闲鱼 120元 Hoka羚羊4 260mm —— 京东 599元 强氧登山包羚羊36L （2 - 3日短线徒步 ） —— 闲鱼 220元 奈特科尔NITECORE头灯 NU25 —— 闲鱼 133元 outdoor research OR 手套 L码—— 淘宝 58元 Outdoor research VERGLAS 雪套 L码 —— 闲鱼 89元 ROCLKSOLID 美利奴羊毛保暖内衣套装 M码 —— 淘宝 198元 Keith凯斯纯钛饭盒 Ti5328 1000mL —— 闲鱼 179元 Keith凯斯钛杯 Ti3240 350mL —— 闲鱼 75元 钛途TiTo纯钛叉勺 —— 淘宝 19元 凯乐石9A攀岩裤KG520220 金鱼黄 170/74A —— 闲鱼 199元 凯乐石远征者pro 三合一冲锋衣 M码 —— 闲鱼 460元 Osprey小鹰水袋 3L —— 闲鱼 230元 急救包 外伤 塑料镊子 1把：伤口的精细化处理 安全别针 10枚：固定三角巾纱布止血带等 剪刀 1把：剪开绷带线条等各种用途 创口贴 10片：小创口的止血处理 酒精棉片 10片：对伤口用品的擦拭消毒 碘伏棉片 4片：伤口的消毒、消炎 医用棉签 20根：日常护理使用 三角绷带 1包：胳膊骨折的固定，头部出血的处理 止血带 1卷：压迫伤口止血，固定骨折部位 PBT绷带 1卷：伤口的包扎止血 无纺布胶带 1卷：固定绷带纱布等敷料 纱布片 2片：可与伤口直接接触 药物 麝香壮骨膏 4贴：扭伤 挫伤 急救毯 1张：失温 云南白药 2罐：跌打损伤，淤血肿痛，肌肉酸痛及风湿疼痛 板蓝根颗粒 2包：肺胃热盛所致的咽喉肿痛、口咽干燥 海外代购 在淘宝上搜亚马逊代购，然后把衣服链接发给他，他会计算价格 ","permalink":"https://xancoding.cn/posts/2023-04-30-09-20-36/","summary":"入门指南 登山者Black 户外运动安全手册（上） 户外运动安全手册（下） 洋葱式穿着/户外运动穿什么 户外必备10要素\u0026ndash;可能拯救你生命的","title":"Outdoor"},{"content":" 学习：\n《概率论与数理统计》1\u0026ndash;7章\n《电路》1\u0026ndash;4、6\u0026ndash;10章\n《操作系统原理与实践》1\u0026ndash;4章\n《算法设计与分析（第2版）》结课（第 12 周）\n《汇编语言》结课（第 8 周）\n《模拟电子技术基础》1\u0026ndash;5章\n小林图解系统：\n四、内存管理（4.7 深入理解 Linux 物理内存管理）\n六、调度算法\n七、文件系统\n九、网络系统（未看）\n十、Linux 命令（未看）\nOI Wiki\nGit 学习\nLaTex 学习\n菜鸟教程\nPython3 学习 深度学习 吴达恩 B站视频\n书籍：\nLife:\n《平凡的世界》\n《明朝那些事》\nTech:\n《程序员的自我修养》p1\u0026ndash;p169\n《深入理解计算机系统》p1\u0026ndash;p119、p399\nOutdoor\n鹫峰徒步（0408）\n北京•门头沟•十里坪🏕️（0415\u0026ndash;0416）\n公园半程马拉松北京公开赛“北京•亦庄”南海子公园站（0422）01:46:07\n北大拉卡拉杯 5+2（0429）\n打卡北京高校\n中国农业大学\n中国石油大学\n北京林业大学\n北京大学\n冥想\n","permalink":"https://xancoding.cn/posts/2023-04-30-01-10-21/","summary":"学习： 《概率论与数理统计》1\u0026ndash;7章 《电路》1\u0026ndash;4、6\u0026ndash;10章 《操作系统原理与实践》1\u0026ndash;4章 《","title":"4 月总结"},{"content":"当待排列的元素为一个对象时，我们既可以通过自定义比较函数，也可以通过重载运算符来达到目的。\n下面我以在对象中重载运算符来达到排序的目的展开说明。\n下面是针对 sort函数 和 Priority_queue优先队列，关于重载运算符所需要注意的要点\n结构体排序 struct node{ int a, b; // 从小到大排序 bool operator \u0026lt; (const node\u0026amp; node_)const{ if(a != node_.a) return a \u0026lt; node_.a; return b \u0026lt; node_.b; } }; int main(){ vector\u0026lt;node\u0026gt; tt; tt.push_back({1,5}); tt.push_back({2,3}); sort(tt.begin(), tt.end()); for(auto \u0026amp;node: tt){ cout\u0026lt;\u0026lt;node.a\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;node.b\u0026lt;\u0026lt;endl; } return 0; } 执行结果： 1 5 2 3 优先队列自定义排序 struct node{ int a, b; // 在优先队列中，跟排序的规则是反的，这里是指a大的排在前面，a相同时，b大的排在前面 bool operator \u0026lt; (const node\u0026amp; node_)const{ if(a != node_.a) return a \u0026lt; node_.a; return b \u0026lt; node_.b; } }; int main(){ priority_queue\u0026lt;node\u0026gt; pq; pq.push({1,5}); pq.push({2,3}); pq.push({2,5}); while(!pq.empty()) { cout\u0026lt;\u0026lt;pq.top().a\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;pq.top().b\u0026lt;\u0026lt;endl; pq.pop(); } return 0; } 执行结果： 2 5 2 3 1 5 Sort函数 sort函数在默认情况下使用std::less作为比较函数类，而std::less定义了小于号\u0026lt;运算符的重载。因此，在sort函数中如果不指定自定义的比较函数对象，就默认使用std::less来进行排序，即升序排序。如果要实现降序排序，则需要提供自定义的比较函数对象，或者使用std::greater作为比较函数类。\nsort函数并不能直接重载大于号运算符。sort函数默认使用小于号运算符来对元素进行排序，因此在对对象进行排序时，我们通常会重载小于号运算符。\n当第一个元素 \u0026lt; 第二个元素时，为true，则最终的排序结果为升序\n同理，当我把 this-\u0026gt;age \u0026lt; other.age 修改为 this-\u0026gt;age \u0026gt; other.age时，说明当第一个元素 \u0026gt; 第二个元素时，为true，则结果为降序\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; // 定义一个自定义对象 class Person { public: string name; int age; Person(string name, int age) { this-\u0026gt;name = name; this-\u0026gt;age = age; } // 第一个元素 \u0026lt; 第二个元素，true，升序 bool operator\u0026lt; (const Person\u0026amp; other) const { return this-\u0026gt;age \u0026lt; other.age; } }; int main() { // 创建一组Person对象并排序 Person p1(\u0026#34;Alice\u0026#34;, 25); Person p2(\u0026#34;Bob\u0026#34;, 30); Person p3(\u0026#34;Charlie\u0026#34;, 20); vector\u0026lt;Person\u0026gt; people = {p1, p2, p3}; sort(people.begin(), people.end()); for (auto \u0026amp;p: people) { cout \u0026lt;\u0026lt; \u0026#34;Name:\u0026#34; \u0026lt;\u0026lt; p.name \u0026lt;\u0026lt; \u0026#39;\\t\u0026#39; \u0026lt;\u0026lt; \u0026#34;Age:\u0026#34; \u0026lt;\u0026lt; p.age \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; } 输出结果：\nName:Charlie Age:20 Name:Alice Age:25 Name:Bob Age:30 通过下述代码，我们可以在调用sort时将比较函数类从默认的std::less改为std::greater，实现降序排序\u0026ndash;前提是记得在对象中重载大于运算符，否则编译器将会报错！！！\nsort(people.begin(), people.end(), greater\u0026lt;\u0026gt;()); Priority_queue堆优先队列 堆是一种数据结构，可以用数组或树实现，常用于实现优先队列、排序算法等。\n优先队列（priority queue）就是堆（heap）的一种应用。\nC++中的优先队列实现就是堆优先队列，底层使用堆来实现。\nstd::priority_queue是一个模板类，它的模板参数有三个，分别是：\nT：指定队列中存储的元素类型。 Container：指定用于存储元素的容器类型，默认是std::vector\u0026lt;T\u0026gt;。 Compare：指定用于比较元素优先级的比较函数类型，默认是std::less\u0026lt;T\u0026gt;。 std::less\u0026lt;T\u0026gt;和std::greater\u0026lt;T\u0026gt;是STL中预定义的两个比较函数类，分别表示小于和大于。它们重载了小于号运算符\u0026lt;和大于号运算符\u0026gt;，用于比较元素的优先级。因此，当我们在定义std::priority_queue时，使用std::less\u0026lt;T\u0026gt;作为比较函数类时，实际上是默认按照小于号进行比较元素优先级；而使用std::greater\u0026lt;T\u0026gt;作为比较函数类时，则是按照大于号进行比较元素优先级。\n如果在使用std::less\u0026lt;T\u0026gt;作为比较函数类时，重载大于号\u0026gt;，或者在使用std::greater\u0026lt;T\u0026gt;作为比较函数类时，重载小于号\u0026lt;，都会导致编译错误，因为这些比较函数类内部的比较操作都是用小于号\u0026lt;或者大于号\u0026gt;实现的，而你重载了不符合预期的运算符，导致编译器无法正确地进行比较操作。\n在C++中，优先队列可以通过指定比较函数来控制是使用大根堆还是小根堆。如果使用 std::greater\u0026lt;\u0026gt; 作为比较函数，则意味着使用小根堆，即优先级高的元素会被放在队列的顶部；如果使用 std::less\u0026lt;\u0026gt; 作为比较函数，则意味着使用大根堆，即优先级高的元素会被放在队列的底部。\n堆中元素之间的优先级关系，这是通过定义比较函数来实现的，比较函数中使用 greater\u0026lt;\u0026gt; 表示元素之间的优先级关系为第一个参数视为较小的元素；使用 less\u0026lt;\u0026gt; 表示元素之间的优先级关系为第一个参数视为较大的元素。\n使用 greater\u0026lt;\u0026gt; 作为比较函数时，会将元素之间的优先级关系视为第一个参数较小，也就是说，若 greater\u0026lt;\u0026gt; 作为比较函数返回 true，则表示第二个参数优先级高于第一个参数，应当排在第一个参数之前。因此，这里的“将第一个参数视为较小的元素”指的是将第一个参数作为比较时的较小值，从而实现小根堆的效果。\n在一个二元比较函数中，第一个参数一般是被比较的左侧参数，第二个参数是被比较的右侧参数。比如在 operator\u0026gt; 函数中，第一个参数就是使用 \u0026gt; 运算符的左侧参数，第二个参数是右侧参数。在优先队列中，第一个参数也就是堆顶元素。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;functional\u0026gt; using namespace std; class Person { public: string name; int age; Person(string name, int age) : name(name), age(age) {} bool operator\u0026gt;(const Person\u0026amp; other) const { return age \u0026gt; other.age; } }; int main() { priority_queue\u0026lt;Person, vector\u0026lt;Person\u0026gt;, greater\u0026lt;\u0026gt;\u0026gt; pq; // 插入元素 pq.push(Person(\u0026#34;张三\u0026#34;, 20)); pq.push(Person(\u0026#34;李四\u0026#34;, 30)); pq.push(Person(\u0026#34;王五\u0026#34;, 25)); cout \u0026lt;\u0026lt; \u0026#34;这是一个小根堆！！！\\n\u0026#34;; while (!pq.empty()) { auto\u0026amp; p = pq.top(); cout \u0026lt;\u0026lt; \u0026#34;Name:\u0026#34; \u0026lt;\u0026lt; p.name \u0026lt;\u0026lt; \u0026#39;\\t\u0026#39; \u0026lt;\u0026lt; \u0026#34;Age:\u0026#34; \u0026lt;\u0026lt; p.age \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; pq.pop(); } return 0; } 输出结果：\n这是一个小根堆！！！ Name:张三 Age:20 Name:王五 Age:25 Name:李四 Age:30 ","permalink":"https://xancoding.cn/posts/2023-04-24-14-17-47/","summary":"当待排列的元素为一个对象时，我们既可以通过自定义比较函数，也可以通过重载运算符来达到目的。 下面我以在对象中重载运算符来达到排序的目的展开说明","title":"C++中的Sort函数与Priority_queue优先队列"},{"content":"配速 330\u0026ndash;4m58s\n400\u0026ndash;5m41s\n赛前 赛前48小时：充分补充碳水化合物和水分。将饮食中的碳水比例升高，多吃如：面包、面食、米饭和土豆等，还可以食用果汁、蜂蜜和能量棒等，来获取更多的碳水化合物。\n赛前12小时：比赛前一晚的晚餐，不要晚于7点进食，尽量选择以前常吃的食物，原则是低脂肪、高碳水，避免辛辣刺激的食物，以及高纤维食物。\n赛前2、3小时：比赛当天，早餐很重要！早餐尽量选择容易消化的食物，少吃产气食物（豆类等）；选择体积小的食物，否则滞留肠胃会带来负担；油脂和纤维素含量要少，否则会加速代谢引发便意，所以油条、油饼、炒饭、薯条之类的不适宜。\n赛前30分钟：如果有条件，补充水分300-500毫升。由于盐丸消化需要时间，因此可以提前15~30分钟服用1粒盐丸\n赛中 赛中补给频率：跑步时补给的目标是维持血糖水平，减轻疲劳，避免撞墙的发生，跑者之间存在个体差距，相对来说每30-45分钟补给一次，比较适合大多数跑者。\n比赛开始后的30-45分钟吃下第一个能量胶或能量棒，之后每30-45分钟再吃。\n对于没有尝试过的跑者，可以将一次一包改为半包。\n此外，建议在服用能量胶的同时搭配水，以此避免可能出现脱水的风险。\n盐丸的补给同样要看气温以及跑者自己的身体状况，平均10km吃一颗，天气炎热可以缩短吃盐丸的间隔，反之就延长。\n赛后 完赛后的补给：\n比赛结束后，立即食用高碳水化合物的零食和适量的蛋白质，可以迅速进行糖原的补充，可选择运动饮料、水果或跑者爱吃的易消化吸收的零食。\n完赛2小时内，吃一顿富含碳水和蛋白质的食物，以充分补充糖原并重建肌肉。赛后大餐不宜吃辛辣、刺激性的食物，并且也不适宜饮酒，酒精会减少肌肉糖原合成和蛋白质的合成，对于身体的恢复产生负面影响。\n马拉松补给TIPS:\n任何比赛中的补给都应该是熟悉的 无论是赛前、赛中还是赛后，都不要去尝试自己不熟悉的食物。也就是，尽量保证所有的饮食都是经过自己身体曾经验证过的；\n早餐控制6-7成饱 早餐吃得过饱会增加身体负担，比赛当天吃6到7成饱就足够了。通常比赛日选手可能会有额外的能量食品，因而在能量摄入上，不用过于担心会不够，质＞量；\n减少脂肪和纤维 在比赛当日，尽量减少高纤维和脂肪含量多的食物，容易引起胃部不适，并可能增加上厕所的机会；\n不要等到口渴才喝水 感到口渴的时候，身体就已经脱水了，比赛中即便不感到口渴，在水站也可以稍微喝一点水。从5公里开始，每个水站都可以小抿一口；\n进入水站的正确姿势 进入和离开水站的时候可以做个简单的手势，警示后面选手你会减速、进入水站，同时要向后观察，在没有和别人有冲突的前提下离开主赛道进入水站；\n减少每次补给摄入的量 比赛中，一来身体会加大对食物的渴求，二来消化吸收能力较差，这样很容易吃太多，又增加胀痛、恶心、呕腹泻等肠胃问题；\n能量胶需伴水服用 多数能量胶都要求，在食用时需要150-250ml的水，才能让它更好的发挥效用，也避免对肠胃过度刺激。最佳饮用方法便是，在每次看到水站前完成能量胶摄入，而后进站喝水；\n比赛中少吃这些食物 生活中常吃的饼干、坚果、面包等碳水补充的食物，吃完后需要较长时间消化，因此在比赛的补给中要少吃这类食物，补给效率低且负担大；\n赛后补充越及时，恢复越快 比赛结束后身体的恢复才刚刚开始，这时候补糖、补水、补盐越及时，体能恢复越快。赛后半个小时内尽快补充，恢复效果要远好过数小时后再大吃大喝。\n","permalink":"https://xancoding.cn/posts/2023-04-02-18-00-40/","summary":"配速 330\u0026ndash;4m58s 400\u0026ndash;5m41s 赛前 赛前48小时：充分补充碳水化合物和水分。将饮食中的碳水比例升高，多吃如：面包、面食、米饭和土豆等，还可以食用果汁、蜂蜜和能量棒等","title":"全马准备工作"},{"content":" 学习：\n开始学习深度学习内容（0327）\n补完之前落下的课（0319）\n小林图解系统：一、二、三、五、八\n书籍：\nLife:\nTech:\n《操作系统导论》 School\n《概率论与数理统计》1\u0026ndash;4章\n《电路》1\u0026ndash;4、6\u0026ndash;7章\n《操作系统原理与实践》1\u0026ndash;2章\n《算法设计与分析（第2版）》1\u0026ndash;3、8、11章\n《汇编语言》1\u0026ndash;12章\n《模拟电子技术基础》1\u0026ndash;2章\n电影：\n狼行者\n爱情神话\n韩剧\n黑暗荣耀 1\u0026ndash;2季 感冒（停跑）受伤（停跑）\nApex 弃坑（体验不好）（0304）（克制一下，一天的结束稍稍玩玩）（0315）（再次弃坑）（0316）\n今日起不看抖音（0304）（克制一下，一天的结束稍稍玩玩）（0315）\n跑步\nGitHub（0305 真的有内容的时候，再做提交）\n🌰👋（0319）\n豁然开朗，随心所欲（0325）\n","permalink":"https://xancoding.cn/posts/2023-03-31-08-14-17/","summary":"学习： 开始学习深度学习内容（0327） 补完之前落下的课（0319） 小林图解系统：一、二、三、五、八 书籍： Life: Tech: 《操作系统导论》 School 《概率论与数理","title":"3 月总结"},{"content":"第1章测试 本征激发体现了半导体的 热敏 特性。 第2章测试 B：三极管是电流控制电流元件，通过 Rb 输入电压 的变化转换为 基极电流 的变化 第3章测试 第4章测试 ","permalink":"https://xancoding.cn/posts/2023-03-26-19-25-14/","summary":"第1章测试 本征激发体现了半导体的 热敏 特性。 第2章测试 B：三极管是电流控制电流元件，通过 Rb 输入电压 的变化转换为 基极电流 的变化 第3章测试 第4章测","title":"模拟电子技术基础"},{"content":"书本的 第七章 参数估计 和 第八章 假设检验 没有做整理，还是看书理解的快一些🤔\n《概率论与数理统计（第四版）》P172 表 7-1 正态总体均值、方差的置信区间与单侧置信限（置信水平为 1-α）\n《概率论与数理统计（第四版）》P189-P190 表 8-1 正态总体均值、方差的检验法（显著性水平为 α）\n概率论的基本概念 条件概率 公式 $$P(B|A)=\\frac{P(AB)}{P(A)}$$\n性质 全概率公式 $$P(A)=\\sum_{j=1}^{n}P(B_j)P(A|B_j)$$\n贝叶斯公式 $$P(B_i|A)=\\frac{P(AB_i)}{P(A)}=\\frac{P(B_i)P(A|B_i)}{\\sum_{j=1}^{n}P(B_j)P(A|B_j)}​$$\n相互独立、两两独立、互斥 随机变量的分布函数 几何表示 离散型随机变量的分布函数 性质 例1 例2 连续型随机变量的分布函数 积分上限函数 概率密度 性质 例1 离散型随机变量及其分布律 五个分布律 0-1分布 二项分布 泊松分布 几何分布 超几何分布 n重伯努利试验 $$P = P(A)$$ $$X：n重伯努利 E 中 A 发生的次数$$\n0-1分布 $$n=1$$ 定义：设随机变量 X 只可能取 0 和 1 两个值，它的分布律为： $$P(X=k)=p^k(1-p)^{n-k}$$ 则称随机变量 X 服从参数为 p 的0-1分布，记为$X\\sim 0-1(p)$\n$$E(X)=p,D(X)=p(1-p)$$\n二项分布 $$n$$ 定义：若 X 的分布律为： $$P(X=k)=C_n^k\\cdot P^k\\cdot (1-p)^{n-k}$$ 则称 X 服从参数为 n，p 的二项分布，记为$X\\sim B(n,p)$\n$$E(X)=np,D(X)=np(1-p)$$\n泊松分布 $$n-\u0026gt;∞$$ 定义：若随机变量 X 的分布律为： $$P(X=k)=\\frac{\\lambda^k e^{-\\lambda}}{k!}\\ (k=0,1,2,\u0026hellip;)$$ 其中 $λ \u0026gt; 0$ 是常数，则称随机变量 X 服从参数为 $λ$ 的泊松分布，记为$X\\sim \\pi(\\lambda)$\n$$E(X)=\\lambda,D(X)=\\lambda$$\n泊松定理 当 n 很大，p 很小时，有二项分布近似公式 $$P(X=k)=C_n^k\\cdot P^k\\cdot (1-p)^{n-k} ≈ \\frac{\\lambda^k e^{-\\lambda}}{k!} ,\\lambda = np$$\n几何分布 定义：在独立重复试验中，试验次数预先不能确定。设每次试验成功的概率为 p，讲试验进行到成功一次为止，以 X 表示所需的试验次数，则 X 的分布律为： $$P(X=k)= (1-p)^{k-1} \\cdot p\\ (k=1,2,\u0026hellip;)$$ 则称随机变量 X 服从参数为 p 的几何分布，记为$X\\sim GE(p)$\n超几何分布 定义：从 N 件产品（其中含次品 M 件）中任取 n 件，以 X 表示取到的次品数，则 X 的分布律为： $$P(X=k)= \\frac {C_ {M}^ {k}C_ {N-M}^ {n-k} }{C_ {N}^ {n}} ,0 \\leqslant k \\leqslant n \\leqslant N,k \\leqslant M$$ 则称随机变量 X 服从参数为 （N，M，n）的超几何分布，记为$X\\sim H(N,M,n)$\n连续型随机变量及其概率密度 均匀分布 定义：若随机变量 X 的概率密度为： $$f(x)=\\frac{1}{b-a}\\ ,a\\leq x\u0026lt;b$$ 则称 X 在区间 $(a, b)$ 上服从均匀分布，记为$X\\sim U(a,b)$\n$$E(X)=\\frac{a+b}{2},D(X)=\\frac{(b-a)^2}{12}$$ 小结 正态分布 定义：若随机变量 X 的概率密度为 $$f(x)=\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}$$ 其中 $\\sigma$，$\\mu$ 为常数，且 $\\mu \u0026gt; 0$\n则称 X 服从参数为 $\\sigma$，$\\mu$ 的正态分布，记为 $X\\sim N(\\mu,\\sigma^2)$\n$$E(X)=\\mu,D(X)=\\sigma^2$$\n性质 标准正态分布 指数分布 定义：若随机变量 X 的概率密度为 $$f(x)=\\frac{1}{\\lambda} e^{-\\frac{x}{\\lambda}}\\ ,x\u0026gt;0$$ 其中 $\\lambda \u0026gt; 0$ 为常数 则称 X 服从参数为 $\\lambda$ 的指数分布，记为$X\\sim E(\\lambda)$\n$$E(X)=\\lambda,D(X)=\\lambda^2$$\n性质 例1 小结 随机变量函数的分布 定义 离散型计算方法 连续型计算方法 分布函数求导法 例1 例2 公式法 例1 小结 二维随机变量 二维离散型随机变量 例1 联合分布函数 小结 二维连续型随机变量 二重积分和二次积分 重积分 第二节 二重积分的计算法 - 知乎 (zhihu.com)\n定义 性质 例1 (1) (2) (3) 小结 边缘分布 边缘分布函数 例1 边缘分布律 例2 联合分布律与边缘分布律 边缘概率密度 推导过程 联合概率密度推导出边缘概率密度 例1 联合分布和边缘分布 小结 条件分布 条件分布律 例题 条件概率密度 例1 例2 相互独立的随机变量 二维离散型随机变量 例1 例2 二维连续型随机变量 例1 例2 例3 n 维随机变量的相关概念 二维随机变量函数的分布（离散型） 例题 二维随机变量函数的分布（连续型） 定理（补充，掌握） 二维随机变量和的分布（连续型） 定理 例1 注 例2 二维随机变量商、积的分布（连续型） 定理 例题 最大值、最小值的分布 定理 最大值 最小值 例题 数学期望 离散型随机变量 连续型随机变量 例1 例2 一维随机变量的函数 例1 例2 例3 二维随机变量的函数 例1 例2 小结 数学期望的性质 例1 数学期望的性质小结 方差 方差的定义 方差的计算 例1 小结 方差的性质 例1 数学期望与方差的比较 切比雪夫不等式 定理 例1 协方差及相关系数 概念 协方差的性质 相关系数的性质 不相关与相互独立的关系 例1 例2 小结 矩、协方差矩阵 矩的概念 协方差矩阵的概念（了解） n 维正态随机变量的概率密度（了解） n 维正态随机变量的四条重要性质 小结 大数定律和中心极限定理 概述 大数定律 依概率收敛 弱大数定理（辛钦大数定理） 证明 例题 伯努利大数定理（辛钦大数定理推论） 证明（技巧重要！！！） 注 中心极限定理 概略 标准化变量 定理 定理1 汇总 定理3(定理1的特殊情形) 二项分布的计算 例1 例2 例3 小结 随机样本 基本概念 简单随机样本 样本的分布 例1 例2 小结 直方图 例1 常用的统计量 基本概念 几个常用的统计量 样本的平均值 样本的方差、标准差 样本的 k 阶矩 样本的 k 阶中心矩 小结 经验分布函数 基本概念 例1 例2 小结 三大抽样分布 卡方分布 定义 例题 可加性及数字特征 t 分布 定义 性质 例题 F 分布 定义 性质 例题 例1 例2 小结 分位点 定义 标准正态分布 卡方分布 t 分布 F 分布 注 正态总体的样本均值与样本方差的分布 引入 样本均值与样本方差的数字特征 正态总体样本均值与样本方差的分布 定理一 定理二 小结 点估计 点估计问题 矩估计 知识点 理论基础 求解步骤 例1 例2 例3 小结 最大似然估计 推荐阅读 【梨米特】全网最适合大学生学习的《概率论与数理统计》课，概率统计知识点全解析（适合大一学习、考研复习基础） 概率论与数理统计 公式大全 - 作业部落 Cmd Markdown 编辑阅读器 (zybuluo.com) ","permalink":"https://xancoding.cn/posts/2023-03-14-13-19-12/","summary":"书本的 第七章 参数估计 和 第八章 假设检验 没有做整理，还是看书理解的快一些🤔 《概率论与数理统计（第四版）》P172 表 7-1 正态总体均值、方差的置信区间","title":"概率论与数理统计"},{"content":"模糊理论 模糊集合和模糊子集 一个模糊集合可以表示为一个元素集合和一个隶属度函数的有序对，即 $A = (X, \\mu_A)$，其中 $X$ 是元素集合，$\\mu_A$ 是 $X$ 上的隶属度函数。隶属度函数 $\\mu_A(x)$ 给出了 $x$ 属于 $A$ 的程度，通常取值在 $[0,1]$ 之间。因此，可以用以下符号表示模糊集合 $A$：\n$$A = {(x, \\mu_A(x)) \\mid x \\in X}$$\n其中，$x$ 表示模糊集合 $A$ 的元素，$\\mu_A(x)$ 表示元素 $x$ 在模糊集合 $A$ 中的隶属度。在这种表示方法下，模糊集合 $A$ 由元素集合 $X$ 和隶属度函数 $\\mu_A$ 组成，用一个有序对 $(X, \\mu_A)$ 或者一个描述元素隶属度的集合 ${ (x, \\mu_A(x)) }$ 来表示。\n虽然模糊集合和模糊子集都是具有隶属度函数的元素集合，但它们的概念是不同的。具体来说：\n模糊集合是一个元素集合，每个元素都具有一个隶属度值，这些隶属度值可以表示成一个隶属度函数。 模糊子集是一个元素集合的子集，每个子集中的元素都具有一个隶属度值，这些隶属度值也可以表示成一个隶属度函数。 模糊幂集合 模糊幂集合指的是由模糊集合所有可能的子集所组成的集合。对于模糊集合 $A$，其模糊幂集合 $FuzzyPower(A)$ 定义为包含 $A$ 的所有模糊子集的集合，即：\n$$FuzzyPower(A) = {B | B \\subseteq A}$$\n其中，$B$ 是 $A$ 的子集，表示为 $B \\subseteq A$。每个子集 $B$ 都是一个模糊集合，包含了 $A$ 中的一些元素及其对应的隶属度。因此，模糊幂集合可以用以下符号表示：\n$$FuzzyPower(A) = {B | B = {(x, \\mu_B(x)) | x \\in X, \\mu_B(x) \\leq \\mu_A(x)} }$$\n其中，$X$ 是元素集合，$\\mu_B(x)$ 是元素 $x$ 在子集 $B$ 中的隶属度。该定义保证了 $B$ 是 $A$ 的子集，即 $B \\subseteq A$，同时也保证了 $B$ 是一个模糊集合，其元素的隶属度不大于 $A$ 中相应元素的隶属度。\n模糊子集之间的关系与运算 模糊子集包含关系：$A$包含$B$，当且仅当 $\\forall x \\in X, \\mu_A(x) \\geq \\mu_B(x)$，即 $A \\geq B$。\n模糊子集相等关系：$A$等于$B$，当且仅当 $\\forall x \\in X, \\mu_A(x) = \\mu_B(x)$，即 $A = B$。\n模糊子集交运算：$A$和$B$的交集，定义为 $A \\cap B = {(x, \\min(\\mu_A(x), \\mu_B(x))) | x \\in X}$。\n模糊子集并运算：$A$和$B$的并集，定义为 $A \\cup B = {(x, \\max(\\mu_A(x), \\mu_B(x))) | x \\in X}$。\n模糊子集补运算：$A$的补集，定义为 $A$的补函数为 $\\overline{A} = {(x, 1 - \\mu_A(x)) | x \\in X}$。\n模糊子集模糊化：将精确的集合转化为模糊集合，定义为对于每个元素 $x \\in X$，给出其隶属度函数 $\\mu_A(x)$。\n模糊子集模糊推理：通过模糊逻辑推导出新的模糊子集。在模糊控制中，可以根据输入变量的模糊子集和控制规则，得到输出变量的模糊子集，实现模糊控制目标。\n博弈棋\u0026ndash;六子棋AI 规则 规则：与传统的五子棋（这里指的是没有禁着的五子棋）非常相似，规则非常简单仅有以下三条：\n玩家：如五子棋及围棋，有黑白两方，各持黑子与白子，黑先。\n玩法：除了第一次黑方下一颗子外，之后黑白双方轮流每次各下两子，直的、横的、斜的连成6子（或以上）者获胜。 若全部棋盘填满仍未分出胜负，则为和局。 没有禁手；例如长连仍算赢。\n棋盘：因为公平性不是问题，棋盘是可以任意地大，甚至是无限大亦可。然而为了让游戏可实质地来玩，目前棋盘采用围棋的十九路棋盘。\n不确定性的传播与计算 概念 例题 ","permalink":"https://xancoding.cn/posts/2023-03-05-18-41-26/","summary":"模糊理论 模糊集合和模糊子集 一个模糊集合可以表示为一个元素集合和一个隶属度函数的有序对，即 $A = (X, \\mu_A)$，其中 $X$ 是元素集合，$\\mu_A","title":"人工智能及其应用"},{"content":" 学习：\n数学建模\n美赛（北京时间2023年2月17日6：00（星期五）至2023年2月21日9：00（星期二）） 书籍：\nLife:\n《解读基金——我的投资观与实践》\n《富爸爸穷爸爸》\nTech:\n《操作系统导论》第二部分：并发 跑步 GitHub 刷抖音\n玩Apex\n","permalink":"https://xancoding.cn/posts/2023-02-28-20-18-17/","summary":"学习： 数学建模 美赛（北京时间2023年2月17日6：00（星期五）至2023年2月21日9：00（星期二）） 书籍： Life: 《解读基金——我的投资观","title":"2 月总结"},{"content":"\u003c!DOCTYPE HTML\u003e 环境会造成一个人的习得性无助，如他人对自己的评价。嘴巴长在别人嘴上我们无能为力，但如何对待这些取决于我们\n成功与幸福的标准有很多，不应该只拘泥于单一标准，不要因为某个方面没做好就觉得事事无望\n发现自己处于无望的状态，如果没有人主动来帮助你，你可以主动寻求帮助，明确表达无助的源头\n不应该轻易地评价一个人——已所不欲，勿施于人\n","permalink":"https://xancoding.cn/posts/2023-02-11-11-50-40/","summary":"\u003c!DOCTYPE HTML\u003e 环境会造成一个人的习得性无助，如他人对自己的评价。嘴巴长在别人嘴上我们无能为力，但如何对待这些取决于我们 成功与幸福的标准有很多，不应该只","title":"习得性无助"},{"content":"\u003c!DOCTYPE HTML\u003e 读书笔记📚 其实，有个观念一定要明确，无论是定投买到的基金，还是一次性申购买到的基金，都是你投资的一部分，都是你总资产的一部分，唯一不同的是投资方式不一样。但到你的账户上，它们都是一样的，所以基于总资产配置的考虑更为重要。 发了年终奖。如果市场在高位，我会先买入货币或者债券基金，然后再考虑在合适的时机进入风险高的品种；如果市场在低位，那当然是直接买入的好机会了啊。简单地说，我现在是保持一个1∶1股债比的投资组合，然后每月的收入，先定投货币基金，然后再定转进入这个组合。而具体购买的品种取决于组合的情况，缺什么买什么。 💪怎么去做？ 有几种方式可以帮助你配置资产，确定到底该把多少钱用来投资比较合适。 三分之一法：把三分之一的钱用来买房地产，三分之一的钱用来投资证券市场，三分之一的钱用作储蓄或者买国债。 指头算法：这是根据你的年龄来划分的，如果你是30岁，你应该至少在储蓄上投入30%的资产，而各种投资不宜超过70%；如果你是40岁，那储蓄40%，投资60%；如果你是60岁，储蓄60%，投资40%。用公式表示就是 可用于各类投资的资产比例=100-你目前的年龄 你不能把所有的钱都用来投资。你必须有充足的 应急资金 去应付万一出现的生病、失业等。这样，一旦有急事你也不用临时抛售基金去解燃眉之急。 当按照自己的投资期限、风险承受能力和投资目标，制定了核心和非核心的比例，或者制定股票基金和债券基金的比例，也就是建立好一个投资组合开始的投资计划，还远远不够，还有一件非常重要的事情，就是比例的再平衡。如制定了自己的股票和债券的配置比例是7∶3。一年以后，股票涨得快，债券涨得慢，比例变成8∶2了，怎么办？这时候要卖掉股票，买成债券。如果再过一年，遇到熊市，股票大跌，比例变成了6∶4，这时就要卖掉债券，买入股票，使比例回到7∶3。这就是再平衡。再平衡是很蹊跷的事情。从表面上看，你是卖掉一个上涨快的优良资产，买入一个下跌或者跑得慢的不良资产，但实际上这是一个“高抛低吸”的过程，是一种通过纪律性投资来进行卖高买低的过程，这符合市场是轮动的这一概念。更重要的是，再平衡能保持资产组合的稳定性，也就是风险和收益的平衡。有人用历史数据做过归算，再平衡的综合效益要远远高于不做再平衡的收益。一般一年到一年半才做一次再平衡，而再平衡也仅仅是一个微调过程，只是为了让组合不要偏离自己制定的目标。 必须要强调的是，所谓激进、成长和平稳，都是相对于较长的周期而言。短期内，很可能平稳组合的收益比激进组合的收益还要大，也可能激进组合比平稳组合波动还小，这些都有可能。如果定下这些比例，就可以在一年以后做再平衡，并且始终保持这种比例。这样就保证了长期的风险控制和总体收益。 基金是一个适合长期持有的投资对象。基金公司也非常鼓励大家长期持有基金，例如，赎回费会随着基金的持有年限而递减。长期持有对咱们和基金公司都非常有利。但长期持有策略并不是意味着当咱们购买了一只基金后就再不用管它。反正是长期持有，不闻不问不就行了？这种办法其实是非常危险的。选择基金的时候主要是基于个人的投资目标、投资期、风险承受能力，也是基于这只基金的资产分配和投资策略，还是基于这只基金背后的基金经理和基金公司的能力，等等。如果这些基本点都没有变化，长期持有一只基金当然也没有问题。但如果这些东西有所改变，就得考虑这只基金是否还适合咱们了。因此，对于这些基本因素，必须进行跟踪，从而确保这只基金在基金组合里面一直保持合适的地位。 什么时候赎回基金： 这只基金不再符合自己的投资策略： 投资组合是根据投资策略制定的。投资策略里面，我认为第一个要考虑的是投资期，第二个要考虑的是投资人的心理风险承受能力。但这两个因素都是会变化的。如你开始制定的投资目标是准备养老金，而这时候你只有40岁，目标是60岁退休。所以，开始的时候，选择了非常激进的投资组合。可过了10年，当你50岁的时候，投资期就缩短了，这时候就要开始考虑将激进的组合过渡到平稳的组合，如增加债券的比例，这样才能确保你在要用钱的时候能基本不受市场大的波动的影响。此外，在刚刚进入市场的时候，你的心理情况可能很脆弱，大盘的跌宕起伏可能让你夜不能寐，那就应该选择平稳点的组合。但是随着对市场的适应，对投资理念的理解，你的心态趋于平和，这时候为获得长期更大的收益，可以逐渐增加投资组合中激进基金的比重。无论是发生上述哪种情况，都要去考虑原来持有基金的赎回或者转换问题。基金本身也是会变化的。当开始做资产组合的时候，你只需按照当时基金的情况进行考虑。但随着时间的推移，基金本身的资产组合和投资策略也会发生变化。例如，上投摩根基金公司的中国优势基金在开始发行的时候，股票的比例是定在80%，而2007年增加到95%。那你可能就要考虑这种变化是不是自己需要的和能承受的。当一个本来规模中等的基金膨胀到一个巨型基金的时候，你也不得不考虑巨型基金在表现上和中等规模的基金的差异；尤其是当一只原本是激进型的基金在规模急剧扩大后，自然就会变化得不那么“激进”的时候，也就是人们常说的船小好调头。另外，如果一只基金的份额大规模减少，这也是非常恐怖的事情，因为太小的基金将面临清盘关闭的风险。这些也是咱们要考虑的东西。基金经理和基金公司也是会发生变化的。基金经理的变迁在国内似乎是一个非常常见的现象。虽然大部分基金公司采用的是团队作战的方式，但基金经理作为一个“前锋”，依然是非常关键的。基金经理的变动往往意味着某种投资风格的变化，在这种情况下，咱们就一定要多多加以关注。也许赎回不是好的策略，但加倍关注是必需的。基金公司更是一个要重点“盯防”的对象。无论是在中国市场还是在美国市场，基金公司暴露丑闻并不是新鲜的事情。不要指望一个“肮脏”的公司下面会有一只为咱们的利益服务的优秀基金。基金的业绩表现是不是咱们需要考虑的因素呢？当然是的，但一定不是短期业绩。业绩的比较一定是要在同种基金之间进行的，如果一只基金在较长的时间内落后同类的其他基金，那事情就比较麻烦。我说的“较长的时间”至少是用半年来衡量的。但同时如果一只基金跑得比同类基金快，也不是好事情，因为这也说明有什么不对头的地方。可能咱们原本想要一只平稳的基金，但跑得太快一般就是波动幅度比较大，这就和我们的要求不一样了。当有上面这些事情发生的时候，就得考虑是不是该赎回原来持有的基金了。 自己的投资目标已经达到： 投资期快要结束时，投资目标基本要达到的时候，也要有个赎回策略。虽然投资期一般都比预想的要长，但最终总是要赎回的。不过也要注意到，即便准备60岁退休，也不是说到60岁的时候就需要把所有的投资都赎回。如果按能活到80岁，那后面还有20年的投资期啊。所以要有一个策略，要一部分一部分地赎回。虽然在股市下跌的时候赎回基金是很不明智的，但为了不在最后的时候被熊市搞得进退不得，只能早做打算。最好是提前5年就做准备，把需要赎回的部分在市场处在较高位置时转换成平稳的基金，或者债券基金。这样，即便5年后遇到熊市，也不会在退休开始的时候没有钱用。不要冒不必要的风险去赌未来的市场情况，在任何时候都不要去预测市场。我也建议，赎回过程宜采用分步的方式。中国的股市波动频率太快，分步赎回也会降低一些风险。在任何时候都要记住，控制风险是最重要的。 市场表现太疯狂了，也要赎回基金： 永远记住：市场只会让少数人赚钱。一旦出现这种情况你就该“跑”了，至少该减仓而不能加仓了。同理，如果周围没有人谈论股票和基金，连骂股市的人都没有了，那市场就是低位了。记住一条，爱的反义词不是恨，而是冷漠，是懒得理你。 有些风险是避免不了的，那就得努力去削弱这种风险；而有些风险是完全可以避免的，那就一定要避免。对于大盘，对于整个市场，咱们是控制不了的，也是预测不了的，那就只能接受这种风险，这就是系统的风险。也只有接受这种风险，才能获得咱们希望得到的收益。这种风险是无法回避的，是必须承受的。对于各股的涨跌、热点的轮动、基金公司和基金经理个性化的风险，咱们可以通过长期投资和分散化投资去削弱和降低它们。这种风险是可以想办法规避的。而对于预测市场、波段操作甚至盲目抢购新基金，我认为这些是额外的风险，是完全可以避免的，而且也是应该去避免的。投资一定不是投机，不是赌博。事实上，职业的赌徒也知道哪些风险是可以规避的，也会去规避。盲目地承担额外的风险，从长期来看，一定是会“失足”的。所以，要好好去研究，好好去区分这些风险。 要说明的一点是，所谓长期投资并不是指长期抱着一只基金不放。我认为，长期投资是指不以做波段为目的，通过卖高买低来投机赚钱，而是通过整个市场的增长来实现一个长远的目标。也就是，我认为当你发现你所持有的基金出现问题时，你转换成另外一只（货币基金除外），这同样是长期持有策略。在长期持有的思想下，这种转换是不需要考虑大盘的涨跌的。在高点，你抛出这只基金，同样在高点进入另外一只基金；或者在低点抛，低点进。这都和大盘表现基本无关。这种转换，我不认为和长期持有相矛盾。 短期市场会向哪里发展没有人知道，但长期持有的策略是不会改变的。卖出策略的总结： 如果我的投资目标变了，我肯定要改变投资组合。例如，当我越接近退休时，我的投资组合就会越稳健。 如果基金公司发生变化，例如，像合丰成长基金那样时，会考虑卖出基金。如果单是基金经理发生变化，会抱着静观的态度。中国的基金大多数是采用集体作战的形式，经理是很重要的一环，但不是唯一的一环。 如果发现犯了错误，会立刻改正错误。银河收益基金的购买就是一个错误，我应该先去看它的季报再买。其实，2005年底，它已经只有不到1亿元的资产了。我被那个五星哄了。如果错了，即便是亏了，也不会等它赚回来再卖掉。一定会立刻卖掉，转换到另外一只基金，无论是亏还是赚，越快越好。 在购买的时候，我选择的基金都是四或五星的。但如果一只基金跌到三星连续3个月以上，我会给它非常多的关注；如果持续6个月，我也许就要给它黄牌或者红牌了。晨星评级是一个相对评级，它不是由大盘决定的，而是在同类中相互比较的结果，这非常有意义。 我不会因为基金的绝对涨跌幅度来决定买卖，也不设置一个止损线。因为行情涨跌很多是由大盘决定的，我更看重相对评价，而不是绝对的收益。 如果一只基金出现问题，我会去选择一个替代品，把它转换过去。这种转换不会受大盘的影响，因为不是追逐波段操作。 核心还是一个理念：不预测市场，主要看基金公司的基本面。 经济基础决定上层建筑，物质决定意识。其实，咱们的投资方式已经决定了咱们的心态。我最早在搜狐“基金天下”论坛写的连载——《我的投资观和实践》的第一篇讲的是“该把多少存款用来投资”，第二篇讲的是“基金投资的风险”。其实，这两篇的核心是必须用闲钱来投资，而且投资期应该足够长。这两点，我认为是投资基金必须遵守的基本准则，是绝对不能违背的。很遗憾，在市场狂热的时候，很多人却忘记了这两点。当你把你所有的钱都投进市场，甚至借钱买基的时候，当你春节以后就要用这笔钱去买房子、结婚的时候，面对市场的下跌，不惊恐也不可能。 首先，我的基本投资思想是保持股债的平衡，也就是根据我自己的风险承受能力，有个平衡比例，如1∶1的比例。然后根据再平衡理论，始终努力保持这个比例，也就是稳定风险。定投会改变这个比例，如开始的时候我定投股基，但当我的股基比例过高的时候，会改定投到债券。另外，在股基中，也有大盘基金和小盘基金的区别，我也有个比例，这样，也会在这些基金中平衡。但有一点，我依然是定时定额，依然是把闲钱尽量地投入市场，只是投资的品种会有变化，可能是股基、中小盘，也可能是债券。其次，我没有定期存款，也没有国债之类的投资。除一些必需的活期以外，基本上银行卡上是没有钱的。工资的大部分就被我先定投到货币基金中了。再怎么加息，货币基金也比活期好啊，流动性也不是太差。现在很多基金公司开放了直销定期转换业务，如广发的“钱袋子”、上投摩根的“现金宝”、富国的“富管家”。我先定投货币基金，然后再定期把里面的钱转换成我需要的定投品种，岂不是非常方便和简单？而且，还能享受4折的优惠和其他转换的优惠。 ","permalink":"https://xancoding.cn/posts/2023-02-01-19-37-10/","summary":"\u003c!DOCTYPE HTML\u003e 读书笔记📚 其实，有个观念一定要明确，无论是定投买到的基金，还是一次性申购买到的基金，都是你投资的一部分，都是你总资产的一部分，唯一不同的","title":"《解读基金——我的投资观与实践》"},{"content":" 学习：\nC++（Learncpp.com）\n数学建模\n做饭：\n炸鸡腿\n紫菜汤\n爆炒鸭腿\n芹菜小炒牛肉末\n炒素面\n糖醋排骨\n书籍：\nLife:\n《小狗钱钱》\n《可能性的艺术》\n《人类简史》\nTech:\n《汇编语言》\n《操作系统导论》第一部分：虚拟化\n博客功能完善（实现自动化发布）\n沟通技能 Up Up Up\n跑步 GitHub ","permalink":"https://xancoding.cn/posts/2023-01-31-16-48-25/","summary":"学习： C++（Learncpp.com） 数学建模 做饭： 炸鸡腿 紫菜汤 爆炒鸭腿 芹菜小炒牛肉末 炒素面 糖醋排骨 书籍： Life: 《小狗钱钱》 《可能性的艺术》 《","title":"1 月总结"},{"content":"\u003c!DOCTYPE html\u003e ","permalink":"https://xancoding.cn/posts/2023-01-26-11-14-43/","summary":"\u003c!DOCTYPE html\u003e","title":"烤红薯 \u0026 烤芋头"},{"content":"\u003c!DOCTYPE html\u003e ","permalink":"https://xancoding.cn/posts/2023-01-23-22-40-50/","summary":"\u003c!DOCTYPE html\u003e","title":"烧烤"},{"content":"\u003c!DOCTYPE html\u003e ","permalink":"https://xancoding.cn/posts/2023-01-18-12-29-48/","summary":"\u003c!DOCTYPE html\u003e","title":"永嘉电视塔"},{"content":"桌面 Wallpaper Engine 这是STEAM平台上的一款动态壁纸软件，可以在创意工坊中找到自己感兴趣的壁纸 目前正在使用的壁纸 Win 10 开始菜单 我不太习惯把应用的快捷方式直接放在桌面上，我将应用放在了开始菜单的位置。\n在需要打开某一个应用时，只需在键盘上敲击 windows键，即可跳出下图的界面，我就可以在在上面打开所需的应用了 如果是常用的网页，我会借助 Chrome浏览器的创建快捷方式，将其创建为应用，并固定到开始界面 生产力 搜索 Everything 通过文件、文件夹名称快速搜索软件，比 Windows 自带的搜索速度快上不少，使用起来很是方便 Wox Windows效率搜索神器Wox快速教程 安装好后，可以通过 alt + 空格键 调出搜索栏，通过Esc 退出。调出输入框后，可以通过在地址栏中输入快捷字词，实现在特定网站中搜索内容，或使用其他搜索引擎进行搜索，如下所示，和这里的效果差不多。 除此之外，由于借助了 Everything 的帮助，也可以直接搜索电脑中的文件以及文件夹，如下所示： 截图 Snipaste Snipaste 是一个简单但强大的截图工具，也可以让你将截图贴回到屏幕上！\n我使用它用于截图和取色。 压缩解压缩 7-Zip 7-Zip是一款高压缩比的压缩软件，不仅支持独有的7z文件格式，而且还支持各种其它压缩文件格式，其中包括ZIP、RAR、CAB、GZIP、BZIP2和TAR等格式。 图床 去不图床 \u0026amp; PicGo \u0026amp; Image auto upload Plugin 我使用的图床是去不图床，借助 PicGo，方便将图片上传到图床，并生成访问链接用于访问图片（我的主要使用场景是博客中的图片），最后再借助 Obsidian 中的 Image auto upload Plugin 插件，简化我原先写博客时需要一张一张上传图片，复制链接的繁琐过程。\n如今，只用把图片拖拽到 Obsidian 编辑器中，即可自动将图片通过 PicGo 上传到 去不图床，并生成链接，显示在 Obsidian 中。\n","permalink":"https://xancoding.cn/posts/2023-01-15-12-42-38/","summary":"桌面 Wallpaper Engine 这是STEAM平台上的一款动态壁纸软件，可以在创意工坊中找到自己感兴趣的壁纸 目前正在使用的壁纸 Win 10 开始菜单 我不太习惯把应用的快捷方式","title":"我的电脑常用工具"},{"content":"\u003c!DOCTYPE HTML\u003e 读书笔记📚 金钱有一些秘密和规律，要想了解这些秘密和规律，前提条件是，你自己必须真的有这个愿望 太多的人做事犹豫不决，就是因为他们觉得没有完全弄懂一样东西。而真正付诸实施要比纯粹的思考要聪明多了 在自己还没有做之前，不要轻易下结论。没有想像力的人是很难成就大事的。我们在一生中投入精力越多的事情，其成功的可能性也越大。可是大多数人把精力放在自己并不喜欢的事情上，而不去想像自己希望得到的东西。 钱的数目并不是决定性因素，更重要的是我们怎么来使用它。我们首先必须学会量入为出。只有这样，我们才有能力获得更多的钱 如果你只是带着试试看的心态，那么你最后只会以失败而告终，你会一事无成。尝试纯粹是一种借口，你还没有做，就已经给自己想好退路了。不能试验。你只有两个选择：做，或者不做 你的自信程度决定了你是否相信自己的能力，你是否相信你自己。假如你根本不相信你能做到的话，那么你就根本不会动手去做，而假如你不开始去做，那么你就什么也得不到 你是否能挣到钱，最关键的因素并不在于你是不是有一个好点子。你有多聪明也不是主要原因，决定因素是你的自信程度 你最好想清楚，你喜欢做什么，然后再考虑你怎么用它来挣钱 你应该在自己遇到困难的时候，仍然坚持自己的意愿。当一切正常的时候，每个人都能做到这一点。可是当真正的困难出现的时候，才见了分晓 陷入债务的人只需要听从四个忠告就可以解决负债问题： 撕毁信用卡。因为大多数人在使用信用卡的时候，比用现金花的钱要多得多 支付许可范围内最小的分期付款数目。分期付款额越高，他们每个月剩下的生活费就越少。为了减少利息的支出，给自己太大的分期付款压力，不值得。许多人和银行约定的分期付款数额是他们刚刚能承受起的数目。因此他们手里的钱会一直很紧缺。大多数情况下，他们没有估计到生活费用是那么的高。那么当他们必须购置一辆新汽车或家里的什么东西坏了的时候，他们只得再次贷款来偿付这些东西的账单 应当将不用于生活的那部分钱中的一半存起来，另一半用于还债。最好不要申请消费贷款。所有的消费贷款都是不明智的。聪明的做法是只支出以前积攒起来的财富。消费贷款是与住房无关的贷款。假如人们为了购置新的汽车、家具、电视机或用于生活的贷款，就是消费贷款。这时候欠债的人应当遵守 50％ / 50％ 的原则。他们应当将不用于生活的那部分钱中的一半存起来，而另一半用于还债 每次借债前问自己：“这真的有必要吗 ?” 当你定下了大目标的时候，就意味着你必须付付出比别人多得多的努力 假如我总是花光我的钱，那我就永远也得不到我的鹅。假如我没有了我的鹅，我就总得为了赚钱而工作。但是一旦我有了一只鹅，我的钱就会自动为我工作了 你干的活最多只占报酬的一半，另一半是因为你的想法和实施这个想法的勇气 我决定以后绝不给我的孩子太多的零花钱，而是指导他们记成功日记，让他们自己挣钱，越早越好 如果说运气是充分准备加上努力工作的结果，那我准备得越充分，工作得越努力，运气也就越好 一个人挣钱多少是和他的自信心联系在一起的。还有就是取决于他的精力是集中在自己的能力范围之内，还是放到了他力所不能及的事情上。没有我的成功日记本，我就不会去思考自己适合在哪些地方赚钱 一个人要想过更幸福、更满意的生活，就得对自身进行改变。这和钱无关，金钱本身既不会使人幸福也不会带来不幸。金钱是中性的，既不好，也不坏。只有当钱属于某一个人的时候，它才会对这个人产生好的或者坏的影响。然后，钱要么被用于好的用途，要么被用作坏的用途。一个幸福的人有了钱会更幸福；而一个悲观忧虑的人，钱越多，烦恼就越多 金钱会暴露一个人的本性。金钱就像一个放大镜，它帮你更充分地展现出你本来的样子。好人可以用钱做很多好事。而如果你是盗贼，那你很可能会把钱挥霍在一些蠢事上 最珍贵的礼物是我们自己争取来的。克服了丢面子的恐惧，世界就会向你敞开大门！ 如果你骄傲自大，你就会停止学习。不学习，人就停止了进步 对困难、犯错误和丢面子的恐惧已经破坏了无数人的生活 当你朝着积极的目标去思考的时候，就不会心生畏惧 决定一件东西价值多少的惟一因素就是，你愿意为它支付多少钱 如果你没有做今天这件事情，你就永远不会知道，给自己一些压力之后，你能够做到些什么。一个人觉得最引以为自豪的事情，往往是那些做起来最艰难的事情。这一点你千万不要忘记 有“困难”是一件好事。因为它逼得我四处寻找新的途径，可以学到很多新东西 市场是一种原则——就像民主一样，它可能被滥用。市场并不意味着没有秩序的横冲直撞，而是意味着透明度、竞赛、对人和自然的责任、公平竞争和一定程度的保护 从小开始赚钱的人拥有对依赖思想的抵抗力，不会乐意让别人来养活自己。而且自己赚钱的人不会成为不断膨胀的消费欲望的奴隶。从事商业活动有助于人们以理智的态度珍惜使用有限的资源。我们推崇一种聪明的、简朴的生活方式。也就是说，宁愿购买一件一流产品，也不要不停地买许多的二流产品。而且，不要仅仅因为一件产品的外观不再时髦而新产品正在流行，就频频追逐新鲜的东西。生活质量不是由越来越多的高科技产品堆砌而成的，而是体现在一些别的方面，比如悠闲地享受一下生活，加强邻里关系，表达感情或者从事艺术性和创造性的活动 思考可以是一种享受，而工作会带来无穷乐趣。具有横向思维能力的人将会受到欢迎，青少年完善自身的愿望和对独立的追求不应遭到遏制 孩子们具有掌握自己发展方向的潜力。因此，成年人不要替孩子决定该如何发展，而是应该理解、支持他们，帮助他们调整。大人应该相信孩子们的自觉性和进取心 💪怎么去做？ 成功日记：你就把所有做成功的事情记录进去。你最好每天都做这件事，每次都至少写五条你个人的成果。任何小事都可以。开始的时候也许你觉得不太容易。也许你会问自己，这件或那件事情是否真的可以算作成果。在这种情况下，你永远应该做出肯定的回答。从现在开始不间断地记录你的成功日记，并且不间断地设想你的未来。而且不论在什么情况下，都坚持每天这么做。当你取得一些成功之后，不要停止写你的成功日记，这是很重要的。当你记成功日记的时候，你会对自身，对世界，还有对成功的规律做更深入的思考，你就会越来越多地了解自己和自己的愿望，这会使你有能力去理解别人。要彻底了解自己和世界上的所有秘密，是我们无法完全实现的一种理想。但我们可以一步一步地慢慢接近这个理想。每当你觉得有些事情不好办的时候，你可以做一件事，你就翻一翻成功日记本，你会从过去的事情中找到未来你也有能力完成任何事情的证据。恐惧总是在我们设想事情会如何不顺的时候出现。我们对失败的可能性想得越多，就会越害怕。而当你看自己的成功日记本时，你就会注意到那些成功的事情，你自然而然也就会想到应该怎样去做 梦想储蓄罐和梦想相册 下定决心，而不是抱着试试看的态度 你要每天不间断地去做对你的未来意义重大的事情。你为此花费的时间不会超过 10 分钟，但是就是这 10 分钟会让一切变得不同。大多数人总是在现有的水平上停滞不前，就是因为他们没有拿出这 10 分钟 当你决定做一件事情的时候，你必须在 72 小时之内完成它，否则你很可能就永远不会再做了 根据自己的需要精确分配。如果你总是把十分之一的钱变成鹅，那么你一定会变得富有。但如果你想有一天真的很有钱的话，你存的比例可能得再高一些 强迫你做自己不愿意做的事情。只有你自己才能强迫自己去做 金钱魔法师的咒语 确定自己希望获得财务上的成功 自信，有想法，做自己喜欢做的事 把钱分成日常开销、梦想目标和金鹅账户三部分 进行明智的投资 享受生活 怎么选择基金 基金应该至少有十年历史。假如它在这么长时间内一直有丰厚的盈利，那我们可以认为，它在未来也会运作良好 应该选择大型的跨国股票基金。这种基金在世界各地购买股票，以此分散风险，所以十分安全 对基金的走势图进行比较。我们应该观察在过去 10 年间哪些基金的年终获利最好 最好的办法就是，我们把钱投在一个大型的基金上，5 到 10 年之内根本不去看它 72 定理 直接用 72 除以你们投资的年收益率的百分比，得出的数字就是这笔钱翻一倍所要的年数，这就是说，如果你们每年得到 12%的红利，6 年以后你们的钱就会翻一倍。 72 公式也可以用来帮助我们计算通货膨胀。它可以告诉我们，在一定通货膨胀率下，我们的钱在多长时间后会贬值一半。按 72 除以 3% 的通货膨胀率计算，得到 24，就是说 24 年以后，你的钱只值现在的一半 没有人能知道，所有试图预测未来走势的专家总是计算失误，意想不到的情况很多。正因为如此，你应该始终储备一些现金。你绝不能把你全部的钱都投资在股票或者基金上面。基金的确很保险，尤其是当你有足够的时间可以等待的时候。就算行情暂时处于谷底，到时总会回升的。但是出于分散风险的考虑，你应该把一部分钱投资在绝对安全的地方。比如你可以投资日拆，获取利息——这是根据市场行情变化的，目前大概是 3.5%。这笔钱你随时可以动用。如果所有资金都投入日拆，你肯定不会变富，甚至可以说，事实上你的财产根本没有增加，因为通货膨胀会完全吞掉你的利息。该把百分之几的钱投资日拆呢？这要根据你的具体情况决定。既然你很年轻，20% 就够了 就算你还很年轻，也该留一些现金做储备。只有这样才能达到最佳的分散风险的效果 怎样在实践中实施这些原则，是自己的事情，自己对自己的财务状况负责 我的感悟💗 从现在就开始有意识的去投资，而不是等手里有一定的资金了再去做。学习是一个认知不断完善的过程，有些亏是吃了才会知道的。趁现在，手中的钱不算很多，就算吃了亏，损失也不会很多。如果等到以后资金多起来的时候才试着去做，那时候吃亏带来的损失就会很大了\n","permalink":"https://xancoding.cn/posts/2023-01-14-14-49-35/","summary":"\u003c!DOCTYPE HTML\u003e 读书笔记📚 金钱有一些秘密和规律，要想了解这些秘密和规律，前提条件是，你自己必须真的有这个愿望 太多的人做事犹豫不决，就是因为他们觉得没有完","title":"《小狗钱钱》"},{"content":" MIT线性代数 | 笔记 MIT线性代数 | Vedio 线性代数的本质 - 系列合集 | Vedio 考生必记：线性代数知识汇总 | 笔记 ","permalink":"https://xancoding.cn/posts/2022-12-15-08-38-27/","summary":"MIT线性代数 | 笔记 MIT线性代数 | Vedio 线性代数的本质 - 系列合集 | Vedio 考生必记：线性代数知识汇总 | 笔记","title":"线性代数"},{"content":"计算机系统基础(一)——程序的表示、转换与链接 原码\u0026amp;移码\u0026amp;补码 原码 最高位放符号位，1 表示负 定点小数，用来表示浮点数的尾数 移码 真值加上一个偏置值 bias，$bias$ 常为 2n - 1 $or$ 2n - 1 - 1 (如 $IEEE 754$) 定点整数，用来表示浮点数的阶 移码的本意是为了方便两个数作比较 补码 假设补码有 $n$ 位，则：x补 = 2n + x 数值为正数时，其值大小就是原码；为负时，其值的大小就是各位取反再加 1 补码表示带符号整数 补码的出现是为了解决计算机的减法运算问题 求补码的真值——简便求法 符号为 0 ，则为正数，数值部分相同 符号为 1，则为负数，数值各位取反，末位加 1 各位取反，末位加 1 简便做法：从后往前看，找到第一个 1 ，将它前面的所有位取反 浮点数——$IEEE754$标准 数符 + 阶码 + 尾数 Float $1 + 8 + 23$ $SP$：$(-1)$s $$ $(1 + Significand)$ $$ $2$(Exponent - 127) Double $1 + 11 + 52$ $DP$：$(-1)$s $$ $(1 + Significand)$ $$ $2$(Exponent - 1023) 数符 $Sign bit$ 1 表示负数 阶码 $Exponent$ 规格化阶码范围为 $0000 0001(-126) —— 1111 1110(127)$ $(single)$ $bias$ 为 $127(single)$ $1023(double)$ 规格化阶范围为 $1——254$$(single)$ 全 $0$ 和全 $1$ 用来表示特殊值 为避免混淆，用阶码表示阶的编码，用阶或指数表示阶码的值 尾数 $Significand$ 规格化尾数最高位总是 $1$，所以隐含表示，省 $1$ 位，小数点前总是 $1$ 特殊数的表示$(single)$ $0$ $阶码：all$ $zeros$ $尾数：all$ $zeros$ $+0：0$ $00000000$ $00000000000000000000000$ $-0：1$ $00000000$ $00000000000000000000000$ $∞$ $阶码：all$ $ones$ $尾数：all$ $zeros$ $+∞：0$ $11111111$ $00000000000000000000000$ $-∞：1$ $11111111$ $00000000000000000000000$ 浮点数除以 $0$ 的结果是 $∞$，而不是溢出异常(整数除以 $0$ 为异常) $NaN$ ($Not$ $a$ $Number$) $阶码：all$ $ones$ $尾数：nonzeros$ 可帮助调试程序 非规格化数 $Denorms$ $阶码：all$ $zeros$ $尾数：nonzeros$ 用于表示 $0$ 与规格化数间的$Gap$ $SP$：$(-1)$s $$ $(0.xxxx\u0026hellip;xxx)$ $$ $2$-126 为了让非规格化单精度浮点数能够平缓过渡到规格化单精度浮点数，所以取 $2$-126 当输入数据为不可表示数时，机器将其转换为最邻近的可表示数 汉字内码\u0026amp;ASCII码 ASCII码为 7 位编码 Ex：汉字 \u0026ldquo;$大$\u0026rdquo; 在码表中位于第 $20$ 行、第 $83$ 列。因此区位码为 $0010100$ $1010011$，在区、位码上各加 $32$ 得到两个字节编码（GB2312国标码），即 $00110100$ $01110011B$ $=$ $3473H$。前面的 $34 H$ 和 字符 $4$ 的 $ACSII$ 的最高位相同，后面的 $73H$ 和字符 $s$ 的 $ACSII$ 码相同。但是，将每个字节的最高位各设为 $1$ 后，就得到其内码： $B4F3H$ ($0110100$ $11110011B$)，因而不会和 $ASCII$ 码混淆 逻辑电路 异或：$n$ 个数做异或运算，若有奇数个 $1$ ，则输出 $1$ 推荐阅读 # 原码、反码、补码 计算机系统基础(一)——程序的表示、转换与链接 计算机系统基础(二)——异常、中断和输入/输出 计算机系统基础(三)——程序的执行和存储访问 以 IA-32 + Linux + C + gcc 为平台 【精校中英字幕】2015 CMU 15-213 CSAPP 深入理解计算机系统 《深入理解计算机系统（原书第3版）》CSAPP \u003c!DOCTYPE HTML\u003e ","permalink":"https://xancoding.cn/posts/2022-11-15-21-37-17/","summary":"计算机系统基础(一)——程序的表示、转换与链接 原码\u0026amp;移码\u0026amp;补码 原码 最高位放符号位，1 表示负 定点小数，用来表示浮点数的尾数 移码","title":"计算机系统基础"},{"content":"为什么 SICP 非常重要 它将注意力重点放在了抽象的核心思想之上 —— 从特定问题直至构建软件工具，帮助你探求一般性的规律\n学习 SICP 之于编程就像学习 学习 本身\n学习 SICP 的目的是为了学会 控制大型系统复杂度 的技术\n推荐阅读 【计算机程序的构造和解释】精译【UC Berkeley 公开课-CS61A (Spring 2021)】-中英双语字幕 为什么 SICP 非常重要 魔法书《SICP》的简明介绍 - 为什么要学习SICP 如何掌握所有的程序语言 [2021 Spring] CS61A 学习笔记 Python tutor CS 61A: Structure and Interpretation of Computer Programs 计算机程序的构造和解释(原书第2版) \u003c!DOCTYPE HTML\u003e ","permalink":"https://xancoding.cn/posts/2022-11-15-14-34-16/","summary":"为什么 SICP 非常重要 它将注意力重点放在了抽象的核心思想之上 —— 从特定问题直至构建软件工具，帮助你探求一般性的规律 学习 SICP 之于编程就像学习 学习 本身 学","title":"计算机程序的构造和解释"},{"content":"汇编语言是什么？ 汇编语言是任何一种用于电子计算机、微处理器、微控制器，或其他可编程器件的低级语言\n部分知识点 一个段的起始地址必定是 16 的倍数 \u0026ndash; CS * 10H 一个段的最大长度是 64KB \u0026ndash; IP 寄存器长度为 16 位，$2^{16} = 64$ A D 在汇编源程序中，数据不能以字母开头，所以要在前面加 0，如 0FFF0H 只有 BX、BP、SI、DI 这 4 个寄存器可以用在 \u0026ldquo;[\u0026hellip;]\u0026rdquo; 来进行内存单元的寻址 有效地址指的就是偏移地址 在汇编源程序中，指令 mov ax, [0] 被编译器当作指令 mov ax, 0 处理 Debug 将 [idata] 解释为 一个内存单元 编译器将 [idata] 解释为 idata 根据位移进行转换的 汇编指令 方便了程序段在内存中的浮动装配 如果在源程序中出现了转移范围超界的问题在编译的时候，编译器将报错 mov、push、pop等指令的执行对标志寄存器没有影响 CF 标志 \u0026ndash; 无符号数 进位或借位 OF 标志 \u0026ndash; 有符号数 溢出 内中断 CPU 内部产生如下情况时，中断类型码在 CPU 内部产生 除法错误 单步执行 执行 into 指令 执行 int 指令 外中断 可屏蔽中断 来自于CPU外部，中断类型码通过数据总线送入 CPU 几乎所有由外设引发的外中断，都是可屏蔽中断。比如说键盘输入发生时, 相关芯片向CPU发出可屏蔽中断信息 不可屏蔽中断 cmp指令的操作数可以是寄存器、立即数或者内存地址 PF标志位，根据结果中最低有效字节(最低8位)中“1”的个数来确定置1还是清0。如果“1”的个数为偶数，则PF的值为1，否则其值为0 程序设计框架 主程序设计框架 ASSUME CS:CODE, DS:DATA DATA SEGMENT STR1 DB 1, 2, 3, 4 DATA ENDS CODE SEGMENT START: CODE ENDS END START 子程序设计框架 1 ASSUME CS:CODE, DS:DATA DATA SEGMENT STR1 DB 1, 2, 3, 4 DATA ENDS CODE SEGMENT START: ... CALL SUB1 ... MOV AX, 4c00H INT 21H ; 功能：计算 N 的 3 次方 ; 参数：(bx) = N ; 返回：(dx:ax) = N^3 SUB1 PROC ... RET SUB1 ENDP CODE ENDS END START 子程序设计框架 2 \u0026ndash; 把主过程看作DOS调用的子进程 ; 调用程序和过程在同一代码段中，则使用NEAR属性 ; 调用程序和过程在不同代码段中，则使用FAR属性 ; 缺省值为 NEAR ASSUME CS:CODE, DS:DATA DATA SEGMENT DB 1, 2, 3, 4 DATA ENDS CODE SEGMENT MAIN PROC FAR ; 把主过程看作DOS调用的子进程，定义为FAR属性 ... CALL SUB1 ; 调用子程序SUB1 ... RET ; 过程返回 MAIN ENDP ; 功能：计算 N 的 3 次方 ; 参数：(bx) = N ; 返回：(dx:ax) = N^3 SUB1 PROC NEAR ; 同一代码段调用使用NEAR属性 ... RET ; 过程返回 SUB1 ENDP ; 过程结束 CODE ENDS END MAIN IF 条件语句的汇编实现框架 cmp a, b jOP true jmp next true: s1 next: ... IF-ELSE 条件语句的汇编实现框架 cmp a, b jOP true jmp false true: s1 jmp next false: s2 next: 程序框架 子程序 传递参数 寄存器传递 \u0026ndash; 参数较少 内存空间传递 \u0026ndash; 参数较多 保存和恢复寄存器 部分知识点 DOS 系统中 .EXE 文件中程序的加载过程 指令 MOV 指令 \u0026ndash; 数据传送指令 寄存器、段寄存器、内存单元、立即数 MOV 寄存器，立即数：MOV AX, 8 MOV 寄存器，寄存器：MOV AX, BX MOV 寄存器，内存单元：MOV AX, [0] MOV 寄存器，段寄存器：MOV AX，DS MOV 段寄存器，立即数 MOV 段寄存器，寄存器：MOV DS, AX MOV 段寄存器，内存单元：MOV DS, [0]（允许，但不建议） MOV 段寄存器，段寄存器 MOV 内存单元，立即数：MOV WORD PTR DS:[0], 1 MOV 内存单元，寄存器：MOV [0], BX MOV 内存单元，内存单元 MOV 内存单元，段寄存器：MOV [0]，DS（允许，但不建议） AND 和 OR 指令 DIV 指令 \u0026ndash; 无符号除法指令 JMP 指令 \u0026ndash; 无条件转移指令 依据位移进行转移的 JMP 指令 转移的目的地址在指令中的 JMP 指令 转移的目的地址在寄存器中的 JMP 指令 转移的目的地址在内存单元中的 JMP 指令 总结 Label：标号 段内段转移（8位）（IP）：依据位移进行转移的 JMP 指令 段内近转移（16位）（IP）依据位移进行转移的 JMP 指令 段内转移（16位）（IP）：转移地址在寄存器中的 JMP 指令 段内转移（16位）（IP）：转移地址在内存中的 JMP 指令 段间远转移（32位）（CS:IP）：转移的目的地址在指令中的 JMP 指令 段间转移（32位）（CS:IP）：转移地址在内存中的 JMP 指令 JCXZ 指令 \u0026ndash; 有条件转移指令 LOOP 指令 \u0026ndash; 循环指令 CALL 和 RET指令 \u0026ndash; 转移指令 MUL 指令 \u0026ndash; 无符号乘法指令 ADC 指令 \u0026ndash; 带进位加法指令 SBB 指令 \u0026ndash; 待借位减法指令 CMP 指令 \u0026ndash; 比较指令 CMP 指令 无符号数比较结果 \u0026amp;\u0026amp; 有符号数比较结果 检测比较结果的条件转移指令 DF 标志和串传送指令 PUSHF 和 POPF IN 和 OUT 指令 \u0026ndash; 端口读写指令 移位指令 汇总 操作符 DUP offset 内存单元寻址 BP默认段前缀为 SS、其他的默认段前缀为 DS 直接寻址：[idata] 寄存器间接寻址：[BX | BP | SI | DI] 寄存器相对寻址：[BX | BP | SI | DI + idata] 基址变址寻址：[BX | BP + SI | DI] 相对基址变址寻址：[BX | BP + SI | DI + idata] 一般来说，我们可以用 [bx+idata+si] 的方式来访问结构体中的数据。用 bx 定位整个结构体，用 idata 定位结构体中的某一个数据项，用 si 定位数据项中的每个元素。为此，汇编语言提供了更为贴切的书写方式，如：[bx].idata、[bx].idata[si] 寄存器 通用寄存器 AX、BX、CX、DX、BP、SP、SI、DI\n段寄存器 DS、SS、CS、ES\n寻址方式 操作数的长度 标志寄存器结构图 中断过程 取得中断类型码 N PUSHF TF=0，IF=0 PUSH CS PUSH IP (IP)=(N*4)，CS=(N*4+2) 软件中断 硬件中断 基本算法 数组累加 Code ; 数组累加 assume cs:code, ds:data data segment array db 16, 16, 36, 46, 56, 66, 76, 86 result dw 0 ; 398--018EH data ends code segment start: mov ax, data mov ds, ax call sum mov ax, 4c00h int 21h ; 功能：array 数组求和 ; 参数：array ; 返回：result sum proc mov cx, 8 ; 循环 8 次 mov si, 0 ; 源地址 mov di, 0 ; 目的地址 mov bh, 0 s: mov bl, array[si] add result[di], bx inc si loop s ret sum endp code ends end start Result 求最大值、最小值、平均值 Code ; 求最大值、最小值、平均值 assume cs:code, ds:data data segment array db 0, 9, 88, 6, 5, 4, 5, 6 max db 0 ; 88--58H min db 0 ; 0 --00H ave db 0 ; 15--0FH rem db 0 ; 3--03H 余数 sum dw 0 ; 123--007BH data ends code segment start: mov ax, data mov ds, ax call func1 call func2 call func3 mov ax, 4c00h int 21h ; 功能：求最大值(无符号数) ; 参数：array ; 输出：max func1 proc mov cx, 8 mov si, 0 ; 源地址 mov di, 0 ; 目的地址 ; max = array[0] mov al, array[si] mov max[di], al s1: mov al, array[si] cmp al, max[di] ja true1 ; al \u0026gt; max jmp next1 true1: mov max[di], al next1: inc si loop s1 ret func1 endp ; 功能：求最小值(无符号数) ; 参数：array ; 输出：max func2 proc mov cx, 8 mov si, 0 ; 源地址 mov di, 0 ; 目的地址 mov al, array[si] mov min[di], al s2: mov al, array[si] cmp al, min[di] jb true2 ; al \u0026lt; min jmp next2 true2: mov min[di], al next2: inc si loop s2 ret func2 endp ; 注意：div 是无符号除法指令 ; 功能：求平均值(无符号数) ; 参数：array ; 输出：ave func3 proc mov cx, 8 mov si, 0 ; 源地址 mov di, 0 ; 目的地址 mov ah, 0 s3: mov al, array[si] add sum[di], ax inc si loop s3 mov ax, sum[di] ; 被除数 mov bl, 8 ; 除数 div bl mov ave[di], al ; 商--平均数 mov rem[di], ah ; 余数 ret func3 endp code ends end start Result 找出符合条件数据并进行统计\u0026ndash;以统计负数为例 Code ; 找出符合条件数据并进行统计--以统计负数为例 assume cs:code, ds:data data segment array db 2, -3, 5, -7, 6, -9, -5, 8 count db 0 ; 统计负数个数 data ends code segment start: mov ax, data mov ds, ax call func mov ax, 4c00h int 21h ; 功能：统计数组中负数的个数 ; 输入：array ; 输出：count func proc mov cx, 8 mov si, 0 mov di, 0 mov bl, 0 ; 统计个数 s: mov al, array[si] cmp al, 0 jl true ; array[si] \u0026lt; 0 jmp next true: inc bl next: inc si loop s mov count[di], bl ret func endp code ends end start Result 斐波那契数列前 20 项 Code ; 求斐波那契数列前 20 项 assume cs:code, ds:data data segment array dw 20 dup(0) data ends code segment start: mov ax, data mov ds, ax call func mov ax, 4c00h int 21h ; 功能：求斐波那契数列前 20 项 ; 输出：array func proc mov cx, 18 mov si, 0 ; fib[1]=1 \u0026amp;\u0026amp; fib[2]=1 mov word ptr array[si], 1 add si, 2 mov word ptr array[si], 1 add si, 2 s: mov ax, array[si-2] add ax, array[si-4] mov array[si], ax add si, 2 loop s ret func endp code ends end start Result 数组排序、查找、插入、删除 Code ; 数组排序、查找、插入、删除 ; 为简化程序，该数组元素不重复 assume cs:code, ds:data, ss:stack data segment array db 1, 5, -6, 8, 6, -5, -9, 2 array_insert db 9 dup(0) ; 在原数组中插入一个数 array_delete db 7 dup(0) ; 在原数组中删除一个数 index dw 0 ; 所查询数在数组中的下标 data ends stack segment dw 8 dup(0) stack ends code segment start: mov ax, data mov ds, ax mov ax, stack mov ss, ax mov sp, 16 call far ptr func1 mov bl, -5 call far ptr func2 mov bp, 4 ; 下标 mov bl, 6 ; 值 call far ptr func3 mov bp, 6 ; 下标 call far ptr func4 mov ax, 4c00h int 21h code ends func segment ; 功能：数组排序（升序）有符号数 ; 参数：array ; 输出：array_sort func1 proc far mov si, 0 mov cx, 7 ; 外层循环 7 次 mov ah, 0 outer: mov al, array[si] ; si--\u0026gt;外层循环i push cx mov cx, 7 sub cx, si ; 内层循环 7 - si 次 mov bp, si ; bp=si+1--\u0026gt;内层循环j inc bp inner: cmp al, ds:array[bp] jg true ; al \u0026gt; ds:array[bp] jmp next true: mov al, ds:array[bp] ; 更新当前这个循环的最小值al mov di, bp ; di最小值在数组中的下标 next: inc bp loop inner pop cx mov al, array[si] mov bl, array[di] mov byte ptr array[si], bl mov array[di], al inc si loop outer retf func1 endp ; 功能：查找值k在数组中的下标 ; 参数：bl--值k ; 输出：index(若未找到，下标为-1) func2 proc far mov cx, 8 mov si, 0 mov di, 0 s2: cmp bl, array[si] je true2 ; 相同，找到下标 inc si loop s2 mov byte ptr index[di], -1 ; 未找到 retf true2: mov index[di], si ; 找到 retf func2 endp ; 功能：在下标x处插入值为k的元素 ; 参数：bp--下标x；bl--值k；array ; 输出：array_insert func3 proc far mov cx, bp mov si, 0 ; 源地址 mov di, 0 ; 目的地址 jcxz next3 ; 先把前x个数放入新数组 s3: mov al, array[si] mov array_insert[di], al inc si inc di loop s3 next3: mov array_insert[di], bl inc di s3_2: cmp si, 8 je finish mov al, array[si] mov array_insert[di], al inc si inc di jmp s3_2 finish: retf func3 endp ; 功能：删除下标为k的元素 ; 参数：bp--下标k ; 输出：array_delete func4 proc far mov cx, bp mov si, 0 mov di, 0 jcxz delete s4: mov al, array[si] mov array_delete[di], al inc si inc di loop s4 delete: inc si s4_2: cmp si, 8 je finish4 mov al, array[si] mov array_delete[di], al inc si inc di jmp s4_2 finish4: retf func4 endp func ends end start Result 字符串长度、连接、复制、比较 Code ; 字符串长度、连接、复制、比较 assume cs:code, ds:data, ss:stack data segment str1 db \u0026#39;abcdef\u0026#39;, 0 ; 字符串通常被定义为一系列连续的字符，以0结尾 str2 db \u0026#39;abc\u0026#39;, 0 str3 db 10 dup(0) ; 连接：str1+str2(6+3+1) str4 db 4 dup(0) ; 复制：str2(3+1) len1 db 0 ; 字符串1长度 len2 db 0 ; 字符串2长度 result db 0 ; 比较结果：相同为 1，不同为 0 data ends stack segment db 8 dup(0) stack ends code segment start: mov ax, data mov ds, ax mov ax, stack ; 栈初始化 mov ss, ax mov sp, 8 mov bp, offset str1 mov bx, offset len1 call far ptr func1 mov bp, offset str2 mov bx, offset len2 call far ptr func1 mov bp, offset str1 mov bx, offset str2 call far ptr func2 mov bx, offset str2 call far ptr func3 ; 比较结果为相同，result==1 mov bp, offset str2 mov bx, offset str4 call far ptr func4 mov ax, 4c00h int 21h code ends ; 子程序段 func segment ; 功能：求字符串长度 ; 参数：bp -- str所在偏移地址; bx -- len所在偏移地址 ; 输出：len func1 proc far mov si, 0 ; 源地址 mov di, 0 ; 目的地址 mov ch, 0 s1: mov cl, ds:[bp+si] ; 字符 jcxz next1 inc si jmp s1 next1: mov [bx+di], si retf func1 endp ; 功能：连接 ; 参数：bp -- str1所在偏移地址; bx -- str2所在偏移地址; str3 -- str1+str3; len1、len2 ; 输出：str3 func2 proc far mov si, 0 mov di, 0 mov ch, 0 mov cl, len1[di] s2_1: mov al, ds:[bp+si] ; 取字符 mov str3[di], al inc si inc di loop s2_1 mov si, 0 mov ch, 0 push di mov di, 0 mov cl, len2[di] pop di s2_2: mov al, [bx+si] ; 取字符 mov str3[di], al inc si inc di loop s2_2 mov byte ptr str3[di], 0 ; 字符串末尾加 0 retf func2 endp ; 功能：复制字符串 ; 参数：bx -- str; str4 == str ; 输出：str4 func3 proc far mov si, 0 mov di, 0 s3: mov cl, [bx+si] ; 字符串末尾为 0 jcxz next3 mov al, [bx+si] ; 复制 mov str4[di], al ; 粘贴 inc si inc di loop s3 next3: mov byte ptr str4[di], 0 retf func3 endp ; 功能：比较 ; 参数：bp--str1; bx--str2 ; 输出: result func4 proc far mov si, 0 ; str1 偏移地址 mov di, 0 ; str2 偏移地址 s4: mov al, ds:[bp+si] cmp al, [bx+di] jz true ; 对应字符串相同 jmp nonsame true: cmp byte ptr [bx+di], 0 jz same ; 当前位为0，字符串结束 inc si ; 当前位不为0，继续 inc di jmp s4 same: mov di, 0 mov byte ptr result[di], 1 ; 两字符串相同 retf nonsame: mov di, 0 mov byte ptr result[di], 0 ; 两字符串不相同 retf func4 endp func ends end start Result 检测点答案（部分） 检测点2.1 （2）最多使用 4 条指令，编程计算 2 的 4 次方\nmov ax, 2H add ax, ax add ax, ax add ax, ax 检测点3.1 （2）\nmov ax,6622H jmp 0ff0:0100 mov ax,2000H mov ds,ax mov ax,[0008] mov ax,[0002] 指令 CS IP DS AX BX mov ax, 6622H 2000H 0003H 1000H 6622H 0000H jmp 0ff0:0100 0ff0H 0100H 1000H 6622H 0000H mov ax, 2000H 0ff0H 0103H 1000H 2000H 0000H mov ds, ax 0ff0H 0105H 2000H 2000H 0000H mov ax, [0008] 0ff0H 0108H 2000H C389H 0000H mov ax, [0002] 0ff0H 010BH 2000H EA66H 0000H 检测点3.2 （1）\nmov ax,2000H mov ss,ax mov sp,0010H （2）\nmov ax,1000H mov ss,ax mov sp,0000H 检测点9.1 （1）\nassume cs:code data segment db 0, 0, 0 ; 第一个字节可以取8位任意值 data ends code segment start:mov ax, data mov ds, ax mov bx, 0 jmp word ptr [bx+1] code ends end start （2）\nassume cs:code data segment dd 12345678H data ends code segment start: mov ax, data mov ds, ax mov bx, 0 mov [bx], bx ; 将 bx 段寄存器中的 0 送入，默认是 字 格式 mov [bx+2], cs jum dword ptr ds:[0] code ends end start （3）\n(CS) = 0006H (IP) = 00BEH 检测点9.2 assume cs:code code segment start: mov ax, 2000H mov ds, ax mov bx, 0 s: mov ch, 0 mov cl, [bx] jcxz ok inc bx jmp short s ok: mov ds, bx mov ax, 4c00h int 21h code ends end start 检测点9.3 assume cs:code code segment start: mov ax, 2000H mov ds, ax mov bx, 0 s:\tmov cl, [bx] mov ch, 0 inc cx ; loop 命令会先执行 (cx)=(cx)-1，再判断(cx)?=0 inc bx loop s ok:\tdec bx mov dx, bx mov ax, 4c00h int 21h code ends end start 检测点10.1 ... mov ax, 1000H ... mov ax, 0000H 检测点10.2 (ax)=6 预加载指令 call s 时，IP 指向下条指令的地址 (IP)=6 检测点10.3 (ax)=1010H 检测点10.4 (ax)=6+(ss:[bp])=6+5=000BH 检测点10.5 （1）\nassume cs:code stack segment dw 8 dup (0) stack ends code segment start:\tmov ax, stack mov ss, ax mov sp, 16 mov ds, ax mov ax, 0 call word ptr ds:[0eh] ; CS:IP 此时指向的是 第一个 inc ax inc ax inc ax inc ax mov ax, 4c00h int 21h code ends end start 上述程序执行后，ax中的数值：\n(ax)=3 （2）\nassume cs:code data segment dw 8 dup (0) data ends code segment start:\tmov ax, data mov ss, ax mov sp, 16 mov word ptr ss:[0], offset s ; 标号 s 的偏移地址移至 ss:[0] mov ss:[2], cs call dword ptr ss:[0] ; (IP)=(ss:[0])=offset s (CS)=(ss:[2])=(CS) nop s:\tmov ax, offset s sub ax, ss:[0cH] ; (ss:[0cH])= nop 指令 的偏移地址 mov bx, cs sub bx, ss:[0eH] ; (ss:[0eH])=(CS) mov ax, 4c00h int 21h code ends end start 上述程序执行后，ax 和 bx 的数值为：\n(ax)=0001H (bx)=0000H 检测点11.2 指令 CF OF SF ZF PF AL sub al, al 0 0 0 1 1 0000 0000 mov al, 10H 0 0 0 1 1 0001 0000 add al, 90H 0 0 1 0 1 1010 0000 mov al, 80H 0 0 1 0 1 1000 0000 add al, 80H 1 1 0 1 1 0000 0000 mov al, 0FCH 1 1 0 1 1 1111 1100 add al, 05H 1 0 0 0 0 0000 0001 add al, 7DH 1 0 0 0 0 0111 1101 add al, 0BH 0 1 1 0 1 1000 1000 检测点11.3 （1）\n... jb s0 ... ja s0 ... （2）\n... jna s0 ... jnb s0 ... 检测点11.4 mov ax, 0fff0h add ax, 0010h 这两句代码执行过后，ax = 0000 0000 0000 0000\n有进位，无溢出，结果为0，各标志位的值分别为：\nzf = 1 pf = 1 sf = 0 cf = 1 of = 0 df = 0 Flag 寄存器：0000 0000 0100 0101 (ax) = 0000 0000 0100 0101 全部执行之后，ax = 0000 0000 0100 0101\n检测点13.1 （1）\n7ch中断例程所能进行的最大转移位移范围是 [-32768, 32767] 即16位补码所能表示的数的范围。 （2） 用 7ch 中断例程完成 jmp near ptr s 指令的功能，用 bx 向中断例程传送转移位移。\n应用举例：在屏幕的笫 12 行，显示 data 段中以 0 结尾的宇符串 。\nassume cs:code data segment db \u0026#39;conversation\u0026#39;,0 data ends code segment start: mov ax,data mov ds,ax mov si,0 mov ax,0b800h mov es,ax mov di,12*160 s: cmp byte ptr [si],0 je ok ; 如果是 0 跳出循环 mov al,[si] mov es:[di],al inc si add di,2 mov bx,offset s-offset ok ; 设置从标号 ok 到标号 s 的转移位移 int 7ch ; 转移到标号 s 处 ok: mov ax,4c00h int 21h code ends end start 7ch 中断例程如下：\nlp: push bp ; 将 bp 这个 ss 栈的偏址保存 mov bp, sp ; 将当前栈顶指针值送入到 bp add [bp+2], bx ; 修改 ss 栈中的从栈顶向下第 2 个单元的值 lpret: pop bp ; 恢复 bp 值 iret ; 返回到调用处 将 7cH 代码写入 0:200H 的装载程序如下：\nassume cs:code code segment start: ; 7cH 中断例程的安装程序 mov ax, cs mov ds, ax mov si, offset lp ; 将 ds:si 指向源地址（captial 的机器码） mov ax, 0000H mov es, ax mov di, 200H ; 将 es:di 指向目的地址（0:200H 向量表中） mov cx, offset lpend - offset lp ; 设置传输长度 cld ; 传输方向为正 rep movsb ; 字节传输 ; 设置中断向量表，使 7cH 条目中断向量指向 0000:200H mov ax, 0000H mov es, ax mov word ptr es:[7cH*4], 200H mov word ptr es:[7cH*4+2], 0000H mov ax, 4c00H int 21H ;----------- ; 装载的例程：7cH ; 功能：int 7cH 实现和 jmp near ptr s 指令相同的功能 ; 入口参数：bx 相对地址偏移量 ; 返回值：无 ;----------- lp: push bp ; 将 bp 这个 ss 栈的偏址保存 mov bp, sp ; 将当前栈顶指针值送入到 bp add [bp+2], bx ; 修改 ss 栈中的从栈顶向下第 2 个单元的值，即 IP 的值 lpret: pop bp ; 恢复 bp 值 iret ; 返回到调用处。 lpend: nop ; 代码段结尾，便于计算 7cH 例程的长度。 code ends end start 检测点14.1 （1）\nassume cs:code code segment start: mov al, 2 ; (al)=2，2 号单元 out 70h, al ; 选中端口 70h 的 2 号单元 in al, 71h ; 从端口 71h 读出 2 号单元，送入 al mov ax, 4c00h int 21h code ends end start （2）\nassume cs:code code segment start: mov al, 2 ; (al) = 2，2 号单元 out 70h, al ; 将 al 送入端口 70h，选中 2 号单元 mov al, 0 ; (al) = 0，写入端口 out 71h, al ; 将 (al)=0 写入到 71h 的 2 号单元 mov ax, 4c00h int 21h code ends end start 检测点14.2 assume cs:code code segment start: mov bx, ax shl ax, 1 ; (ax)=(ax)*2 mov cl, 3 ; 移动次数大于 1 必须放到 cl shl bx, cl ; (bx)=(ax)*8 add ax, bx ; (ax)=(ax)*8+(ax)*2 mov 4c00h int 21h code ends end start 检测点15.1 （2） 设置新中断向量表代码：\nmov ax,0 mov es,ax ; es 指向中断向量表，内存地址 0 处 ... mov word ptr es:[9*4], offset int9 mov es:[9*4+2],cs ; 在中断向量表中设置新的 int9 中断例程的入口段地址和偏移地址 ; 其中段地址等于当前 cs 写回原中断向量表：\nmov ax,0 mov es,ax ; es 指向中断向量表，内存地址 0 处 push ds:[0] ; 从 ds[0]、ds[2] 处取出原 int 9 入口地址 pop es:[9*4] ; 将中断向量表中 int 9 的入口地址恢复为原地址 push ds:[2] pop es:[9*4+2] 如果在指令执行在这两端程序中间，触发键盘中断事件，那么由于正在设置中断向量表，(ip) 和 (cs) 值可能不确定。为了避免这 2 段代码不受中断事件干扰，需要将中断屏蔽。在这两段代码前后加上 cli 和 sti 指令即可。\ncli ; 屏蔽任何（可屏蔽）中断 ... sti ; 解除屏蔽（可屏蔽）中断 检测点16.1 assume cs:code code segment a dw 1,2,3,4,5,6,7,8 ; code:[0] ~ code:[15] b dd 0 ; code:[16]~ code:[19] start: mov si,0 mov cx,8 s: mov ax,a[si] ; 将 a 中偏移量为 si 的内存单元按字送入 ax add word ptr b[0],ax ; 与 bx 的低字相加 adc word ptr b[2],0 ; 与 bx 的高字相加 add si,2 ; ax 单位为字，因此偏移 2 个字节，偏移量的单位是字节 loop s mov ax,4c00h int 21h code ends end start 检测点17.1 “在 int16h 中断例程中，一定有设置 IF=1 的指令。”这种说法对吗？\n答案：对。\nint 16h 中断的 0 号功能，若缓冲区空，则循环等待，直到缓冲区中有数据。所以缓冲区空的时候，它又会继续检测，也就是可以说返回上一步。\nint 9h 是将按键信息放入缓冲区。 若没有设置 IF=1 的指令，也即 IF=0，则不会处理任何（可屏蔽）中断，当然也就不能屏蔽 int 9 中断，则缓冲区永远不会有数据放入，这将造成 int 16h 的死循环检测。显然不允许这样的事发生，所以一定有设置 IF=1 的指令。\n课后实验（部分） 实验 3 （3）PSP 的内容 实验 4 （2）\nassume cs:code code segment mov ax, 0020H mov ds, ax ;(ds) = 0020H mov bx, 0 ;ds:bx 指向 0020:0，即 0:200 mov cx, 40H ;循环 64 次 s: mov ds:[bx], bx ;((ds) * 16 + bx)) = bx inc bx loop s mov ax, 4c00h int 21h code ends end （3）\nassume cs:code code segment mov ax, code mov ds, ax mov ax, 0020h mov es, ax mov bx, 0 mov cx, 17 s: mov al, [bx] mov es:[bx], al inc bx loop s mov ax, 4c00h int 21h code ends end 实验 5 （1）\nassume cs:code, ds:data, ss:stack data segment dw 0123h, 0456h, 0789h, 0abch, 0defh, 0fedh, 0cbah, 0987h data ends stack segment dw 0, 0, 0, 0, 0, 0, 0, 0 stack ends code segment start: mov ax, stack mov ss, ax mov sp, 16 mov ax, data mov ds, ax push ds:[0] push ds:[2] pop ds:[2] pop ds:[0] mov ax, 4c00h int 21h code ends end start （2）\nassume cs:code, ds:data, ss:stack data segment dw 0123H, 0456H data ends stack segment dw 0, 0 stack ends code segment start: mov ax, stack mov ss, ax mov sp, 16 mov ax, data mov ds, ax push ds:[0] push ds:[2] pop ds:[2] pop ds:[0] mov ax, 4c00h int 21h code ends end start （3）\nassume cs:code, ds:data, ss:stack code segment start: mov ax, stack mov ss, ax mov sp, 16 mov ax, data mov ds, ax push ds:[0] push ds:[2] pop ds:[2] pop ds:[0] mov ax, 4c00h int 21h code ends data segment dw 0123H, 0456H data ends stack segment dw 0, 0 stack ends end start （4）\n都能执行，但只有程序 3 可以正确执行，因为程序 加载后会从程序第一个单元开始执行，但只有 3 中的code段在程序 的开始位置，所以所以只有 3 中的程序 是可以正确执行的\n（5）段的大小必须为 16 Byte 的倍数，即最小为 0010H\nassume cs:code a segment db 1, 2, 3, 4, 5, 6, 7, 8 ; db定义字节单元数据、dw字义字单元数据、dd定义双字单元数据 a ends b segment db 1, 2, 3, 4, 5, 6, 7, 8 b ends c segment db 0, 0, 0, 0, 0, 0, 0, 0 c ends code segment start: ; 由于push与pop指令只对字操作，而这里要操作的是字节，所以不能用push和pop传送数据 mov ax, a mov ds, ax ; ds定位到a段 mov ax, b mov es, ax ; es定位到b段 mov dx, 0 mov bx, 0 ; 偏移地址 mov cx, 8 ; 循环次数8次 s: mov dl, ds:[bx] add dl, es:[bx] mov ds:[bx+32], dl ; 将dl的数值传送到c段的偏移位置 inc bx loop s mov ax, 4c00h int 21h code ends end start （6）\nassume cs:code a segment dw 1, 2, 3, 4, 5, 6, 7, 8, 9, 0ah, 0bh, 0ch, 0dh, 0ch, 0dh, 0eh, 0fh, 0ffh a ends b segment dw 0, 0, 0, 0, 0, 0, 0, 0 b ends code segment start: mov ax, a mov ds, ax mov ax, b mov ss, ax mov sp, 10h mov bx, 0 mov cx, 8 s: push [bx] add bx, 2 loop s mov ax, 4c00h int 21h code ends end start 实验 6 assume cs:codesg, ss:stacksg, ds:datasg stacksg segment dw 0, 0, 0, 0, 0, 0, 0, 0 stacksg ends datasg segment db \u0026#39;1. display \u0026#39; db \u0026#39;2. brows \u0026#39; db \u0026#39;3. replace \u0026#39; db \u0026#39;4. modify \u0026#39; datasg ends codesg segment start: mov ax, stacksg mov ss, ax mov sp, 16 mov ax, datasg mov ds, ax mov bx, 0 ; 每一个数组（即每一行的地址） mov cx, 4 ; 设置外层循环的次数 s0: push cx ; 将外层循环 cx 中的值暂存到 栈 中 mov si, 0 ; 每一行中元素的下标，相当于数组的下标 mov cx, 4 ; cx 设置内层循环的次数 s: mov al, [bx+3+si] and al, 11011111b ; 将 al 中的 ASCII 码的第 5 位置为 0，小写字母变为大写字母 mov [bx+3+si], al inc si ; si 加 1，指向下一个字母 loop s add bx, 16 pop cx ; 从栈顶弹出原 cx 的值，恢复 cx loop s0 mov ax, 4c00H int 21H codesg ends end start 实验 7 参考网络 assume cs:codesg,ds:data,es:table data segment db \u0026#39;1975\u0026#39;,\u0026#39;1976\u0026#39;,\u0026#39;1977\u0026#39;,\u0026#39;1978\u0026#39;,\u0026#39;1979\u0026#39;,\u0026#39;1980\u0026#39;,\u0026#39;1981\u0026#39;,\u0026#39;1982\u0026#39;,\u0026#39;1983\u0026#39; db \u0026#39;1984\u0026#39;,\u0026#39;1985\u0026#39;,\u0026#39;1986\u0026#39;,\u0026#39;1987\u0026#39;,\u0026#39;1988\u0026#39;,\u0026#39;1989\u0026#39;,\u0026#39;1990\u0026#39;,\u0026#39;1991\u0026#39;,\u0026#39;1992\u0026#39; db \u0026#39;1993\u0026#39;,\u0026#39;1994\u0026#39;,\u0026#39;1995\u0026#39; ; 以上是表示 21 年的 21 个字符串 dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514 dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000 ; 以上是表示 21 年公司总收入的 21 个 dword 型数据 dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226 dw 11542,14430,15257,17800 ; 以上是表示 21 年公司雇员人数的 21 个 word 型数据 data ends table segment db 21 dup(\u0026#39;year summ ne ??\u0026#39;) table ends codesg segment start: mov ax, data mov ds, ax sub si, si mov ax, table mov es, ax sub di, di sub bx, bx mov cx, 21 ; 21 年的 21 个字符串 s: mov ax, [si] ; 写入年份 mov es:[di], ax mov ax, [si+2] mov es:[di+2], ax mov byte ptr es:[di+4], 20h mov ax, [si+84] ; 写入公司总收入 mov es:[di+5], ax mov ax, [si+86] mov es:[di+7], ax mov byte ptr es:[di+9], 20h sub si, bx mov ax, [si+168] ; 写入雇员人数 mov es:[di+10], ax mov byte ptr es:[di+12], 20h add si, bx mov dx, [si+86] ; 写入人均收入\tmov ax, [si+84] div word ptr es:[di+10] mov es:[di+13], ax mov byte ptr es:[di+15], 20h add si, 4 ; data 年份偏移量（年份 4 字节 收入 4 字节） add di, 16 ; table 偏移量 add bx, 2 ; data 雇员偏移量（雇员 2 字节） loop s\tmov ax, 4c00h int 21h codesg ends end start 自己书写 assume cs: codesg data segment db \u0026#39;1975\u0026#39;,\u0026#39;1976\u0026#39;,\u0026#39;1977\u0026#39;,\u0026#39;1978\u0026#39;,\u0026#39;1979\u0026#39;,\u0026#39;1980\u0026#39;,\u0026#39;1981\u0026#39;,\u0026#39;1982\u0026#39;,\u0026#39;1983\u0026#39;,\u0026#39;1984\u0026#39; db \u0026#39;1985\u0026#39;,\u0026#39;1986\u0026#39;,\u0026#39;1987\u0026#39;,\u0026#39;1988\u0026#39;,\u0026#39;1989\u0026#39;,\u0026#39;1990\u0026#39;,\u0026#39;1991\u0026#39;,\u0026#39;1992\u0026#39;,\u0026#39;1993\u0026#39;,\u0026#39;1994\u0026#39; db \u0026#39;1995\u0026#39; ; 以上是表示 21 年的 21 个字符串 dd 16, 22, 382, 1356, 2390, 8000, 16000, 24486, 50065, 97479 dd 140417, 197514, 345980, 590827, 803530, 1183000, 1843000, 2759000, 3753000, 4649000 dd 5937000 ; 以上是表示 21 年公司总收入的 21 dword 型数据 dw 3, 7, 9, 13, 28, 38, 130, 220, 476, 778 dw 1001, 1442, 2258, 2793, 4037, 5635, 8226, 1542, 14430, 15257 dw 17800 ;以上是表示 21 年公司雇员人数的 21 word 型数据 data ends table segment db 21 dup (\u0026#39;year summ ne ?? \u0026#39;) ; 用字符表示对应格式及其字节数 table ends codesg segment start: mov ax, data ; data 数据段基址 mov es, ax mov ax, table ; table 数据段基址 mov ds, ax mov bx, 0 ; 雇员偏移量 mov si, 0 ; 源地址 mov di, 0 ; 目的地址 mov cx, 21 ; 21 年的 21 个字符串 s: mov ax, es:[si] ; 年份 mov [di], ax mov ax, es:[si+2] mov [di+2], ax mov byte ptr [di+4], 20h ; 空格 mov ax, es:[si+84] ; 收入 mov [di+5], ax mov ax, es:[si+84+2] mov [di+5+2], ax mov byte ptr [di+9], 20h ; 空格 sub si, bx ; 雇员偏移量 mov ax, es:[si+168] ; 收入 mov [di+10], ax mov byte ptr [di+12], 20h ; 空格 add si, bx mov ax, es:[si+84] ; 低 16 位 mov dx, es:[si+84+2] ; 高 16 位 div word ptr [di+10] mov [di+13], ax ; 人均收入 mov byte ptr [di+15], 20h ; 空格 add bx, 2 add di, 16 add si, 4 loop s mov ax, 4c00H int 21H codesg ends end start 运行结果 实验 8 assume cs:code code segment mov ax, 4C00H int 21H start: mov ax, 0000H s: nop ; 跳到它的末尾之前的 10 个字节处，刚好是 mov ax, 4C00H，正确返回 nop mov di, offset s ; 标号 s 后的两个空操作被 \u0026#34;jmp short s1\u0026#34; 的机器码覆盖 mov si, offset s2 mov ax, cs:[si] mov cs:[di], ax s0: jmp short s s1: mov ax, 0000H int 21H mov ax, 0000H s2: jmp short s1 ; 它的功能：跳到它的末尾之前的 10 个字节处（offset s1 - offset s2+2） nop code ends end start 实验 9 实验 10 实验 11 实验 12 实验 13 实验 14 实验 15 实验 16 实验 17 课程设计 课程设计 1 课程设计 2 综合研究 研究试验 1 搭建一个精简的 C 语言开发环境 研究试验 2 使用寄存器 研究试验 3 使用内存空间 研究试验 4 不用 main 函数编程 研究试验 5 函数如何接受不定数量的参数 推荐阅读 使用 VS Code 进行 x86 汇编语言 MASM Dosbox Debug (仅适用 Windows 平台) Win10下配置汇编语言 （王爽）实验环境 《汇编语言》第三版检测点答案 《汇编语言 王爽著》课后实验参考答案 《汇编语言》（第 3 版）的检测点和实验的解答与说明 《汇编语言（第4版）》 \u003c!DOCTYPE HTML\u003e ","permalink":"https://xancoding.cn/posts/2022-11-15-13-16-12/","summary":"汇编语言是什么？ 汇编语言是任何一种用于电子计算机、微处理器、微控制器，或其他可编程器件的低级语言 部分知识点 一个段的起始地址必定是 16 的倍数 \u0026ndash; CS","title":"汇编语言"},{"content":"推荐阅读 【中英字幕】C++ | The Cherno C++标准 11-14 | 侯捷 C++ STL标准库和 C++ 泛型编程 | 侯捷 https://www.learncpp.com/ 学习网站，非常全面系统的介绍了 C++ 相关知识，从编译器使用到如何运行第一行代码都介绍的非常细致 https://cplusplus.com/ 平时看一看语法，某些函数的使用 https://en.cppreference.com/w/cpp C++ 语言的在线参考手册 https://zh.cppreference.com/w/首页 C++ 语言的在线参考手册 https://github.com/linw7/Skill-Tree 《C++ Primer 中文版（第 5 版）》 《Effective C++》 《Effective STL》 《STL 源码剖析》 《深度探索C++对象模型》 《C++并发编程实战（第2版）》 \u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e 入门 当您在 IDE 中创建新项目时，大多数 IDE 会为您设置两种不同的构建配置：发布配置和调试配置，开发程序时使用调试构建配置。当您准备好将可执行文件发布给其他人时，或者想要测试性能时，请使用发布构建配置 Debug：调试版本， 包含调试信息，所以 容量比Release大很多， 并且不进行任何优化（优化会使调试复杂化，因为源代码和生成的指令间关系会更复杂），便于程序员调试 Release：发布版本， 不对源代码进行调试，编译时对应用程序的速度进行优化，使得程序在代码大小和运行速度上都是最优的 对于 CLion 用户，您可以添加 Release：按 Alt+Ctrl+S 调出 Settings \u0026gt; Build，Execution，Deployment \u0026gt; CMake \u0026gt; 单击 Profiles 部分中的 + 按钮，将自动添加 Release 选项 禁用编译器扩展以确保您的程序（和编码实践）保持符合 C++ 标准并且可以在任何系统上运行 CLion 使用 CMake 构建项目。 将行 set(CMAKE_CXX_EXTENSIONS OFF) 添加到 CMakeList.txt 以禁用扩展 将你的警告级别调到最大，尤其是在你学习的时候。它将帮助您识别可能的问题 在 Clion（从 2021.3 版本开始）中，要将警告级别调到最高，您可以按 Alt+Ctrl+S 调出 Settings ，然后选择 Editor \u0026gt; Inspections \u0026gt; C/C++，然后手动选中所有框，或者在窗口的右侧，在矩形的 severity 框中选择错误，然后在另一个框中选择 In All Scopes 选择语言标准：在专业环境中，通常选择比最新标准低一个或两个版本的语言标准（例如，现在 C++20 已经出来了，这意味着 C++14 或 C++17）。这样做通常是为了确保编译器制造商有机会解决缺陷，以便更好地理解新功能的最佳实践。在相关的情况下，这也有助于确保更好的跨平台兼容性，因为某些平台上的编译器可能不会立即为更新的语言标准提供全面支持。启用 C++17 语言标准（或更高版本）后，您应该能够在没有任何警告或错误的情况下编译以下代码 #include \u0026lt;array\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string_view\u0026gt; #include \u0026lt;tuple\u0026gt; #include \u0026lt;type_traits\u0026gt; namespace a:🅱️:c { inline constexpr std::string_view str{ \u0026#34;hello\u0026#34; }; } template \u0026lt;class... T\u0026gt; std::tuple\u0026lt;std::size_t, std::common_type_t\u0026lt;T...\u0026gt;\u0026gt; sum(T... args) { return { sizeof...(T), (args + ...) }; } int main() { auto [iNumbers, iSum]{ sum(1, 2, 3) }; std::cout \u0026lt;\u0026lt; a:🅱️:c::str \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; iNumbers \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; iSum \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::array arr{ 1, 2, 3 }; std::cout \u0026lt;\u0026lt; std::size(arr) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } C++ 基础知识 注释 写在前面 通常，注释应该用于三件事 在库、程序或函数级别，使用注释来描述作用 在库、程序或函数内部，使用注释来描述如何操作 在语句级别，使用注释来描述原因 注释是一种很好的方式来提醒自己（或告诉别人）你做出一个决定而不是另一个决定的原因 注释您的代码，像在对不知道代码功能的人说话一样写您的注释。不要假设你会记得你为什么做出特定的选择 单行注释 在行的右侧添加注释会使代码和注释都难以阅读，尤其是在行很长的情况下。如果行相当短，评论可以简单地对齐（通常是一个制表位），像这样： std::cout \u0026lt;\u0026lt; \u0026#34;Hello world!\\n\u0026#34;; // std::cout lives in the iostream library std::cout \u0026lt;\u0026lt; \u0026#34;It is very nice to meet you!\\n\u0026#34;; // this is much easier to read std::cout \u0026lt;\u0026lt; \u0026#34;Yeah!\\n\u0026#34;; // don\u0026#39;t you think so? 但是，如果行很长，将注释放在右边会使行变得很长。在这种情况下，单行注释通常放在它正在注释的行之上： // std::cout lives in the iostream library std::cout \u0026lt;\u0026lt; \u0026#34;Hello world!\\n\u0026#34;; // this is much easier to read std::cout \u0026lt;\u0026lt; \u0026#34;It is very nice to meet you!\\n\u0026#34;; // don\u0026#39;t you think so? std::cout \u0026lt;\u0026lt; \u0026#34;Yeah!\\n\u0026#34;; Commenting out code // std::cout \u0026lt;\u0026lt; 1; 多行注释 Explaining code /* This is a multi-line comment. * the matching asterisks to the left * can make this easier to read */ Commenting out code /* std::cout \u0026lt;\u0026lt; 1; std::cout \u0026lt;\u0026lt; 2; std::cout \u0026lt;\u0026lt; 3; */ 代码的可读性 您的行的长度不应超过 80 个字符 int main() { std::cout \u0026lt;\u0026lt; \u0026#34;This is a really, really, really, really, really, really, really, \u0026#34; \u0026#34;really long line\\n\u0026#34;; // one extra indentation for continuation line std::cout \u0026lt;\u0026lt; \u0026#34;This is another really, really, really, really, really, really, really, \u0026#34; \u0026#34;really long line\\n\u0026#34;; // text aligned with the previous line for continuation line std::cout \u0026lt;\u0026lt; \u0026#34;This one is short\\n\u0026#34;; } 如果用操作符（例如 \u0026laquo; 或 +）拆分长行，则应将操作符放在下一行的开头，而不是当前行的结尾\nstd::cout \u0026lt;\u0026lt; 3 + 4 + 5 + 6 * 7 * 8; 许多编辑器都有一个内置功能（或插件/扩展），可以在给定的列（例如 80 个字符）处显示一行（称为“列指南”），因此您可以轻松查看行何时变得太长\nClion column guide : File \u0026gt; Settings \u0026gt; Editor \u0026gt; Code Style \u0026gt; General \u0026gt; 在 \u0026#34;Visual guides\u0026#34; 矩形框中键入 80 并应用更改 使用空格通过对齐值或注释或在代码块之间添加间距来使您的代码更易于阅读 cost = 57; pricePerItem = 24; value = 5; numberOfItems = 17; std::cout \u0026lt;\u0026lt; \u0026#34;Hello world!\\n\u0026#34;; // cout lives in the iostream library std::cout \u0026lt;\u0026lt; \u0026#34;It is very nice to meet you!\\n\u0026#34;; // these comments are easier to read std::cout \u0026lt;\u0026lt; \u0026#34;Yeah!\\n\u0026#34;; // especially when all lined up // cout lives in the iostream library std::cout \u0026lt;\u0026lt; \u0026#34;Hello world!\\n\u0026#34;; // these comments are easier to read std::cout \u0026lt;\u0026lt; \u0026#34;It is very nice to meet you!\\n\u0026#34;; // when separated by whitespace std::cout \u0026lt;\u0026lt; \u0026#34;Yeah!\\n\u0026#34;; C++ 基础：函数和文件 函数返回值 C++标准只定义了3种状态码的含义：0、EXIT_SUCCESS、EXIT_FAILURE。 0 和 EXIT_SUCCESS 都表示程序执行成功。 EXIT_FAILURE 表示程序没有成功执行\nEXIT_SUCCESS 和 EXIT_FAILURE 是 \u0026lt;cstdlib\u0026gt; 标头中定义的预处理器宏：\n#include \u0026lt;cstdlib\u0026gt; // for EXIT_SUCCESS and EXIT_FAILURE int main() { return EXIT_SUCCESS; } 如果你想最大限度地提高可移植性，你应该只使用 0 或 EXIT_SUCCESS 来指示成功终止，或者使用 EXIT_FAILURE 来指示不成功终止\ninclude 头文件顺序 在 C++ 中，头文件的顺序通常应该遵循以下顺序：\nC 标准库头文件（如 \u0026lt;stdio.h\u0026gt;） C++ 标准库头文件（如 \u0026lt;iostream\u0026gt;） 第三方库头文件（如 Boost） 项目特定的头文件（如自定义的头文件） 这样的顺序可以避免头文件之间的依赖关系问题，同时也可以更快地查找问题。\nThe headers for each grouping should be sorted alphabetically（按字母顺序排序）.\n这个顺序并不是强制的，主要取决于项目的需要和编程风格。\nHeader file best practices 始终 include header guards 不要在头文件中定义变量和函数（全局常量是一个例外） 为头文件指定与其关联的源文件相同的名称（例如，grades.h 与 grades.cpp 配对） 每个头文件应该有一个特定的工作，并且尽可能独立。例如，您可以将与功能 A 相关的所有声明放在 A.h 中，将与功能 B 相关的所有声明放在 B.h 中。这样如果你以后只关心 A，你可以只 include A.h 而不会得到任何与 B 相关的东西 请注意您需要为代码文件中使用的功能显式包含哪些 header 您编写的每个 header 都应该自行编译（它应该#include 它需要的每个依赖项） 仅 #include 您需要的内容（不要仅仅因为可以就包含所有内容） 不要#include .cpp 文件 预处理器 在编译之前，代码文件会经历一个称为翻译的阶段。翻译阶段会发生很多事情，让您的代码准备好进行编译（如果您好奇，可以在此处找到翻译阶段列表）。应用了翻译的代码文件称为翻译单元\n最值得注意的翻译阶段涉及预处理器。预处理器最好被认为是一个单独的程序，它可以处理每个代码文件中的文本\n当预处理器运行时，它会扫描代码文件（从上到下），寻找预处理器指令。预处理程序指令（通常简称为 指令（Directives））是以# 符号开头并以换行符（不是分号）结尾的指令。这些指令告诉预处理器执行某些文本操作任务。请注意，预处理器不理解 C++ 语法——相反，指令有自己的语法（在某些情况下类似于 C++ 语法，而在其他情况下，则不太相似）\n请注意，预处理器不会以任何方式修改原始代码文件——相反，预处理器所做的所有文本更改都会在每次编译代码文件时临时发生在内存中或使用临时文件\nIncludes 当您 #include 一个文件时，预处理器会用 include 文件的内容替换 #include 指令。然后对 include 的内容进行预处理（连同文件的其余部分），然后进行编译\nMacro defines #define 指令可用于创建 宏\n有两种基本类型的宏：类对象宏和类函数宏\n类函数宏的行为类似于函数，并且具有相似的目的。它们的使用通常被认为是危险的，它们几乎可以做的任何事情都可以通过一个正常的函数来完成\n类对象宏可以通过以下两种方式之一定义：\n#define identifier #define identifier substitution_text 替换文本的类对象宏被用作（在 C 中）将名称分配给文字的一种方式。这不再是必需的，因为 C++ 中提供了更好的方法（Const 变量和符号常量）。带有替换文本的类对象宏现在通常只能在遗留代码中看到\n没有替换文本的类对象宏：标识符的任何进一步出现都将被删除并被替换为任何东西！\n与带有替换文本的类对象宏不同，这种形式的宏通常被认为可以使用。\nConditional compilation 条件编译预处理器指令允许您指定在什么条件下编译或不编译。有很多不同的条件编译指令，但我们在这里只介绍目前使用最多的三个：#ifdef、#ifndef 和 #endif\n#ifdef 预处理器指令允许预处理器检查标识符是否先前已被#defined。如果是，编译 #ifdef 和匹配的 #endif 之间的代码。如果不是，代码将被忽略\n考虑以下程序：\n#include \u0026lt;iostream\u0026gt; #define PRINT_JOE int main() { #ifdef PRINT_JOE std::cout \u0026lt;\u0026lt; \u0026#34;Joe\\n\u0026#34;; // will be compiled since PRINT_JOE is defined #endif #ifdef PRINT_BOB std::cout \u0026lt;\u0026lt; \u0026#34;Bob\\n\u0026#34;; // will be ignored since PRINT_BOB is not defined #endif return 0; } 因为 PRINT_JOE 已被 #defined，std::cout \u0026lt;\u0026lt; \u0026quot;Joe\\n\u0026quot; 行将被编译。因为 PRINT_BOB 尚未被 #defined，std::cout \u0026lt;\u0026lt; \u0026quot;Bob\\n\u0026quot; 行将被忽略\n#ifndef 与 #ifdef 相反，因为它允许您检查标识符是否尚未 #defined\n#include \u0026lt;iostream\u0026gt; int main() { #ifndef PRINT_BOB std::cout \u0026lt;\u0026lt; \u0026#34;Bob\\n\u0026#34;; #endif return 0; } 该程序打印 “Bob”，因为 PRINT_BOB 从未被 #defined\n条件编译的一个更常见的用途是使用 #if 0 将代码块排除在编译之外（就像它在注释块中一样）：\n#include \u0026lt;iostream\u0026gt; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Joe\\n\u0026#34;; #if 0 // Don\u0026#39;t compile anything starting here std::cout \u0026lt;\u0026lt; \u0026#34;Bob\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;Steve\\n\u0026#34;; #endif // until this point return 0; } 这也提供了一种方便的方法来**“注释掉”包含多行注释的代码**（由于多行注释是不可嵌套的，因此不能使用另一个多行注释来注释掉）：\n#include \u0026lt;iostream\u0026gt; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Joe\\n\u0026#34;; #if 0 // Don\u0026#39;t compile anything starting here std::cout \u0026lt;\u0026lt; \u0026#34;Bob\\n\u0026#34;; /* Some * multi-line * comment here */ std::cout \u0026lt;\u0026lt; \u0026#34;Steve\\n\u0026#34;; #endif // until this point return 0; } 类对象宏不影响其他预处理器指令，宏只会导致普通代码的文本替换。其他预处理器命令将被忽略\n#define FOO 9 // Here\u0026#39;s a macro substitution #ifdef FOO // This FOO does not get replaced because it’s part of another preprocessor directive std::cout \u0026lt;\u0026lt; FOO; // This FOO gets replaced with 9 because it\u0026#39;s part of the normal code #endif 指令在编译前解析，逐个文件地从上到下解析\n#include \u0026lt;iostream\u0026gt; void foo() { #define MY_NAME \u0026#34;Alex\u0026#34; } int main() { std::cout \u0026lt;\u0026lt; \u0026#34;My name is: \u0026#34; \u0026lt;\u0026lt; MY_NAME; return 0; } 即使看起来 #define MY_NAME “Alex” 是在函数 foo 中定义的，预处理器也不会注意到，因为它不理解像函数这样的 C++ 概念。因此，该程序的行为与 #define MY_NAME “Alex” 在函数 foo 之前或之后立即定义的程序相同。为了一般的可读性，您通常希望在函数之外 #define 标识符\n预处理器完成后，该文件中所有定义的标识符都将被丢弃。这意味着指令仅从定义点到定义它们的文件末尾有效。一个代码文件中定义的指令不会影响同一项目中的其他代码文件\n考虑以下示例：\nfunction.cpp:\n#include \u0026lt;iostream\u0026gt; void doSomething() { #ifdef PRINT std::cout \u0026lt;\u0026lt; \u0026#34;Printing!\u0026#34;; #endif #ifndef PRINT std::cout \u0026lt;\u0026lt; \u0026#34;Not printing!\u0026#34;; #endif } main.cpp:\nvoid doSomething(); // forward declaration for function doSomething() #define PRINT int main() { doSomething(); return 0; } 上面的程序会打印：\nNot printing! 尽管 PRINT 是在 main.cpp 中定义的，但这对 function.cpp 中的任何代码都没有任何影响（PRINT 只是从定义点到 main.cpp 末尾的 #defined）\n如何完成你的第一个程序 Design（设计） 定义目标。将此表示为面向用户的结果通常很有用，例如： 允许用户组织姓名和相关电话号码的列表 模拟球从塔上掉落到地面需要多长时间 定义需求。既指您的解决方案需要遵守的约束（例如预算、时间线、空间、内存等），也指程序为满足用户需求而必须展示的能力。请注意，您的要求同样应该关注“什么”，而不是“如何”。例如： 应保存电话号码，以便日后调用 用户应该能够输入塔的高度 定义您的工具、目标和备份计划 定义您的程序将运行的目标架构 和/或 操作系统 确定您将使用的工具集 确定您是单独编写程序还是作为团队的一部分编写程序’ 定义您的测试/反馈/发布策略 确定您将如何备份您的代码 将困难问题分解为简单问题。如果发现其中一个项目（功能）太难实现，只需将该项目拆分为多个子项目/子功能。最终，您应该达到程序中的每个功能都可以轻松实现的地步 弄清楚事件的顺序 Implementation（实现） 概述您的主要功能。 int main() { // Get first number from user // getUserInput(); // Get mathematical operation from user // getMathematicalOperation(); // Get second number from user // getUserInput(); // Calculate result // calculateResult(); // Print result // printResult(); return 0; } 实现各个功能。对于每个函数，您将做三件事： 定义函数原型（输入和输出） 编写函数 测试功能 最终测试。一旦你的程序“完成”，最后一步就是测试整个程序并确保它按预期工作。如果它不起作用，请修复它 Words of advice when writing programs（忠告） Keep your programs simple to start.让你的第一个目标尽可能简单，一些你绝对可以实现的目标 Add features over time.一旦您的简单程序运行良好并且运行良好，您就可以向其添加功能 Focus on one area at a time.不要试图一次编写所有代码，也不要将注意力分散到多个任务上。一次专注于一项任务 Test each piece of code as you go.编写一段代码，然后立即编译并测试它。如果它不起作用，您将确切地知道问题出在哪里，并且很容易修复。确定代码有效后，移至下一段并重复。完成代码的编写可能需要更长的时间，但是当您完成后，整个事情应该可以正常工作，并且您不必花费两倍的时间来弄清楚为什么它不起作用 Don’t invest in perfecting early code.让你的功能最低限度地工作，然后继续。不要以完美为目标——重要的程序从来都不是完美的，而且总有更多的事情可以做来改进它们。达到“足够好”并继续前进 调试 C++ 程序 调试过程 找到问题的根本原因（通常是不起作用的代码行） 确保您了解问题发生的原因 确定您将如何解决问题 修复问题 重新测试以确保问题已解决并且没有出现新问题 调试策略 观察程序运行时的行为，并尝试从中诊断问题\n弄清楚如何重现问题 运行程序并收集信息以缩小问题所在的范围 重复前面的步骤，直到找到问题 调试策略 1：注释掉你的代码 如果您的程序表现出错误行为，减少必须搜索的代码量的一种方法是注释掉一些代码并查看问题是否仍然存在。如果问题仍然存在，则注释掉的代码不负责任\n调试策略 2：验证代码流 另一个在更复杂的程序中常见的问题是程序调用一个函数的次数太多或太少（包括根本不调用）\n在这种情况下，将语句放在函数的顶部以打印函数的名称会很有帮助。这样，当程序运行时，您可以看到调用了哪些函数\n当出于调试目的打印信息时，使用 std::cerr 而不是 std::cout。这样做的一个原因是 std::cout 可能被缓冲，这意味着在您要求 std::cout 输出信息和它实际输出信息之间可能会有一个暂停。如果您使用 std::cout 进行输出，然后您的程序随后立即崩溃，则 std::cout 可能已经或可能还没有实际输出。这可能会误导您了解问题出在哪里。另一方面，std::cerr 是无缓冲1的，这意味着您发送给它的任何内容都会立即输出。这有助于确保所有调试输出尽快出现（以一些性能为代价，我们在调试时通常不关心）\n使用 std::cerr 还有助于明确输出的信息是针对错误情况而不是正常情况\n添加临时调试语句时，不缩进它们会很有帮助。这使它们更容易在以后找到并移除\n#include \u0026lt;iostream\u0026gt; int getValue() { std::cerr \u0026lt;\u0026lt; \u0026#34;getValue() called\\n\u0026#34;; return 4; } int main() { std::cerr \u0026lt;\u0026lt; \u0026#34;main() called\\n\u0026#34;; std::cout \u0026lt;\u0026lt; getValue; return 0; } 调试策略 3：打印值 对于某些类型的错误，程序可能会计算或传递错误的值。\n我们还可以输出变量（包括参数）或表达式的值，以确保它们是正确的。\nFor example:\n#include \u0026lt;iostream\u0026gt; int add(int x, int y) { std::cerr \u0026lt;\u0026lt; \u0026#34;add() called (x=\u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt;\u0026#34;, y=\u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;)\\n\u0026#34;; return x + y; } void printResult(int z) { std::cout \u0026lt;\u0026lt; \u0026#34;The answer is: \u0026#34; \u0026lt;\u0026lt; z \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int getUserInput() { std::cout \u0026lt;\u0026lt; \u0026#34;Enter a number: \u0026#34;; int x{}; std::cin \u0026gt;\u0026gt; x; return x; } int main() { int x{ getUserInput() }; std::cerr \u0026lt;\u0026lt; \u0026#34;main::x = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; int y{ getUserInput() }; std::cerr \u0026lt;\u0026lt; \u0026#34;main::y = \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; + \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; int z{ add(x, 5) }; std::cerr \u0026lt;\u0026lt; \u0026#34;main::z = \u0026#34; \u0026lt;\u0026lt; z \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; printResult(z); return 0; } 现在我们将得到输出：\nEnter a number: 4 main::x = 4 Enter a number: 3 main::y = 3 add() called (x=4, y=5) main::z = 9 The answer is: 9 虽然为诊断目的向程序添加调试语句是一种常见的基本技术，也是一种功能性技术（尤其是当调试器由于某种原因不可用时），但由于多种原因它并不是很好：\n调试语句使您的代码混乱。 调试语句使程序的输出混乱。 调试语句必须在完成后删除，这使得它们不可重用。 调试语句需要修改您的代码以添加和删除，这可能会引入新的错误。 条件化调试代码 一种更容易在整个程序中禁用和启用调试的方法是使用预处理器指令使调试语句有条件：\n#include \u0026lt;iostream\u0026gt; #define ENABLE_DEBUG // comment out to disable debugging int getUserInput() { #ifdef ENABLE_DEBUG std::cerr \u0026lt;\u0026lt; \u0026#34;getUserInput() called\\n\u0026#34;; #endif std::cout \u0026lt;\u0026lt; \u0026#34;Enter a number: \u0026#34;; int x{}; std::cin \u0026gt;\u0026gt; x; return x; } int main() { #ifdef ENABLE_DEBUG std::cerr \u0026lt;\u0026lt; \u0026#34;main() called\\n\u0026#34;; #endif int x{ getUserInput() }; std::cout \u0026lt;\u0026lt; \u0026#34;You entered: \u0026#34; \u0026lt;\u0026lt; x; return 0; } 现在我们可以通过注释/取消注释#define ENABLE_DEBUG 来启用调试。这使我们能够重用以前添加的调试语句，然后在用完它们后将它们禁用，而不必从代码中实际删除它们\n这解决了必须删除调试语句的问题以及这样做的风险，但代价是代码更加混乱。这种方法的另一个缺点是，如果您输入错误（例如拼错“DEBUG”）或忘记将标头包含到代码文件中，则可能无法启用该文件的部分或全部调试\n使用日志 通过预处理器进行条件化调试的另一种方法是将调试信息发送到日志文件。日志文件是记录软件中发生的事件的文件（通常存储在磁盘上）。将信息写入日志文件的过程称为日志记录。大多数应用程序和操作系统都会写入可用于帮助诊断发生的问题的日志文件\n日志文件有几个优点。因为写入日志文件的信息与程序的输出是分开的，所以可以避免将正常输出和调试输出混合在一起造成的混乱。日志文件也可以很容易地发送给其他人进行诊断——所以如果有人使用你的软件有问题，你可以让他们把日志文件发给你，这可能会帮助你找到问题所在的线索\n虽然您可以编写自己的代码来创建日志文件并将输出发送给它们，但最好还是使用许多现有的第三方日志记录工具之一\nUsing the plog logger：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;plog/Log.h\u0026gt; // Step 1: include the logger headers #include \u0026lt;plog/Initializers/RollingFileInitializer.h\u0026gt; int getUserInput() { PLOGD \u0026lt;\u0026lt; \u0026#34;getUserInput() called\u0026#34;; // PLOGD is defined by the plog library std::cout \u0026lt;\u0026lt; \u0026#34;Enter a number: \u0026#34;; int x{}; std::cin \u0026gt;\u0026gt; x; return x; } int main() { plog::init(plog::debug, \u0026#34;Logfile.txt\u0026#34;); // Step 2: initialize the logger PLOGD \u0026lt;\u0026lt; \u0026#34;main() called\u0026#34;; // Step 3: Output to the log as if you were writing to the console int x{ getUserInput() }; std::cout \u0026lt;\u0026lt; \u0026#34;You entered: \u0026#34; \u0026lt;\u0026lt; x; return 0; } 这是上述记录器的输出（在 Logfile.txt 文件中）：\n2018-12-26 20:03:33.295 DEBUG [4752] [main@14] main() called 2018-12-26 20:03:33.296 DEBUG [4752] [getUserInput@4] getUserInput() called 您如何包含、初始化和使用记录器将根据您选择的特定记录器而有所不同\n请注意，使用此方法也不需要条件编译指令，因为大多数记录器都有减少/消除将输出写入日志的方法。这使得代码更容易阅读，因为条件编译行增加了很多混乱。使用 plog，可以通过将 init 语句更改为以下内容来暂时禁用日志记录：\nplog::init(plog::none , \u0026#34;Logfile.txt\u0026#34;); // plog::none eliminates writing of most messages, essentially turning logging off 使用集成调试器：Stepping（步进） 当您运行您的程序时，执行从 main 函数的顶部开始，然后逐个语句按顺序执行，直到程序结束。在你的程序运行的任何时间点，程序都在跟踪很多事情：你正在使用的变量的值，调用了哪些函数（这样当这些函数返回时，程序就会知道在哪里返回），以及程序中的当前执行点（因此它知道接下来要执行哪个语句）。所有这些跟踪信息都称为您的程序状态（或简称为状态）\nStepping 是一组相关调试器功能的名称，这些功能让我们逐条语句地执行（单步执行）我们的代码\n箭头标记表示接下来将执行所指向的行\nStep into 步入 命令执行程序正常执行路径中的下一条语句，然后暂停程序的执行，以便我们可以使用调试器检查程序的状态。如果正在执行的语句包含一个函数调用，step into 会使程序跳转到被调用函数的顶部，并在那里暂停\nStep over 同步入命令一样，步过命令执行程序正常执行路径中的下一条语句。然而，step into 将输入函数调用并逐行执行它们，step over 将不间断地执行整个函数，并在函数执行后将控制权返回给您\nstep over 命令提供了一种方便的方法来跳过函数，当您确定它们已经工作或现在对调试它们不感兴趣时\nStep out 与其他两个步进命令不同，步出 命令不只是执行下一行代码。相反，它执行当前正在执行的函数中的所有剩余代码，然后在函数返回时将控制权返回给您\n当你不小心进入了一个你不想调试的函数时，这个命令最有用\n使用集成调试器：Running and breakpoints（运行和断点） Run to cursor 第一个有用的命令通常称为运行到光标。此运行到光标命令执行程序，直到执行到达光标选择的语句。然后它将控制权返回给您，以便您可以从那时开始进行调试\nBreakpoints 断点 是一个特殊的标记，它告诉调试器在调试模式下运行时在断点处停止执行程序\n使用集成调试器：调用堆栈 调用堆栈是为到达当前执行点而调用的所有活动函数的列表。调用堆栈包括每个调用的函数的条目，以及函数返回时将返回到哪一行代码。每当调用一个新函数时，该函数就会被添加到调用堆栈的顶部。当前函数返回给调用者时，它会从调用栈的顶部移除，控制权会返回到它下面的函数\n调用堆栈窗口是一个显示当前调用堆栈的调试器窗口\n函数名称后的行号显示了每个函数中要执行的下一行\n由于调用堆栈的顶部条目代表当前正在执行的函数，因此此处的行号显示了执行恢复时将执行的下一行。调用堆栈中的其余条目表示将在某个时间点返回的函数，因此这些条目的行号表示函数返回后将执行的下一条语句\n在问题成为问题之前发现问题 重构你的代码 当您向程序添加新功能（“行为更改”）时，您会发现某些功能的长度会增加。随着函数越来越长，它们变得越来越复杂，也越来越难以理解\n解决此问题的一种方法是将单个长函数分解为多个较短的函数。这种在不改变代码行为的情况下对代码进行结构更改的过程（通常是为了使您的程序更有组织性、模块化或性能）称为重构\n一个函数占据一个垂直屏幕的代码通常被认为太长了——如果你必须滚动才能阅读整个函数，函数的可理解性会显着下降。但越短越好 \u0026ndash; 少于十行的功能是好的。少于五行的函数就更好了\n更改代码时，进行行为更改或结构更改，然后重新测试正确性。同时进行行为和结构更改往往会导致更多错误以及更难发现的错误\n约束 基于约束的技术涉及添加一些额外的代码（如果需要，可以在非调试构建中编译出来）以检查是否违反了某些假设或期望集\n例如，如果我们正在编写一个函数来计算一个数字的阶乘，它需要一个非负参数，该函数可以检查以确保调用者在继续之前传递了一个非负数。如果调用者传入一个负数，那么该函数可能会立即出错，而不是产生一些不确定的结果，从而有助于确保立即发现问题\n一种常见的方法是通过 assert 和 static_assert\n基本数据类型 数据类型大小 数据类型的大小取决于编译器和计算机体系结构！\nC++ 仅保证每个基本数据类型都具有最小大小 为了获得最大的兼容性，您不应假设变量大于指定的最小大小\n#include \u0026lt;iostream\u0026gt; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;bool:\\t\\t\u0026#34; \u0026lt;\u0026lt; sizeof(bool) \u0026lt;\u0026lt; \u0026#34; bytes\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;char:\\t\\t\u0026#34; \u0026lt;\u0026lt; sizeof(char) \u0026lt;\u0026lt; \u0026#34; bytes\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;wchar_t:\\t\u0026#34; \u0026lt;\u0026lt; sizeof(wchar_t) \u0026lt;\u0026lt; \u0026#34; bytes\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;char16_t:\\t\u0026#34; \u0026lt;\u0026lt; sizeof(char16_t) \u0026lt;\u0026lt; \u0026#34; bytes\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;char32_t:\\t\u0026#34; \u0026lt;\u0026lt; sizeof(char32_t) \u0026lt;\u0026lt; \u0026#34; bytes\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;short:\\t\\t\u0026#34; \u0026lt;\u0026lt; sizeof(short) \u0026lt;\u0026lt; \u0026#34; bytes\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;int:\\t\\t\u0026#34; \u0026lt;\u0026lt; sizeof(int) \u0026lt;\u0026lt; \u0026#34; bytes\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;long:\\t\\t\u0026#34; \u0026lt;\u0026lt; sizeof(long) \u0026lt;\u0026lt; \u0026#34; bytes\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;long long:\\t\u0026#34; \u0026lt;\u0026lt; sizeof(long long) \u0026lt;\u0026lt; \u0026#34; bytes\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;float:\\t\\t\u0026#34; \u0026lt;\u0026lt; sizeof(float) \u0026lt;\u0026lt; \u0026#34; bytes\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;double:\\t\\t\u0026#34; \u0026lt;\u0026lt; sizeof(double) \u0026lt;\u0026lt; \u0026#34; bytes\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;long double:\\t\u0026#34; \u0026lt;\u0026lt; sizeof(long double) \u0026lt;\u0026lt; \u0026#34; bytes\\n\u0026#34;; return 0; } 下面是我的 x64 机器的输出，使用 Clion：\nbool: 1 bytes char: 1 bytes wchar_t: 2 bytes char16_t: 2 bytes char32_t: 4 bytes short: 2 bytes int: 4 bytes long: 4 bytes long long: 8 bytes float: 4 bytes double: 8 bytes long double: 16 bytes 如果您使用不同类型的机器或不同的编译器，您的结果可能会有所不同。请注意，您不能对 void 类型使用 sizeof 运算符，因为它没有大小（这样做会导致编译错误）\n无符号整数和有符号整数 有符号整数范围： 无符号整数范围： 如果无符号整数超出范围，则将其除以大于该类型的最大数，只保留余数\n在 C++ 的数学运算中（例如算术或比较），如果使用一个有符号整数和一个无符号整数，则有符号整数将转换为无符号整数。并且无符号整数不能存储负数，这会导致数据丢失\n在保存整数（甚至应该是非负的整数）和数学运算时，有符号数优于无符号数。避免混合有符号和无符号数字\n在 C++ 中仍然有一些情况必须使用无符号数：\n首先，在处理位操作时首选无符号数。当需要明确定义的环绕行为时，它们也很有用（在某些算法中很有用，例如加密和随机数生成）\n其次，无符号数的使用在某些情况下仍然是不可避免的，主要是那些与数组索引有关的情况。。在这些情况下，无符号值可以转换为有符号值\n固定宽度整数和 size_t Fixed-width 整数 为什么整数变量的大小不固定？\n这可以追溯到 C，当时计算机速度很慢，性能是最受关注的问题。 C 选择有意保留整数的大小，以便编译器实现者可以选择在目标计算机体系结构上表现最佳的 int 大小\nC99 定义了一组固定宽度的整数（在 stdint.h 头文件中），保证在任何体系结构上都具有相同的大小\nC++ 正式采用这些固定宽度整数作为 C++11 的一部分。可以通过包含 \u0026lt;cstdint\u0026gt; 头文件来访问它们，它们在 std 命名空间内定义\nFast and least 整数 The fast 类型（std::int_fast#_t 和 std::uint_fast#_t）提供最快的有符号/无符号整数类型，宽度至少为 # 位（其中 # = 8、16、32 或 64）。例如，std::int_fast32_t 将为您提供最快的至少 32 位的有符号整数类型\nThe least 类型（std::int_least#_t 和 std::uint_least#_t）提供宽度至少为 # 位（其中 # = 8、16、32 或 64）的最小有符号/无符号整数类型。例如，std::uint_least32_t 将为您提供至少 32 位的最小无符号整数类型\n示例：\n#include \u0026lt;cstdint\u0026gt; // for fixed-width integers #include \u0026lt;iostream\u0026gt; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;least 8: \u0026#34; \u0026lt;\u0026lt; sizeof(std::int_least8_t) * 8 \u0026lt;\u0026lt; \u0026#34; bits\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;least 16: \u0026#34; \u0026lt;\u0026lt; sizeof(std::int_least16_t) * 8 \u0026lt;\u0026lt; \u0026#34; bits\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;least 32: \u0026#34; \u0026lt;\u0026lt; sizeof(std::int_least32_t) * 8 \u0026lt;\u0026lt; \u0026#34; bits\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;fast 8: \u0026#34; \u0026lt;\u0026lt; sizeof(std::int_fast8_t) * 8 \u0026lt;\u0026lt; \u0026#34; bits\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;fast 16: \u0026#34; \u0026lt;\u0026lt; sizeof(std::int_fast16_t) * 8 \u0026lt;\u0026lt; \u0026#34; bits\\n\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;fast 32: \u0026#34; \u0026lt;\u0026lt; sizeof(std::int_fast32_t) * 8 \u0026lt;\u0026lt; \u0026#34; bits\\n\u0026#34;; return 0; } Result：\nleast 8: 8 bits least 16: 16 bits least 32: 32 bits fast 8: 8 bits fast 16: 16 bits fast 32: 32 bits 然而，这些快速且最小的整数有其自身的缺点：首先，真正使用它们的程序员并不多，不熟悉会导致错误。其次，快速类型会导致与我们在 4 字节整数中看到的相同类型的内存浪费。最严重的是，由于快速/最小整数的大小可能会有所不同，因此您的程序可能会在解析为不同大小的架构上表现出不同的行为\nstd::int8_t 和 std::uint8_t 可能表现得像字符而不是整数 由于 C++ 规范中的疏忽，大多数编译器分别将 std::int8_t 和 std::uint8_t（以及相应的快速和最小固定宽度类型）定义为 signed char 和 unsigned char 类型，并将其视为相同的类型。这意味着这些 8 位类型的行为可能（或可能不）与其他固定宽度类型不同，这可能会导致错误。此行为是系统相关的，因此在一种体系结构上正确运行的程序可能无法编译或在另一种体系结构上正确运行\n为了保持一致性，最好完全避免使用 std::int8_t 和 std::uint8_t（以及相关的快速和最少类型）（改用 std::int16_t 或 std::uint16_t）\n8 位固定宽度整数类型通常被视为字符而不是整数值（这可能因系统而异）。大多数情况下首选 16 位固定整数类型\nBest practice 我们的立场是正确比快速更好，在编译时失败比运行时更好——因此，我们建议避免使用快速/最少的类型，而使用固定宽度的类型。如果您后来发现需要支持无法编译固定宽度类型的平台，那么您可以在此时决定如何迁移您的程序（并彻底测试）\n当整数的大小无关紧要时，首选 int（例如，数字将始终适合 2 字节有符号整数的范围）。例如，如果您要求用户输入他们的年龄，或者从 1 数到 10，则 int 是 16 位还是 32 位都没有关系（数字将适合任何一种方式）。这将涵盖您可能遇到的绝大多数情况 存储需要保证范围的数量时，首选 std::int#_t 在进行位操作或需要明确定义的环绕行为时，首选 std::uint#_t 尽可能避免以下情况： 存储数量的无符号类型 8 位固定宽度整数类型 Fast and least 整数类型 任何特定于编译器的固定宽度整数——例如，Visual Studio 定义了 __int8、__int16 …… size_t sizeof（以及许多返回大小或长度值的函数）返回一个 std::size_t 类型的值。 std::size_t 被定义为无符号整数类型，通常用于表示对象的大小或长度\n有趣的是，我们可以使用 sizeof 运算符（返回 std::size_t 类型的值）来询问 std::size_t 本身的大小：\n#include \u0026lt;cstddef\u0026gt; // std::size_t #include \u0026lt;iostream\u0026gt; int main() { std::cout \u0026lt;\u0026lt; sizeof(std::size_t) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 就像整数的大小会因系统而异一样，std::size_t 的大小也会有所不同。 std::size_t 保证为无符号且至少为 16 位，但在大多数系统上将等同于应用程序的地址宽度。也就是说，对于 32 位应用程序，std::size_t 通常是 32 位无符号整数，而对于 64 位应用程序，size_t 通常是 64 位无符号整数。 size_t 被定义为足够大以容纳系统上可创建的最大对象的大小（以字节为单位）。例如，如果 std::size_t 为 4 字节宽，则系统上可创建的最大对象不能大于 4,294,967,295 字节，因为 4,294,967,295 是 4 字节无符号整数可以存储的最大数字。这只是对象大小的上限，实际大小限制可能会更低，具体取决于您使用的编译器\n根据定义，任何大小（以字节为单位）大于 size_t 可以容纳的最大整数值的对象都被视为格式错误（并将导致编译错误），因为 sizeof 运算符将无法在不环绕的情况下返回大小\n浮点数（IEEE 754） 浮点范围和浮点精度 使用浮点文字时，始终至少包含一位小数（即使小数为 0）。这有助于编译器理解该数字是浮点数而不是整数\nint x{5}; // 5 means integer double y{5.0}; // 5.0 is a floating point literal (no suffix means double type by default) float z{5.0f}; // 5.0 is a floating point literal, f suffix means float type 始终确保字面量的类型与分配给它们或用于初始化的变量的类型相匹配。否则会导致不必要的转换，可能会导致精度损失\n确保在应该使用浮点文字的地方不使用整数文字。这包括初始化浮点对象或为浮点对象赋值、进行浮点运算以及调用需要浮点值的函数\n输出浮点数时，std::cout 的默认精度为 6——也就是说，它假定所有浮点变量仅对 6 位有效（浮点数的最小精度），因此它将截断之后的任何内容\n浮点变量的精度位数取决于大小（浮点数的精度低于双精度数）和存储的特定值（某些值的精度高于其他值）。浮点值的精度在 6 到 9 位之间，大多数浮点值至少有 7 位有效数字。双精度值的精度在 15 到 18 位之间，大多数双精度值至少有 16 位有效数字。 Long double 的最小精度为 15、18 或 33 位有效数字，具体取决于它占用的字节数\n舍入误差 我们可以使用名为 std::setprecision() 的输出操纵器函数覆盖 std::cout 显示的默认精度。输出操纵器改变数据的输出方式，并在 iomanip 标头中定义\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; // for output manipulator std::setprecision() int main() { std::cout \u0026lt;\u0026lt; std::setprecision(16); // show 16 digits of precision std::cout \u0026lt;\u0026lt; 3.33333333333333333333333333333333333333f \u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; // f suffix means float std::cout \u0026lt;\u0026lt; 3.33333333333333333333333333333333333333 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // no suffix means double return 0; } 在使用需要比变量所能容纳的精度更高的浮点数时，必须小心\n除非空间非常宝贵，否则最好使用 double over float，因为 float 缺乏精度通常会导致不准确\n值 123456789.0 具有 10 位有效数字，但浮点值通常具有 7 位精度（而 123456792 的结果仅精确到 7 位有效数字）。我们失去了一些精度！当由于无法精确存储数字而导致精度丢失时，这称为舍入误差\n数学运算（例如加法和乘法）往往会使舍入误差增大。所以即使0.1在第17位有效位有舍入误差，但是当我们加上0.1十次时，舍入误差已经爬到第16位有效位了。继续操作会导致此错误变得越来越严重\nNaN 和 Inf 有两种特殊类别的浮点数。第一个是 Inf，代表无穷大。 Inf 可以是正数或负数。第二个是 NaN，代表“不是数字”。有几种不同类型的 NaN（我们不会在这里讨论）。 NaN 和 Inf 仅在编译器对浮点数使用特定格式 (IEEE 754) 时可用\nConclusion 总而言之，关于浮点数你应该记住两件事：\n浮点数对于存储非常大或非常小的数字很有用，包括带有小数部分的数字\n浮点数通常有小的舍入误差，即使数字的有效数字少于精度也是如此。很多时候这些都没有引起注意，因为它们太小了，而且因为输出的数字被截断了。但是，浮点数的比较可能不会给出预期的结果。对这些值执行数学运算将导致舍入误差变大\n布尔值 如果您希望 std::cout 打印“true”或“false”而不是 0 或 1，您可以使用 std::boolalpha。这是一个例子：\n#include \u0026lt;iostream\u0026gt; int main() { std::cout \u0026lt;\u0026lt; true \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; false \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; std::boolalpha; // print bools as true or false std::cout \u0026lt;\u0026lt; true \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; false \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 您可以使用 std::noboolalpha 将其关闭\n您不能使用除 0 1 外的整数初始化布尔值：\n#include \u0026lt;iostream\u0026gt; int main() { bool b{ 4 }; // error: narrowing conversions disallowed std::cout \u0026lt;\u0026lt; b; return 0; } 但是，在任何可以将整数转换为布尔值的上下文中，整数 0 将转换为 false，而任何其他整数将转换为 true\n事实证明，std::cin 只接受布尔变量的两个输入：0 和 1（不是 true 或 false）。任何其他输入都会导致 std::cin 无声地失败。在这种情况下，因为我们输入了 true，所以 std::cin 默默地失败了。失败的输入也会将变量清零，因此 b 也被赋值 false。因此，当 std::cout 打印 b 的值时，它打印 0\n要允许 std::cin 接受“false”和“true”作为输入，必须启用 std::boolalpha 选项：\n#include \u0026lt;iostream\u0026gt; int main() { bool b{}; std::cout \u0026lt;\u0026lt; \u0026#34;Enter a boolean value: \u0026#34;; // Allow the user to enter \u0026#39;true\u0026#39; or \u0026#39;false\u0026#39; for boolean values // This is case-sensitive, so True or TRUE will not work std::cin \u0026gt;\u0026gt; std::boolalpha; std::cin \u0026gt;\u0026gt; b; std::cout \u0026lt;\u0026lt; \u0026#34;You entered: \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 但是，当启用 std::boolalpha 时，“0”和“1”将不再被视为布尔值\nChars char 数据类型旨在保存单个字符。字符可以是单个字母、数字、符号或空格\nchar 数据类型是整数类型，这意味着基础值存储为整数。类似于布尔值 0 被解释为 false 而非零被解释为 true 的方式，char 变量存储的整数被解释为 ASCII 字符\nChar 由 C++ 定义为大小始终为 1 个字节。默认情况下，char 可以是有符号的或无符号的（尽管它通常是有符号的）。如果您使用 chars 来保存 ASCII 字符，则不需要指定符号（因为有符号和无符号字符都可以保存 0 到 127 之间的值）\n如果您使用 char 来保存小整数（除非您明确优化空间，否则您不应该这样做），您应该始终指定它是有符号的还是无符号的。 signed char 可以保存 -128 到 127 之间的数字。unsigned char 可以保存 0 到 255 之间的数字\n将单个字符放在单引号中（ e.g. 't' or '\\n', not \u0026quot;t\u0026quot; or \u0026quot;\\n\u0026quot;）这有助于编译器更有效地进行优化\n出于向后兼容性的原因，许多 C++ 编译器支持多字符文字，即包含多个字符（例如“56”）的字符文字。如果支持，它们具有实现定义的值（意味着它因编译器而异）。因为它们不是 C++ 标准的一部分，而且它们的值也没有严格定义，所以应该避免使用多字符文字\nASCII 之外最著名的映射是 Unicode 标准，它将超过 144,000 个整数映射到许多不同语言的字符。由于 Unicode 包含如此多的代码点，因此单个 Unicode 代码点需要 32 位来表示一个字符（称为 UTF-32）。但是，Unicode 字符也可以使用多个 16 位或 8 位字符（分别称为 UTF-16 和 UTF-8）进行编码\nchar16_t 和 char32_t 添加到 C++11 以提供对 16 位和 32 位 Unicode 字符的明确支持。 C++20 中添加了 char8_t\n您不需要使用 char8_t、char16_t 或 char32_t，除非您计划让您的程序与 Unicode 兼容\n同时，在处理字符（和字符串）时，您应该只使用 ASCII 字符。使用来自其他字符集的字符可能会导致您的字符显示不正确\n常量和符号常量 const variables Const 变量必须在定义它们时进行初始化，然后不能通过赋值更改该值\nConst 变量可以从其他变量（包括非常量变量）初始化\n命名时以 “k” 开头, 大小写混合,例如：\nconst int kDaysInAWeek = 7; 符号常量 符号常量指的是被赋予常量值的名称。const variables 是一种符号常量，因为变量有一个名称（它的标识符）和一个常量值\n#include \u0026lt;iostream\u0026gt; #define MAX_STUDENTS_PER_CLASS 30 int main() { std::cout \u0026lt;\u0026lt; \u0026#34;The class has \u0026#34; \u0026lt;\u0026lt; MAX_STUDENTS_PER_CLASS \u0026lt;\u0026lt; \u0026#34; students.\\n\u0026#34;; return 0; } 编译此程序时，预处理器会将 MAX_STUDENTS_PER_CLASS 替换为字面值 30，然后编译器会将其编译为您的可执行文件\n因为类对象宏有一个名字，并且替换文本是一个常量值，所以带有替换文本的类对象宏也是符号常量\n对于符号常量，更喜欢常量变量而不是类对象宏 首先，因为宏是由预处理器解析的，所有出现的宏都在编译之前被定义的值替换。如果您正在调试代码，您将看不到实际值（例如 30）——您只会看到符号常量的名称（例如 MAX_STUDENTS_PER_CLASS）。因为这些#defined 值不是变量，所以您无法在调试器中添加监视来查看它们的值。如果您想知道 MAX_STUDENTS_PER_CLASS 解析为什么值，您必须找到 MAX_STUDENTS_PER_CLASS 的定义（可能在不同的文件中）。这会使您的程序更难调试\n其次，宏可能与普通代码有命名冲突\n第三，宏不遵循正常的作用域规则，这意味着在极少数情况下，在程序的一部分中定义的宏可能会与在程序的另一部分中编写的代码发生冲突，而它不应该与之交互\n编译时常量、常量表达式和 constexpr Constant expressions 常量表达式是可以在编译时由编译器求值的表达式。要成为常量表达式，表达式中的所有值必须在编译时已知（并且所有调用的运算符和函数必须支持编译时求值）\n在编译时对常量表达式求值会使我们的编译时间变长（因为编译器必须做更多的工作），但这样的表达式只需要求值一次（而不是每次程序运行时）。生成的可执行文件速度更快，使用的内存更少\nCompile-time constants 编译时常量是其值在编译时已知的常量。文字（例如“1”、“2.3”和“Hello, world!”）是一种编译时常量\nConst 变量可能是也可能不是编译时常量\nCompile-time const 如果 const 变量的初始值设定项是常量表达式，则它是编译时常量\n#include \u0026lt;iostream\u0026gt; int main() { const int x { 3 }; // x is a compile-time const const int y { 4 }; // y is a compile-time const const int z { x + y }; // x + y is a compile-time expression std::cout \u0026lt;\u0026lt; z \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 因为 x 和 y 的初始化值是常量表达式，所以 x 和 y 是编译时常量。这意味着 x + y 也是常量表达式。所以当编译器编译这个程序时，它可以计算 x + y 的值，并将常量表达式替换为结果文字 7\nRuntime const 任何使用非常量表达式初始化的 const 变量都是运行时常量。运行时常量是其初始化值直到运行时才知道的常量\n#include \u0026lt;iostream\u0026gt; int getNumber() { std::cout \u0026lt;\u0026lt; \u0026#34;Enter a number: \u0026#34;; int y{}; std::cin \u0026gt;\u0026gt; y; return y; } int main() { const int x{ 3 }; // x is a compile time constant const int y{ getNumber() }; // y is a runtime constant const int z{ x + y }; // x + y is a runtime expression std::cout \u0026lt;\u0026lt; z \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // this is also a runtime expression return 0; } 即使 y 是常量，初始化值（getNumber() 的返回值）直到运行时才知道。因此，y 是运行时常量，而不是编译时常量。因此，表达式 x + y 是一个运行时表达式\nconstexpr 关键字 当你声明一个 const 变量时，编译器会隐式地跟踪它是运行时常量还是编译时常量。在大多数情况下，除了优化目的之外，这无关紧要，但有一些奇怪的情况，C++ 需要编译时常量而不是运行时常量\n因为编译时常量通常允许更好的优化（并且几乎没有缺点），所以我们通常希望尽可能使用编译时常量\n我们可以寻求编译器的帮助，以确保我们得到一个我们期望的编译时常量。为此，我们在变量声明中使用 constexpr 关键字而不是 const。 constexpr（“常量表达式”的缩写）变量只能是编译时常量。如果 constexpr 变量的初始化值不是常量表达式，编译器会出错\n#include \u0026lt;iostream\u0026gt; int five() { return 5; } int main() { constexpr double gravity { 9.8 }; // ok: 9.8 is a constant expression constexpr int sum { 4 + 5 }; // ok: 4 + 5 is a constant expression constexpr int something { sum }; // ok: sum is a constant expression std::cout \u0026lt;\u0026lt; \u0026#34;Enter your age: \u0026#34;; int age{}; std::cin \u0026gt;\u0026gt; age; constexpr int myAge { age }; // compile error: age is not a constant expression constexpr int f { five() }; // compile error: return value of five() is not a constant expression return 0; } 任何在初始化后不应修改且其初始值设定项在编译时已知的变量都应声明为 constexpr\n任何在初始化后不应修改且其初始值设定项在编译时未知的变量都应声明为 const\nLiterals 文字是直接插入代码中的未命名值。例如：\nreturn 5; // 5 is an integer literal bool myNameIsAlex { true }; // true is a boolean literal std::cout \u0026lt;\u0026lt; 3.4; // 3.4 is a double literal 如对象有类型一样，所有文字都有类型。文字的类型是从文字的值推导出来的\n十进制、二进制、十六进制和八进制 二进制文字和数字分隔符 在 C++14 之前，不支持二进制文字。然而，十六进制文字为我们提供了一个有用的解决方法（您可能仍会在现有代码库中看到）：\n#include \u0026lt;iostream\u0026gt; int main() { int bin{}; // assume 16-bit ints bin = 0x0001; // assign binary 0000 0000 0000 0001 to the variable bin = 0x0002; // assign binary 0000 0000 0000 0010 to the variable bin = 0x0004; // assign binary 0000 0000 0000 0100 to the variable bin = 0x0008; // assign binary 0000 0000 0000 1000 to the variable bin = 0x0010; // assign binary 0000 0000 0001 0000 to the variable bin = 0x0020; // assign binary 0000 0000 0010 0000 to the variable bin = 0x0040; // assign binary 0000 0000 0100 0000 to the variable bin = 0x0080; // assign binary 0000 0000 1000 0000 to the variable bin = 0x00FF; // assign binary 0000 0000 1111 1111 to the variable bin = 0x00B3; // assign binary 0000 0000 1011 0011 to the variable bin = 0xF770; // assign binary 1111 0111 0111 0000 to the variable return 0; } 在 C++14 中，我们可以通过使用 0b 前缀来使用二进制文字：\n#include \u0026lt;iostream\u0026gt; int main() { int bin{}; // assume 16-bit ints bin = 0b1; // assign binary 0000 0000 0000 0001 to the variable bin = 0b11; // assign binary 0000 0000 0000 0011 to the variable bin = 0b1010; // assign binary 0000 0000 0000 1010 to the variable bin = 0b11110000; // assign binary 0000 0000 1111 0000 to the variable return 0; } 由于长文本可能难以阅读，C++14 还添加了使用引号 (‘) 作为数字分隔符的功能（分隔符不能出现在值的第一位数字之前）（数字分隔符纯粹是视觉上的，不会以任何方式影响字面值）\n#include \u0026lt;iostream\u0026gt; int main() { int bin { 0b1011\u0026#39;0010 }; // assign binary 1011 0010 to the variable long value { 2\u0026#39;132\u0026#39;673\u0026#39;462 }; // much easier to read than 2132673462 return 0; } 以十进制、八进制或十六进制输出值 默认情况下，C++ 以十进制形式输出值。但是，您可以通过使用 std::dec、std::oct 和 std::hex I/O 操纵器更改输出格式：\n#include \u0026lt;iostream\u0026gt; int main() { int x { 12 }; std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // decimal (by default) std::cout \u0026lt;\u0026lt; std::hex \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // hexadecimal std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // now hexadecimal std::cout \u0026lt;\u0026lt; std::oct \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // octal std::cout \u0026lt;\u0026lt; std::dec \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // return to decimal std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // decimal return 0; } 以二进制输出值 以二进制形式输出值有点困难，因为 std::cout 没有内置此功能。幸运的是，C++ 标准库包含一个名为 std::bitset 的类型，它将为我们完成此操作（在 \u0026lt;bitset\u0026gt; 标头中）。要使用 std::bitset，我们可以定义一个 std::bitset 变量并告诉 std::bitset 我们要存储多少位。位数必须是编译时常量。 std::bitset 可以用无符号整数值（任何格式，包括十进制、八进制、十六进制或二进制）初始化\n#include \u0026lt;bitset\u0026gt; // for std::bitset #include \u0026lt;iostream\u0026gt; int main() { // std::bitset\u0026lt;8\u0026gt; means we want to store 8 bits std::bitset\u0026lt;8\u0026gt; bin1{ 0b1100\u0026#39;0101 }; // binary literal for binary 1100 0101 std::bitset\u0026lt;8\u0026gt; bin2{ 0xC5 }; // hexadecimal literal for binary 1100 0101 std::cout \u0026lt;\u0026lt; bin1 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39; \u0026lt;\u0026lt; bin2 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; std::bitset\u0026lt;4\u0026gt;{ 0b1010 } \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // create a temporary std::bitset and print it return 0; } std::string 使用 std::getline() 输入文本 事实证明，当使用 operator\u0026raquo; 从 std::cin 中提取字符串时，operator\u0026raquo; 只返回它遇到的第一个空格之前的字符。任何其他字符都留在 std::cin 中，等待下一次提取\n要将整行输入读入字符串，最好改用 std::getline() 函数。 std::getline() 需要两个参数：第一个是 std::cin，第二个是您的字符串变量\n#include \u0026lt;string\u0026gt; // For std::string and std::getline #include \u0026lt;iostream\u0026gt; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Enter your full name: \u0026#34;; std::string name{}; std::getline(std::cin \u0026gt;\u0026gt; std::ws, name); // read a full line of text into name std::cout \u0026lt;\u0026lt; \u0026#34;Enter your age: \u0026#34;; std::string age{}; std::getline(std::cin \u0026gt;\u0026gt; std::ws, age); // read a full line of text into age std::cout \u0026lt;\u0026lt; \u0026#34;Your name is \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34; and your age is \u0026#34; \u0026lt;\u0026lt; age \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } std::ws 输入操纵器告诉 std::cin 在提取之前忽略任何前导空格。前导空白是出现在字符串开头的任何空白字符（空格、制表符、换行符）\n如果使用 std::getline() 读取字符串，请使用 std::cin \u0026gt;\u0026gt; std::ws 输入操纵器忽略前导空格\n将提取运算符 (\u0026raquo;) 与 std::cin 一起使用会忽略前导空格\nstd::getline() 不会忽略前导空格，除非您使用输入操纵器 std::ws\n字符串长度 如果我们想知道 std::string 中有多少个字符，我们可以向 std::string 对象询问它的长度。注意 std::string::length() 返回一个无符号整数值（很可能是 size_t 类型）。如果你想将长度分配给一个 int 变量，你应该对其进行 static_cast 以避免编译器关于有符号/无符号转换的警告：\nint length { static_cast\u0026lt;int\u0026gt;(name.length()) }; std::string 的初始化和复制开销很大 每当初始化 std::string 时，都会生成用于初始化它的字符串的副本。每当 std::string 按值传递给 std::string 参数时，都会生成另一个副本。不要按值传递 std::string，因为生成 std::string 的副本开销很大。更喜欢 std::string_view 参数\nLiterals for std::string \u0026amp; std::string_view 双引号字符串文字（比如“Hello, world!”）默认是 C 风格的字符串\n我们可以通过在双引号字符串文字后使用 s 后缀来创建类型为 std::string 的字符串文字\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; // for std::string #include \u0026lt;string_view\u0026gt; // for std::string_view int main() { using namespace std::literals; // easiest way to access the s and sv suffixes std::cout \u0026lt;\u0026lt; \u0026#34;foo\\n\u0026#34;; // no suffix is a C-style string literal std::cout \u0026lt;\u0026lt; \u0026#34;goo\\n\u0026#34;s; // s suffix is a std::string literal std::cout \u0026lt;\u0026lt; \u0026#34;moo\\n\u0026#34;sv; // sv suffix is a std::string_view literal return 0; } “s”后缀位于命名空间 std::literals::string_literals 中。“sv”后缀位于命名空间 std::literals::string_view_literals 中。访问文字后缀的最简单方法是通过使用指令使用命名空间 std::literals。这是可以使用整个命名空间的例外情况之一，因为其中定义的后缀不太可能与您的任何代码冲突\n你可能不需要经常使用 std::string 文字（因为用 C 风格的字符串文字初始化 std::string 对象很好），但我们会在以后的课程中看到一些使用 std 的情况::string literals 而不是 C 风格的 string literals 使事情变得更容易\nConstexpr 字符串 如果您尝试定义一个 constexpr std::string，您的编译器可能会产生一个错误\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std::literals; int main() { constexpr std::string name{ \u0026#34;Alex\u0026#34;s }; // compile error std::cout \u0026lt;\u0026lt; \u0026#34;My name is: \u0026#34; \u0026lt;\u0026lt; name; return 0; } 发生这种情况是因为 constexpr std::string 在 C++17 或更早版本中不受支持，并且在 C++20 中仅提供最低限度的支持。如果您需要 constexpr 字符串，请改用 std::string_view\nstd::string_view std::string_view C++17 为了解决 std::string 初始化（或复制）成本高昂的问题，C++17 引入了 std::string_view（位于 \u0026lt;string_view\u0026gt; 标头中）。 std::string_view 提供对现有字符串（C 风格字符串文字、std::string 或 char 数组）的只读访问，而无需制作副本\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string_view\u0026gt; void printSV(std::string_view str) // now a std::string_view { std::cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { std::string_view s{ \u0026#34;Hello, world!\u0026#34; }; // now a std::string_view printSV(s); return 0; } 当我们用 C 风格的字符串文字“Hello, world!”初始化 std::string_view s 时，s 提供对“Hello, world!”的只读访问。无需复制字符串。当我们将 s 传递给 printSV() 时，参数 str 从 s 初始化。这使我们能够通过 str 访问“Hello, world!”，不用再次复制字符串\n当您需要只读字符串时，尤其是对于函数参数，优先使用 std::string_view 而不是 std::string\nconstexpr std::string_view std::string_view 完全支持 constexpr：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string_view\u0026gt; int main() { constexpr std::string_view s{ \u0026#34;Hello, world!\u0026#34; }; std::cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // s will be replaced with \u0026#34;Hello, world!\u0026#34; at compile-time return 0; } std::string \u0026amp; std::string_view 可以使用 std::string 初始值设定项创建 std::string_view，并且 std::string 将隐式转换为 std::string_view：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;string_view\u0026gt; void printSV(std::string_view str) { std::cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { std::string s{ \u0026#34;Hello, world\u0026#34; }; std::string_view sv{ s }; // Initialize a std::string_view from a std::string std::cout \u0026lt;\u0026lt; sv \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; printSV(s); // implicitly convert a std::string to std::string_view return 0; } 因为 std::string 复制了它的初始化器（这开销很大），C++ 不允许将 std::string_view 隐式转换为 std::string。但是，我们可以使用 std::string_view 初始值设定项显式创建 std::string，或者我们可以使用 static_cast 将现有的 std::string_view 转换为 std::string\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;string_view\u0026gt; void printString(std::string str) { std::cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { std::string_view sv{ \u0026#34;balloon\u0026#34; }; std::string str{ sv }; // okay, we can create std::string using std::string_view initializer // printString(sv); // compile error: won\u0026#39;t implicitly convert std::string_view to a std::string printString(static_cast\u0026lt;std::string\u0026gt;(sv)); // okay, we can explicitly cast a std::string_view to a std::string return 0; } Operators（操作符） , \u0026amp; ? : 运算符 C++ 没有定义函数参数或运算符操作数的计算顺序\n不要在给定语句中多次使用具有副作用的变量。如果这样做，结果可能是未定义的\n逗号在所有运算符中的优先级最低，甚至低于赋值\n请注意， ? : 运算符的优先级非常低。如果除了将结果分配给变量之外做任何事情，整个 ? : 运算符也需要用括号括起来\nstd::cout \u0026lt;\u0026lt; ((x \u0026gt; y) ? x : y) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 如果在上述情况下我们不将整个条件运算符括起来会发生什么。因为 \u0026laquo; 运算符的优先级高于 ?: 运算符，所以语句：\nstd::cout \u0026lt;\u0026lt; (x \u0026gt; y) ? x : y \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 将评估为：\n(std::cout \u0026lt;\u0026lt; (x \u0026gt; y)) ? x : y \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 比较浮点数大小 进行浮点相等的最常见方法涉及使用一个函数来查看两个数字是否几乎相同。如果它们“足够接近”，那么我们称它们相等。用于表示“足够接近”的值传统上称为 epsilon。 Epsilon 通常被定义为一个小的正数（例如 0.00000001，有时写作 1e-8）\n#include \u0026lt;cmath\u0026gt; // for std::abs() // epsilon is an absolute value bool approximatelyEqualAbs(double a, double b, double absEpsilon) { // if the distance between a and b is less than absEpsilon, then a and b are \u0026#34;close enough\u0026#34; return std::abs(a - b) \u0026lt;= absEpsilon; } 虽然这个功能可以工作，但不是很好。 0.00001 的 epsilon 适用于 1.0 左右的输入，对于 0.0000001 左右的输入太大，对于 10,000 这样的输入太小\n著名计算机科学家唐纳德·高德纳 (Donald Knuth) 在他的著作“计算机编程的艺术，第二卷：半数值算法 (Addison-Wesley, 1969)”一书中提出了以下方法：\n#include \u0026lt;algorithm\u0026gt; // std::max #include \u0026lt;cmath\u0026gt; // std::abs // return true if the difference between a and b is within epsilon percent of the larger of a and b bool approximatelyEqualRel(double a, double b, double relEpsilon) { return (std::abs(a - b) \u0026lt;= (std::max(std::abs(a), std::abs(b)) * relEpsilon)); } 在这种情况下，epsilon 不是绝对数字，而是相对于 a 或 b 的大小。在 \u0026lt;= 运算符的左侧，std::abs(a - b) 告诉我们 a 和 b 之间的距离为正数。在 \u0026lt;= 运算符的右侧，我们需要计算我们愿意接受的“足够接近”的最大值。为此，该算法选择 a 和 b 中较大的一个（作为数字总体大小的粗略指标），然后将其乘以 relEpsilon。在此函数中，relEpsilon 表示百分比。例如，如果我们想说“足够接近”意味着 a 和 b 在 a 和 b 中较大者的 1% 以内，我们传入 0.01 (1% = 1/100 = 0.01) 的 relEpsilon。 relEpsilon 的值可以根据情况调整为最合适的值（例如，0.002 的 epsilon 表示在 0.2% 以内）\n要执行不等式 (!=) 而不是相等，只需调用此函数并使用逻辑 NOT 运算符 (!) 翻转结果：\nif (!approximatelyEqualRel(a, b, 0.001)) std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; is not equal to \u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; 虽然 approximatelyEqualRel() 函数适用于大多数情况，但它并不完美，尤其是当数字接近零时：\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;iostream\u0026gt; // return true if the difference between a and b is within epsilon percent of the larger of a and b bool approximatelyEqualRel(double a, double b, double relEpsilon) { return (std::abs(a - b) \u0026lt;= (std::max(std::abs(a), std::abs(b)) * relEpsilon)); } int main() { // a is really close to 1.0, but has rounding errors, so it\u0026#39;s slightly smaller than 1.0 double a{ 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 }; // First, let\u0026#39;s compare a (almost 1.0) to 1.0. std::cout \u0026lt;\u0026lt; approximatelyEqualRel(a, 1.0, 1e-8) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // Second, let\u0026#39;s compare a-1.0 (almost 0.0) to 0.0 std::cout \u0026lt;\u0026lt; approximatelyEqualRel(a-1.0, 0.0, 1e-8) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 这会返回：\n1 0 避免这种情况的一种方法是同时使用绝对 epsilon（如我们在第一种方法中所做的）和相对 epsilon（如我们在 Knuth 的方法中所做的）：\n// return true if the difference between a and b is less than absEpsilon, or within relEpsilon percent of the larger of a and b bool approximatelyEqualAbsRel(double a, double b, double absEpsilon, double relEpsilon) { // Check if the numbers are really close -- needed when comparing numbers near zero. double diff{ std::abs(a - b) }; if (diff \u0026lt;= absEpsilon) return true; // Otherwise fall back to Knuth\u0026#39;s algorithm return (diff \u0026lt;= (std::max(std::abs(a), std::abs(b)) * relEpsilon)); } 在这个算法中，我们首先检查 a 和 b 在绝对值上是否接近，这处理了 a 和 b 都接近于零的情况。 absEpsilon 参数应设置为非常小的值（例如 1e-12）。如果失败，则我们使用相对 epsilon 回退到 Knuth 的算法\n浮点数的比较是一个困难的话题，并且没有适用于所有情况的“一刀切”算法。但是，absEpsilon 为 1e-12 和 relEpsilon 为 1e-8 的 approximatesEqualAbsRel() 应该足以处理您将遇到的大多数情况\n逻辑 XOR 运算符 C++ 不提供逻辑 XOR 运算符。与逻辑或或逻辑与不同，逻辑异或不能进行短路评估。因此，从逻辑 OR 和逻辑 AND 运算符中创建逻辑 XOR 运算符具有挑战性。但是，您可以使用不等运算符 (!=) 轻松模拟逻辑 XOR：\nif (a != b) ... // a XOR b, assuming a and b are Booleans 这可以扩展到多个操作数，如下所示：\nif (a != b != c != d) ... // a XOR b XOR c XOR d, assuming a, b, c, and d are Booleans 请注意，上述 XOR 模式仅在操作数为布尔值（而非整数）时才有效。如果您需要一种适用于非布尔操作数的逻辑 XOR 形式，您可以将它们静态转换为布尔值：\nif (static_cast\u0026lt;bool\u0026gt;(a) != static_cast\u0026lt;bool\u0026gt;(b) != static_cast\u0026lt;bool\u0026gt;(c) != static_cast\u0026lt;bool\u0026gt;(d)) ... // a XOR b XOR c XOR d, for any type that can be converted to bool 位操作 位标志 and 位操作 via std::bitset 要定义一组位标志，我们通常会使用适当大小的无符号整数（8 位、16 位、32 位等……取决于我们有多少标志），或 std::bitset\n#include \u0026lt;bitset\u0026gt; // for std::bitset std::bitset\u0026lt;8\u0026gt; mybitset {}; // 8 bits in size means room for 8 flags 位操作是您应该明确使用无符号整数（或 std::bitset）的少数情况之一\nstd::bitset 提供了 4 个可用于位操作的关键函数：\ntest() 允许我们查询某个位是 0 还是 1 set() 允许我们打开一个位（如果位已经打开，这将不执行任何操作） reset() 允许我们关闭一个位（如果该位已经关闭，这将不执行任何操作） flip() 允许我们将位值从 0 翻转为 1，反之亦然 这些函数中的每一个都将我们要操作的位的位置作为它们唯一的参数\n#include \u0026lt;bitset\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { std::bitset\u0026lt;8\u0026gt; bits{ 0b0000\u0026#39;0101 }; // we need 8 bits, start with bit pattern 0000 0101 bits.set(3); // set bit position 3 to 1 (now we have 0000 1101) bits.flip(4); // flip bit 4 (now we have 0001 1101) bits.reset(4); // set bit 4 back to 0 (now we have 0000 1101) std::cout \u0026lt;\u0026lt; \u0026#34;All the bits: \u0026#34; \u0026lt;\u0026lt; bits \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;Bit 3 has value: \u0026#34; \u0026lt;\u0026lt; bits.test(3) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;Bit 4 has value: \u0026#34; \u0026lt;\u0026lt; bits.test(4) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 按位运算符 为避免意外，请使用无符号操作数或 std::bitset 的按位运算符\n在计算按位 XOR 时，如果一列中有奇数个 1 位，则该列的结果为 1\n位掩码 位掩码是一组预定义的位，用于选择哪些特定位将被后续操作修改。位掩码阻止按位运算符接触我们不想修改的位，并允许访问我们确实想要修改的位\n最简单的一组位掩码是为每个位位置定义一个位掩码。我们用 0 来屏蔽我们不关心的位，用 1 来表示我们想要修改的位\n尽管位掩码可以是文字，但它们通常被定义为符号常量，因此可以为它们指定一个有意义的名称并易于重用\n在 C++14 中定义位掩码 因为 C++14 支持二进制文字，所以定义这些位掩码很容易：\n#include \u0026lt;cstdint\u0026gt; constexpr std::uint8_t mask0{ 0b0000\u0026#39;0001 }; // represents bit 0 constexpr std::uint8_t mask1{ 0b0000\u0026#39;0010 }; // represents bit 1 constexpr std::uint8_t mask2{ 0b0000\u0026#39;0100 }; // represents bit 2 constexpr std::uint8_t mask3{ 0b0000\u0026#39;1000 }; // represents bit 3 constexpr std::uint8_t mask4{ 0b0001\u0026#39;0000 }; // represents bit 4 constexpr std::uint8_t mask5{ 0b0010\u0026#39;0000 }; // represents bit 5 constexpr std::uint8_t mask6{ 0b0100\u0026#39;0000 }; // represents bit 6 constexpr std::uint8_t mask7{ 0b1000\u0026#39;0000 }; // represents bit 7 在 C++11 或更早版本中定义位掩码 由于 C++11 不支持二进制文字，我们必须使用其他方法来设置符号常量\n第一种方法是使用十六进制文字：\nconstexpr std::uint8_t mask0{ 0x01 }; // hex for 0000 0001 constexpr std::uint8_t mask1{ 0x02 }; // hex for 0000 0010 constexpr std::uint8_t mask2{ 0x04 }; // hex for 0000 0100 constexpr std::uint8_t mask3{ 0x08 }; // hex for 0000 1000 constexpr std::uint8_t mask4{ 0x10 }; // hex for 0001 0000 constexpr std::uint8_t mask5{ 0x20 }; // hex for 0010 0000 constexpr std::uint8_t mask6{ 0x40 }; // hex for 0100 0000 constexpr std::uint8_t mask7{ 0x80 }; // hex for 1000 0000 另一种更简单的方法是使用左移运算符将一位移动到正确的位置：\nconstexpr std::uint8_t mask0{ 1 \u0026lt;\u0026lt; 0 }; // 0000 0001 constexpr std::uint8_t mask1{ 1 \u0026lt;\u0026lt; 1 }; // 0000 0010 constexpr std::uint8_t mask2{ 1 \u0026lt;\u0026lt; 2 }; // 0000 0100 constexpr std::uint8_t mask3{ 1 \u0026lt;\u0026lt; 3 }; // 0000 1000 constexpr std::uint8_t mask4{ 1 \u0026lt;\u0026lt; 4 }; // 0001 0000 constexpr std::uint8_t mask5{ 1 \u0026lt;\u0026lt; 5 }; // 0010 0000 constexpr std::uint8_t mask6{ 1 \u0026lt;\u0026lt; 6 }; // 0100 0000 constexpr std::uint8_t mask7{ 1 \u0026lt;\u0026lt; 7 }; // 1000 0000 Testing a bit 要确定某个位是开还是关，我们使用 \u0026amp; 结合相应位的位掩码：\n#include \u0026lt;cstdint\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { constexpr std::uint8_t mask0{ 0b0000\u0026#39;0001 }; // represents bit 0 constexpr std::uint8_t mask1{ 0b0000\u0026#39;0010 }; // represents bit 1 constexpr std::uint8_t mask2{ 0b0000\u0026#39;0100 }; // represents bit 2 constexpr std::uint8_t mask3{ 0b0000\u0026#39;1000 }; // represents bit 3 constexpr std::uint8_t mask4{ 0b0001\u0026#39;0000 }; // represents bit 4 constexpr std::uint8_t mask5{ 0b0010\u0026#39;0000 }; // represents bit 5 constexpr std::uint8_t mask6{ 0b0100\u0026#39;0000 }; // represents bit 6 constexpr std::uint8_t mask7{ 0b1000\u0026#39;0000 }; // represents bit 7 std::uint8_t flags{ 0b0000\u0026#39;0101 }; // 8 bits in size means room for 8 flags std::cout \u0026lt;\u0026lt; \u0026#34;bit 0 is \u0026#34; \u0026lt;\u0026lt; ((flags \u0026amp; mask0) ? \u0026#34;on\\n\u0026#34; : \u0026#34;off\\n\u0026#34;); std::cout \u0026lt;\u0026lt; \u0026#34;bit 1 is \u0026#34; \u0026lt;\u0026lt; ((flags \u0026amp; mask1) ? \u0026#34;on\\n\u0026#34; : \u0026#34;off\\n\u0026#34;); return 0; } Setting a bit 要设置（打开）位，我们将按位或等于（运算符 |=）与相应位的位掩码结合使用：\n#include \u0026lt;cstdint\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { constexpr std::uint8_t mask0{ 0b0000\u0026#39;0001 }; // represents bit 0 constexpr std::uint8_t mask1{ 0b0000\u0026#39;0010 }; // represents bit 1 constexpr std::uint8_t mask2{ 0b0000\u0026#39;0100 }; // represents bit 2 constexpr std::uint8_t mask3{ 0b0000\u0026#39;1000 }; // represents bit 3 constexpr std::uint8_t mask4{ 0b0001\u0026#39;0000 }; // represents bit 4 constexpr std::uint8_t mask5{ 0b0010\u0026#39;0000 }; // represents bit 5 constexpr std::uint8_t mask6{ 0b0100\u0026#39;0000 }; // represents bit 6 constexpr std::uint8_t mask7{ 0b1000\u0026#39;0000 }; // represents bit 7 std::uint8_t flags{ 0b0000\u0026#39;0101 }; // 8 bits in size means room for 8 flags std::cout \u0026lt;\u0026lt; \u0026#34;bit 1 is \u0026#34; \u0026lt;\u0026lt; ((flags \u0026amp; mask1) ? \u0026#34;on\\n\u0026#34; : \u0026#34;off\\n\u0026#34;); flags |= mask1; // turn on bit 1 std::cout \u0026lt;\u0026lt; \u0026#34;bit 1 is \u0026#34; \u0026lt;\u0026lt; ((flags \u0026amp; mask1) ? \u0026#34;on\\n\u0026#34; : \u0026#34;off\\n\u0026#34;); return 0; } 我们还可以使用按位或同时打开多个位：\nflags |= (mask4 | mask5); // turn bits 4 and 5 on at the same time Resetting a bit 要清除位（关闭），我们同时使用 \u0026amp;= 和 ~ ：\n#include \u0026lt;cstdint\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { constexpr std::uint8_t mask0{ 0b0000\u0026#39;0001 }; // represents bit 0 constexpr std::uint8_t mask1{ 0b0000\u0026#39;0010 }; // represents bit 1 constexpr std::uint8_t mask2{ 0b0000\u0026#39;0100 }; // represents bit 2 constexpr std::uint8_t mask3{ 0b0000\u0026#39;1000 }; // represents bit 3 constexpr std::uint8_t mask4{ 0b0001\u0026#39;0000 }; // represents bit 4 constexpr std::uint8_t mask5{ 0b0010\u0026#39;0000 }; // represents bit 5 constexpr std::uint8_t mask6{ 0b0100\u0026#39;0000 }; // represents bit 6 constexpr std::uint8_t mask7{ 0b1000\u0026#39;0000 }; // represents bit 7 std::uint8_t flags{ 0b0000\u0026#39;0101 }; // 8 bits in size means room for 8 flags std::cout \u0026lt;\u0026lt; \u0026#34;bit 2 is \u0026#34; \u0026lt;\u0026lt; ((flags \u0026amp; mask2) ? \u0026#34;on\\n\u0026#34; : \u0026#34;off\\n\u0026#34;); flags \u0026amp;= ~mask2; // turn off bit 2 std::cout \u0026lt;\u0026lt; \u0026#34;bit 2 is \u0026#34; \u0026lt;\u0026lt; ((flags \u0026amp; mask2) ? \u0026#34;on\\n\u0026#34; : \u0026#34;off\\n\u0026#34;); return 0; } 我们可以同时关闭多个位：\nflags \u0026amp;= ~(mask4 | mask5); // turn bits 4 and 5 off at the same time Flipping a bit 要切换位状态，我们使用 ^=：\n#include \u0026lt;cstdint\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { constexpr std::uint8_t mask0{ 0b0000\u0026#39;0001 }; // represents bit 0 constexpr std::uint8_t mask1{ 0b0000\u0026#39;0010 }; // represents bit 1 constexpr std::uint8_t mask2{ 0b0000\u0026#39;0100 }; // represents bit 2 constexpr std::uint8_t mask3{ 0b0000\u0026#39;1000 }; // represents bit 3 constexpr std::uint8_t mask4{ 0b0001\u0026#39;0000 }; // represents bit 4 constexpr std::uint8_t mask5{ 0b0010\u0026#39;0000 }; // represents bit 5 constexpr std::uint8_t mask6{ 0b0100\u0026#39;0000 }; // represents bit 6 constexpr std::uint8_t mask7{ 0b1000\u0026#39;0000 }; // represents bit 7 std::uint8_t flags{ 0b0000\u0026#39;0101 }; // 8 bits in size means room for 8 flags std::cout \u0026lt;\u0026lt; \u0026#34;bit 2 is \u0026#34; \u0026lt;\u0026lt; ((flags \u0026amp; mask2) ? \u0026#34;on\\n\u0026#34; : \u0026#34;off\\n\u0026#34;); flags ^= mask2; // flip bit 2 std::cout \u0026lt;\u0026lt; \u0026#34;bit 2 is \u0026#34; \u0026lt;\u0026lt; ((flags \u0026amp; mask2) ? \u0026#34;on\\n\u0026#34; : \u0026#34;off\\n\u0026#34;); flags ^= mask2; // flip bit 2 std::cout \u0026lt;\u0026lt; \u0026#34;bit 2 is \u0026#34; \u0026lt;\u0026lt; ((flags \u0026amp; mask2) ? \u0026#34;on\\n\u0026#34; : \u0026#34;off\\n\u0026#34;); return 0; } 我们可以同时翻转多个位：\nflags ^= (mask4 | mask5); // flip bits 4 and 5 at the same time 位掩码和 std::bitset std::bitset 支持全套位运算符。因此，尽管使用函数（测试、设置、重置和翻转）修改单个位更容易，但如果需要，您可以使用按位运算符和位掩码\n函数只允许您一次修改单个位。按位运算符允许您一次修改多个位\n#include \u0026lt;cstdint\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;bitset\u0026gt; int main() { constexpr std::bitset\u0026lt;8\u0026gt; mask0{ 0b0000\u0026#39;0001 }; // represents bit 0 constexpr std::bitset\u0026lt;8\u0026gt; mask1{ 0b0000\u0026#39;0010 }; // represents bit 1 constexpr std::bitset\u0026lt;8\u0026gt; mask2{ 0b0000\u0026#39;0100 }; // represents bit 2 constexpr std::bitset\u0026lt;8\u0026gt; mask3{ 0b0000\u0026#39;1000 }; // represents bit 3 constexpr std::bitset\u0026lt;8\u0026gt; mask4{ 0b0001\u0026#39;0000 }; // represents bit 4 constexpr std::bitset\u0026lt;8\u0026gt; mask5{ 0b0010\u0026#39;0000 }; // represents bit 5 constexpr std::bitset\u0026lt;8\u0026gt; mask6{ 0b0100\u0026#39;0000 }; // represents bit 6 constexpr std::bitset\u0026lt;8\u0026gt; mask7{ 0b1000\u0026#39;0000 }; // represents bit 7 std::bitset\u0026lt;8\u0026gt; flags{ 0b0000\u0026#39;0101 }; // 8 bits in size means room for 8 flags std::cout \u0026lt;\u0026lt; \u0026#34;bit 1 is \u0026#34; \u0026lt;\u0026lt; (flags.test(1) ? \u0026#34;on\\n\u0026#34; : \u0026#34;off\\n\u0026#34;); std::cout \u0026lt;\u0026lt; \u0026#34;bit 2 is \u0026#34; \u0026lt;\u0026lt; (flags.test(2) ? \u0026#34;on\\n\u0026#34; : \u0026#34;off\\n\u0026#34;); flags ^= (mask1 | mask2); // flip bits 1 and 2 std::cout \u0026lt;\u0026lt; \u0026#34;bit 1 is \u0026#34; \u0026lt;\u0026lt; (flags.test(1) ? \u0026#34;on\\n\u0026#34; : \u0026#34;off\\n\u0026#34;); std::cout \u0026lt;\u0026lt; \u0026#34;bit 2 is \u0026#34; \u0026lt;\u0026lt; (flags.test(2) ? \u0026#34;on\\n\u0026#34; : \u0026#34;off\\n\u0026#34;); flags |= (mask1 | mask2); // turn bits 1 and 2 on std::cout \u0026lt;\u0026lt; \u0026#34;bit 1 is \u0026#34; \u0026lt;\u0026lt; (flags.test(1) ? \u0026#34;on\\n\u0026#34; : \u0026#34;off\\n\u0026#34;); std::cout \u0026lt;\u0026lt; \u0026#34;bit 2 is \u0026#34; \u0026lt;\u0026lt; (flags.test(2) ? \u0026#34;on\\n\u0026#34; : \u0026#34;off\\n\u0026#34;); flags \u0026amp;= ~(mask1 | mask2); // turn bits 1 and 2 off std::cout \u0026lt;\u0026lt; \u0026#34;bit 1 is \u0026#34; \u0026lt;\u0026lt; (flags.test(1) ? \u0026#34;on\\n\u0026#34; : \u0026#34;off\\n\u0026#34;); std::cout \u0026lt;\u0026lt; \u0026#34;bit 2 is \u0026#34; \u0026lt;\u0026lt; (flags.test(2) ? \u0026#34;on\\n\u0026#34; : \u0026#34;off\\n\u0026#34;); return 0; } Summary query bit states if (flags \u0026amp; option4) ... // if option4 is set, do something set bits (turn on) flags |= option4; // turn option 4 on. flags |= (option4 | option5); // turn options 4 and 5 on. clear bits (turn off) flags \u0026amp;= ~option4; // turn option 4 off flags \u0026amp;= ~(option4 | option5); // turn options 4 and 5 off flip bit states flags ^= option4; // flip option4 from on to off, or vice versa flags ^= (option4 | option5); // flip options 4 and 5 运算符重载 何时使用普通函数、友元函数或成员函数重载运算符 在处理不修改左操作数的二元运算符（例如 operator+）时，通常首选普通或友元函数版本，因为它适用于所有参数类型（即使左操作数不是类对象，或者是一个不可修改的类）。普通或友元函数版本具有“对称”的额外好处，因为所有操作数都成为显式参数（而不是左操作数成为 *this 而右操作数成为显式参数） 在处理确实修改左操作数的二元运算符时（例如 operator+=），通常首选成员函数版本。在这些情况下，最左边的操作数将始终是类类型，并且让被修改的对象成为 *this 指向的对象是很自然的。因为最右边的操作数成为一个显式参数，所以不会混淆谁正在修改和谁正在评估 一元运算符通常也作为成员函数重载，因为成员函数版本没有参数 以下经验法则可以帮助您确定哪种形式最适合给定情况： 如果要重载赋值 (=)、下标 ([])、函数调用 (()) 或成员选择 (-\u0026gt;)，请将其作为成员函数进行重载 如果要重载一元运算符，请将其作为成员函数 如果要重载不修改其左操作数的二元运算符（例如 operator+），请将其作为普通函数（首选）或友元函数 如果您正在重载修改其左操作数的二元运算符，但您不能将成员添加到左操作数的类定义中（例如，operator\u0026laquo;，它有一个 ostream 类型的左操作数），请像往常一样这样做函数（首选）或友元函数 如果您正在重载修改其左操作数的二元运算符（例如 operator+=），并且您可以修改左操作数的定义，请将其作为成员函数进行 最小化比较冗余 也就是说我们只需要实现operator==和operator\u0026lt;的逻辑，其他四个比较运算符就可以根据这两个来定义了！这是一个更新的 Cents 示例，说明了这一点：\n#include \u0026lt;iostream\u0026gt; class Cents { private: int m_cents; public: Cents(int cents) : m_cents{ cents } {} friend bool operator== (const Cents\u0026amp; c1, const Cents\u0026amp; c2) { return c1.m_cents == c2.m_cents; }; friend bool operator!= (const Cents\u0026amp; c1, const Cents\u0026amp; c2) { return !(operator==(c1, c2)); }; friend bool operator\u0026lt; (const Cents\u0026amp; c1, const Cents\u0026amp; c2) { return c1.m_cents \u0026lt; c2.m_cents; }; friend bool operator\u0026gt; (const Cents\u0026amp; c1, const Cents\u0026amp; c2) { return operator\u0026lt;(c2, c1); }; friend bool operator\u0026lt;= (const Cents\u0026amp; c1, const Cents\u0026amp; c2) { return !(operator\u0026gt;(c1, c2)); }; friend bool operator\u0026gt;= (const Cents\u0026amp; c1, const Cents\u0026amp; c2) { return !(operator\u0026lt;(c1, c2)); }; }; int main() { Cents dime{ 10 }; Cents nickel{ 5 }; if (nickel \u0026gt; dime) std::cout \u0026lt;\u0026lt; \u0026#34;a nickel is greater than a dime.\\n\u0026#34;; if (nickel \u0026gt;= dime) std::cout \u0026lt;\u0026lt; \u0026#34;a nickel is greater than or equal to a dime.\\n\u0026#34;; if (nickel \u0026lt; dime) std::cout \u0026lt;\u0026lt; \u0026#34;a dime is greater than a nickel.\\n\u0026#34;; if (nickel \u0026lt;= dime) std::cout \u0026lt;\u0026lt; \u0026#34;a dime is greater than or equal to a nickel.\\n\u0026#34;; if (nickel == dime) std::cout \u0026lt;\u0026lt; \u0026#34;a dime is equal to a nickel.\\n\u0026#34;; if (nickel != dime) std::cout \u0026lt;\u0026lt; \u0026#34;a dime is not equal to a nickel.\\n\u0026#34;; return 0; } 这样，如果我们需要更改某些内容，我们只需要更新 operator== 和 operator\u0026lt; 而不是所有六个比较运算符！\n浅拷贝与深拷贝 编译器提供的默认复制构造函数和默认赋值运算符如下所示：\n#include \u0026lt;cassert\u0026gt; #include \u0026lt;iostream\u0026gt; class Fraction { private: int m_numerator { 0 }; int m_denominator { 1 }; public: // Default constructor Fraction(int numerator = 0, int denominator = 1) : m_numerator{ numerator } , m_denominator{ denominator } { assert(denominator != 0); } // Possible implementation of implicit copy constructor Fraction(const Fraction\u0026amp; f) : m_numerator{ f.m_numerator } , m_denominator{ f.m_denominator } { } // Possible implementation of implicit assignment operator Fraction\u0026amp; operator= (const Fraction\u0026amp; fraction) { // self-assignment guard if (this == \u0026amp;fraction) return *this; // do the copy m_numerator = fraction.m_numerator; m_denominator = fraction.m_denominator; // return the existing object so we can chain this operator return *this; } friend std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; out, const Fraction\u0026amp; f1) { out \u0026lt;\u0026lt; f1.m_numerator \u0026lt;\u0026lt; \u0026#39;/\u0026#39; \u0026lt;\u0026lt; f1.m_denominator; return out; } }; 请注意，因为这些默认版本可以很好地复制此类，所以在这种情况下真的没有理由编写我们自己的这些函数版本\n然而，在设计处理动态分配内存的类时，成员（浅）复制会给我们带来很多麻烦！这是因为指针的浅拷贝只是复制指针的地址——它不分配任何内存或复制指向的内容！\n深拷贝为副本分配内存，然后复制实际值，以便副本位于与源不同的内存中。这样，副本和来源是截然不同的，不会以任何方式相互影响。进行深度复制需要我们编写自己的复制构造函数和重载赋值运算符。\n默认复制构造函数和默认赋值运算符执行浅拷贝，这适用于不包含动态分配变量的类。\n具有动态分配变量的类需要有一个复制构造函数和赋值运算符来执行深复制。\n喜欢使用标准库中的类而不是自己进行内存管理。\n深拷贝为副本分配内存，然后复制实际值，以便副本位于与源不同的内存中。这样，副本和来源是截然不同的，不会以任何方式相互影响。进行深度复制需要我们编写自己的复制构造函数和重载赋值运算符。\n// assumes m_data is initialized void MyString::deepCopy(const MyString\u0026amp; source) { // first we need to deallocate any value that this string is holding! delete[] m_data; // because m_length is not a pointer, we can shallow copy it m_length = source.m_length; // m_data is a pointer, so we need to deep copy it if it is non-null if (source.m_data) { // allocate memory for our copy m_data = new char[m_length]; // do the copy for (int i{ 0 }; i \u0026lt; m_length; ++i) m_data[i] = source.m_data[i]; } else m_data = nullptr; } // Copy constructor MyString::MyString(const MyString\u0026amp; source) { deepCopy(source); } 这比简单的浅拷贝要复杂得多！\n现在让我们做重载的赋值运算符。重载的赋值运算符有点棘手：\n// Assignment operator MyString\u0026amp; MyString::operator=(const MyString\u0026amp; source) { // check for self-assignment if (this != \u0026amp;source) { // now do the deep copy deepCopy(source); } return *this; } 输出不是直接写入的，它存储在缓冲区中，直到缓冲区被刷新。输出到文件或终端历来很慢（终端或控制台仍然很慢），逐个字符地写入是低效率的，写入一大块字节要有效得多。若 cerr 被缓冲，那么如果程序以非正常方式崩溃，您可能会将有用的调试信息卡在缓冲区中，而不是打印到 stderr。stdout 是行缓冲的，即在您编写换行符或显式刷新缓冲区之前，输出不会发送到操作系统。通常，std::endl 函数通过插入换行符并刷新流来工作。读取 stdcin 会刷新 stdcout\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://xancoding.cn/posts/2022-11-15-12-54-07/","summary":"推荐阅读 【中英字幕】C++ | The Cherno C++标准 11-14 | 侯捷 C++ STL标准库和 C++ 泛型编程 | 侯捷 https://www.learncpp.com/ 学习网站，非常全面系统的介绍了 C++ 相关知识，从编译器使用到","title":"C++ 学习路线"},{"content":" 《鸟哥的Linux私房菜》 《TCP/IP网络编程》 《Linux高性能服务器编程》 《UNIX环境高级编程》 《Unix网络编程》 \u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e ","permalink":"https://xancoding.cn/posts/2022-11-15-12-50-59/","summary":"《鸟哥的Linux私房菜》 《TCP/IP网络编程》 《Linux高性能服务器编程》 《UNIX环境高级编程》 《Unix网络编程》 \u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e","title":"Linux 网络编程"},{"content":" 计算机科学速成 [40 集全/精校] - Crash Course Computer Science 王道计算机考研 计算机组成原理 计算机组成原理（哈工大刘宏伟）135讲（全）高清 【精校中英字幕】2015 CMU 15-213 CSAPP 深入理解计算机系统 《程序是怎样跑起来的》 《计算机是怎样跑起来的》 《计算机组成与设计硬件/软件接口》 指令格式是 RISC 的 第一章：计算机抽象以及相关技术，这个章节主要是介绍了计算机组成的思想，可以简单快读看，不用重点读 第二章：指令，大体上讲的是计算机是如果识别和运行指令的，以及代码到指令的过程 第三章：计算机的算数运算，介绍的是计算机是如何进行加减乘除法的，以及浮点数的运算 第五章：层次化存储，讲的是计算机的存储层次结构，而且重点讲的是 CPU Cahe 《深入理解计算机系统（原书第3版）》CSAPP 指令格式是 x86 的 计算机组成 + 操作系统 + 汇编 + C语言 + Linux系统编程 \u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e ","permalink":"https://xancoding.cn/posts/2022-11-15-12-47-32/","summary":"计算机科学速成 [40 集全/精校] - Crash Course Computer Science 王道计算机考研 计算机组成原理 计算机组成原理（哈工大刘宏伟）135讲（全）高清 【精校中英字幕】2015 CMU","title":"计算机组成原理"},{"content":" 哈工大数据库系统 【尚硅谷】Redis MySQL 《MySQL必知必会》 《MySQL 是怎么运行的：从根儿上理解 MySQL》 《MySQL技术内幕：InnoDB存储引擎》 \u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e Redis 《Redis设计与实现》 《Redis实战》 \u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e ","permalink":"https://xancoding.cn/posts/2022-11-15-12-38-04/","summary":"哈工大数据库系统 【尚硅谷】Redis MySQL 《MySQL必知必会》 《MySQL 是怎么运行的：从根儿上理解 MySQL》 《MySQL技术内幕：Inno","title":"数据库"},{"content":"链接 程序设计时 在这种情况下，我们将所有的源代码都放在一个文件中，例如 main.cpp：\n#include \u0026lt;iostream\u0026gt; int add(int a, int b) { return a + b; } int main() { int a = 1, b = 2; std::cout \u0026lt;\u0026lt; add(a, b) \u0026lt;\u0026lt; std::endl; return 0; } 在编译时，我们只需要编译这一个文件：\ng++ main.cpp -o program 这样就生成了可执行文件 program，可以直接运行。在这种情况下，所有的代码都在一个文件中，编译器可以直接看到所有的代码，进行必要的优化，生成更高效的代码。\n编译或汇编时 这种情况下，我们将程序拆分成多个源文件，并在编译或汇编时进行链接。例如，我们有两个源文件 add.cpp 和 main.cpp：\n// add.cpp int add(int a, int b) { return a + b; } // main.cpp #include \u0026lt;iostream\u0026gt; int add(int a, int b); int main() { int a = 1, b = 2; std::cout \u0026lt;\u0026lt; add(a, b) \u0026lt;\u0026lt; std::endl; return 0; } 在编译时，我们需要先将每个源文件编译成目标文件，然后再将它们链接在一起生成可执行文件。例如，我们可以这样编译和链接：\ng++ -c add.cpp -o add.o g++ -c main.cpp -o main.o g++ add.o main.o -o program 这样也会生成可执行文件 program。在这种情况下，编译器只能看到单个源文件中的代码，无法对整个程序进行优化，因此可能会生成一些冗余的代码。但是，由于目标文件已经生成，后续的编译速度会更快。\n加载时链接和运行时链接 加载时动态链接是指在可执行文件被加载到内存时，由系统动态链接器将可执行文件所依赖的共享库链接到进程的地址空间中。这样一来，可执行文件和共享库的代码和数据就可以在同一个地址空间中执行和访问。这种方式的优点是加载后不需要进行额外的链接操作，因此程序启动速度较快。缺点是如果共享库更新或者变更，需要重新编译和链接可执行文件。\n运行时动态链接是指在程序运行过程中，通过调用动态链接库（也称为共享库）的API函数，将共享库链接到进程的地址空间中。这样一来，程序可以在运行时根据需要动态地加载和卸载共享库。这种方式的优点是程序的灵活性和可维护性较高，但是在程序启动时需要进行额外的链接操作，因此启动速度相对较慢。\n在加载时动态链接中，程序在运行之前会链接所需要的 DLL 文件，并将 DLL 文件中的代码和数据加载到内存中。这种链接方式的好处是可以减小可执行文件的大小，同时多个程序可以共享同一个 DLL 文件，减少内存占用。缺点是如果所需的 DLL 文件不存在或者出现错误，程序将无法运行。\n在运行时动态链接中，程序在运行时使用特定的函数动态链接到 DLL 文件中的代码和数据。这种链接方式的好处是可以在运行时根据需要加载 DLL 文件，灵活性更高。缺点是每次调用 DLL 中的函数都需要进行链接，会带来一定的性能开销。\n记录型信号量 S：信号量的值。当其值大于 0 时，表示可供使用的资源数；当其值小于 0 时，其绝对值表示等待使用该资源的进程数 /* P 操作的定义 */ P(S) { S.value--; if (S.value \u0026lt; 0) { // 将该进程加到 S.list 队列 block(); } } /* V 操作的定义 */ V(S) { S.value++; if (S.value \u0026lt;= 0) { // 从 S.list 队列中将 Q 移走 wakeup(Q); } } 进程同步问题 生产者\u0026ndash;消费者 假设有一个缓冲区，生产者往其中生产数据，消费者从其中取出数据。生产者和消费者各有若干个，它们之间需要通过缓冲区进行数据交换。\n初始化信号量： empty：计数信号量，初始值为N，表示缓冲区空闲的数量。 full：计数信号量，初始值为0，表示缓冲区中已经存放的数据量。 mutex：互斥信号量，初始值为1，用于保护缓冲区的互斥访问。 生产者过程： while (true) { produce(item); // 生产数据 P(empty); // 等待空闲缓冲区 P(mutex); // 占用缓冲区 put(item); // 将数据放入缓冲区 V(mutex); // 释放缓冲区 V(full); // 增加缓冲区已有数据的数量 } 消费者过程： while (true) { P(full); // 等待有数据的缓冲区 P(mutex); // 占用缓冲区 item = get(); // 从缓冲区取出数据 V(mutex); // 释放缓冲区 V(empty); // 增加空闲缓冲区的数量 consume(item); // 消费数据 } 在这个过程中，P操作表示进程占用一个信号量资源，V操作表示进程释放一个信号量资源。对于互斥信号量mutex，每次只有一个进程可以占用资源，以保证缓冲区的互斥访问。对于计数信号量empty和full，它们都是等待队列，生产者和消费者通过占用和释放信号量来加入和离开等待队列。\n理发师问题 问题描述 一个理发店有一个理发师和若干个顾客。理发师可以理发，顾客可以等待理发或者离开。当顾客进入理发店时，如果理发师忙，顾客就等待。如果理发师闲着，顾客就可以马上得到理发。理发师理完一位顾客的头发后，会从等待区中选择一个顾客进行服务。\n问题的关键在于如何使理发师和顾客之间进行合理的协作，避免死锁和饥饿的问题。\n解决办法 经典的解决方法是使用信号量机制实现同步。定义以下信号量：\ncustomers：计数信号量，初始值为0，表示等待理发的顾客数量。 barber：互斥信号量，初始值为1，用于控制理发师的访问。 mutex：互斥信号量，初始值为1，用于保护customers计数信号量的互斥访问。 理发师过程：\nwhile (true) { P(customers); // 等待有顾客到来 P(mutex); // 占用顾客数量计数信号量 customer = dequeue(); // 从顾客队列中取出一个顾客 V(mutex); // 释放顾客数量计数信号量 cut_hair(customer); // 为顾客理发 V(barber); // 理发 顾客过程：\nwhile (true) { P(mutex); // 占用顾客数量计数信号量 if (customers \u0026lt; chairs) { // 如果有空椅子 enqueue(customer); // 排队等待理发 V(customers); // 增加等待的顾客数量 V(mutex); // 释放顾客数量计数信号量 P(barber); // 等待理发师空闲 get_haircut(customer); // 接受理发师的服务 } else { // 如果没有空椅子，离开 V(mutex); // 释放顾客数量计数信号量 leave(customer); // 离开理发店 } } 在这个过程中，P操作表示进程占用一个信号量资源，V操作表示进程释放一个信号量资源。对于互斥信号量barber和mutex，每次只有一个进程可以占用资源，以保证对理发师和顾客队列的互斥访问。对于计数信号量customers，它是一个等待队列，顾客通过占用和释放信号量来加入和离开等待队列，而理发师则通过占用和释放信号量来控制顾客的理发顺序。\n读者\u0026ndash;写者问题 问题描述 多个读者和写者共享一个资源，读者可以同时读取该资源，但写者进行写操作时需要独占该资源； 写者优先级高于读者，即当有写者等待时，不允许新的读者访问资源，直到所有写者完成写操作； 读写操作的互斥性，即在同一时刻只允许一个读写操作进行。 解决办法 wmutex：计数信号量，初始值为1，用于保护写操作的互斥访问。 rmutex：计数信号量，初始值为1，用于互斥访问 readcount。 readcount：整型变量，初始值为0，表示读者计数器 写者：\nwhile (true) { P(wmutex); // 请求写访问权 write_data(); // 写操作 V(wmutex); // 释放写访问权 } 读者：\nwhile (true) { P(rmutex); // 保证对计数器的互斥访问 readcount++; // 有一个读者进入临界区 if (readcount == 1) { // 如果是第一个读者 P(wmutex); // 请求写访问权，禁止写者同时写入 } V(rmutex); // 释放对计数器的访问 read_data(); // 读操作 P(rmutex); // 保证对计数器的互斥访问 readcount--; // 有一个读者离开临界区 if (readers == 0) { // 如果是最后一个读者 V(wmutex); // 释放写访问权 } V(rmutex); // 释放对计数器的访问 } 哲学家就餐问题 问题描述 在一个圆形餐桌上坐着N个哲学家，每个哲学家面前有一盘食物和一只叉子。这些哲学家只有在同时拿到自己面前的两个叉子时才能进食。每个哲学家都有两个邻居，因此有N个叉子。\n问题的关键在于如何使哲学家能够避免死锁和饥饿地进食。\n解决办法 解决哲学家就餐问题的一种常见方法是使用资源分级和时间限制。以下是一种解决方案：\n给每个叉子都分配一个编号，从1到N。 哲学家只有在同时拿到两个编号为i和(i+1)%N的叉子时才能吃饭。 为了避免死锁，可以采用两种方法之一： 方法一：将一个叉子的拿取和放下操作定义为原子性操作，采用信号量来实现同步。每个哲学家需要先尝试获取自己左右两个叉子的信号量，只有在同时获取到两个信号量时才能进食。在哲学家用完餐具后，释放这两个信号量，让其他哲学家能够使用这些餐具。 方法二：引入一个“服务员”线程，服务员维护一个计数器，记录当前使用餐具的数量。当哲学家需要进餐时，需要向服务员发出请求。服务员检查当前使用餐具的数量是否已经达到了N-1，如果是，则等待一段时间再重新检查，直到有餐具被释放出来。如果不是，则服务员将餐具分配给该哲学家。哲学家用完餐具后，将餐具归还给服务员。 需要注意的是，无论是哪种方法，都需要遵循以下两个原则：\n要确保每个哲学家都能获得进餐的机会，避免饥饿。 要确保所有哲学家都能进餐，而不会导致死锁。 图书馆阅览室问题 问题描述 假定阅览室最多可同时容纳 100 个人阅读，读者进入时，必须在阅览室门口的一个登记表上登记，内容包括姓名、座号等，离开时要撤掉登记内容。用P、V操作描述读者进程的同步算法。\n解决办法 count：计数信号量，初始值为100，代表阅览室的空闲座位数 mutex：计数信号量，初始值为1，用于互斥访问登记表 while (true) { P(count); P(mutex); 查登记表，置某座位为占用； V(mutex); ...... read(); ...... P(mutex); 查登记表，置某座位为空； V(mutex); V(count); } 性能指标 响应时间：自进程就绪至进程第一次获得CPU响应的时间 周转时间：进程从第一次进入就绪状态到完成所花费的总时间 等待时间：进程处于就绪状态等待CPU所花费的总时间 推荐阅读 NJU操作系统 操作系统：设计与实现 (2022 春季学期) 【精校中英字幕】2015 CMU 15-213 CSAPP 深入理解计算机系统 《操作系统导论》 《现代操作系统》（原书第4版） 《操作系统:精髓与设计原理》 《深入理解计算机系统（原书第3版）》CSAPP 计算机组成 + 操作系统 + 汇编 + C语言 + Linux系统编程 \u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e ","permalink":"https://xancoding.cn/posts/2022-11-15-12-04-42/","summary":"链接 程序设计时 在这种情况下，我们将所有的源代码都放在一个文件中，例如 main.cpp： #include \u0026lt;iostream\u0026gt; int add(int a, int b) { return a + b; } int main() { int a = 1, b = 2; std::cout \u0026lt;\u0026lt; add(a, b)","title":"操作系统"},{"content":"正确的方法 学习媒介 学习的最佳媒介在我看来，还是以 文字 为最佳\n视频，会是很多人学习的途径，我也曾在很长的一段时间内通过视频来进行学习 ，但效率不高（PS：也许是我个人学习方法不佳的原因）\n我认为视频这种媒介有以下的一些弊端：\n看视频难以进入深层次的思考。观看视频的过程是被动的，在这个过程中，你需要跟上视频播放的节奏，这自然压缩了主动思考的可能。再而言之，看视频是一种相对容易的方式，因为你只需要借助记忆力（简单的复制到自己的脑子里），而比较少的运用其他的思维能力（深入的理解，将其变成自己的东西） 看视频带来更低的时间效率。同一段文字，读和看的速度不是一个层面的。而看视频，就相当于别人读给你听，时间效率自然是比不了阅读文字 视频带来更多的干扰因素。在观看视频过程中，大脑需要同时处理图像信息、语言信息和文字信息，这无形中增加了大脑的负担。在这种情况下，你就根本不能指望自己的🧠可以进入深层次的思考 当然，具体情况还是要具体分析，有一些知识通过视频可以更为形象的表示出来，这也不可否认。我的核心观点是，学习的主要媒介应是以文字为主的。视频，作为补充的学习媒介还是可以的。\n如何开始新知识的学习？ 要带有目的去学，带有问题去学，而不能是盲目的去学 在开始一个新东西的学习时，先问问自己几个问题：我为什么要学它？我需要学到什么程度？—— 这直接决定了你后面要以什么样的态度去对待它 在学习一个新东西时，要先对其知识体系有个大致的了解，先有了全面的认识之后，再对细枝末节做深入的了解。否则，很容易陷入找不到重点，不知道在学什么，不能很好的形成体系等等问题。当然，对细枝末节的了解，也是要有优先级之分的 在开始之前，准备工作是必不可少的。你需要尽可能的找到你所需要的所有资源，可以从问答论坛、搜索引擎、好友推荐等等途径，主要是筛选学习过程中所要读的书籍，包括入门以及深入学习的书籍 同时，阅读书籍也不能采取从头看到尾的做法，而是根据自己的情况，做一些取舍。同时看多本书籍也是不错的选择，它们往往会给你带来不一样的启发 还要学会边读边做，通过一些具体的项目带动学习。这在学习技术方面的知识时，尤其重要。毕竟，你学习它，为的是最后的应用 学习应该是阶梯式的，要懂得循序渐进，不能一开始就是困难模式。这不仅会打击自己的自信心，也不利于后续的学习 如何知道自己是否掌握？ 你要先能在脑子里有个清楚的脉络，多多问自己问题，从 WHY 到 HOW，再到 WHY。发现自己卡壳的地方，要借助搜索引擎、书籍或是别的途径及时解决 写下来——知识点可能会很杂很乱，有时候做一个知识导图可以很好的帮助理解。过一段时间，当因为不怎么用到某一个知识点而忘得差不多时，你自己写的文字或者做的图，可以很好的帮助你回忆起来——前提是这是你经过思考的出的，而不只是复制粘贴——那将毫无用处。我是通过 Obsidian 来记录自己的学习记录的。维护一个自己的博客，用来记录自己的学习过程，存放自己用来学习的资源，在我看来也是不错的 讲出来——你可以跟别人（也可以自己跟自己讲）将你最近学到的东西。通过语言的形式，用嘴讲出来（一定是用嘴讲，而不只是停留在脑子里想）。每当这个时候，你都会意识到自己以为掌握的东西，实际上并没有。多数时候，你会讲述的很混乱。但不必灰心，多尝试尝试，自然会理顺的。当你可以流利的讲出来时，自然就说明它已经成为了你自己的东西 良好的心态 在我看来，除了方法，人的情绪也同样不可忽略，甚至是更重要的部分\n人在很大的程度上，还是以感性为主的。许多事，在你理性的大脑看来，是不可取的；但是，感性的大脑常常会占据上风\n忽然想到，自己之前看到的一个言论，感觉还蛮有意思的——我们的身体并没有随着社会的进步做出及时的进化，我们相当于用着几千年之前的原始人的身体生活在如今现代化的社会里，这也给从众心理、懒惰、容易肥胖等等看似不合理的现象提供了一个解释\n学习是个枯燥的过程，特别是未知而又困难的挑战，更容易让人退缩。这里就简单说说我个人的一些想法吧：\n排除所有不必要的干扰，如减少手机的使用、减少查看消息的频率、不去浏览任何借助推荐算法生成的信息流等等。做到这几点，你就可以有 长时间 的 连续 的自我支配时间啦（不过，我还是觉得每天的时间不够） 当然，社交也是必须的。我觉得，从更深的层面来看，是因为人是群居动物，长时间的独身一人不交流，至少对我来说，还是无法忍受的。每天抽出些许时间，跟身边的人聊聊天，说些有的没没的，也是必不可少的 摆正心态，从来都没有什么捷径，要打好基础。我觉得这个我感触很大，回顾之前自己的学习，很大程度上都是不扎实的。你觉得省下来的时间，往往会在将来给你带来更大的损失 走的慢没关系，只要每天都在前进，那就够了 学会肯定自己，你努力的每一分钟，都有它的意义。人总是会在对比中贬低自己，所有的不愉快都是在比较中得来的。要明白，你对自己的看法，会在无形中影响你自己成为什么样的人。无论怎么说，要积极的看自己 一些我自己的碎碎念 有很多事，光是脑子里想到，明白重要性，是远远不够的。只有真正，实际经历过，你才会有一个全新的认识\n多跟别人交流，多接触新的东西。不同的思想的碰撞，往往会产生意想不到的妙处\n写文章，并不是字多就是好，言简意赅更应该得到推崇，重要的是要表达出自己的想法，在此基础上，字数做到越少越好\n","permalink":"https://xancoding.cn/posts/2022-11-14-15-56-45/","summary":"正确的方法 学习媒介 学习的最佳媒介在我看来，还是以 文字 为最佳 视频，会是很多人学习的途径，我也曾在很长的一段时间内通过视频来进行学习 ，但效率不高","title":"一些关于自学的感悟"},{"content":"要求 团队合作、合理分工、按组为单位进行 报告文字内容不可拷贝粘贴现有文献，应反映小组所做的工作，有分析，实践性的选题应有具体操作或者配置过程描述，辅以截图或实验数据 所交报告中应在最后注明组员分工、参考文献，报告字数3000-6000 不同班级的小组可选择相同的题目，但重复计数（由各班学委协调），不可多于3组，且报告内容不可相同，要求独立完成各组任务 除了个别综述性的选题，其它选题要求在实际平台上实践 选题 基于网络嗅探软件（wireshark）的协议分析实验\nWireshark的深入学习与掌握，如过滤器的使用，归纳方法 通过实验阐述ARP的工作原理 利用实验结果分析ICMP协议的报文结构字段定义 基于实验数据深入分析TCP协议的连接过程原理，报文的分片等功能 从校园网发起向外网中某Web服务器的访问，记录并分析从MAC层协议、IP协议、TCP协议一直到HTTP协议的过程 基于网络嗅探软件Wireshark的协议分析实验 Wireshark 是什么？ Wirkshark 是一个功能十分强大的开源的网络数据包分析器，能够在多种平台上抓取和分析网络包\nWirkshark 可被用于检查安全问题和解决网络问题，也可供开发者调试协议的实现和学习网络协议的原理\nWireshark使用 Npcap or WinPcap 作为接口，直接与网卡进行数据报文交换\nWireshark 下载与安装 官网地址：https://www.wireshark.org/，直接点击下一步下一步安装即可 但是，我在安装过程中报了如下的错误： 排查了好久，没找到合适的解决办法\n最后，下载 WinPcap 来代替 Npcap ，成功运行。\nWireshark 基本用法 简单抓包基础步骤：选择捕获接口 -\u0026gt; 获取网络实时痕迹 -\u0026gt; 获取报文 -\u0026gt; 深入解析\n选择接口（网卡） 网络上传输的数据包需要经过网卡到达计算机，Wireshark可以捕获流经网卡的数据包\n在使用Wireshark捕获数据前，先要选择捕获接口。一台计算机可能会有不止一个网卡，此时需要选择你要捕获数据的接口。\n选择菜单栏上的 捕获-\u0026gt;选项 选择想要捕获数据的接口后，点击开始 界面说明 开始捕获后，Wireshark会把捕获到的报文显示到界面上\n显示过滤器用于设置过滤条件进行数据列表区数据过滤 数据列表区展示的是Wireshark捕获到的所有数据包的列表，每个数据包包含 编号、时间戳、源地址、目标地址、协议、长度以及数据包信息 数据详细区展示的是在数据列表区中选中的数据包的分协议展示 Frame：物理层的数据帧概况 Ethernet II：数据链路层以太网帧头部信息 Internet Protocol Version 4： 互联网层IP包头部信息 Transmission Control Protocol：传输层的数据段头部信息，此处是TCP 数据字节区展示的是选中的数据包的源数据。另外，在数据详细区选中的某层或某字段，对应的数据会在数据字节区中高亮 过滤器设置 根据我们想要抓取的数据包，对过滤器进行设置。过滤掉冗余的数据包，找到我们需要的信息\n捕获过滤器 捕获过滤器表达式作用在Wireshark捕获数据包之前，只捕获符合条件的数据包\n当需要处理大量数据时，使用捕获过滤器可以节省大量资源\n界面说明 选择菜单栏上的 捕获-\u0026gt;捕获过滤器 点击 + 即可添加新的过滤规则\nFilter Name 指代过滤器名称，用来给自己看该过滤器的过滤效果\nFilter Expression 指代过滤器表达式，需要使用 Berkeley Packet Filter 语法书写 语法规则 捕获过滤器使用 BPF 语法，表达式由多个原语组成：\n原语(primitives)：由名称或数字，以及描述它的多个限定词组成。 * 限定词(qualifiers) * Types：设置数字或者名称所指示类型，例如host www.baidu.com，如果没有指定此值，则默认使用“host”关键字 * host、post * net，设定子网， net 192.168.0.0 mask 255.255.255.0等价于net 192.168.0.0/24 * port，设置端口范围，例如port 6000-8000 * Dir：设置网络出入方向，例如dst port 80，如果没有特别指明来源或目的地，则默认使用“src or dst”作为关键字 * src、dst、src or dst、src and dst(src：源端口，dst：目标端口) * Proto：指定协议类型，例如udp，如果没有特别指明是什么协议，则默认使用所有支持的协议 * ether、fddi、tr、wlan、ip、ip6、arp、rarp、decnet、tcp、udp、icmp、igmp、icmp、igrp、pim、ah、esp、vrrp * 其他 * gateway：指明网关IP地址，等价于ether host \u0026#39;ehost\u0026#39; and not host \u0026#39;host\u0026#39; * broadcast：广播报文，例如ether broadcast或者ip broadcast * multicast：多播报文，例如ip multicast或者ip6 multicast * less、greater：小于或者大于 * 原语运算符 * 与：\u0026amp;\u0026amp;或者and * 或：||或者or * 非：!或者not 转载自：https://juejin.cn/post/6844904066229747720 应用示例 只抓取源端口或者目的端口范围6000到8000，并且是一个tcp协议或者ipv6的数据包\nsrc or dst port 6000-8000 \u0026amp;\u0026amp; tcp or ip6 只抓取IP地址为192.168.0.10的数据包\nhost 192.168.0.10 显示过滤器 显示过滤器表达式作用在在Wireshark捕获数据包之后，从已捕获的所有数据包中显示出符合条件的数据包\n显示过滤表达式在工具栏下方的“应用显示过滤器”输入框输入即可生效 基本过滤表达式 一条基本的表达式由过滤项、过滤关系、过滤值三项组成 例如：ip.addr == 192.168.1.1，其中 ip.addr 为过滤项，== 为过滤关系，192.168.1.1 为过滤值。 该表达式的意思是 找出所有ip协议中源或目标ip等于192.168.1.1的数据包 过滤项 Wireshark的过滤项是 协议.协议字段 的模式，Wireshark支持的全部协议及协议字段可查看官方说明。 以端口为例，端口出现于tcp协议中。所以有端口这个过滤项且其写法就是tcp.port Wireshark出于缩减长度的原因，有些字段没有使用协议规定的名称而是使用简写，比如Destination Port在Wireshark中写为dstport Wireshark出于简便使用的原因，增加了一些协议中没有的字段，比如tcp协议只有源端口和目标端口字段，为了简便使用Wireshark增加了tcp.port来同时代表这两个字段 实际使用时我们输入协议.后Wireshark就会有支持的字段提示 过滤关系 过滤关系指的是大于、等于、小于等等式关系，具体可以看官方给出的表 过滤值 过滤值就是设定的过滤项应该满足过滤关系的标准，比如500、5000、50000等等。\n过滤值的写法一般已经被过滤项和过滤关系设定好了，只是填下自己的期望值就可以了。\n复合过滤表达式 所谓复合过滤表达示，就是指由多条基本过滤表达式组合而成的表达示。\n基本过滤表达式的写法还是不变的，复合过滤表达示多出来的东西就只是基本过滤表达示的“连接词”，我们依然直接参照官方给出的表 常见显示过滤需求及其对应表达式 数据链路层 筛选mac地址为04:f9:38:ad:13:26的数据包----eth.src == 04:f9:38:ad:13:26 筛选源mac地址为04:f9:38:ad:13:26的数据包----eth.src == 04:f9:38:ad:13:26 网络层 筛选ip地址为192.168.1.1的数据包----ip.addr == 192.168.1.1 筛选192.168.1.0网段的数据---- ip contains \u0026#34;192.168.1\u0026#34; 筛选192.168.1.1和192.168.1.2之间的数据包----ip.addr == 192.168.1.1 \u0026amp;\u0026amp; ip.addr == 192.168.1.2 筛选从192.168.1.1到192.168.1.2的数据包----ip.src == 192.168.1.1 \u0026amp;\u0026amp; ip.dst == 192.168.1.2 传输层 筛选tcp协议的数据包----tcp 筛选除tcp协议以外的数据包----!tcp 筛选端口为80的数据包----tcp.port == 80 筛选12345端口和80端口之间的数据包----tcp.port == 12345 \u0026amp;\u0026amp; tcp.port == 80 筛选从12345端口到80端口的数据包----tcp.srcport == 12345 \u0026amp;\u0026amp; tcp.dstport == 80 应用层 特别说明----http中http.request表示请求头中的第一行（如GET index.jsp HTTP/1.1），http.response表示响应头中的第一行（如HTTP/1.1 200 OK），其他头部都用http.header_name形式。 筛选url中包含.php的http数据包----http.request.uri contains \u0026#34;.php\u0026#34; 筛选内容包含username的http数据包----http contains \u0026#34;username\u0026#34; 通过实验阐述ARP的工作原理 ARP即地址解析协议（Address Resolution Protocol），是根据IP地址获取MAC地址的一个TCP/IP协议\nARP用于解决同一个局域网上的主机或路由器的IP地址和MAC地址的映射问题\n每一台主机都设有一个 ARP高速缓存，里面存有 本局域网上 各主机和路由器的IP地址到MAC地址的映射表\nARP工作流程 当主机A要向本局域网上的某台主机B发送IP数据报时，就现在其ARP高速缓存中查找有无主机B的IP地址。若有，查出其对应的MAC地址，写入MAC帧；若没有，进行下述步骤 主机A的ARP进程在本局域网上广播一个ARP请求分组，其中有自己的IP地址到MAC地址的映射 本局域网上的所有主机运行的ARP进程都收到此ARP请求分组 主机B的IP地址与ARP请求分组中要查询的IP地址一致，就收下这个ARP请求分组，将主机A的MAC映射写入自己的ARP高速缓存，并向主机A发送ARP响应分组，同时在这个ARP响应分组中写入自己的MAC地址。由于其余所有主机的IP地址都与ARP请求分组中要查询的IP地址不一致，因此不理睬 主机A收到主机B的ARP响应分组后，就在其ARP高速缓存中写入主机B的IP地址到MAC地址的映射 实验步骤及内容 主机A\nIP地址：192.168.31.248\nMAC地址：c0:3c:59:5e:37:47\n主机B\nIP地址：192.168.31.186\nMAC地址：28:7f:cf:12:af:89\nARP命令练习 在cmd中使用ipconfig/all命令，查看自己的IP地址和MAC地址，同时让小组成员连接同一个WIFI执行相同的操作并记录 主机A IP地址和MAC地址 主机B IP地址和MAC地址 主机A使用arp -a查看ARP缓存表 主机A通过ping主机B的IP来添加动态ARP缓存表数据 我在ping主机Bip地址时碰到请求超时的问题。\n经排查，是因为windows防火墙默认设置的是不让别人ping通，通过修改防火墙相关设置解决了该问题。\n步骤：控制面板 → 系统和安全 → Windows防火墙 → 高级设置 → 入站规则 → 文件和打印机共享（回显请求 - ICMPv4-In）设置为启用 主机A使用arp -a查看ARP缓存表，发生新增一条数据 以管理员身份运行cmd，执行arp -d *，删除缓存信息 抓包分析ARP协议 当ARP缓存对应数据为空时 实验步骤 主机A执行arp -d *，删除缓存信息 主机A运行Wireshark，设置显示过滤器表达式为arp.dst.proto_ipv4 == 192.168.31.186 and arp.src.proto_ipv4 == 192.168.31.248 or icmp 主机Aping主机B的ip地址 结果分析 主机A将自己的ip地址 192.168.31.248 \u0026amp; MAC地址 c0:3c:59:5e:37:47写入请求分组，并将目的ip地址设置为192.168.31.186，目的MAC地址设置为00:00:00:00:00:00，对本局域网内的所有主机进行广播 主机A发出的ARP请求分组 主机B收下这个ARP请求分组，将主机A的MAC映射写入自己的ARP高速缓存，并向主机A发送ARP响应分组，同时在这个ARP响应分组中写入自己的MAC地址，即28:7f:cf:12:af:89 主机A收到主机B的ARP响应分组后，就在其ARP高速缓存中写入主机B的IP地址到MAC地址的映射 主机A收到的来自主机B的ARP响应分组 主机A的ARP高速缓存表 当ARP缓存对应数据不为空时 实验步骤 主机A运行Wireshark，设置显示过滤器表达式为arp.dst.proto_ipv4 == 192.168.31.186 and arp.src.proto_ipv4 == 192.168.31.248 or icmp 主机A ping主机B的ip地址 结果分析 主机A没有发出ARP请求，而主机B接受到了主机A的ICMP报文，说明主机A直接使用了高速缓存区内的对应数据，而没有发出广播\n主机A发出的报文 利用实验结果分析ICMP协议的报文结构字段定义 ICMP即互联网控制报文协议（Internet Control Message Protocol），网络设备（包括路由器）使用它来发送错误消息和指示与另一个IP 地址通信时成功或失败的操作信息\nICMP报文结构 ICMP报文格式 +0------7-------15---------------31 | Type | Code | Checksum | +--------------------------------+ | Message Body | | (Variable length) | +--------------------------------+ ICMP报文格式解释 Type：占一个字节，标识ICMP报文的类型，可以分为差错报告报文和询问报文两大类 Code：占一个字节，用于进一步区分某种类型中的不同情况 Checksum：占两个字节，检验报文在传输过程中是否出现差错 ICMP应用举例 Ping命令 「ping」是用来探测本机与网络中另一主机之间是否可达的命令\n在此次实验中，使用主机A在cmd环境下ping baidu.com，分析回送请求报文和回送回答报文\n回送请求报文 Internet Control Message Protocol Type: 8 (Echo (ping) request) Code: 0 Checksum: 0x4ae9 [correct] [Checksum Status: Good] Identifier (BE): 1 (0x0001) Identifier (LE): 256 (0x0100) Sequence Number (BE): 626 (0x0272) Sequence Number (LE): 29186 (0x7202) [Response frame: 215] Data (32 bytes) Data: 6162636465666768696a6b6c6d6e6f7071727374757677616263646566676869 [Length: 32] Type的值为 8，Code的值为 0，表示回显请求 Checksum的值为 0x4ae9，这里校验和验证正确 Identifier：识别码，用于区分不同进程的应用。由于Window系统与Linux系统发出的ping报文的字节序不一样，所以需要 BE 和 LE 两个值，而这两个值所表示的十六进制值（HEX）是相同的。这里的 BE 指的是大端字节序，在Linux中使用；LE指的是小端字节序，在Windows中使用 Sequence Number：序列号，用于对应请求与响应。这里对于 BE 和 LE 解释同上。 回送回答报文 Internet Control Message Protocol Type: 0 (Echo (ping) reply) Code: 0 Checksum: 0x52e9 [correct] [Checksum Status: Good] Identifier (BE): 1 (0x0001) Identifier (LE): 256 (0x0100) Sequence Number (BE): 626 (0x0272) Sequence Number (LE): 29186 (0x7202) [Request frame: 213] [Response time: 20.855 ms] Data (32 bytes) Data: 6162636465666768696a6b6c6d6e6f7071727374757677616263646566676869 [Length: 32] Type的值为 0，Code的值为 0，表示回送回答 Checksum的值为 0x52e9，这里校验和验证正确 Identifier：识别码，用于区分不同进程的应用 Sequence Number：序列号，用于对应请求与响应。这里的值 626 同上文 回送请求报文 Sequence Number 的值，说明这俩请求和响应是对应的 Tracert命令 「Tracert」是用来显示可能的路由（路径）和测量数据包在 IP 网络中的传输延迟的命令\n在此次实验中，使用主机A在cmd环境下tracert baidu.com，分析报文\n差错报告报文 ICMP的差错报告报文中，会把收到的需要进行差错报告的IP的数据提取出来作为ICMP报文的数据部分\nInternet Protocol Version 4, Src: 192.168.31.248, Dst: 110.242.68.66 0100 .... = Version: 4 .... 0101 = Header Length: 20 bytes (5) Differentiated Services Field: 0x00 (DSCP: CS0, ECN: Not-ECT) 0000 00.. = Differentiated Services Codepoint: Default (0) .... ..00 = Explicit Congestion Notification: Not ECN-Capable Transport (0) Total Length: 92 Identification: 0x1f2e (7982) 000. .... = Flags: 0x0 0... .... = Reserved bit: Not set .0.. .... = Don\u0026#39;t fragment: Not set ..0. .... = More fragments: Not set ...0 0000 0000 0000 = Fragment Offset: 0 Time to Live: 1 [Expert Info (Note/Sequence): \u0026#34;Time To Live\u0026#34; only 1] [\u0026#34;Time To Live\u0026#34; only 1] [Severity level: Note] [Group: Sequence] Protocol: ICMP (1) Header Checksum: 0x0000 [validation disabled] [Header checksum status: Unverified] Source Address: 192.168.31.248 Destination Address: 110.242.68.66 Internet Control Message Protocol Type: 8 (Echo (ping) request) Code: 0 Checksum: 0xf4e4 [correct] [Checksum Status: Good] Identifier (BE): 1 (0x0001) Identifier (LE): 256 (0x0100) Sequence Number (BE): 794 (0x031a) Sequence Number (LE): 6659 (0x1a03) [No response seen] [Expert Info (Warning/Sequence): No response seen to ICMP request] [No response seen to ICMP request] [Severity level: Warning] [Group: Sequence] Data (64 bytes) Data: 000000000000000000000000000000000000000000000000000000000000000000000000… [Length: 64] Internet Control Message Protocol Type: 11 (Time-to-live exceeded) Code: 0 (Time to live exceeded in transit) Checksum: 0xf4ff [correct] [Checksum Status: Good] Unused: 00000000 Internet Protocol Version 4, Src: 192.168.31.248, Dst: 110.242.68.66 0100 .... = Version: 4 .... 0101 = Header Length: 20 bytes (5) Differentiated Services Field: 0x00 (DSCP: CS0, ECN: Not-ECT) 0000 00.. = Differentiated Services Codepoint: Default (0) .... ..00 = Explicit Congestion Notification: Not ECN-Capable Transport (0) Total Length: 92 Identification: 0x1f2e (7982) 000. .... = Flags: 0x0 0... .... = Reserved bit: Not set .0.. .... = Don\u0026#39;t fragment: Not set ..0. .... = More fragments: Not set ...0 0000 0000 0000 = Fragment Offset: 0 Time to Live: 1 [Expert Info (Note/Sequence): \u0026#34;Time To Live\u0026#34; only 1] [\u0026#34;Time To Live\u0026#34; only 1] [Severity level: Note] [Group: Sequence] Protocol: ICMP (1) Header Checksum: 0x069f [validation disabled] [Header checksum status: Unverified] Source Address: 192.168.31.248 Destination Address: 110.242.68.66 Internet Control Message Protocol Type: 8 (Echo (ping) request) Code: 0 Checksum: 0xf4e4 [unverified] [in ICMP error packet] [Checksum Status: Unverified] Identifier (BE): 1 (0x0001) Identifier (LE): 256 (0x0100) Sequence Number (BE): 794 (0x031a) Sequence Number (LE): 6659 (0x1a03) Data (64 bytes) Data: 000000000000000000000000000000000000000000000000000000000000000000000000… [Length: 64] Type的值为 11，Code的值为 0，表示超时报错 图1的回送请求报文出错，图2相对应的差错报告报文，把图1报文的IP数据报的首部和数据字段的前8个字节提取出来，作为ICMP报文的数据字段 基于实验数据深入分析TCP协议功能 TCP即传输控制协议（Transmission Control Protocol），是面向连接的运输层协议\nTCP报文格式 TCP报文格式解释 源端口和目的端口：各占 2 字节，和 IP 头部的 源地址 和 目的地址 一起唯一地标识了每个连接 序列号：占 4 字节，TCP连接中传送的数据流中的每一个字节都按顺序编号，序号字段的值指的是本报文段所发送的数据的第一个字节的序号 确认号：占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号 数据偏移：占 4 位，它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远，实际是指出TCP报文段的首部长度 保留：占 6 位，保留为今后使用，默认置0 紧急 URG(URGent)：当 URG = 1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据) 确认 ACK(ACKnowledegment)：只有当 ACK = 1 时确认号字段有效，当 ACK = 0 时确认号无效 推送 PSH(PuSH)：接收 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程，不再等到整个缓存都填满了后再向上交付 复位 RST(ReSeT)：当 RST = 1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因）必须释放连接，然后再重新建立运输连接。RST置1还用来拒绝一个非法报文或拒绝打开一个连接 同步 SYN(SYNchronization)：在连接建立时用来同步序号。当 SYN = 1 而 ACK = 0 时，表明这是一个连接请求报文段。对方若同意建立连接，则在响应的报文段中使 SYN = 1 和 ACK = 1 终止 FIN(FINish)：用来释放一个连接。FIN = 1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。 窗口：占 2 字节，指的是发送本报文段的一方的接收窗口。用于流量控制，指示接收方愿意接收的字节数量 检验和：占 2 字节，检验和字段检验的范围包括TCP首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部 选项：长度可变，最长可达 40 字节。如 最长报文段长度MSS、窗口扩大选项、时间戳选项等等 填充字段：仅仅是为了使整个TCP首部长度为 4 字节的整数倍 实验步骤 下载 TCP/UDP Socket 调试工具 在cmd中ping zhihu.com，得到ip地址为103.41.167.234 使用TCP调试工具，创建一个连接 打开Wireshark，设置显示过滤器为 ip.addr == 103.41.167.234 在TCP调试工具中，点击 连接 在TCP调试工具中，发送数据 Hello World!!!后，连接自动断开 在Wireshark中捕获到以下数据包 三次握手 三次握手目的是保证双方都有发送和接收的能力\n一开始，客户端和服务端都处于 CLOSE 状态。先是服务端主动监听某个端口，处于 LISTEN 状态 客户端随机初始化 序列号 seq 为 x，同时把 SYN 置1，接着把报文发送给服务端。之后，TCP客户端进入 SYN-SENT 状态 服务器收到连接请求报文段后，若同意连接，将进行下述操作。首先，随机初始化自己的 序列号 seq 为 y，其次把 确认号 ack 置为 x + 1，接着 SYN 和 ACK 均置为1，最后把该报文发给客户端。这时，服务端进入SYN-RCVD 状态 客户端收到服务端报文后，还要向服务端回应最后一个应答报文。首先将应答报文的 ACK 置为1，确认号 ack 置为 y + 1，序列号 seq 置为 x + 1，最后把报文发送给服务端。之后，客户端处于ESTABLISHED 状态，因为它一收一发了 服务端收到客户端的应答报文后，也进入 ESTABLISHED 状态，因为它也一收一发了 四次挥手 客户端打算关闭连接，此时会发送一个 TCP 首部 FIN 标志位被置为 1 的报文并指明自己当前的 序列号 seq 为 u，之后客户端进入 FIN_WAIT_1 状态 服务端收到该报文后，就向客户端发送 ACK 应答报文，指明自己当前的 序列号 seq 为 v， 确认号 ack 为 u + 1，接着服务端进入 CLOSE_WAIT 状态 客户端收到服务端的 ACK 应答报文后，之后进入 FIN_WAIT_2 状态 等待服务端处理完数据后，也向客户端发送 FIN 报文，报文的 ACK 置为 1，序列号 seq 为 w， 确认号 ack 为 u + 1，之后服务端进入 LAST_ACK 状态 客户端收到服务端的 FIN 报文后，回一个 ACK 应答报文，其中 序列号 seq 为 u + 1， 确认号 ack 为 w + 1，之后进入 TIME_WAIT 状态 服务端收到了 ACK 应答报文后，就进入了 CLOSE 状态，至此服务端已经完成连接的关闭 客户端在经过 2MSL 一段时间后，自动进入 CLOSE 状态，至此客户端也完成连接的关闭 访问外网某服务器，分析从MAC层协议、IP协议、TCP协议一直到HTTP协议的过程 网络包的旅途 用户输入网址 浏览器解析网址，生成 HTTP 消息 在发送 HTTP 消息给 Web 服务器之前，浏览器先向 DNS 服务器发送请求，查询与服务器域名相对应的 IP 地址 通过 DNS 获取到 IP 后，浏览器把 HTTP 消息转交给 Socket 库 Socket 库将收到的 HTTP 消息作为数据转交给协议栈 TCP 按照网络包的长度对数据进行拆分，在每个包前面加上 TCP 头部并转交给 IP IP 在 TCP 包前面加上 IP 头部（目的 IP 为 Web 服务器 IP 地址，源 IP 为主机 IP 地址），IP 包生成后参考路由控制表决定接受此 IP 包的路由或主机的 IP 地址。随后，IP 包将被发送给连接这些路由器或主机网络接口的驱动程序 如果尚不知道下一跳接收端的 MAC 地址，可以利用 ARP 查找，加上 MAC 头部，然后将包转交给网卡驱动 网卡驱动收到 IP 模块发来的包，将其转交给网卡并发出发送指令 网卡检查以太网的可发送状态，将数字信息转换为电信号发送出去 服务端的局域网中有防火墙，对进入的包进行检查，判断是否允许通过 Web 服务器前面有如果有缓存服务器，会拦截通过防火墙的包如果用户请求的页面已经缓存在服务器上，则代替服务器向用户返回页面数据 如果请求的页面没有被缓存，缓存服务器会将请求转发给 Web 服务器 Web 服务器收到包后，网卡和网卡驱动会接收这个包并转交给协议栈 协议栈依次检查 IP 头部和 TCP 头部，如果没有问题则取出 HTTP 的数据块并进行组装 HTTP 消息恢复成原始状态，然后通过 Socket 库转交给 Web 服务器 Web 服务器分析 HTTP 消息的内容，并根据请求内容将读取的数据返回给客户端 浏览器接收到响应包后，进行页面的渲染 HTTP请求结束，TCP连接断开 DNS DNS报文结构 DNS查询步骤 浏览器在解析域名时，会经过下列步骤：\n浏览器会先看自身有没有对这个域名的缓存，如果有，就直接返回；如果没有，就去问操作系统 操作系统也会去看自己的缓存，如果有，就直接返回；如果没有，再去 Hosts 文件看 本地的 Hosts 文件，若有域名和 IP 地址的对应关系，直接使用该 IP 地址通信；如果没有，浏览器向本地域名服务器发出一个查询请求 本地域名服务器查看有无缓存记录。若有，直接响应；若没有，本地域名服务器向根域名服务器查询 根域名服务器响应本地域名服务器，给出对应域名的顶级域名服务器IP地址，让本地域名服务器去向其查询 顶级域名服务器响应本地域名服务器，给出对应域名的权威域名服务器（权威 DNS 服务器，它是域名解析结果的原出处）IP地址，让本地域名服务器去向其查询 权威 DNS 服务器查询后将对应的 IP 地址告诉本地 DNS 服务器 本地 DNS 将 IP 地址返回给客户端，客户端和目标建立连接 实验步骤 访问http://www.smartclass.cn/Default.aspx 分析 HTTP 请求报文及 HTTP 响应报文 报文分析 HTTP报文结构 HTTP请求报文 数据链路层 网络层 传输层 应用层 Hypertext Transfer Protocol GET /Default.aspx HTTP/1.1\\r\\n Host: www.smartclass.cn\\r\\n User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36 Edg/107.0.1418.42\\r\\n Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\\r\\n Accept-Encoding: gzip, deflate\\r\\n Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6\\r\\n Upgrade-Insecure-Requests: 1\\r\\n \\r\\n [Full request URI: http://www.smartclass.cn/Default.aspx] [HTTP request 1/14] [Response in frame: 1787] [Next request in frame: 1804] 请求行：由 请求方法字段、URL字段 和 HTTP协议版本字段 组成，如 GET /Default.aspx HTTP/1.1 请求头部：关键字/值对组成，每行一对 Host：请求的主机名 User-Agent：发出请求的浏览器类型 Accept：客户端可识别的内容类型列表 空行：最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头 请求数据 HTTP响应报文 传输层 TCP 协议会分段传输过大的数据段（Segment）保证传输的性能 TCP 协议引入了最大分段大小（Maximum segment size，MSS）这一概念，它是 TCP 数据段能够携带的数据上限。在正常情况下，TCP 连接的 MSS 是 MTU - 40 字节，即 1460 字节 MSS：一个网络包的最大长度，以太网中一般为 1500 字节 MTU：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度 该报文 MSS 值为 1360，数据段分成 8 份从服务端发出，并在客户端经过拼接后被接收 应用层 Hypertext Transfer Protocol HTTP/1.1 200 OK\\r\\n [Expert Info (Chat/Sequence): HTTP/1.1 200 OK\\r\\n] [HTTP/1.1 200 OK\\r\\n] [Severity level: Chat] [Group: Sequence] Response Version: HTTP/1.1 Status Code: 200 [Status Code Description: OK] Response Phrase: OK Date: Sun, 13 Nov 2022 13:06:05 GMT\\r\\n Content-Type: text/html; charset=utf-8\\r\\n Content-Length: 9696\\r\\n [Content length: 9696] Connection: keep-alive\\r\\n Cache-Control: private\\r\\n Content-Encoding: gzip\\r\\n Vary: Accept-Encoding\\r\\n MANUFACTURER: Hanboer\\r\\n X-AspNet-Version: 4.0.30319\\r\\n X-UA-Compatible: IE=edge,chrome=1\\r\\n Access-Control-Allow-Headers: content-type\\r\\n Access-Control-Allow-Methods: GET,POST,PUT,DELETE,OPTIONS\\r\\n Access-Control-Allow-Origin: http://localhost:9527\\r\\n Access-Control-Allow-Credentials: true\\r\\n \\r\\n [HTTP response 1/14] [Time since request: 0.067102000 seconds] [Request in frame: 1776] [Next request in frame: 1804] [Next response in frame: 1806] [Request URI: http://www.smartclass.cn/Webapi/V1/Live/GetPublicLives?csrkToken=0aat6ee1aaks3\u0026amp;IsLiving=true\u0026amp;Sort=StartTime\u0026amp;Order=0\u0026amp;PageSize=8\u0026amp;PageNumber=1\u0026amp;attribute=] Content-encoded entity body (gzip): 9696 bytes -\u0026gt; 40818 bytes File Data: 40818 bytes 状态行：由 HTTP版本 、状态码 和原因短语 组成，如 HTTP/1.1 200 OK 响应头部：关键字/值对组成，每行一对 空行：最后一个响应头之后是一个空行，发送回车符和换行符，通知服务器以下不再有响应头 响应正文 参考 Wireshark系列之4 捕获过滤器 网络——Wireshark工具 WireShark的基本用法 Wireshark使用教程（界面说明、捕获过滤器表达式、显示过滤器表达式） 一文精讲Wireshark的抓包和分析 Wireshark简明教程，新手专用，挑实在的讲，不搞花里胡哨 WireShark网络封包抓包工具各个界面介绍 实验3.利用Wireshark分析ARP协议 如何计算IP或ICMP协议首部里的checksum字段 带你深入熟悉你所不知道的ICMP 使用Wireshark学习网络协议之ICMP 实战！我用 Wireshark 让你“看见“ TCP 4.1 TCP 三次握手与四次挥手面试题 Wireshark抓包TCP三次握手 TCP 中的三次握手和四次挥手 Wireshark配合TCP调试工具理解TCP三次握手和四次挥手过程 老生常谈的TCP三次握手和四次挥手，你会了吗？ HTTP请求报文和HTTP响应报文 为什么 TCP/IP 协议会拆分数据 HTTP的曲折：网络请求到层层封装和终端拆分 浅谈http协议（三）：HTTP 报文及其结构 Wireshark官方文档 ","permalink":"https://xancoding.cn/posts/2022-11-12-11-38-21/","summary":"要求 团队合作、合理分工、按组为单位进行 报告文字内容不可拷贝粘贴现有文献，应反映小组所做的工作，有分析，实践性的选题应有具体操作或者配置过程描","title":"计算机网络课程大作业"},{"content":"Vimium是什么？ Vimium是一款Chrome插件，它提供了类Vim操作来控制浏览器网页\n熟练掌握后，可以脱离鼠标，只使用键盘浏览页面\nVimium常用命令 ? 指令可以打开帮助指南，其中有大多数的指令介绍 小写字母一般是在当前页面的操作 大写字母一般是跳转到新页面的操作 页面浏览 j/k/h/l：向上/下/左/右滚动页面 d/u：向下/上滚动半屏页面 gg/G：回到顶/底部 J/K：选择左/右标签 x/X：关闭/恢复标签 r：刷新页面 gi：将焦点聚集在第一个输入框 \u0026lt;\u0026lt;/\u0026gt;\u0026gt;：移动当前标签到左/右侧边 W：把当前标签页转移到一个新的窗口 ^：跳转到上一个标签页面 g0/$：跳转到第一个/最后一个标签页面 URL操作 H/L：当前页面的浏览历史记录的后退和前进 yy：把当前页面的URL复制到剪切板 yf：选择一个URL复制到剪切板 p/P：在当前/新页面打开剪切板中的URL gu/U：跳转到当前URL的父/根目录 g + e/E：编辑当前地址栏，并在当前/新页面打开 模式切换 f/F：点击模式，为页面上所有可见的链接分配到一个好按的键位，这个时候按下相应的键位，就会打开对应的链接 i：插入模式，可以屏蔽掉vimium快捷键，使其不和网页默认快捷键冲突 v/V：视觉/行视觉 模式，用于选区 Esc：退出模式 查找操作 /：查找 n/N：向下/上查找结果 o/O：查找历史记录 \u0026amp; 书签 t/T：创建/查找标签页 常用技巧 快速定位 + 复制文本： \u0026lt;a-f\u0026gt;搜索指定关键字，并定位至起点 按v切换到视觉模式 使用h、j、k、l、b、e、w、$、Shift + w控制方向，选择范围 最后使用y复制内容至剪切板 推荐阅读 我比想象中更需要浏览器中的 Vim 模式 Vimium完全教程，各类技巧大全 Vimium教程 | Micracle\u0026rsquo;s blog Vimium如何选中网页中的内容并对其进行复制和粘贴？ ","permalink":"https://xancoding.cn/posts/2022-11-11-20-39-13/","summary":"Vimium是什么？ Vimium是一款Chrome插件，它提供了类Vim操作来控制浏览器网页 熟练掌握后，可以脱离鼠标，只使用键盘浏览页面 Vi","title":"Vimium学习记"},{"content":" AcWing Web 应用课 | Colopen\u0026rsquo;s blog AcWing Web 应用课 HTML 基础标签 CSS JavaScript React Vue3 MDN官方文档 Web 入门 HTML —— 构建 Web CSS —— 设计Web JavaScript —— 用户端动态脚本 React 入门 Vue 入门 Canvas 教程 怪异英文生成器 生成比较好看的英文字体，支持复制粘贴 Color Hunt 设计师和艺术家的调色板 Game-icons 游戏图标在线存储库 VSCode 自动生成缺省的 HTML 代码框架 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 输入！，接着输入 tab 键，自动生成缺省的 HTML 代码框架 再按三下 tab 键，光标会移动到 \u0026lt;body\u0026gt; 与 \u0026lt;/body\u0026gt; 之间的空行 KOF KOF AcWing Web 应用课 | 中期项目——拳皇（上） | Vedio AcWing Web 应用课 | 中期项目——拳皇（下） | Vedio 基础操作 操作如下： 角色一: w 跳 a 左移 d 右移 j 拳击 角色二: ↑ 跳 ← 左移 → 右移 1 拳击 文件结构 |-- README.md |-- static | |-- css | | `-- base.css | |-- images | | |-- background | | | `-- 0.gif | | `-- player | | `-- kyo | | |-- 0.gif | | |-- 1.gif | | |-- 2.gif | | |-- 3.gif | | |-- 4.gif | | |-- 5.gif | | `-- 6.gif | `-- js | |-- ac_game_object | | `-- base.js | |-- base.js | |-- controller | | `-- base.js | |-- game_map | | `-- base.js | |-- player | | |-- base.js | | `-- kyo.js | `-- utils | `-- gif.js `-- templates `-- index.html 整体架构 逻辑结构 Retrieved from：https://www.acwing.com/solution/content/139831/ HTML templates/index.html\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;KOF\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;../static/css/base.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.acwing.com/static/jquery/js/jquery-3.3.1.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;kof\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import {KOF} from \u0026#39;../static/js/base.js\u0026#39;; let kof = new KOF(\u0026#39;kof\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; CSS css/base.css\n#kof { width: 1280px; height: 720px; background-image: url(\u0026#39;../images/background/0.gif\u0026#39;); background-size: 200% 100%; background-position: top; position: absolute; } #kof\u0026gt;.kof-head { width: 100%; height: 80px; position: absolute; top: 0; display: flex; align-items: center; } #kof\u0026gt;.kof-head\u0026gt;.kof-head-hp-0 { height: 40px; width: calc(50% - 60px); margin-left: 20px; border: white 5px solid; box-sizing: border-box; border-right: none; } #kof\u0026gt;.kof-head\u0026gt;.kof-head-timer { height: 60px; width: 80px; background-color: orange; border: white 5px solid; box-sizing: border-box; color: white; font-size: 30px; font-weight: 800; text-align: center; line-height: 50px; user-select: none; } #kof\u0026gt;.kof-head\u0026gt;.kof-head-hp-1 { height: 40px; width: calc(50% - 60px); border: white 5px solid; box-sizing: border-box; border-left: none; } #kof\u0026gt;.kof-head\u0026gt;.kof-head-hp-0\u0026gt;div { background-color: red; height: 100%; width: 100%; float: right; } #kof\u0026gt;.kof-head\u0026gt;.kof-head-hp-1\u0026gt;div { background-color: red; height: 100%; width: 100%; } #kof\u0026gt;.kof-head\u0026gt;.kof-head-hp-0\u0026gt;div\u0026gt;div { background-color: lightgreen; height: 100%; width: 100%; float: right; } #kof\u0026gt;.kof-head\u0026gt;.kof-head-hp-1\u0026gt;div\u0026gt;div { background-color: lightgreen; height: 100%; width: 100%; } JavaScript 逻辑结构 KOF js/base.js\nimport { GameMap } from \u0026#39;../js/game_map/base.js\u0026#39; import { Kyo } from \u0026#39;../js/player/kyo.js\u0026#39;; export class KOF { constructor(id) { this.$kof = $(\u0026#39;#\u0026#39; + id); this.game_map = new GameMap(this); this.players = [ new Kyo(this, { id: 0, x: 200, y: 0, width: 120, height: 200, color: \u0026#39;blue\u0026#39; }), new Kyo(this, { id: 1, x: 900, y: 0, width: 120, height: 200, color: \u0026#39;red\u0026#39; }) ] } } AcGameObject js/ac_game_object/base.js\nlet AC_GAME_OBJECTS = []; export class AcGameObject { constructor() { AC_GAME_OBJECTS.push(this); this.timedelta = 0; this.has_call_start = false; } start() { // 初始化 } update() { // 每一帧执行一次 } destory() { // 删除当前对象 for (let i in AC_GAME_OBJECTS) { if (AC_GAME_OBJECTS[i] === this) { AC_GAME_OBJECTS.splice(i, 1); break; } } } } let last_timestamp; // 上一次执行函数时的时刻 /** * @description 该函数每一帧执行一次 * @param {number} timestamp 当前执行函数时的时刻 */ let AC_GAME_OBJECTS_FRAME = (timestamp) =\u0026gt; { for (let obj of AC_GAME_OBJECTS) { if (!obj.has_call_start) { obj.start(); obj.has_call_start = true; } else { obj.timedelta = timestamp - last_timestamp; obj.update(); } } last_timestamp = timestamp; requestAnimationFrame(AC_GAME_OBJECTS_FRAME); } requestAnimationFrame(AC_GAME_OBJECTS_FRAME); Controller controller 控制器，读取玩家的输入 js/constroller/base.js export class Controller { // 手动实现键盘触发事件——当前按住的按键（效果不同于keydown） constructor($canvas) { this.$canvas = $canvas; this.pressed_keys = new Set(); // Set 对象允许你存储任何类型的唯一值 this.start(); } start() { let outer = this; this.$canvas.keydown(function(e){ // keydown：某个键是否被按住，事件会连续触发 outer.pressed_keys.add(e.key); }); this.$canvas.keyup(function(e){ // keyup：某个按键是否被释放 outer.pressed_keys.delete(e.key); }); } } GameMap js/game_map/base.js\nimport {AcGameObject} from \u0026#39;../ac_game_object/base.js\u0026#39; import { Controller } from \u0026#39;../controller/base.js\u0026#39;; export class GameMap extends AcGameObject { constructor(root) { super(); this.root = root; this.$canvas = $(\u0026#39;\u0026lt;canvas width=\u0026#34;1280\u0026#34; height=\u0026#34;720\u0026#34; tabindex=0\u0026gt;\u0026lt;/canvas\u0026gt;\u0026#39;); // 构造一个jQuery对象 其中，tabindex=\u0026#34;0\u0026#34;使\u0026lt;canvas\u0026gt;元素可以聚焦 this.ctx = this.$canvas[0].getContext(\u0026#39;2d\u0026#39;); // this.$canvas[0]是\u0026lt;canvas\u0026gt;元素的DOM对象 this.ctx用于画布的渲染 this.root.$kof.append(this.$canvas); this.$canvas.focus(); // 聚焦，使之可以获取输入 this.controller = new Controller(this.$canvas); // 加入血条 this.root.$kof.append($(` \u0026lt;div class=\u0026#34;kof-head\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;kof-head-hp-0\u0026#34;\u0026gt;\u0026lt;div\u0026gt;\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;kof-head-timer\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;kof-head-hp-1\u0026#34;\u0026gt;\u0026lt;div\u0026gt;\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; `)); // 加入计时表 this.time_left = 60000; //单位：毫秒（因为定义的timedelta单位是ms） this.$timer = this.root.$kof.find(\u0026#39;.kof-head-timer\u0026#39;); } start() { } update() { this.update_time(); this.render(); } update_time() { this.time_left -= this.timedelta; if (this.time_left \u0026lt; 0) { // 时间到，游戏结束 this.time_left = 0; let [a, b] = this.root.players; if (a.status !== 6 \u0026amp;\u0026amp; b.status !== 6) { a.statu = b.status = 6; a.frame_current_cnt = b.frame_current_cnt = 0; a.vx = b.vx = 0; } } this.$timer.text(parseInt(this.time_left / 1000)); } render() { this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height); } } Player js/player/base.js\nimport { AcGameObject } from \u0026#39;../ac_game_object/base.js\u0026#39;; export class Player extends AcGameObject { constructor(root, info) { super(); this.root = root; this.id = info.id; this.x = info.x; this.y = info.y; this.width = info.width; this.height = info.height; this.color = info.color; this.direction = 1; this.vx = 0; this.vy = 0; this.speedx = 400; // 水平速度 this.speedy = -1000; // 跳跃初始速度 this.gravity = 50; this.ctx = this.root.game_map.ctx; this.pressed_keys = this.root.game_map.controller.pressed_keys; this.status = 3; // 0：静止， 1：向前，2：向后，3：跳跃，4：攻击，5：被攻击，6：死亡 随着项目的完善，动作会变的很多，这时用数组存储字符串代替this.status会更方便 this.animations = new Map(); // 存储GIF动画的每一帧 this.frame_current_cnt = 0; // 记录当前的帧数 this.hp = 100; this.$hp = this.root.$kof.find(`.kof-head-hp-${this.id}\u0026gt;div`); this.$hp_div = this.$hp.find(\u0026#39;div\u0026#39;); } start() { } update_control() { let w, a, d, j; if (this.id === 0) { w = this.pressed_keys.has(\u0026#39;w\u0026#39;); a = this.pressed_keys.has(\u0026#39;a\u0026#39;); d = this.pressed_keys.has(\u0026#39;d\u0026#39;); j = this.pressed_keys.has(\u0026#39;j\u0026#39;); } else { w = this.pressed_keys.has(\u0026#39;ArrowUp\u0026#39;); a = this.pressed_keys.has(\u0026#39;ArrowLeft\u0026#39;); d = this.pressed_keys.has(\u0026#39;ArrowRight\u0026#39;); j = this.pressed_keys.has(\u0026#39;1\u0026#39;); } if (this.status === 0 || this.status === 1) { // 静止状态 || 移动状态 if (j) { // 攻击 this.status = 4; this.vx = 0; this.frame_current_cnt = 0; } else if (w) { // 跳跃 if (d) { // 向右跳 this.vx = this.speedx; } else if (a) { // 向左跳 this.vx = -this.speedx; } else { // 垂直跳 this.vx = 0; } this.vy = this.speedy; this.status = 3; this.frame_current_cnt = 0; // 每次跳跃重新记录帧数，确保跳跃动画正常 } else if (d) { // 向右移动 this.vx = this.speedx; this.status = 1; } else if (a) { // 向左移动 this.vx = - this.speedx; this.status = 1; } else { // 静止 this.vx = 0; } } } update_move() { this.vy += this.gravity; this.x += this.vx * this.timedelta / 1000; this.y += this.vy * this.timedelta / 1000; // 确保两个角色不会重叠 a 是自己、b 是对手 // let [a, b] = this.root.players; // if (a !== this) [a,b] = [b, a]; // let r1 = { // x1: a.x, // y1: a.y, // x2: a.x + a.width, // y2: a.x + a.height, // }; // let r2 = { // x1: b.x, // y1: b.y, // x2: b.x + b.width, // y2: b.x + b.height, // }; // if (this.is_collusion(r1, r2)) { // b.x += this.vx * this.timedelta / 1000 / 2; // b.y += this.vy * this.timedelta / 1000 / 2; // a.x -= this.vx * this.timedelta / 1000 / 2; // a.y -= this.vy * this.timedelta / 1000 / 2; // if (this.status === 3) this.status = 0; // } // 落到平地上后静止 if (this.y \u0026gt; 450) { this.y = 450; this.vy = 0; if (this.status === 3) this.status = 0; // 因为任何时刻都有重力施加，不加这一句会导致状态只有静止状态 } // 不能超出左右边界 if (this.x \u0026lt; 0) { this.x = 0; } else if (this.x + this.width \u0026gt; this.root.game_map.$canvas.width()) { this.x = this.root.game_map.$canvas.width() - this.width; } } update_direction() { // 确保两个角色始终相对 if (this.status === 6) return; let players = this.root.players; if (players[0] \u0026amp;\u0026amp; players[1]) { let me = this, you = players[1 - this.id]; if (me.x \u0026lt; you.x) me.direction = 1; else me.direction = -1; } } is_collusion(r1, r2) { // 判断两个矩阵是否有交集 if (Math.max(r1.x1, r2.x1) \u0026gt; Math.min(r1.x2, r2.x2)) return false; if (Math.max(r1.y1, r2.y1) \u0026gt; Math.min(r1.y2,r2.y2)) return false; return true; } is_attack() { if (this.status === 6) return; // 已经倒地，无法再被攻击 this.status = 5; this.frame_current_cnt = 0; this.hp = Math.max(this.hp - 10, 0); this.$hp_div.animate({ // 血条减少，渐变 width: this.$hp.parent().width() * this.hp / 100, }, 350); this.$hp.animate({ // 血条减少，渐变 width: this.$hp.parent().width() * this.hp / 100, }, 600); if (this.hp \u0026lt;= 0) { this.status = 6; this.frame_current_cnt = 0; this.vx = 0; } } update_attack() { // 判定是否被攻击到 if (this.status === 4 \u0026amp;\u0026amp; this.frame_current_cnt === 18) { // 第18帧时动画挥出拳，判断此时是否拳头与对方有碰撞 let me = this, you = this.root.players[1 - this.id]; let r1; // 攻击判定矩形 let r2; // 敌方人物矩形 if (this.direction \u0026gt; 0) { r1 = { x1: me.x + 120, y1: me.y + 40, x2: me.x + 120 + 100, y2: me.y + 40 + 20, } } else { r1 = { x1: me.x + me.width - 120 - 100, y1: me.y + 40, x2: me.x + me.width - 120 - 100 + 100, y2: me.y + 40 + 20, } } r2 = { x1: you.x, y2: you.y, x2: you.x + you.width, y2: you.y + you.height }; if (this.is_collusion(r1, r2)) { you.is_attack(); } } } update() { this.update_attack(); this.update_direction(); this.update_control(); this.update_move(); this.render(); } render() { let status = this.status; if (this.status === 1 \u0026amp;\u0026amp; this.direction * this.vx \u0026lt; 0) status = 2; // 后退状态 let obj = this.animations.get(status); if (obj \u0026amp;\u0026amp; obj.loaded) { // GIF 已经加载完成 if (this.direction \u0026gt; 0) { // 正方向 let k = parseInt(this.frame_current_cnt / obj.frame_rate) % obj.frame_cnt; // 通过obj.frame_rate控制渲染动画的速率，方便控制动画，而不只是单纯的每一帧都渲染一次 let image = obj.gif.frames[k].image; this.ctx.drawImage(image, this.x, this.y + obj.offset_y, image.width * obj.scale, image.height * obj.scale); } else { // 反方向 通过调整坐标系来翻转方向 this.ctx.save(); this.ctx.scale(-1, 1); this.ctx.translate(-this.root.game_map.$canvas.width(), 0); let k = parseInt(this.frame_current_cnt / obj.frame_rate) % obj.frame_cnt; let image = obj.gif.frames[k].image; this.ctx.drawImage(image, this.root.game_map.$canvas.width() - this.width - this.x, this.y + obj.offset_y, image.width * obj.scale, image.height * obj.scale); // 不同于正方向时的渲染，因为此时坐标系改变，需要在对称的位置渲染 this.ctx.restore(); } } if (status === 4 || status === 5 || status === 6) { // 确保不会一直循环GIF if (this.frame_current_cnt === obj.frame_rate * (obj.frame_cnt - 1)) { // 确保此时已经播放完一次GIF动画 if (status === 6) { // 死亡倒地不起，这里的 -- 和 下面的 ++ 相抵消，使之在最后一帧不再变化 this.frame_current_cnt--; } else { this.status = 0; } } } this.frame_current_cnt++; } } js/player/kyo.js\nimport { Player } from \u0026#34;../player/base.js\u0026#34;; import {GIF} from \u0026#39;../utils/gif.js\u0026#39; export class Kyo extends Player { constructor(root, info) { super(root, info); this.init_animations(); // 初始化动画 } init_animations() { let outer = this; let offsets = [0, -22, -22, -150, 0, 0, 0]; // 偏移量 不同的动画高度不同，因此需要借助竖直方向上的偏移量将他们调整至同一水平面 for (let i = 0; i \u0026lt; 7; ++ i) { // 7个动作 let gif = GIF(); gif.load(`/static/images/player/kyo/${i}.gif`); this.animations.set(i, { // 动画 gif: gif, frame_cnt: 0, // GIF帧数 frame_rate: 5, // 每5帧过渡一次 offset_y: offsets[i], // y方向偏移量 loaded: false, // 是否加载完成 scale: 2, // 放大2倍 }); gif.onload = function() { // 加载完成 let obj = outer.animations.get(i); obj.frame_cnt = gif.frames.length; obj.loaded = true; if (i === 3) { // 调整跳跃时GIF播放速率 obj.frame_rate = 4; } } } } } GIF Loading and playing GIF image to canvas 把玩家的GIF动画渲染在canvas上 js/utils/gif.js\nconst GIF = function () { // **NOT** for commercial use. var timerID; // timer handle for set time out usage var st; // holds the stream object when loading. var interlaceOffsets = [0, 4, 2, 1]; // used in de-interlacing. var interlaceSteps = [8, 8, 4, 2]; var interlacedBufSize; // this holds a buffer to de interlace. Created on the first frame and when size changed var deinterlaceBuf; var pixelBufSize; // this holds a buffer for pixels. Created on the first frame and when size changed var pixelBuf; const GIF_FILE = { // gif file data headers GCExt: 0xF9, COMMENT: 0xFE, APPExt: 0xFF, UNKNOWN: 0x01, // not sure what this is but need to skip it in parser IMAGE: 0x2C, EOF: 59, // This is entered as decimal EXT: 0x21, }; // simple buffered stream used to read from the file var Stream = function (data) { this.data = new Uint8ClampedArray(data); this.pos = 0; var len = this.data.length; this.getString = function (count) { // returns a string from current pos of len count var s = \u0026#34;\u0026#34;; while (count--) { s += String.fromCharCode(this.data[this.pos++]) } return s; }; this.readSubBlocks = function () { // reads a set of blocks as a string var size, count, data = \u0026#34;\u0026#34;; do { count = size = this.data[this.pos++]; while (count--) { data += String.fromCharCode(this.data[this.pos++]) } } while (size !== 0 \u0026amp;\u0026amp; this.pos \u0026lt; len); return data; } this.readSubBlocksB = function () { // reads a set of blocks as binary var size, count, data = []; do { count = size = this.data[this.pos++]; while (count--) { data.push(this.data[this.pos++]); } } while (size !== 0 \u0026amp;\u0026amp; this.pos \u0026lt; len); return data; } }; // LZW decoder uncompressed each frames pixels // this needs to be optimised. // minSize is the min dictionary as powers of two // size and data is the compressed pixels function lzwDecode(minSize, data) { var i, pixelPos, pos, clear, eod, size, done, dic, code, last, d, len; pos = pixelPos = 0; dic = []; clear = 1 \u0026lt;\u0026lt; minSize; eod = clear + 1; size = minSize + 1; done = false; while (!done) { // JavaScript optimisers like a clear exit though I never use \u0026#39;done\u0026#39; apart from fooling the optimiser last = code; code = 0; for (i = 0; i \u0026lt; size; i++) { if (data[pos \u0026gt;\u0026gt; 3] \u0026amp; (1 \u0026lt;\u0026lt; (pos \u0026amp; 7))) { code |= 1 \u0026lt;\u0026lt; i } pos++; } if (code === clear) { // clear and reset the dictionary dic = []; size = minSize + 1; for (i = 0; i \u0026lt; clear; i++) { dic[i] = [i] } dic[clear] = []; dic[eod] = null; } else { if (code === eod) { done = true; return } if (code \u0026gt;= dic.length) { dic.push(dic[last].concat(dic[last][0])) } else if (last !== clear) { dic.push(dic[last].concat(dic[code][0])) } d = dic[code]; len = d.length; for (i = 0; i \u0026lt; len; i++) { pixelBuf[pixelPos++] = d[i] } if (dic.length === (1 \u0026lt;\u0026lt; size) \u0026amp;\u0026amp; size \u0026lt; 12) { size++ } } } }; function parseColourTable(count) { // get a colour table of length count Each entry is 3 bytes, for RGB. var colours = []; for (var i = 0; i \u0026lt; count; i++) { colours.push([st.data[st.pos++], st.data[st.pos++], st.data[st.pos++]]) } return colours; } function parse() { // read the header. This is the starting point of the decode and async calls parseBlock var bitField; st.pos += 6; gif.width = (st.data[st.pos++]) + ((st.data[st.pos++]) \u0026lt;\u0026lt; 8); gif.height = (st.data[st.pos++]) + ((st.data[st.pos++]) \u0026lt;\u0026lt; 8); bitField = st.data[st.pos++]; gif.colorRes = (bitField \u0026amp; 0b1110000) \u0026gt;\u0026gt; 4; gif.globalColourCount = 1 \u0026lt;\u0026lt; ((bitField \u0026amp; 0b111) + 1); gif.bgColourIndex = st.data[st.pos++]; st.pos++; // ignoring pixel aspect ratio. if not 0, aspectRatio = (pixelAspectRatio + 15) / 64 if (bitField \u0026amp; 0b10000000) { gif.globalColourTable = parseColourTable(gif.globalColourCount) } // global colour flag setTimeout(parseBlock, 0); } function parseAppExt() { // get application specific data. Netscape added iterations and terminator. Ignoring that st.pos += 1; if (\u0026#39;NETSCAPE\u0026#39; === st.getString(8)) { st.pos += 8 } // ignoring this data. iterations (word) and terminator (byte) else { st.pos += 3; // 3 bytes of string usually \u0026#34;2.0\u0026#34; when identifier is NETSCAPE st.readSubBlocks(); // unknown app extension } }; function parseGCExt() { // get GC data var bitField; st.pos++; bitField = st.data[st.pos++]; gif.disposalMethod = (bitField \u0026amp; 0b11100) \u0026gt;\u0026gt; 2; gif.transparencyGiven = bitField \u0026amp; 0b1 ? true : false; // ignoring bit two that is marked as userInput??? gif.delayTime = (st.data[st.pos++]) + ((st.data[st.pos++]) \u0026lt;\u0026lt; 8); gif.transparencyIndex = st.data[st.pos++]; st.pos++; }; function parseImg() { // decodes image data to create the indexed pixel image var deinterlace, frame, bitField; deinterlace = function (width) { // de interlace pixel data if needed var lines, fromLine, pass, toline; lines = pixelBufSize / width; fromLine = 0; if (interlacedBufSize !== pixelBufSize) { // create the buffer if size changed or undefined. deinterlaceBuf = new Uint8Array(pixelBufSize); interlacedBufSize = pixelBufSize; } for (pass = 0; pass \u0026lt; 4; pass++) { for (toLine = interlaceOffsets[pass]; toLine \u0026lt; lines; toLine += interlaceSteps[pass]) { deinterlaceBuf.set(pixelBuf.subarray(fromLine, fromLine + width), toLine * width); fromLine += width; } } }; frame = {} gif.frames.push(frame); frame.disposalMethod = gif.disposalMethod; frame.time = gif.length; frame.delay = gif.delayTime * 10; gif.length += frame.delay; if (gif.transparencyGiven) { frame.transparencyIndex = gif.transparencyIndex } else { frame.transparencyIndex = undefined } frame.leftPos = (st.data[st.pos++]) + ((st.data[st.pos++]) \u0026lt;\u0026lt; 8); frame.topPos = (st.data[st.pos++]) + ((st.data[st.pos++]) \u0026lt;\u0026lt; 8); frame.width = (st.data[st.pos++]) + ((st.data[st.pos++]) \u0026lt;\u0026lt; 8); frame.height = (st.data[st.pos++]) + ((st.data[st.pos++]) \u0026lt;\u0026lt; 8); bitField = st.data[st.pos++]; frame.localColourTableFlag = bitField \u0026amp; 0b10000000 ? true : false; if (frame.localColourTableFlag) { frame.localColourTable = parseColourTable(1 \u0026lt;\u0026lt; ((bitField \u0026amp; 0b111) + 1)) } if (pixelBufSize !== frame.width * frame.height) { // create a pixel buffer if not yet created or if current frame size is different from previous pixelBuf = new Uint8Array(frame.width * frame.height); pixelBufSize = frame.width * frame.height; } lzwDecode(st.data[st.pos++], st.readSubBlocksB()); // decode the pixels if (bitField \u0026amp; 0b1000000) { // de interlace if needed frame.interlaced = true; deinterlace(frame.width); } else { frame.interlaced = false } processFrame(frame); // convert to canvas image }; function processFrame(frame) { // creates a RGBA canvas image from the indexed pixel data. var ct, cData, dat, pixCount, ind, useT, i, pixel, pDat, col, frame, ti; frame.image = document.createElement(\u0026#39;canvas\u0026#39;); frame.image.width = gif.width; frame.image.height = gif.height; frame.image.ctx = frame.image.getContext(\u0026#34;2d\u0026#34;); ct = frame.localColourTableFlag ? frame.localColourTable : gif.globalColourTable; if (gif.lastFrame === null) { gif.lastFrame = frame } useT = (gif.lastFrame.disposalMethod === 2 || gif.lastFrame.disposalMethod === 3) ? true : false; if (!useT) { frame.image.ctx.drawImage(gif.lastFrame.image, 0, 0, gif.width, gif.height) } cData = frame.image.ctx.getImageData(frame.leftPos, frame.topPos, frame.width, frame.height); ti = frame.transparencyIndex; dat = cData.data; if (frame.interlaced) { pDat = deinterlaceBuf } else { pDat = pixelBuf } pixCount = pDat.length; ind = 0; for (i = 0; i \u0026lt; pixCount; i++) { pixel = pDat[i]; col = ct[pixel]; if (ti !== pixel) { dat[ind++] = col[0]; dat[ind++] = col[1]; dat[ind++] = col[2]; dat[ind++] = 255; // Opaque. } else if (useT) { dat[ind + 3] = 0; // Transparent. ind += 4; } else { ind += 4 } } frame.image.ctx.putImageData(cData, frame.leftPos, frame.topPos); gif.lastFrame = frame; if (!gif.waitTillDone \u0026amp;\u0026amp; typeof gif.onload === \u0026#34;function\u0026#34;) { doOnloadEvent() }// if !waitTillDone the call onload now after first frame is loaded }; // **NOT** for commercial use. function finnished() { // called when the load has completed gif.loading = false; gif.frameCount = gif.frames.length; gif.lastFrame = null; st = undefined; gif.complete = true; gif.disposalMethod = undefined; gif.transparencyGiven = undefined; gif.delayTime = undefined; gif.transparencyIndex = undefined; gif.waitTillDone = undefined; pixelBuf = undefined; // dereference pixel buffer deinterlaceBuf = undefined; // dereference interlace buff (may or may not be used); pixelBufSize = undefined; deinterlaceBuf = undefined; gif.currentFrame = 0; if (gif.frames.length \u0026gt; 0) { gif.image = gif.frames[0].image } doOnloadEvent(); if (typeof gif.onloadall === \u0026#34;function\u0026#34;) { (gif.onloadall.bind(gif))({ type: \u0026#39;loadall\u0026#39;, path: [gif] }); } if (gif.playOnLoad) { gif.play() } } function canceled() { // called if the load has been cancelled finnished(); if (typeof gif.cancelCallback === \u0026#34;function\u0026#34;) { (gif.cancelCallback.bind(gif))({ type: \u0026#39;canceled\u0026#39;, path: [gif] }) } } function parseExt() { // parse extended blocks const blockID = st.data[st.pos++]; if (blockID === GIF_FILE.GCExt) { parseGCExt() } else if (blockID === GIF_FILE.COMMENT) { gif.comment += st.readSubBlocks() } else if (blockID === GIF_FILE.APPExt) { parseAppExt() } else { if (blockID === GIF_FILE.UNKNOWN) { st.pos += 13; } // skip unknow block st.readSubBlocks(); } } function parseBlock() { // parsing the blocks if (gif.cancel !== undefined \u0026amp;\u0026amp; gif.cancel === true) { canceled(); return } const blockId = st.data[st.pos++]; if (blockId === GIF_FILE.IMAGE) { // image block parseImg(); if (gif.firstFrameOnly) { finnished(); return } } else if (blockId === GIF_FILE.EOF) { finnished(); return } else { parseExt() } if (typeof gif.onprogress === \u0026#34;function\u0026#34;) { gif.onprogress({ bytesRead: st.pos, totalBytes: st.data.length, frame: gif.frames.length }); } setTimeout(parseBlock, 0); // parsing frame async so processes can get some time in. }; function cancelLoad(callback) { // cancels the loading. This will cancel the load before the next frame is decoded if (gif.complete) { return false } gif.cancelCallback = callback; gif.cancel = true; return true; } function error(type) { if (typeof gif.onerror === \u0026#34;function\u0026#34;) { (gif.onerror.bind(this))({ type: type, path: [this] }) } gif.onload = gif.onerror = undefined; gif.loading = false; } function doOnloadEvent() { // fire onload event if set gif.currentFrame = 0; gif.nextFrameAt = gif.lastFrameAt = new Date().valueOf(); // just sets the time now if (typeof gif.onload === \u0026#34;function\u0026#34;) { (gif.onload.bind(gif))({ type: \u0026#39;load\u0026#39;, path: [gif] }) } gif.onerror = gif.onload = undefined; } function dataLoaded(data) { // Data loaded create stream and parse st = new Stream(data); parse(); } function loadGif(filename) { // starts the load var ajax = new XMLHttpRequest(); ajax.responseType = \u0026#34;arraybuffer\u0026#34;; ajax.onload = function (e) { if (e.target.status === 404) { error(\u0026#34;File not found\u0026#34;) } else if (e.target.status \u0026gt;= 200 \u0026amp;\u0026amp; e.target.status \u0026lt; 300) { dataLoaded(ajax.response) } else { error(\u0026#34;Loading error : \u0026#34; + e.target.status) } }; ajax.open(\u0026#39;GET\u0026#39;, filename, true); ajax.send(); ajax.onerror = function (e) { error(\u0026#34;File error\u0026#34;) }; this.src = filename; this.loading = true; } function play() { // starts play if paused if (!gif.playing) { gif.paused = false; gif.playing = true; playing(); } } function pause() { // stops play gif.paused = true; gif.playing = false; clearTimeout(timerID); } function togglePlay() { if (gif.paused || !gif.playing) { gif.play() } else { gif.pause() } } function seekFrame(frame) { // seeks to frame number. clearTimeout(timerID); gif.currentFrame = frame % gif.frames.length; if (gif.playing) { playing() } else { gif.image = gif.frames[gif.currentFrame].image } } function seek(time) { // time in Seconds // seek to frame that would be displayed at time clearTimeout(timerID); if (time \u0026lt; 0) { time = 0 } time *= 1000; // in ms time %= gif.length; var frame = 0; while (time \u0026gt; gif.frames[frame].time + gif.frames[frame].delay \u0026amp;\u0026amp; frame \u0026lt; gif.frames.length) { frame += 1 } gif.currentFrame = frame; if (gif.playing) { playing() } else { gif.image = gif.frames[gif.currentFrame].image } } function playing() { var delay; var frame; if (gif.playSpeed === 0) { gif.pause(); return; } else { if (gif.playSpeed \u0026lt; 0) { gif.currentFrame -= 1; if (gif.currentFrame \u0026lt; 0) { gif.currentFrame = gif.frames.length - 1 } frame = gif.currentFrame; frame -= 1; if (frame \u0026lt; 0) { frame = gif.frames.length - 1 } delay = -gif.frames[frame].delay * 1 / gif.playSpeed; } else { gif.currentFrame += 1; gif.currentFrame %= gif.frames.length; delay = gif.frames[gif.currentFrame].delay * 1 / gif.playSpeed; } gif.image = gif.frames[gif.currentFrame].image; timerID = setTimeout(playing, delay); } } var gif = { // the gif image object onload: null, // fire on load. Use waitTillDone = true to have load fire at end or false to fire on first frame onerror: null, // fires on error onprogress: null, // fires a load progress event onloadall: null, // event fires when all frames have loaded and gif is ready paused: false, // true if paused playing: false, // true if playing waitTillDone: true, // If true onload will fire when all frames loaded, if false, onload will fire when first frame has loaded loading: false, // true if still loading firstFrameOnly: false, // if true only load the first frame width: null, // width in pixels height: null, // height in pixels frames: [], // array of frames comment: \u0026#34;\u0026#34;, // comments if found in file. Note I remember that some gifs have comments per frame if so this will be all comment concatenated length: 0, // gif length in ms (1/1000 second) currentFrame: 0, // current frame. frameCount: 0, // number of frames playSpeed: 1, // play speed 1 normal, 2 twice 0.5 half, -1 reverse etc... lastFrame: null, // temp hold last frame loaded so you can display the gif as it loads image: null, // the current image at the currentFrame playOnLoad: true, // if true starts playback when loaded // functions load: loadGif, // call this to load a file cancel: cancelLoad, // call to stop loading play: play, // call to start play pause: pause, // call to pause seek: seek, // call to seek to time seekFrame: seekFrame, // call to seek to frame togglePlay: togglePlay, // call to toggle play and pause state }; return gif; } export { GIF } 状态机 0：静止 1：移动 3：跳跃 4：攻击 MySpace MySpace AcWing Web 应用课 | Vue3——网站整体布局、用户动态页面 | Vedio AcWing Web 应用课 | Vue3——用户列表、登录、注册页面 | Vedio ","permalink":"https://xancoding.cn/posts/2022-11-02-15-49-03/","summary":"AcWing Web 应用课 | Colopen\u0026rsquo;s blog AcWing Web 应用课 HTML 基础标签 CSS JavaScript React Vue3 MDN官方文档 Web 入门 HTML —— 构建 Web CSS —— 设计Web JavaScript —— 用户端动态脚本 React 入门 Vue 入门 Canvas 教程 怪异英文生","title":"AcWing Web 应用课"},{"content":" 画图的工具并不重要，重要的其实是你应该如何形成自己的规则体系，想要为博客配图并不是一件困难的事情，比较困难的是长期坚持并且经常思考，对自己形成的规则不断改善，最终就一定能够做好。\n推荐阅读 Sketch UI 设计工具 Figma UI 设计工具 蓝湖 UI 设计工具 LucidChart 绘制 UML 图、流程图的商业软件 Excalidraw 手绘风格图表工具 Plantuml 快速编写UML图的组件 Drawio 一款开源免费的流程图绘制软件 Midjourney AI绘画 Drawio —— 一款开源免费的流程图绘制软件 AI绘画的关键词 技术文章配图指南\n编程和绘画；AI 从文本绘画；技术文章中的插图\n在 AI 绘画的世界里，怎样才算一名合格的「甲方」？\n","permalink":"https://xancoding.cn/posts/2022-10-31-18-01-02/","summary":"画图的工具并不重要，重要的其实是你应该如何形成自己的规则体系，想要为博客配图并不是一件困难的事情，比较困难的是长期坚持并且经常思考，对自己形","title":"如何为你的文章配图？"},{"content":"知识管理 个人网站 前前后后花了大概是有一个月的时间，把这个博客从零到有，再到功能的补充完善，到目前已经是一个很满意的状态，自我感觉投入的时间确实也是很值得的。建立这个博客，作为我对外输出的一个途径，也可以算是我的学习笔记的存放处，再加上我一些有感悟的点，想要记录下来的内容，都是写在这上面。\n知识管理工具 Obsidian 我的笔记记录工作，都是在 obsidian 上完成的，现在也是建立起了一个很方便的工作流，是我可以只用思考要写什么内容，其余的步骤已经可以完全交给自动化来完成了，诸如同步到github、编译博客的源文件再发表等等\nObsidian 插件推荐 简单的幻灯片演示 用obsidian做ppt【玩转Obsidian的保姆级教程】\nHypothes.is 在日常浏览网页内容时，可以对感兴趣的内容进行高亮批注，并可自动同步到 Obsidian\nHypothesis 使用小记\nEPUB Reader 在 Obsidian 中可以阅读 Epub 电子书\nVarious Complements 单词提示，自动补全\n灵感与想法 flomo 浮墨笔记 在日常生活中，有碰到想法和灵感需要记录的时候，我会使用它进行一个快速的记录\n在想回顾时，可以方便知晓过去的想法 信息暂存 语雀 我会将部分的信息暂存在语雀中，记录下来，在需要用的时候再去语雀上找来用 推荐阅读 什么是 Zettelkasten 卡片盒笔记法？ 卢曼：与卡片盒交流 我的知识管理工具和经验 我的 Obsidian 使用经验 不要再碎片化笔记了 - 关于笔记的思考 程序员的喵喵 | Obsidian 使用 【中文字幕】Zettelkasten笔记系统的搭建 | 手把手教学 | Zettelkasten in Obsidian ","permalink":"https://xancoding.cn/posts/2022-10-30-15-28-22/","summary":"知识管理 个人网站 前前后后花了大概是有一个月的时间，把这个博客从零到有，再到功能的补充完善，到目前已经是一个很满意的状态，自我感觉投入的时间确","title":"我输出信息的途径"},{"content":" AcWing Django 框架课 | Colopen\u0026rsquo;s blog AcWing Django 框架课 WarOfWarlock 搭建工具 HTML \u0026amp; CSS \u0026amp; JavaScript \u0026amp; Django 参考资料 AcWing Django 框架课 | Colopen\u0026rsquo;s blog AcWing Django框架课 Django 项目创建 2.1上课笔记 | 栎 2.1上课笔记 | Andrew1729 启动初始项目 django-admin startproject acapp：在当前目录下创建名为acapp的django项目 python3 manage.py runserver 0.0.0.0:8000：启动项目 打开settings.py，找到ALLOWED_HOSTS=[]，修改成ALLOWED_HOSTS=[\u0026quot;自己的服务器的公网IP\u0026quot;] 通过自己的服务器公网IP:8000 打开Django页面 创建管理员登录页面 在一级acapp文件夹下，python3 manage.py startapp XXX，XXX是可以自定义的app名，这里用game示例，这时候会多一个文件夹game，树形结构如图： |-- game | |-- __init__.py | |-- admin.py # 管理员页面 | |-- apps.py # 用的不多 | |-- migrations # 存储数据库 | | `-- __init__.py | |-- models.py # 定义网站里的数据库表 | |-- tests.py | `-- views.py # 视图，即函数 python3 manage.py migrate：将所有修改更新进数据库 创建一个 管理员用户： $ python3 manage.py createsuperuser \u0026gt; Username (leave blank to use \u0026#39;acs\u0026#39;): admin \u0026gt; Email address: \u0026gt; Password: 123456 \u0026gt; Password (again): 123456 \u0026gt; Superuser created successfully. 然后利用该 管理员用户 登录 admin 页面，即可成功登陆\n创建用户登录页面 game 下的各个文件作用 templates目录：管理 html 文件 urls目录：管理路由，即链接与函数的对应关系 (接收链接，调用相对应的函数) views目录：管理 http 函数（接收浏览器请求，返回字符串至浏览器） models目录：管理数据库数据 static目录：管理静态文件 consumers目录：管理websocket函数 实现一个路由重定向 url 输入网址 -\u0026gt; acapp.urls -\u0026gt; game.urls -\u0026gt; game.views.index -\u0026gt; 展示页面 game.views\n这其中，HttpResponse()内部使用html的语法，返回的响应就直接用这个字符串作为页面，转换成html\nfrom django.http import HttpResponse def index(request): line1 = \u0026#39;\u0026lt;h1 style=\u0026#34;text-align: center\u0026#34;\u0026gt; 第一个网页 \u0026lt;/h1\u0026gt;\u0026#39; return HttpResponse(line1) game.urls\n这其中，path('PATH', function, name)的含义是，在用户访问网站的时候，如果是网站/game/PATH，就会调用function，名字为name，这是在/game/目录下的调用，所以这个PATH是在/game/的基础上的相对路径，所以他的绝对路径是网站/game/PATH\nfrom django.urls import path from game.views import index urlpatterns = [ path(\u0026#34;\u0026#34;, index, name=\u0026#34;index\u0026#34;), ] acapp.urls\n这其中，path('PATH', include('game.urls'))的含义是：在用户访问网站的时候，如果是网站/PATH，就会走到/game/urls，并根据/game/urls.py来跑路由，就是说，用户在访问网站/的时候，由于此时调用的函数是include('game.urls')，所以访问网站/相当于根据game/urls访问\nfrom django.contrib import admin from django.urls import path, include urlpatterns = [ path(\u0026#39;\u0026#39;, include(\u0026#39;game.urls\u0026#39;)), path(\u0026#39;admin/\u0026#39;, admin.site.urls), ] 然后直接打开 ip:socket 可以直接显示 index 返回的网页\n创建菜单界面 3. 创建菜单界面 | 讲义 3.1 上课笔记 | 大家好今天是 3.1 上课笔记 | 栎 构建项目框架 项目系统设计 menu：菜单页面 playground：游戏界面 settings：设置界面 项目文件结构 . |-- README.md |-- acapp | |-- __init__.py # 文件夹在加上 __init__.py 文件后，python 便可以通过 import 来引用该文件夹 | |-- asgi.py | |-- settings.py | |-- urls.py | `-- wsgi.py |-- db.sqlite3 |-- game | |-- __init__.py | |-- admin.py | |-- apps.py | |-- migrations | | `-- __init__.py | |-- models | | `-- __init__.py | |-- static | | |-- css | | | `-- game.css # 一般一个工程，只有一个 css 文件就足够了 | | |-- image | | | `-- menu | | | `-- background.gif | | `-- js | | |-- dist | | | `-- game.js | | `-- src | | `-- zbase.js # 总的 js 文件，命名以 z 开头会自动在字典序最后 | |-- templates | | `-- multiends | | `-- web.html | |-- tests.py | |-- urls | | |-- __init__.py | | |-- index.py | | |-- menu | | | |-- __init__.py | | | `-- index.py | | |-- playground | | | |-- __init__.py | | | `-- index.py | | `-- settings | | |-- __init__.py | | `-- index.py | `-- views | |-- __init__.py | |-- index.py | |-- menu | | `-- __init__.py | |-- playground | | `-- __init__.py | `-- settings | `-- __init__.py |-- manage.py `-- scripts `-- compress_game_js.sh js 文件管理 一般一个工程会有很多个 .js 源文件，为了加快网络的传输，也为了每次写新的 .js 文件不用每个 html 都额外引入一次\n考虑用一个 src 源文件夹来存储所有的 .js 源文件\n然后用 dist 文件夹来存放由 src 下所有源文件整合生成的一个目标 .js 文件\n这样既实现了快速传输的好处，也方便了后续编写 html 文件时，引入 .js 的便利\n创建一个脚本实现上述 整合 的功能 ~/acapp/scripts/compress_game_js.sh\n#! /bin/bash JS_PATH=/home/acs/acapp/game/static/js/ JS_PATH_DIST=${JS_PATH}dist/ JS_PATH_SRC=${JS_PATH}src/ find $JS_PATH_SRC -type f -name \u0026#39;*.js\u0026#39; | sort | xargs cat \u0026gt; ${JS_PATH_DIST}game.js html 文件管理 在 templates 文件夹下创建 menu、playground、settings、multiends 四个文件夹，用于存储三个模块和终端的 html 文件\n在 multiends 下创建 web.html 文件\n{% load static %} \u0026lt;!-- Django 中引入全局setting里的变量 static 的语法--\u0026gt; \u0026lt;head\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.acwing.com/static/jquery-ui-dist/jquery-ui.min.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.acwing.com/static/jquery/js/jquery-3.3.1.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- 上述两句引入 jQuery 库 --\u0026gt; \u0026lt;!-- 使用引入的变量 static 的语法如下 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;{% static \u0026#39;css/game.css\u0026#39; %}\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;{% static \u0026#39;js/dist/game.js\u0026#39; %}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- 分别引入 css 文件和总的 js 文件 --\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body style=\u0026#34;margin: 0\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;ac_game_12345678\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; $(document).ready(function(){ let ac_game = new AcGame(\u0026#34;ac_game_12345678\u0026#34;) }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; views 视图管理 在 views 文件夹下新建三个模块的视图文件夹\n写一个 index.py 文件，目的是在 web 端被访问时，返回上面写的 web.html 文件\nfrom django.shortcuts import render def index(request): return render(request, \u0026#34;multiends/web.html\u0026#34;) urls 路由管理 /-- \u0026#34;\u0026#34; -- index / -- \u0026#34;menu/\u0026#34; -- menu.index / \u0026#34;\u0026#34; --\u0026gt; \u0026#34;game.url\u0026#34; --\u0026gt; / \\ -- \u0026#34;playground/\u0026#34; -- playground.index id:scoket -\u0026gt; \\-- \u0026#34;settings/\u0026#34; -- settings.index \\ \\ \u0026#34;/admin\u0026#34; -- 到达管理员页面 ~/acapp/acapp/urls.py\nfrom django.contrib import admin from django.urls import path, include urlpatterns = [ path(\u0026#39;\u0026#39;, include(\u0026#39;game.urls.index\u0026#39;)), path(\u0026#39;admin/\u0026#39;, admin.site.urls), ] ~/acapp/game/urls/index.py\nfrom django.urls import path, include from game.views.index import index urlpatterns = [ path(\u0026#34;\u0026#34;, index, name=\u0026#34;index\u0026#34;), path(\u0026#34;menu/\u0026#34;, include(\u0026#34;game.urls.menu.index\u0026#34;)), path(\u0026#34;playground/\u0026#34;, include(\u0026#34;game.urls.playground.index\u0026#34;)), path(\u0026#34;settings/\u0026#34;, include(\u0026#34;game.urls.settings.index\u0026#34;)) ] 网页渲染流程 根据用户的链接，首先进入acapp/urls.py，根据path再进入game/urls/index.py，再根据path进入下一层url或调用相对应的views中的index.py函数，函数接收参数，在网页端渲染templates/multiends下的web.html，html中有JS执行\n注意：本项目为前后端分离，即通过JS在client中渲染项目(动态生成页面)，而不是在server渲染项目\n修改全局配置 设置时区 修改项目的 UTC 时间为 CN 时间\n$ vim /acapp/settings.py ****** TIME_ZONE = \u0026#39;Asia/Shanghai\u0026#39; # 原来默认是 UTC ****** 添加配置文件 将新创建的 game 下的 apps.py 中的 GameConfig 加到 settings.py 下\n$ vim /acapp/settings.py ****** INSTALLED_APPS = [ \u0026#39;game.apps.GameConfig\u0026#39;, ...... ] ****** 声明将静态文件路径 STATIC_ROOT 和 MEDIA_ROOT\n$ vim /acapp/settings.py ****** import os ...... STATIC_ROOT = os.path.join(BASE_DIR, \u0026#39;static\u0026#39;) STATIC_URL = \u0026#39;/static/\u0026#39; MEDIA_ROOT = os.path.join(BASE_DIR, \u0026#39;media\u0026#39;) MEDIA_URL = \u0026#39;/media/\u0026#39; ****** 创建菜单 menu 界面 搭建菜单 menu 界面的框架 我们采用的 前后端分离式 开发，所有的 html 渲染都要求在前端完成\n开发流程就是，先在 html 里创建好一个有 id 的 div\n然后利用 js 文件，捕获到该 div，并进行 渲染\n/templates/multiends/web.html\n... \u0026lt;div id=\u0026#34;ac_game_12345678\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; $(document).ready(function(){ let ac_game = new AcGame(\u0026#34;ac_game_12345678\u0026#34;) }) \u0026lt;/script\u0026gt; ... js/src/zbase.js\nclass AcGame { constructor(id) { this.id = id; this.$ac_game = $(\u0026#39;#\u0026#39; + id); this.menu = new AcGameMenu(this); } } js/src/menu/zbase.js\nclass AcGameMenu { constructor(root) { this.root = root; this.$menu = $(` \u0026lt;div class=\u0026#34;ac-game-menu\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; `); this.root.$ac_game.append(this.$menu); } css/game.css\n.ac-game-menu { width: 100%; height: 100%; background-image: url(\u0026#39;/static/image/menu/background.gif\u0026#39;); background-size: 100% 100%; user-select: none; } 这里的 代码逻辑 如下：\nhtml 页面执行到 js 代码，利用 AcGame类 创建对象 ac_game 同时传递参数 div 的 id AcGame 开始执行构造函数，在构造函数中，捕获 html 标签，并利用 AcGameMenu类 创建对象 menu，并将整个对象作为参数下传 AcGameMenu 开始执行构造函数，然后创建 html 代码，加到捕获到的 html 代码下 最终成功渲染出背景图片 设置菜单 menu 页面的内容 主要内容就是在主页面中，显示：单人模式、多人模式、设置，三个按钮的选项 js/src/menu/zbase.js\nclass AcGameMenu { constructor(root) { this.root = root; this.$menu = $(` \u0026lt;div class=\u0026#34;ac-game-menu\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;ac-game-menu-field\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;ac-game-menu-field-item ac-game-menu-field-item-single-mode\u0026#34;\u0026gt; 单人模式 \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;ac-game-menu-field-item ac-game-menu-field-item-multi-mode\u0026#34;\u0026gt; 多人模式 \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;ac-game-menu-field-item ac-game-menu-field-item-settings-mode\u0026#34;\u0026gt; 设置 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; `); this.root.$ac_game.append(this.$menu); this.$single_mode = this.$menu.find(\u0026#39;.ac-game-menu-field-item-single-mode\u0026#39;); this.$multi_mode = this.$menu.find(\u0026#39;.ac-game-menu-field-item-multi-mode\u0026#39;); this.$settings_mode = this.$menu.find(\u0026#39;.ac-game-menu-field-item-settings-mode\u0026#39;); } } css/game.css\n.ac-game-menu { width: 100%; height: 100%; background-image: url(\u0026#39;/static/image/menu/background.gif\u0026#39;); background-size: 100% 100%; user-select: none; } .ac-game-menu-field { width: 20vw; position: relative; top: 40vh; left: 19vh; } .ac-game-menu-field-item { height: 7vh; width: 18vw; color: white; font-size: 6vh; font-style: italic; padding: 2vh; margin: 1vh 0; cursor: pointer; text-align: center; background-color: rgba(39, 21, 28, 0.6); border-radius: 10px; letter-spacing: 0.5vw; } .ac-game-menu-field-item:hover { transform: scale(1.2); transition: 100ms; } 添加 \u0026lsquo;单人模式\u0026rsquo; 监听函数 —— 打开游戏界面 功能 这里要实现的 逻辑：\n点击 \u0026lsquo;单人模式\u0026rsquo; 按钮触发 click 事件，随即触发监听函数，开始执行 关闭 menu 页面 打开 playground 页面 因此，我们先简易的实现一个 playground 页面，方便调试该功能 js/src/playground/zbase.js\nclass AcGamePlayground { constructor(root) { this.root = root; this.$playground = $(`\u0026lt;div\u0026gt;游戏界面\u0026lt;/div\u0026gt;`); this.hide(); this.root.$ac_game.append(this.$playground); this.start(); } start() { } show() { //打开 playground 界面 this.$playground.show(); } hide() { //关闭 playground 界面 this.$playground.hide(); } } 在实现监听函数功能之前，先在 /src/zbase.js 即主 js 文件下，利用 AcGamePlayground 类创建好 playground 对象\n这样我们就能在前端，渲染出两个界面了，分别是：menu 和 playground\njs/src/zbase.js\nclass AcGame { constructor(id) { this.id = id; this.$ac_game = $(\u0026#39;#\u0026#39; + id); this.menu = new AcGameMenu(this); // 把 playground 对象也建好，这样我们就同时有两个界面了 this.playground = new AcGamePlayground(this); this.start(); } start() { } } 然后，我们开始实现 ac-game-menu-field-item-single-mode 标签的 click 事件的监听函数\n其功能之前讲过了，就是关闭 menu 页面，打开 playground 页面\njs/src/menu/zbase.js\nclass AcGameMenu { constructor(root) { this.root = root; this.$menu = $(` \u0026lt;div class=\u0026#34;ac-game-menu\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;ac-game-menu-field\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;ac-game-menu-field-item ac-game-menu-field-item-single-mode\u0026#34;\u0026gt; 单人模式 \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;ac-game-menu-field-item ac-game-menu-field-item-multi-mode\u0026#34;\u0026gt; 多人模式 \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;ac-game-menu-field-item ac-game-menu-field-item-settings-mode\u0026#34;\u0026gt; 设置 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; `); this.root.$ac_game.append(this.$menu); this.$single_mode = this.$menu.find(\u0026#39;.ac-game-menu-field-item-single-mode\u0026#39;); this.$multi_mode = this.$menu.find(\u0026#39;.ac-game-menu-field-item-multi-mode\u0026#39;); this.$settings_mode = this.$menu.find(\u0026#39;.ac-game-menu-field-item-settings-mode\u0026#39;); this.start(); } start() { this.add_listening_events(); } add_listening_events() { let outer = this; this.$single_mode.click(function(){ outer.hide(); // 关闭主页面 outer.root.playground.show(); // 打开游戏界面 }); } show() { //显示menu界面 this.$menu.show(); } hide() { //隐藏menu界面 this.$menu.hide(); } } 创建游戏界面 4.1 上课笔记 | Andrew1729 若修改static文件夹下的相关文件，需在~/acapp下执行./scripts/compress_game_js.sh来打包文件\n前端的模块化引入 由于在 html 代码部分，是将整个 game.js 文件引入\n这样会导致在 game.js 中定义的变量，会变成整个网页的 全局变量（之后可能会引起变量重名的诸多问题）\n因此，我们考虑使用 模块化引入 的功能，让网页只引入在 html 中需要的部分\n修改 web.html\n\u0026lt;!-- 首先，先删掉上面整个引入 game.js 的部分 --\u0026gt; \u0026lt;!-- 然后，下方创建对象的部分，先使用模块化引入 --\u0026gt; ...... \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import {AcGame} from \u0026#34;{% static \u0026#39;js/dist/game.js\u0026#39; %}\u0026#34; $(document).ready(function(){ let ac_game = new AcGame(\u0026#34;ac_game_12345678\u0026#34;) }) \u0026lt;/script\u0026gt; ...... 此外，还有修改引入的类，在前面加上 export，如下修改 js/src/zbase.js\nexport class AcGame { ...... } 这样，在全局中，只会出现引入的模块，其他的 .js 代码不会出现在全局中\n构建游戏界面框架 static/js/src/playground/zbase.js\n...... this.$playground = $(`\u0026lt;div class=\u0026#34;ac-game-playground\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;`); ...... game.css\n...... .ac-game-playground { height: 100%; width: 100%; user-select: none; // 禁用右键弹菜单 } 实现游戏引擎框架 游戏中，物体在移动，其实现原理是：每一个动作都会渲染多张图片出来，然后图片快速的切换，从而实现动的过程\n因此，需要先实现一个游戏引擎的基类 AcGameObject ，使得每帧能渲染一张图片出来\n该基类需要具备的功能有：\nstart() 在游戏开始的第一帧时需要执行的任务（一般是创建对象） update() 在游戏开始后的每一帧均会执行的任务（一般是渲染当前对象的各种状态） on_destroy() 删掉该物体前需要执行的任务（一般是删掉动画，或者给对手加分） destroy() 删掉该物体 根据上述逻辑，我们就可以基本搭建出来一个游戏引擎的基类了，具体如下： /static/js/playground/ac_game_object/zbase.js\nlet AC_GAME_OBJECTS = []; // 用于记录当前画布中，需要渲染的对象有哪些 class AcGameObject { constructor() { AC_GAME_OBJECTS.push(this); // 将当前新建的对象，加入到全局的画布中去，参与渲染 this.has_called_start = false; // 是否执行过 start 函数 this.timedelta = 0; // 当前帧距离上一帧的时间间隔 // 该数据记录是为了后续计算速度等参数的 } start() { // 只会在第一帧执行一次 } update() { // 每一帧均会执行一次 } on_destroy() { // 在被销毁前执行一次 } destroy() { // 删掉该物体 this.on_destroy(); //删掉该物体前，执行删前的操作 // 在全局渲染物体中，找到该物体，并将其删掉 for (let i = 0; i \u0026lt; AC_GAME_OBJECTS.length; i ++ ) { if (AC_GAME_OBJECTS[i] === this) { // 三等号，在js里额外加了一层类型相等约束 AC_GAME_OBJECTS.splice(i, 1); break; } } } } let last_timestamp; let AC_GAME_ANIMATION = function(timestamp) { // 回调函数，实现：每一帧重绘时，都会执行一遍 for (let i = 0; i \u0026lt; AC_GAME_OBJECTS.length; i ++ ) { let obj = AC_GAME_OBJECTS[i]; if (!obj.has_called_start) { // 如果还未执行初始帧动作，就先执行 obj.start(); obj.has_called_start = true; } else { // 执行过初始帧，就执行每一帧的任务 obj.timedelta = timestamp - last_timestamp; obj.update(); } } last_timestamp = timestamp; // 更新最后一次时间戳 requestAnimationFrame(AC_GAME_ANIMATION); } requestAnimationFrame(AC_GAME_ANIMATION); // JS的API，可以调用1帧里面的函数。(有些浏览器的一秒帧数不一定相等) 接下来所有的一切游戏，都是基于这个引擎的基类完成的\n实现游戏地图功能 目标：实现一个每一秒都在渲染的纯黑背景\n虽然现阶段要实现的地图较为简单，但为了后期的拓展性，故还是考虑新建一个文件夹来完成\n然后在 js 中，已经封装好了一个 canvas 的 api 来帮助实现背景画布，直接调用即可\n先铺开画布，然后设置为黑色\nstatic/js/playground/zbase.js\nclass AcGamePlayground { constructor(root) { ...... // $(\u0026#39;.playground\u0026#39;)对象已经在 css 文件里渲染出高宽了 // 现在把他的高宽存下来，往下传递 this.width = this.$playground.width(); this.height = this.$playground.height(); this.game_map = new GameMap(this); ...... } ..... } static/js/playground/game-map/zbase.js\nclass GameMap extends AcGameObject { // 继承自游戏引擎基类 constructor(playground) { super(); // 自函数功能：调用基类的构造函数 this.playground = playground; this.$canvas = $(`\u0026lt;canvas\u0026gt;\u0026lt;/canvas\u0026gt;`); // 创建一个canvas的jQuery对象，就是我们要实现的画布 this.ctx = this.$canvas[0].getContext(\u0026#39;2d\u0026#39;); // jQuery对象是一个数组，第一个索引是html对象 // 设置画布的宽高 this.ctx.canvas.width = this.playground.width; this.ctx.canvas.height = this.playground.height; this.playground.$playground.append(this.$canvas); } start() { } update() { // 游戏地图每帧都要渲染 this.render(); } render() { this.ctx.fillStyle = \u0026#34;rgba(0, 0, 0, 0.2)\u0026#34;; this.ctx.fillRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height); } } 实现玩家显示功能 毛坯版玩家显示，每个玩家定义成一个圆，然后渲染在前端\n需要对于玩家类定义多个参数，以方便日后拓展：\nx 当前位置的横坐标 y 当前位置的纵坐标 radius 当前的半径 speed 当前的速度 is_me 该对象是否是当前玩家操控的对象（一是区别于 bot，二是区别于 日后联机的其他玩家） static/js/playground/zbase.js\nclass AcGamePlayground { constructor(root) { ...... this.players = []; // 存放当前游戏中的所有玩家 // 将玩家加入游戏中 this.players.push(new Player(this, this.width / 2, this.height / 2, this.height * 0.05, \u0026#34;white\u0026#34;, this.height * 0.15, true)); ...... } ..... } static/js/playground/player/zbase.js\nclass Player extends AcGameObject { constructor(playground, x, y, radius, color, speed, is_me) { super(); // 把信息都存下来 this.playground = playground; this.ctx = this.playground.game_map.ctx; this.x = x; this.y = y; this.color = color; this.speed = speed; this.radius = radius; this.is_me = is_me; // 用于浮点数运算 this.eps = 0.1; } start() { } update() { this.render(); } render() { // 渲染一个圆 this.ctx.beginPath(); this.ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI, false); this.ctx.fillStyle = this.color; this.ctx.fill(); } on_destroy() { } } 实现玩家移动功能 移动的实现逻辑很简单，就是让每帧渲染的圆的位置发生移动即可\n上述简单逻辑的实现如下：\nclass Player extends AcGameObject { constructor(....) { ... this.vx = 1; this.vy = 1; ... } ... update() { this.x += x; this.y += y; this.render(); } } 然后我们来实现一个向鼠标点击位置移动的功能\n这就需要设置一个 click 事件的监听函数，分别传递：\n鼠标点击事件 鼠标点击位置的横坐标 鼠标点击位置的纵坐标 然后开始让圆的位置逐步向鼠标点击位置进行移动\nstart() { if (this.is_me) { // 对于用户玩家，加上监听函数 this.add_listening_events(); } } add_listening_events() { let outer = this; // 把鼠标右键调出菜单栏的功能关掉 this.playground.game_map.$canvas.on(\u0026#34;contextmenu\u0026#34;, function() { return false; }); // 把右键控制移动功能加上 this.playground.game_map.$canvas.mousedown(function(e) { // 左键:1 中键:2 右键:3 if (e.which === 3) { outer.move_to(e.clientX, e.clientY); } }); } 然后，我们来实现移动功能的函数 move_to(tx, ty)\nconstructor(...){ ... this.vx = 0; // x方向上的移动速度 this.vy = 0; // y方向上的移动速度 this.move_length = 0; // 剩余移动距离 ... } ... get_dist (x1, y1, x2, y2) { // 求两点的欧几里得距离 let dx = x2 - x1; let dy = y2 - y1; return Math.sqrt(dx * dx + dy * dy); } move_to(tx, ty) { // 计算移动距离 this.move_length = this.get_dist(this.x, this.y, tx, ty); // 计算移动角度，api接口：atan2(dy, dx) let angle = Math.atan2(ty - this.y, tx - this.x); // 位移 1 个单位长度（向着矢量方向移动到单位圆上） this.vx = Math.cos(angle); // 极直互化 this.vy = Math.sin(angle); } update() { // 浮点数精度运算 if (this.move_length \u0026lt; this.eps) { this.move_length = 0; this.vx = this.vy = 0; } else { // 计算单位帧里的移动距离 let moved = Math.min(this.move_length, this.speed * this.timedelta / 1000); this.x += this.vx * moved; this.y += this.vy * moved; // 还要减掉移动的距离 this.move_length -= moved; } this.render(); } ... 这样就实现了玩家的移动功能了，可以登录 id:socket 调试该功能\n实现火球技能的功能 火球对象的建立与玩家基本一致，直接照搬，在从细节上改改即可\njs/src/playground/skill/fireball/zbase.js\nclass FireBall extends AcGameObject { constructor(playground, player, x, y, radius, vx, vy, color, speed, move_length, damage) { super(); this.playground = playground; this.ctx = this.playground.game_map.ctx; this.player = player; this.x = x; this.y = y; this.vx = vx; this.vy = vy; this.radius = radius; this.color = color; this.speed = speed; this.move_length = move.length; this.damage = damage; this.eps = 0.1; } start() { } update() { if (this.move_length \u0026lt; this.eps) { this.destroy(); return false; } else { let moved = Math.min(this.move_length, this.speed * this.timedelta / 1000); this.x += this.vx * moved; this.y += this.vy * moved; this.move_length -= moved; } this.render(); } render() { this.ctx.beginPath(); this.ctx.arc(this.x, this.y, this.radius, 0, 2 * Math * Pi, false); this.ctx.fillStyle = this.color; this.ctx.fill(); } } 然后在玩家身上实现发火球的功能\n基本实现逻辑：当前选中了火球技能，鼠标左键点击一处，向该处发射一个火球\n因此，为了知道用户是否选择了技能，需要加一个键盘触发事件监听函数，然后加一个鼠标左键触发事件监听函数\n然后发射一个火球即可\njs/src/playground/player/zbase.js\nconstructor(...) { ... this.cur_skill = null; // 记录当前选择的技能 ... } add_listening_events() { ... this.playground.game_map.$canvas.mousedown(function(e) { // 左键:1 中键:2 右键:3 if (e.which === 3) { outer.move_to(e.clientX, e.clientY); } else if (e.which === 1) { // 鼠标左键事件 if (outer.cur_skill === \u0026#34;fireball\u0026#34;) { // 当前已经选中火球技能 outer.shoot_fireball(e.clientX, e.clientY); } } outer.cur_skill = null; // 清空当前技能 }); $(window).keydown(function(e) { if (e.which === 81) { // 键盘按下事件 outer.cur_skill = \u0026#34;fireball\u0026#34;; return false; } }); } shoot_fireball(tx, ty) { // 确定火球的参数 let x = this.x, y = this.y; // 火球发射点就是当前玩家的位置 let radius = this.playground.height * 0.01; let angle = Math.atan2(ty - this.y, tx - this.x); let vx = Math.cos(angle), vy = Math.sin(angle); let color = \u0026#34;orange\u0026#34;; let speed = this.playground.height * 0.5; let move_length = this.playground.height * 1.0; let damage = this.playground.height * 0.01; new FireBall(this.playground, this, x, y, radius, vx, vy, color, speed, move_length, damage); } 这样就成功实现了玩家发射火球的功能了\n实现单人模式下的人机功能 先创建好 5 个人机 playground/zbase.js\n... //创建好 5 个人机 for (len i = 0; i \u0026lt; 5; i ++ ) { this.players.push(new Player(this, this.width / 2, this.height / 2, this.height * 0.05, \u0026#34;blue\u0026#34;, this.height * 0.15, false)); } ... 这样创建出来的 5 个人机是不会行动的\n我们写一个简易的 AI 程序，让他们也会移动\n这里实现的逻辑是：每次随机一个目的地，向目的地移动，然后再随机一个目的地，循环下去\n根据该逻辑，修改两个函数即可\nplayground/player/zbase.js\n... start() { if (this.is_me) { // 对于用户玩家，加上监听函数 this.add_listening_events(); } else { let tx = Math.random() * this.playground.width; let ty = Math.random() * this.playground.height; this.move_to(tx, ty); } } ... update() { if (this.move_length \u0026lt; this.eps) { this.move_length = 0; this.vx = this.vy = 0; if (!this.is_me) { // 如果是人机，停下来时再随机一个方向前进 let tx = Math.random() * this.playground.width; let ty = Math.random() * this.playground.height; this.move_to(tx, ty); } } ... } on_destroy() { for (let i = 0; i \u0026lt; this.playground.players.length; i ++ ) { if (this.playground.players[i] === this) { this.playground.players.splice(i, 1); } } } 实现技能命中效果（碰撞检测功能） 实现逻辑：检测两个圆的中心距离是否小于两个圆的半径之和\n小于等于时，代表发生碰撞，开始执行命中效果：\n被击中用户掉血 被击中用户收到向后击退效果 碰撞检测写在火球类里，击退效果写在玩家类里\nfireball/zbase.js\nupdate() { if (...) { ... } else { ... // 碰撞检测 for (let i = 0; i \u0026lt; this.playground.players.length; i ++ ) { let player = this.playground.players[i]; if (this.player !== player \u0026amp;\u0026amp; this.is_collision(player)) { // 碰撞发生一定是在非施法者身上 this.attack(player); // 火球命中，目标玩家执行击退效果 } } } this.render(); } get_dist(x1, y1, x2, y2) { // 获得两点的欧几里得距离 let dx = x2 - x1; let dy = y2 - y1; return Math.sqrt(dx * dx + dy * dy); } is_collision(player) { // 检测两个圆的中心距离是否小于两个圆的半径之和 let distance = this.get_dist(this.x, this.y, player.x, player.y); if (distance \u0026lt; (this.radius + player.radius)) return true; return false; } attack(player) { // 火球命中，目标玩家执行击退效果 let angle = Math.atan2(player.y - this.y, player.x - this.x); // 计算角度 player.is_attacked(angle, this.damage); // 火球命中，目标玩家执行击退效果 this.destroy(); // 火球命中后，自然消失 } 被击退的时候，原来的移动速度应该置为 0，当前的移动应该转为向被击中方向上的移动 player/zbase.js\nis_attacked(angle, damage) { this.radius -= damage; // 受伤，半径减少 if (this.radius \u0026lt; 10) { // 当半径小于10像素时，代表死亡 this.destroy(); return false; } // 开始执行击退效果 this.damage_vx = Math.cos(angle); this.damage_vy = Math.sin(angle); this.damage_speed = damage * 100; this.speed *= 0.5; // 被击中以后移动速度减半 } update() { if (this.damage_speed \u0026gt; this.eps) { // 当前仍处于击退效果中 this.vx = this.vy = 0; this.move_length = 0; this.x += this.damage_vx * this.damage_speed * this.timedelta / 1000; this.y += this.damage_vy * this.damage_speed * this.timedelta / 1000; this.damage_speed *= this.friction; // 击退速度乘以摩擦系数，已达到削减的目的 } else { ... } ... } 被击中以后的粒子效果特效 实现逻辑：被击中以后，在玩家附近随机生成一些粒子小球\n因此我们要先实现 粒子小球 对象\nstatic/js/src/playground/particle/zbase.js\nclass Particle extends AcGameObject { constructor(playground, x, y, radius, vx, vy, color, speed) { super(); this.playground = playground; this.ctx = this.playground.game_map.ctx; this.x = x; this.y = y; this.radius = radius; this.vx = vx; this.vy = vy; this.color = color; this.speed = speed; this.friction = 0.9; } start() { } update() { if (this.speed \u0026lt; this.eps) { this.destroy; return false; } this.x += this.vx * this.speed * this.timedelta / 1000; this.y += this.vy * this.speed * this.timedelta / 1000; this.speed *= this.friction; this.render(); } render() { this.ctx.beginPath(); this.ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI, false); this.ctx.fillStyle = this.color; this.ctx.fill(); } } 然后我们在被击退功能模块，实现生成粒子小球的效果\n粒子小球释放弧度为 $[0,2π)$ 的随机数 粒子小球的 x, y 分量比率根据弧度来设定 粒子小球的起始坐标应与玩家的坐标相同 粒子小球的颜色与玩家颜色相同 粒子小球的速度为玩家移动速度的 $10$ 倍 js/src/playground/player/zbase.js\nis_attacked(angle, damage) { // 粒子小球效果 for (let i = 0; i \u0026lt; 10 + Math.random() * 5; i ++ ) { let x = this.x, y = this.y; let radius = this.radius * Math.random() * 0.1; let angle = 2 * Math.PI * Math.random(); let vx = Math.cos(angle), vy = Math.sin(angle); let color = this.color; let speed = this.speed * 10; new Particle(this.playground, x, y, radius, vx, vy, color, speed); } ... } 一些小优化 人机随机颜色 js/src/playground/zbase.js\nconstructor(root) { ...... // 创建好 5 个人机 for (let i = 0; i \u0026lt; 5; i ++ ) { this.players.push(new Player(this, this.width / 2, this.height / 2, this.height * 0.05, this.get_random_color(), this.height * 0.15, false)); } ...... } get_random_color() { let colors = [\u0026#34;blue\u0026#34;, \u0026#34;red\u0026#34;, \u0026#34;pink\u0026#34;, \u0026#34;grey\u0026#34;, \u0026#34;green\u0026#34;]; return colors[Math.floor(Math.random() * 5)]; } 人机AI随机攻击操作 js/src/playground/player/zbase.js\nconstructor (...) { ... this.spent_time = 0; // 初始人机冷却攻击时间 } ... update() { this.spent_time += this.timedelta / 1000; if (!this.is_me \u0026amp;\u0026amp; this.spent_time \u0026gt; 4 \u0026amp;\u0026amp; Math.random() * 180 \u0026lt; 1) { let player = this.playground.players[Math.floor(Math.random() * this.playground.players.length)]; this.shoot_fireball(player.x, player.y); } 部署nginx与对接acappஐ 5. 部署nginx与对接acapp | 讲义 5.1 上课笔记 | Andrew1729 5.1. 上课笔记 | 菊花 Ngnix 介绍 nginx 和uwsgi的区别与作用 Nginx是什么？ Nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器\nNginx可以作为一个HTTP服务器进行网站的发布处理，另外Nginx可以作为反向代理进行负载均衡的实现\nNginx中HttpUwsgiModule的作用是与uWSGI服务器进行交换\nuWSGI是什么？ uWSGI是一个全功能的HTTP服务器，实现了WSGI、uwsgi、http等协议\n它要做的就是把HTTP协议转化成语言支持的网络协议。比如把HTTP协议转化成WSGI协议，让Python可以直接使用\nWSGI协议是Python 语言定义的 Web 服务器和 Web 应用程序或框架之间的一种简单而通用的接口\n简单来说uWSGI就是用来沟通nginx和django的一座桥梁\nNginx+uWSGI+Diango 工作流程 nginx 是对外的服务接口，外部浏览器通过url访问nginx\nnginx 接收到浏览器发送过来的http请求，将包进行解析\n分析url，如果是静态文件请求就直接访问用户给nginx配置的静态文件目录，直接返回用户请求的静态文件\n如果不是静态文件，而是一个动态的请求，那么nginx就将请求转发给uwsgi，uwsgi 接收到请求之后将包进行处理，处理成wsgi可以接受的格式，并发给wsgi，wsgi 根据请求调用应用程序的某个文件，某个文件的某个函数，最后处理完将返回值再次交给wsgi，wsgi将返回值进行打包，打包成uwsgi能够接收的格式，uwsgi接收wsgi 发送的请求，并转发给nginx, nginx最终将返回值返回给浏览器\nuwsgi服务的开启\u0026amp;\u0026amp;关闭 在~/acapp启动uwsgi服务：uwsgi --ini scripts/uwsgi.ini 关闭uwsgi服务：sudo pkill -f uwsgi -9 针对 acapp 的优化 打包脚本优化 由于现在 发布版本的脚本文件 用的是打包在根目录里的 static 文件夹\n每次修改好 static 文件夹后，不仅需要对 js 文件打包，还需要对 static 文件夹打包\n不放把 \u0026ldquo;将static文件夹打包\u0026rdquo; 的 shell 代码一起加入 js 打包脚本中，从而实现一键打包\nscripts/compress_game_js.sh\n#! /bin/bash JS_PATH=/home/acs/acapp/game/static/js/ JS_PATH_DIST=${JS_PATH}dist/ JS_PATH_SRC=${JS_PATH}src/ find $JS_PATH_SRC -type f -name \u0026#39;*.js\u0026#39; | sort | xargs cat \u0026gt; ${JS_PATH_DIST}game.js echo \u0026#34;yes\u0026#34; | python3 manage.py collectstatic 鼠标点击事件的相对偏移 由于写游戏界面的时候，玩家移动是按照鼠标相对于当前整个浏览器取的位置参数 e.clientX\n而 acapp 里，每个应用是一个小窗口，鼠标点击位置的参数应当是 相对于整个游戏窗口的位置参数\n所有会导致出现，点击的位置与移动的位置不同，这里需要做出小优化\n优化的逻辑 :\n$clientX−窗口左侧到浏览器左侧的距离=玩家的目标X$ $clientY−窗口上侧到浏览器上侧的距离=玩家的目标Y$ 这就要用到一个 js 的 API 了 : getBoundingClientRect() rectObject = object.getBoundingClientRect(); rectObject.top : 元素上边到视窗上边的距离; rectObject.right : 元素右边到视窗左边的距离; rectObject.bottom : 元素下边到视窗上边的距离; rectObject.left : 元素左边到视窗左边的距离; rectObject.width : 是元素自身的宽 rectObject.height : 是元素自身的高 player/zbase.js\n... add_listening_events() { ... this.playground.game_map.$canvas.mousedown(function(e) { // 创建 rect 对象 const rect = outer.ctx.canvas.getBoundingClientRect(); if (e.which === 3) { // 调整偏移量 outer.move_to(e.clientX - rect.left, e.clientY - rect.top); } else if (e.which === 1) { if (outer.cur_skill === \u0026#34;fireball\u0026#34;) { // 调整偏移量 outer.shoot_fireball(e.clientX - rect.left, e.clientY - rect.top); } } ... }); ... } ... 将菜单界面重新设为主界面 js/zbase.js 的注释取消，使之创建出 menu 对象\njs/playground/zbase.js 的注释取消，并设置逻辑，让 playground 打开后，才进行游戏界面初始化\nclass AcGamePlayground { constructor(root) { this.root = root; this.$playground = $(`\u0026lt;div class=\u0026#34;ac-game-playground\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;`); this.hide(); // 初始时隐藏 // 游戏界面生成代码在下面展示 playground 时执行 this.start(); } ... show() { // 打开 playground 界面 this.$playground.show(); // 开始生成游戏界面 this.root.$ac_game.append(this.$playground); this.width = this.$playground.width(); this.height = this.$playground.height(); this.game_map = new GameMap(this); this.players = []; // 存放当前游戏中的所有玩家 // 将玩家加入游戏中 this.players.push(new Player(this, this.width / 2, this.height / 2, this.height * 0.05, \u0026#34;white\u0026#34;, this.height * 0.15, true)); // 创建好 5 个人机 for (let i = 0; i \u0026lt; 5; i ++ ) { this.players.push(new Player(this, this.width / 2, this.height / 2, this.height * 0.05, this.get_random_color(), this.height * 0.15, false)); } } ... } 调整 css 文件，适应窗口 在设置 web 网页的时候，有些设置了绝对值，可能对于窗口化的 acapp 显示效果差\n将他们修改成相对数值\ngame.css\n... .ac-game-menu-field { ... top: 40%; left: 20%; } .ac-game-menu-field-item { height: 6vh; ... font-size: 4vh; ... } ... 创建账号系统 6. 创建账号系统 | 讲义\n用户名密码登录 6.1 用户名密码登录 | 讲义 6.1 上课笔记 | Andrew1729 6.1 上课笔记 | 吃饱喝足不学习 客户端请求与Django响应流程 用户在客户端通过$.ajax发送请求，根据urls路由到对应的views中的函数，处理request后返回JsonResponse 至客户端\n前期准备工作 做开发，先开启调试模式，如果不开启，服务器一旦运行错误，就只返回 Error 报错 settings.py\n... DEBUG = True ... 不过 django 自带的 User 表并不能满足我们的需求，因此我们需要自己额外建表\n创建用户表 所有的数据表都存在 models 里\n我们在 models 里创建一个 player 文件夹，用于存储所有的 player 相关的表\n然后对文件夹初始化 __init__.py，接着扩充成一个我们需要的数据表\ngame/models/player/player.py\nfrom django.db import models from django.contrib.auth.models import User class Player(models.Model): # Player 类继承自 Model 类 user = models.OneToOneField(User, on_delete=models.CASCADE) # 说明Player是从User表扩充过来的，每一个player都与一个user是一一对应关联关系 # 后一个参数是指，当user被删除后，对应的player也要被删除 # （感觉就是外键的意思） photo = models.URLField(max_length=256, blank=True) # 用于存储用户的头像的url # 指定每个player数据展示在前台的数据 def __str__(self): return str(self.user) # 展示用户的用户名 将定义的表，注册到后台 admin 页面中\ngame/admin.py\n... from game.models.player.player import Player admin.site.register(Player) 然后将创建的数据表更新到 django 的数据库中去\n$ python3 manage.py makemigrations \u0026gt; Migrations for \u0026#39;game\u0026#39;: \u0026gt; game/migrations/0001_initial.py \u0026gt; - Create model Player $ $ python3 manage.py migrate \u0026gt; Operations to perform: \u0026gt; Apply all migrations: admin, auth, contenttypes, game, sessions \u0026gt; Running migrations: \u0026gt; Applying game.0001_initial... OK 然后重启一下服务，就可以在管理员页面看到新建的数据库了\n实现客户端的类型判别（ACAPP or WEB） 由于我们实现的项目是前后端分离类型，因此对于不同的客户端，前端要控制生成不同的页面\n为了增强扩展性，故这里要实现客户端类型的判别\ny总 已经提前写好了 ACAPP 的接口，如果用户用的是 ACAPP 访问，则在新建对象 ac_game 时，会额外传递一个参数\n我们只需按照这个接口去完成扩充即可\n之后写小程序之类的同理，额外传一个接口\njs/zbase.js\nexport class AcGame { constructor(id, AcWingOS) { this.id = id; this.$ac_game = $(\u0026#39;#\u0026#39; + id); this.AcWingOS = AcWingOS; //如果是acapp端，该变量就会带着一系列y总提供的接口 this.menu = new AcGameMenu(this); this.playground = new AcGamePlayground(this); this.start(); } start() { } } 构建登录功能框架 基本逻辑 : 用户访问页面 -\u0026gt; 进入登录页面 -\u0026gt; 提交登录信息 -\u0026gt; 核对登录信息 -\u0026gt; 返回登陆结果和其他信息\n每实现一个函数，就需要实现三个部分：\nviews : 实现具体的调用数据库的逻辑 urls : 实现一个路由 js : 前端实现GET上述接口的过程 欲实现流程 :\n用户访问网站，通过先前完成的路由，访问到 web.html web.html 中的 js 部分创建了一个 AcGame 对象 AcGame 对象创建的过程中，生成了 Settings 对象 Settings 对象创建完成后，调用 Settings.start() 函数 Settings.start() 函数调用了 Settings.getinfo() 函数 Settings.getinfo() 函数中执行了 ajax 向 getinfo 接口发起一个含参数 platform 的 GET 请求 通过 urls 路由的实现，最终定位到 views/settings/getinfo.py 文件的 getinfo(request) 函数 根据传递过来的 platform 函数，实现不同的 JsonResponse 返回 Settings.getinfo() 接受到了 response 完成上述基本逻辑 views views/settings/getinfo.py\nfrom django.http import JsonResponse from game.models.player.player import Player def getinfo_acapp(request): player = Player.objects.all()[0] # 取出数据库中第一个用户(调试该功能) return JsonResponse({ \u0026#39;result\u0026#39;: \u0026#34;success\u0026#34;, \u0026#39;username\u0026#39;: player.user.username, \u0026#39;photo\u0026#39;: player.photo, }) def getinfo_web(request): player = Player.objects.all()[0] # 取出数据库中第一个用户(调试该功能) return JsonResponse({ \u0026#39;result\u0026#39;: \u0026#34;success\u0026#34;, \u0026#39;username\u0026#39;: player.user.username, \u0026#39;photo\u0026#39;: player.photo, }) def getinfo(request): # 处理请求 platform = request.GET.get(\u0026#39;platform\u0026#39;) # 根据请求的平台不同，进行不同返回处理 if platform == \u0026#34;ACAPP\u0026#34;: return getinfo_acapp(request) elif platform == \u0026#34;WEB\u0026#34;: return getinfo_web(request) urls urls/settings/index.py\nfrom django.urls import path from game.views.settings.getinfo import getinfo urlpatterns = [ path(\u0026#34;getinfo/\u0026#34;, getinfo, name=\u0026#34;settings_getinfo\u0026#34;), ] 路由建立好以后，访问 xxxx/settings/getinfo，可以看到 getinfo.py 返回的 JSON 类型的 JSONResponse\njs 网页刚访问时，应先将 menu 关闭，然后打开登录界面，随意先修改一个让 menu 初始关闭\nstatic/js/src/menu/zbase.js\nclass AcGameMenu { constructor(root) { ... this.$menu.hide(); ... } ... static/js/src/settings/zbase.js\nclass Settings { constructor(root) { this.root = root; this.platform = \u0026#34;WEB\u0026#34;; if (this.root.AcWingOS) this.platform = \u0026#34;ACAPP\u0026#34;; this.start(); } start() { this.getinfo(); } register() { // 打开注册界面 } login() { // 打开登录界面 } getinfo() { let outer = this; $.ajax({ url: \u0026#34;https://app1117.acapp.acwing.com.cn/settings/getinfo/\u0026#34;, type: \u0026#34;GET\u0026#34;, data: { platform: outer.platform, }, success: function(resp) { console.log(resp); if (resp.result === \u0026#34;success\u0026#34;) { // 登录成功，关闭登录界面，打开主菜单 outer.hide(); outer.root.menu.show(); } else { outer.login(); } } }); } hide() { } show() { } } 然后不要忘记在 根js 下创建对象\nexport class AcGame { constructor(id, AcWingOS) { ... this.settings = new Settings(this); ... } ... } 这样基本框架就完成了\n完善 HTTP 请求的函数 如果用户未登录，返回信息 \u0026ldquo;not login\u0026rdquo;\n如果用户登录，返回信息 \u0026ldquo;success\u0026rdquo; 以及用户名和头像\nviews/setting/getinfo.py\ndef getinfo_web(request): user = request.user if not user.is_authenticated: # 未登录 return JsonResponse({ \u0026#39;result\u0026#39;: \u0026#34;not login\u0026#34; }) else: # 已登录 player = Player.objects.get(user=user) return JsonResponse({ \u0026#39;result\u0026#39;: \u0026#34;success\u0026#34;, \u0026#39;username\u0026#39;: player.user.username, \u0026#39;photo\u0026#39;: player.photo, }) 注意前后台是一个登录系统，因此要先退掉后台，再测试\n将用户头像渲染到玩家上 将返回的 JsonResponse 存到 Settings 类的变量中 settings/zbase.js\nclass Settings { constructor(root) { ... this.username = \u0026#34;\u0026#34;; this.photo = \u0026#34;\u0026#34;; ... } ... getinfo() { let outer = this; $.ajax({ ... success: function(resp) { ... if (resp.result === \u0026#34;success\u0026#34;) { outer.username = resp.username; outer.photo = resp.photo; ... } .. } }); } } 然后在 Player 里把用户的头像渲染到对应的玩家上\nplayground/player/zbase.js\nclass Player { constructor(...) { ... this.img = new Image(); this.img.src = this.playground.root.settings.photo; } ... render() { if (this.is_me) { this.ctx.save(); this.ctx.beginPath(); this.ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false); this.ctx.stroke(); this.ctx.clip(); this.ctx.drawImage(this.img, this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2); this.ctx.restore(); } else { this.ctx.beginPath(); this.ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI, false); this.ctx.fillStyle = this.color; this.ctx.fill(); } } ... } 实现登录界面的前端 先完成登录界面显示的逻辑\nsettings/zbase.js\nclass Settings { ... register() { // 打开注册界面 this.$login.hide(); this.$register.show(); } login() { // 打开登录界面 this.$register.hide(); this.$login.show(); } ... hide() { this.$settings.hide(); } show() { this.$settings.show(); } } 实现前端的基础框架 settings/zbase.js\nclass Settings { constructor(root) { ... this.$settings = $(` \u0026lt;div class=\u0026#34;ac-game-settings\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-login\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-title\u0026#34;\u0026gt; 登录 \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-username\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-item\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;用户名\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-password\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-item\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; placeholder=\u0026#34;密码\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-submit\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-item\u0026#34;\u0026gt; \u0026lt;button\u0026gt;登录\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-error-message\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-option\u0026#34;\u0026gt; 注册 \u0026lt;/div\u0026gt; \u0026lt;br\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-acwing\u0026#34;\u0026gt; \u0026lt;img width=\u0026#34;30\u0026#34; src=\u0026#34;https://app165.acapp.acwing.com.cn/static/image/settings/acwing_logo.png\u0026#34;\u0026gt; \u0026lt;br\u0026gt; \u0026lt;div\u0026gt; AcWing一键登录 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-register\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-title\u0026#34;\u0026gt; 注册 \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-username\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-item\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;用户名\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-password ac-game-settings-password-first\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-item\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; placeholder=\u0026#34;密码\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-password ac-game-settings-password-second\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-item\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; placeholder=\u0026#34;确认密码\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-submit\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-item\u0026#34;\u0026gt; \u0026lt;button\u0026gt;注册\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-error-message\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-option\u0026#34;\u0026gt; 登录 \u0026lt;/div\u0026gt; \u0026lt;br\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-acwing\u0026#34;\u0026gt; \u0026lt;img width=\u0026#34;30\u0026#34; src=\u0026#34;https://app165.acapp.acwing.com.cn/static/image/settings/acwing_logo.png\u0026#34;\u0026gt; \u0026lt;br\u0026gt; \u0026lt;div\u0026gt; AcWing一键登录 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; `); this.$login = this.$settings.find(\u0026#34;.ac-game-settings-login\u0026#34;); this.$login_username = this.$login.find(\u0026#34;.ac-game-settings-username input\u0026#34;); this.$login_password = this.$login.find(\u0026#34;.ac-game-settings-password input\u0026#34;); this.$login_submit = this.$login.find(\u0026#34;.ac-game-settings-submit button\u0026#34;); this.$login_error_message = this.$login.find(\u0026#34;.ac-game-settings-error-message\u0026#34;); this.$login_register = this.$login.find(\u0026#34;.ac-game-settings-option\u0026#34;); this.$login.hide(); this.$register = this.$settings.find(\u0026#34;.ac-game-settings-register\u0026#34;); this.$register_username = this.$register.find(\u0026#34;.ac-game-settings-username input\u0026#34;); this.$register_password = this.$register.find(\u0026#34;.ac-game-settings-password-first input\u0026#34;); this.$register_password_confirm = this.$register.find(\u0026#34;.ac-game-settings-password-second input\u0026#34;); this.$register_submit = this.$register.find(\u0026#34;.ac-game-settings-submit button\u0026#34;); this.$register_error_message = this.$register.find(\u0026#34;.ac-game-settings-error-message\u0026#34;); this.$register_login = this.$register.find(\u0026#34;.ac-game-settings-option\u0026#34;); this.$register.hide(); this.root.$ac_game.append(this.$settings); ... } ... } 对应的 css 文件部分：\ncss/game.css\n.ac-game-settings { width: 100%; height: 100%; background-image: url(\u0026#34;/static/image/menu/background.gif\u0026#34;); background-size: 100% 100%; user-select: none; } .ac-game-settings-login { height: 41vh; width: 20vw; position: relative; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0, 0, 0, 0.7); border-radius: 5px; } .ac-game-settings-title { color: white; font-size: 3vh; text-align: center; padding-top: 2vh; margin-bottom: 2vh; } .ac-game-settings-username { display: block; height: 7vh; } .ac-game-settings-password { display: block; height: 7vh; } .ac-game-settings-submit { display: block; height: 7vh; } .ac-game-settings-acwing { display: block; height: 7vh; } .ac-game-settings-item { width: 100%; height: 100%; } .ac-game-settings-item \u0026gt; input { width: 90%; line-height: 3vh; position: relative; top: 50%; left: 50%; transform: translate(-50%, -50%); } .ac-game-settings-item \u0026gt; button { color: white; width: 90%; line-height: 3vh; position: relative; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: #4CAF50; border-radius: 5px; } .ac-game-settings-error-message { color: red; font-size: 0.8vh; display: inline; float: left; padding-left: 1vw; } .ac-game-settings-option { color: white; font-size: 2vh; display: inline; float: right; padding-right: 1vw; cursor: pointer; } .ac-game-settings-acwing \u0026gt; img { position: relative; top: 50%; left: 50%; transform: translate(-50%, -50%); cursor: pointer; display: block; } .ac-game-settings-acwing \u0026gt; div { color: white; font-size: 1.5vh; text-align: center; display: block; } .ac-game-settings-register { height: 49vh; width: 20vw; position: relative; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0, 0, 0, 0.7); border-radius: 5px; } 实现登录/注册的相互切换 class Settings { constructor(root) { ... } start() { this.getinfo(); this.add_listening_events(); } add_listening_events() { this.add_listening_events_login(); this.add_listening_events_register(); } add_listening_events_login() { let outer = this; this.$login_register.click(function() { outer.register(); // 跳到注册界面 }); } add_listening_events_register() { let outer = this; this.$register_login.click(function() { outer.login(); // 跳到登录界面 }) } ... } 实现登录功能 views/settings/login.py\nfrom django.http import JsonResponse from django.contrib.auth import authenticate, login def signin(request): data = request.GET username = data.get(\u0026#39;username\u0026#39;) password = data.get(\u0026#39;password\u0026#39;) user = authenticate(username=username, password=password) if not user: return JsonResponse({ \u0026#39;result\u0026#39;: \u0026#34;用户名或密码不正确\u0026#34; }) login(request, user) return JsonResponse({ \u0026#39;result\u0026#39;: \u0026#34;success\u0026#34; }) urls/settings/index.py\nfrom django.urls import path from game.views.settings.getinfo import getinfo from game.views.settings.login import signin urlpatterns = [ path(\u0026#34;getinfo/\u0026#34;, getinfo, name=\u0026#34;settings_getinfo\u0026#34;), path(\u0026#34;login/\u0026#34;, signin, name=\u0026#34;settings_login\u0026#34;), ] settings/zbase.js\nclass Settings{ ... add_listening_events_login() { ... this.$login_submit.click(function() { outer.login_on_remote(); }); } ... login_on_remote() { // 在远程服务器上登录 let outer = this; let username = this.$login_username.val(); let password = this.$login_password.val(); this.$login_error_message.empty(); $.ajax({ url: \u0026#34;https://app1117.acapp.acwing.com.cn/settings/login/\u0026#34;, type: \u0026#34;GET\u0026#34;, data: { username: username, password: password, }, success: function(resp) { console.log(resp); if (resp.result === \u0026#34;success\u0026#34;) { location.reload(); } else { outer.$login_error_message.html(resp.result); } } }); } } 实现登出功能 views/settings/logout.py\nfrom django.http import JsonResponse from django.contrib.auth import logout def signout(request): user = request.user if not user.is_authenticated: return JsonResponse({ \u0026#39;result\u0026#39;: \u0026#34;success\u0026#34;, }) logout(request) return JsonResponse({ \u0026#39;result\u0026#39;: \u0026#34;success\u0026#34;, }) urls/settings/index.py\n... from game.views.settings.logout import signout urlpatterns = [ ... path(\u0026#34;logout/\u0026#34;, signout, name=\u0026#34;settings_logout\u0026#34;), ] settings/zbase.js\n... login_on_remote() { // 在远程服务器上登录 let outer = this; let username = this.$login_username.val(); let password = this.$login_password.val(); this.$login_error_message.empty(); $.ajax({ url: \u0026#34;https://app1117.acapp.acwing.com.cn/settings/login/\u0026#34;, type: \u0026#34;GET\u0026#34;, data: { username: username, password: password, }, success: function(resp) { console.log(resp); if (resp.result === \u0026#34;success\u0026#34;) { location.reload(); } else { outer.$login_error_message.html(resp.result); } } }); } ... 再顺便将 menu 菜单页面里的 设置 按钮也绑定上登出功能\nmenu/zbase.js\nadd_listening_events() { let outer = this; ... this.$settings_mode.click(function() { ... outer.root.settings.logout_on_remote(); }); } 实现注册功能 views/settings/register.py\nfrom django.http import JsonResponse from django.contrib.auth import login from django.contrib.auth.models import User from game.models.player.player import Player def register(request): data = request.GET username = data.get(\u0026#34;username\u0026#34;, \u0026#34;\u0026#34;).strip() password = data.get(\u0026#34;password\u0026#34;, \u0026#34;\u0026#34;).strip() password_confirm = data.get(\u0026#34;password_confirm\u0026#34;, \u0026#34;\u0026#34;).strip() if not username or not password: return JsonResponse({ \u0026#39;result\u0026#39;: \u0026#34;用户名或密码不能为空\u0026#34;, }) if password != password_confirm: return JsonResponse({ \u0026#39;result\u0026#39;: \u0026#34;两个密码不一致\u0026#34;, }) if User.objects.filter(username=username).exists(): return JsonResponse({ \u0026#39;result\u0026#39;: \u0026#34;用户名已存在\u0026#34;, }) user = User(username=username) user.set_password(password) user.save() Player.objects.create(user=user, photo=\u0026#34;https://cdn.acwing.com/media/user/profile/photo/42832_lg_f999efc3c8.png\u0026#34;) login(request, user) return JsonResponse({ \u0026#39;result\u0026#39;: \u0026#34;success\u0026#34;, }) urls/settings/index.py\n... from game.views.settings.register import register ... urlpatterns = [ ... path(\u0026#34;register/\u0026#34;, register, name=\u0026#34;settings_register\u0026#34;), ] settings/zbase.js\n... add_listening_events_register() { ... this.$register_submit.click(function() { outer.register_on_remote(); }); } ... register_on_remote() { // 在远程服务器上注册 let outer = this; let username = this.$register_username.val(); let password = this.$register_password.val(); let password_confirm = this.$register_password_confirm.val(); this.$register_error_message.empty(); $.ajax({ url: \u0026#34;https://app1117.acapp.acwing.com.cn/settings/register/\u0026#34;, type: \u0026#34;GET\u0026#34;, data: { username: username, password: password, password_confirm: password_confirm, }, success: function(resp) { console.log(resp); if (resp.result === \u0026#34;success\u0026#34;) { location.reload(); } else { outer.$register_error_message.html(resp.result); } } }) } ... Redisஐ Redis是什么？ Redis 是一款内存高速缓存数据库\n为什么要使用Redis? 我们目前用的是Django自带的数据库Sqlite。Django是很容易将数据库迁移到mySQL的。但是存储效率不如redis，因为redis是内存数据库，所以调用东西都非常快，存的是一个一个的\u0026lt;key, value\u0026gt;，而且是单线程的\n在Django中集成Redis 安装 django_redis pip install django_redis 配置 settings.py CACHES = { \u0026#39;default\u0026#39;: { \u0026#39;BACKEND\u0026#39;: \u0026#39;django_redis.cache.RedisCache\u0026#39;, \u0026#39;LOCATION\u0026#39;: \u0026#39;redis://127.0.0.1:6379/1\u0026#39;, \u0026#34;OPTIONS\u0026#34;: { \u0026#34;CLIENT_CLASS\u0026#34;: \u0026#34;django_redis.client.DefaultClient\u0026#34;, }, }, } USER_AGENTS_CACHE = \u0026#39;default\u0026#39; 启动 redis-server sudo redis-server /etc/redis/redis.conf 在 Django 后台里操纵 Redis $ python3 manage.py shell\u0026#39; In [1]: from django.core.cache import cache # 引入redis In [2]: cache.keys(\u0026#39;*\u0026#39;) # 查询redis里所有的关键字 Out[2]: [] In [3]: cache.set(\u0026#39;yxc\u0026#39;, 1, 5) # 插入一个key-val，存在 5 s Out[3]: True In [4]: cache.keys(\u0026#39;*\u0026#39;) # 查询redis里所有的关键字 Out[4]: [\u0026#39;yxc\u0026#39;] In [5]: cache.set(\u0026#39;yxc\u0026#39;, 2, None) # 插入一个key-val，不会过期 Out[5]: True In [6]: cache.set(\u0026#39;abc\u0026#39;, 3, None) Out[6]: True In [7]: cache.keys(\u0026#39;y*\u0026#39;) Out[7]: [\u0026#39;yxc\u0026#39;] In [8]: cache.has_key(\u0026#39;abc\u0026#39;) Out[8]: True In [9]: cache.has_key(\u0026#39;abcd\u0026#39;) Out[9]: False In [10]: cache.get(\u0026#39;yxc\u0026#39;) Out[10]: 2 In [11]: cache.delete(\u0026#39;yxc\u0026#39;) Out[11]: True In [12]: cache.keys(\u0026#39;*\u0026#39;) Out[12]: [\u0026#39;abc\u0026#39;] In [13]: Web端AcWing一键登录ஐ 6.2 Web端AcWing一键登录 | 讲义 6.2 上课笔记 | Andrew1729 6.2 Web端AcWing一键登录 | Vedio Oauth2一键授权登录的基本原理：$17m30s——29m15s——32m51s$ 数据表添加openid信息：$33m20s——34m47s$ Oauth2一键授权登录的代码实现：$35m20s——1h25s——1h27m20s$ 用户点击AcWing一键登录，通过urls \u0026amp; views调用apply_code函数，将state放到redis中，将appid \u0026amp; redirect_uri \u0026amp; scope \u0026amp; state 传入apply_code_url链接，返回并重定向至apply_code_url向用户询问是否授权\n用户点击同意后，重定向至redirect_uri链接，返回参数为code和state，通过urls \u0026amp; views调用receive_code函数\n若验证state失败，直接重定向至初始界面\n若验证state成功，将appid \u0026amp; code \u0026amp; secret发送至AcWing服务器，申请授权令牌access_token和用户的openid\n若申请令牌成功，将access_token \u0026amp; openid发送至AcWing服务器，得到用户信息，创建并登录用户，最后重定向至初始界面\nAcApp端AcWing一键登录ஐ 6.3 AcApp端AcWing一键登录 | 讲义 6.3 上课笔记 | Andrew1729 6.3 Acapp端AcWing一键登录 | Vedio Oauth2一键授权登录的基本原理：$10m——12m20s——16m35s——18m$ Oauth2一键授权登录的代码实现：$19m25s——21m——23m25s——34m29s——42m10s$ 实现联机对战ஐ 7. 实现联机对战 | 讲义 7.1 上课笔记 | 大菜狗 7.2 上课笔记 | 菊花 统一长度单位 由于联机对战的时候，每个用户的客户端长宽不一样\n在之前完成的游戏界面里，我们会根据当前客户端的大小，进行渲染\n但是在联机对战的时候，应当让所有玩家的游戏界面保持同步才可以\n所有，就引入了 统一长度单位 的目标\n地图渲染 地图 16:9 等比例缩放 实现逻辑：根据当前用户的客户端大小，统一渲染成 16:9 的游戏界面，且随着用户调整窗口大小，也动态调整\njs/src/playground/zbase.js\nclass AcGamePlayground { constructor(root) { ... this.root.$ac_game.append(this.$playground);// 未来可能会多次 show 因此把创建场景挪到这里 ... } ... start() { let outer = this; $(window).resize(function() { outer.resize(); }); } resize() { this.width = this.$playground.width(); this.height = this.$playground.height(); let unit = Math.min(this.width / 16, this.height / 9); // 以最小的作为基准，渲染 this.width = unit * 16; this.height = unit * 9; this.resize(); this.scale = this.height; // resize时，其他元素的渲染大小都以当前渲染的高度为基准，存为 scale 变量 if (this.game_map) this.game_map.resize(); //如果此时地图已创建，则resize一下 } show() { // 打开 playground 界面 this.$playground.show(); this.resize(); ... } ... } js/src/playground/game_map/zbase.js\nclass GameMap extends AcGameObject { ... resize() { this.ctx.canvas.width = this.playground.width; this.ctx.canvas.height = this.playground.height; } ... } 地图居中 直接把 canvas 元素，用相对位置居中即可\ncss/game.css\n... .ac-game-playground { ... background-color: grey; } .ac-game-playground \u0026gt; canvas { position: relative; top: 50%; left: 50%; transform: translate(-50%, -50%); } 解决地图 resize 时，会出现渐变成黑色的情况 原由是因为我们的实现逻辑是：每帧会渲染一层半透明的黑色背景\n也就造就了一开始会出现灰屏的情况，解决方法很简单，直接 resize 完，强制涂一层不透明的黑色即可\njs/src/playground/game_map/zbase.js\nclass GameMap extends AcGameObject { ... resize() { this.ctx.canvas.width = this.playground.width; this.ctx.canvas.height = this.playground.height; this.ctx.fillStyle = \u0026#34;rgba(0, 0, 0, 1)\u0026#34;; // resize 完，涂一层不透明的即可 this.ctx.fillRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height); } ... } 元素渲染 地图随着尺寸等比例放大缩小的同时，地图内的其他元素也应与背景一同等比例放大缩小\n因此，我们只需把元素全部设为相对大小即可，用我们先前设置的 playground.scale 值即可\n玩家 Player 初始化的时候，转为传递 scale 的比例值\njs/src/playground/zbase.js\nclass AcGamePlayground { ... show() { // 打开 playground 界面 ... this.players.push(new Player(this, this.width / 2 / this.scale, 0.5, 0.05, \u0026#34;white\u0026#34;, 0.15, true)); for (let i = 0; i \u0026lt; 5; i ++ ) { this.players.push(new Player(this, this.width / 2 / this.scale, 0.5, 0.05, this.get_random_color(), 0.15, false)); } } } js/src/playground/player/zbase.js\nclass Player { ... start() { if (this.is_me) { ... } else { let tx = Math.random() * this.playground.width / this.playground.scale; let ty = Math.random() * this.playground.height / this.playground.scale; ... } } add_listening_events() { ... this.playground.game_map.$canvas.mousedown(function(e) { ... if (e.which === 3) { outer.move_to((e.clientX - rect.left) / outer.playground.scale, (e.clientY - rect.top) / outer.playground.scale); } else if (e.which === 1) { if (outer.cur_skill === \u0026#34;fireball\u0026#34;) { outer.shoot_fireball((e.clientX - rect.left) / outer.playground.scale, (e.clientY - rect.top) / outer.playground.scale); } } ... }); ... } shoot_fireball(tx, ty) { let x = this.x, y = this.y; let radius = 0.01; let angle = Math.atan2(ty - this.y, tx - this.x); let vx = Math.cos(angle), vy = Math.sin(angle); let color = \u0026#34;orange\u0026#34;; let speed = 0.5; let move_length = 1.0; let damage = 0.01; new FireBall(this.playground, this, x, y, radius, vx, vy, color, speed, move_length, damage); } ... update() { this.update_move(); this.render(); } update_move() { // 更新玩家移动 ... if (!this.is_me \u0026amp;\u0026amp; this.spent_time \u0026gt; 4 \u0026amp;\u0026amp; Math.random() * 180 \u0026lt; 1) { ... } if (this.damage_speed \u0026gt; this.eps) { ... } else { if (this.move_length \u0026lt; this.eps) { ... if (!this.is_me) { let tx = Math.random() * this.playground.width / this.playground.scale; let ty = Math.random() * this.playground.height / this.playground.scale; ... } } else { ... } } } render() { let scale = this.playground.scale; if (this.is_me) { ... this.ctx.arc(this.x * scale, this.y * scale, this.radius * scale, 0, Math.PI * 2, false); ... this.ctx.drawImage(this.img, (this.x - this.radius) * scale, (this.y - this.radius) * scale, this.radius * 2 * scale, this.radius * 2 * scale); ... } else { ... this.ctx.arc(this.x * scale, this.y * scale, this.radius * scale, 0, 2 * Math.PI, false); ... } } } 火球 Fireball js/src/playground/skill/fireball/zbase.js\nclass Fireball { ... render() { let scale = this.playground.scale; this.ctx.beginPath(); this.ctx.arc(this.x * scale, this.y * scale, this.radius * scale, 0, 2 * Math.PI, false); this.ctx.fillStyle = this.color; this.ctx.fill(); } } 粒子 Particle js/src/playground/particle/zbase.js\nclass Particle { ... render() { let scale = this.playground.scale; this.ctx.beginPath(); this.ctx.arc(this.x * scale, this.y * scale, this.radius * scale, 0, 2 * Math.PI, false); this.ctx.fillStyle = this.color; this.ctx.fill(); } } 增加“联机对战”模式 为了区分：用户自己，机器人，联机玩家\n需要把 is_me 改成字符串，用以表示不同 Player\nmenu/zbase.js\nclass AcGameMenu{ ... add_listening_events() { ... this.$single_mode.click(function(){ outer.hide(); outer.root.playground.show(\u0026#34;single mode\u0026#34;); }); this.$multi_mode.click(function() { outer.hide(); outer.root.playground.show(\u0026#34;multi mode\u0026#34;); }); ... } ... } playground/zbase.js\nclass Playground { ... show(mode) { // 打开 playground 界面 ... this.players.push(new Player(this, this.width / 2 / this.scale, 0.5, 0.05, \u0026#34;white\u0026#34;, 0.15, \u0026#34;me\u0026#34;, this.root.settings.username, this.root.settings.photo))); if (mode === \u0026#34;single mode\u0026#34;) { for (let i = 0; i \u0026lt; 5; i ++ ) { this.players.push(new Player(this, this.width / 2 / this.scale, 0.5, 0.05, this.get_random_color(), 0.15, \u0026#34;robot\u0026#34;)); } } else if (mode === \u0026#34;multi mode\u0026#34;) { } } ... } playground/player/zbase.js\nclass Player extends AcGameObject { constructor(playground, x, y, radius, color, speed, character, username, photo) { ... this.character = character; this.username = username; this.photo = photo; ... if (this.character !== \u0026#34;robot\u0026#34;) { this.img = new Image(); this.img.src = this.photo; } } ... // 同理，根据对应的逻辑，修改后面所有的 is_me 为 character } Django_channels 谈谈Websocket HTTP/TCP Django_channels是什么？ Django_Channels 是一个为Django 提供异步扩展的库，通常主要用来提供WebSocket 支持和后台任务\nWSS 是 Web Socket 协议的安全模式，支持 C/S 下的双向通信（HTTP协议只支持单向通信）\n配置Django_channels 安装 channels_redis pip install channels_redis 配置 acapp/asgi.py import os from channels.auth import AuthMiddlewareStack from channels.routing import ProtocolTypeRouter, URLRouter from django.core.asgi import get_asgi_application from game.routing import websocket_urlpatterns os.environ.setdefault(\u0026#39;DJANGO_SETTINGS_MODULE\u0026#39;, \u0026#39;acapp.settings\u0026#39;) application = ProtocolTypeRouter({ \u0026#34;http\u0026#34;: get_asgi_application(), \u0026#34;websocket\u0026#34;: AuthMiddlewareStack(URLRouter(websocket_urlpatterns)) }) 配置 acapp/settings.py 在 INSTALLED_APPS 中添加 channels ，添加后如下所示：\nINSTALLED_APPS = [ \u0026#39;channels\u0026#39;, \u0026#39;game.apps.GameConfig\u0026#39;, \u0026#39;django.contrib.admin\u0026#39;, \u0026#39;django.contrib.auth\u0026#39;, \u0026#39;django.contrib.contenttypes\u0026#39;, \u0026#39;django.contrib.sessions\u0026#39;, \u0026#39;django.contrib.messages\u0026#39;, \u0026#39;django.contrib.staticfiles\u0026#39;, ] 然后在文件末尾添加：\nASGI_APPLICATION = \u0026#39;acapp.asgi.application\u0026#39; CHANNEL_LAYERS = { \u0026#34;default\u0026#34;: { \u0026#34;BACKEND\u0026#34;: \u0026#34;channels_redis.core.RedisChannelLayer\u0026#34;, \u0026#34;CONFIG\u0026#34;: { \u0026#34;hosts\u0026#34;: [(\u0026#34;127.0.0.1\u0026#34;, 6379)], }, }, } 配置 game/routing.py 这一部分的作用相当于 http 的 urls 内容如下：\nfrom django.urls import path websocket_urlpatterns = [ ] 编写 game/consumers 这一部分的作用相当于 http 的 views 参考示例：\nconsumers/multiplayer/index.py\nfrom channels.generic.websocket import AsyncWebsocketConsumer import json class MultiPlayer(AsyncWebsocketConsumer): async def connect(self): await self.accept() print(\u0026#39;accept\u0026#39;) self.room_name = \u0026#34;room\u0026#34; await self.channel_layer.group_add(self.room_name, self.channel_name) async def disconnect(self, close_code): print(\u0026#39;disconnect\u0026#39;) await self.channel_layer.group_discard(self.room_name, self.channel_name); async def receive(self, text_data): data = json.loads(text_data) print(data) 启动 django_channels 在 ~/acapp 目录下执行：\ndaphne -b 0.0.0.0 -p 5015 acapp.asgi:application 建立 WSS 连接 game/routing.py\nfrom django.urls import path from game.consumers.multiplayer.index import MultiPlayer websocket_urlpatterns = [ path(\u0026#34;wss/multiplayer/\u0026#34;, MultiPlayer.as_asgi(), name=\u0026#34;wss_multiplayer\u0026#34;), ] playground/zbase.js\nclass AcGamePlayground { ... show(mode) { // 打开 playground 界面 ... if (mode === \u0026#34;single mode\u0026#34;) { ... } else if (mode === \u0026#34;multi mode\u0026#34;) { this.mps = new MultiPlayerSocket(this); this.mps.ws.onopen = function() { outer.mps.send_create_player(); }; } } } playground/socket/multiplayer/zbase.js\nclass MultiPlayerSocket { constructor(playground) { this.playground = playground; this.ws = new WebSocket(\u0026#34;wss://app1117.acapp.acwing.com.cn/wss/multiplayer/\u0026#34;); this.start(); } start() { } send_create_player() { this.ws.send(JSON.stringify({ \u0026#39;message\u0026#39;: \u0026#39;hello acapp server\u0026#39;, })); } receive_create_player() { } } 编写同步函数 一共需要完成四个通信：\n（通信的逻辑基本都是先在本地完成，然后将结果返回给服务器，服务器再分发给其他客户端，达成同步）\ncreate-player : 在所有玩家的游戏界面，创建一个新加入的玩家 move-to : 在所有玩家的游戏界面，将一个角色移动到一个位置 shoot-fireball : 在所有玩家的游戏界面，让一个角色发射一个火球 attack : 在所有玩家的游戏界面，让一个角色被攻击 一场游戏里，所有的元素（玩家，火球等）都需要唯一的标识，来方便同步\n为此，我们可以直接修改一下游戏引擎，对于每个元素都创建我们需要的唯一标识\nplayground/ac-game-object/zbase.js\nclass AcGameObject { constructor() { ... this.uuid = this.create_uuid(); } create_uuid() { let res = \u0026#34;\u0026#34;; for (let i = 0; i \u0026lt; 8; i ++ ) { let x = parseInt(Math.floor(Math.random() * 10)); // [0, 10) res += x; } return res; ... } playground/zbase.js\nclass AcGamePlayground { ... show(mode) { ... if (mode === \u0026#34;single mode\u0026#34;) { ... } else if (mode === \u0026#34;multi mode\u0026#34;) { this.mps = new MultiPlayerSocket(this); this.mps.uuid = this.players[0].uuid; this.mps.ws.onopen = function() { outer.mps.send_create_player(); }; } } ... } playground/socket/multiplayer/zbase.js\nclass MultiPlayerSocket { ... send_create_player() { let outer = this; this.ws.send(JSON.stringify({ \u0026#39;event\u0026#39;: \u0026#39;create_player\u0026#39;, \u0026#39;uuid\u0026#39;: outer.uuid, })); } } 接着，利用通信的方式，使得每个窗口内，逻辑上相同的元素，其 uid 也相同即可\n原则是：哪个窗口创建的元素，就用他创建时的 uid 作为整个项目运行时的 uid\n然后，我们打算用 redis 来实现存储每个游戏房间，以及元素，并初始默认设定每个房间上限 3 人\ncreate-player 前端 game/static/js/src/playground/socket/multiplayer/zbase.js\nclass MultiPlayerSocket { constructor(playground) { this.playground = playground; this.ws = new WebSocket(\u0026#34;wss://app1117.acapp.acwing.com.cn/wss/multiplayer/\u0026#34;); this.start(); } start() { this.receive(); } receive() { let outer = this; this.ws.onmessage = function(e) { let data = JSON.parse(e.data); let uuid = data.uuid; if (uuid === outer.uuid) return false; let event = data.event; if (event === \u0026#34;create_player\u0026#34;) { outer.receive_create_player(uuid, data.username, data.photo); } }; } send_create_player(username, photo) { let outer = this; this.ws.send(JSON.stringify({ \u0026#39;event\u0026#39;: \u0026#39;create_player\u0026#39;, \u0026#39;uuid\u0026#39;: outer.uuid, \u0026#39;username\u0026#39;: username, \u0026#39;photo\u0026#39;: photo, })); } receive_create_player(uuid, username, photo) { let player = new Player( this.playground, this.playground.width / 2 / this.playground.scale, 0.5, 0.05, \u0026#34;white\u0026#34;, 0.15, \u0026#34;enemy\u0026#34;, username, photo, ); player.uuid = uuid; this.playground.players.push(player); } } 后端 settings.py\n... ROOM_CAPACITY = 3 consumers/multiplayer/index.py\nfrom channels.generic.websocket import AsyncWebsocketConsumer import json from django.conf import settings from django.core.cache import cache class MultiPlayer(AsyncWebsocketConsumer): async def connect(self): self.room_name = None for i in range(1000): # 上限 1k 个房间 name = \u0026#34;room-%d\u0026#34; % (i) # 当前房间为空，或房间内玩家人数不到 ROOM_CAPACITY if not cache.has_key(name) or len(cache.get(name)) \u0026lt; settings.ROOM_CAPACITY: self.room_name = name break if not self.room_name: return await self.accept() if not cache.has_key(self.room_name): # 如果房间不存在，则新建房间 cache.set(self.room_name, [], 3600) # 有效期 1 小时 for player in cache.get(self.room_name): # 对该房间已存在的用户，创建到新加入的用户的游戏界面中 await self.send(text_data=json.dumps({ \u0026#39;event\u0026#39;: \u0026#34;create_player\u0026#34;, \u0026#39;uuid\u0026#39;: player[\u0026#39;uuid\u0026#39;], \u0026#39;username\u0026#39;: player[\u0026#39;username\u0026#39;], \u0026#39;photo\u0026#39;: player[\u0026#39;photo\u0026#39;], })) await self.channel_layer.group_add(self.room_name, self.channel_name) async def disconnect(self, close_code): print(\u0026#39;disconnect\u0026#39;) await self.channel_layer.group_discard(self.room_name, self.channel_name); async def create_player(self, data): players = cache.get(self.room_name) players.append({ \u0026#39;uuid\u0026#39;: data[\u0026#39;uuid\u0026#39;], \u0026#39;username\u0026#39;: data[\u0026#39;username\u0026#39;], \u0026#39;photo\u0026#39;: data[\u0026#39;photo\u0026#39;], }) cache.set(self.room_name, players, 3600) # 更新房间存在时间为 1 小时（最后一次加入一名玩家时） # 群发消息更新 await self.channel_layer.group_send( self.room_name, { \u0026#39;type\u0026#39;: \u0026#34;group_create_player\u0026#34;, # 群发该消息后，作为客户端接受者，所接受用的函数名 \u0026#39;event\u0026#39;: \u0026#34;create_player\u0026#34;, \u0026#39;uuid\u0026#39;: data[\u0026#39;uuid\u0026#39;], \u0026#39;username\u0026#39;: data[\u0026#39;username\u0026#39;], \u0026#39;photo\u0026#39;: data[\u0026#39;photo\u0026#39;], } ) async def group_create_player(self, data): await self.send(text_data=json.dumps(data)) async def receive(self, text_data): data = json.loads(text_data) event = data[\u0026#39;event\u0026#39;] if event == \u0026#34;create_player\u0026#34;: await self.create_player(data) redis 调试语句 打开 shell 交互\npython3 manage.py shell 然后用 py3 交互进行 cache 调试\nfrom django.core.cache import cache def clear(): for key in cache.keys(\u0026#39;*\u0026#39;): cache.delete(key) cache.keys(\u0026#39;*\u0026#39;) # 查询当前 redis 中所有 key cache.get(\u0026#39;room-1\u0026#39;) # 查询当前 redis 中 key 为 room-1 的值 到目前为止，便可以在不同的窗口渲染同一批玩家了\nmove-to 前端 客户端的通信的发出和接受函数\ngame/static/js/src/playground/socket/multiplayer/zbase.js\nclass MultiPlayerSocket { ... receive() { let outer = this; this.ws.onmessage = function(e) { ... else if (event === \u0026#34;move_to\u0026#34;) { outer.receive_move_to(uuid, data.tx, data.ty); } }; } send_move_to(tx, ty) { let outer = this; this.ws.send(JSON.stringify({ \u0026#39;event\u0026#39;: \u0026#39;move_to\u0026#39;, \u0026#39;uuid\u0026#39;: outer.uuid, \u0026#39;tx\u0026#39;: tx, \u0026#39;ty\u0026#39;: ty, })); } get_player(uuid) { let players = this.playground.players; for (let i = 0; i \u0026lt; players.length; i ++ ) { let player = players[i]; if (player.uuid === uuid) { return player; } } return null; } receive_move_to(uuid, tx, ty) { let player = this.get_player(uuid); if (player) { player.move_to(tx, ty); } } } 为了让游戏界面中对于要移动的元素做出移动动作，需要对 move_to 函数做出一些修改\n首先要标识出当前为多人模式，然后模式为多人模式时，每次移动都会触发一次通信\nplayground/zbase.js\nclass AcGamePlayground { ... show(mode) { ... this.mode = mode; } } playground/player/zbase.js\nclass Player extends AcGameObject { ... add_listening_events() { ... this.playground.game_map.$canvas.mousedown(function(e) { ... if (e.which === 3) { let tx = (e.clientX - rect.left) / outer.playground.scale; let ty = (e.clientY - rect.top) / outer.playground.scale; outer.move_to(tx, ty); if (outer.playground.mode === \u0026#34;multi mode\u0026#34;) { outer.playground.mps.send_move_to(tx, ty); } } ... } ... } 后端 consumers/multiplayer/index.py\nasync def move_to(self, data): await self.channel_layer.group_send( self.room_name, { \u0026#39;type\u0026#39;: \u0026#34;group_send_event\u0026#34;, \u0026#39;event\u0026#39;: \u0026#34;move_to\u0026#34;, \u0026#39;uuid\u0026#39;: data[\u0026#39;uuid\u0026#39;], \u0026#39;tx\u0026#39;: data[\u0026#39;tx\u0026#39;], \u0026#39;ty\u0026#39;: data[\u0026#39;ty\u0026#39;], } ) async def group_send_event(self, data): await self.send(text_data=json.dumps(data)) async def receive(self, text_data): data = json.loads(text_data) event = data[\u0026#39;event\u0026#39;] if event == \u0026#34;create_player\u0026#34;: await self.create_player(data) elif event == \u0026#34;move_to\u0026#34;: await self.move_to(data) shoot-fireball 前端 用一个数组来存一个玩家发射的所有火球，以便于子弹消失时，将他们找出并对应删掉\nplayground/player/zbase.js\nclass Player extends AcGameObject { constructor(playground, x, y, radius, color, speed, character, username, photo) { ... this.fireballs = []; // 存该用户发射的所有火球 } add_listening_events() { ... this.playground.game_map.$canvas.mousedown(function(e) { ... else if (e.which === 1) { let tx = (e.clientX - rect.left) / outer.playground.scale; let ty = (e.clientY - rect.top) / outer.playground.scale; if (outer.cur_skill === \u0026#34;fireball\u0026#34;) { let fireball = outer.shoot_fireball(tx, ty); if (outer.playground.mode === \u0026#34;multi mode\u0026#34;) { outer.playground.mps.send_shoot_fireball(tx, ty, fireball.uuid); } } } ... }); $(window).keydown(function(e) { if (e.which === 81) { // 键盘按下q事件 outer.cur_skill = \u0026#34;fireball\u0026#34;; return false; } }); } ... shoot_fireball(tx, ty) { ... let fireball = new FireBall(this.playground, this, x, y, radius, vx, vy, color, speed, move_length, damage); this.fireballs.push(fireball); return fireball; } destroy_fireball(uuid) { for (let i = 0; i \u0026lt; this.fireballs.length; i ++ ) { let fireball = this.fireballs[i]; if (fireball.uuid == uuid) { fireball.destroy(); break; } } } ... playground/skill/fireball/zbase.js\nclass FireBall extends AcGameObject { ... on_destory() { let fireballs = this.player.fireballs; for (let i = 0; i \u0026lt; fireballs.length; i ++ ) { if (fireballs[i] === this) { fireballs.splice(i, 1); break; } } } } game/static/js/src/playground/socket/multiplayer/zbase.js\nclass MultiPlayerSocket { ... send_shoot_fireball(tx, ty, ball_uuid) { let outer = this; this.ws.send(JSON.stringify({ \u0026#39;event\u0026#39;: \u0026#39;move_to\u0026#39;, \u0026#39;uuid\u0026#39;: outer.uuid, \u0026#39;tx\u0026#39;: tx, \u0026#39;ty\u0026#39;: ty, \u0026#39;ball_uuid\u0026#39;: ball_uuid; })); } receive_shoot_fireball(uuid, tx, ty, ball_uuid) { let player = this.get_player(uuid); if (player) { let fireball = player.shoot_fireball(tx, ty); fireball.uuid = ball_uuid; } } } 后端 consumers/multiplayer/index.py\n... class MultiPlayer(AsyncWebsocketConsumer): ... async def shoot_fireball(self, data): await self.channel_layer.group_send( self.room_name, { \u0026#39;type\u0026#39;: \u0026#34;group_send_event\u0026#34;, \u0026#39;event\u0026#39;: \u0026#34;shoot_fireball\u0026#34;, \u0026#39;uuid\u0026#39;: data[\u0026#39;uuid\u0026#39;], \u0026#39;tx\u0026#39;: data[\u0026#39;tx\u0026#39;], \u0026#39;ty\u0026#39;: data[\u0026#39;ty\u0026#39;], \u0026#39;ball_uuid\u0026#39;: data[\u0026#39;ball_uuid\u0026#39;], } ) async def receive(self, text_data): ... elif event == \u0026#34;shoot_fireball\u0026#34;: await self.shoot_fireball(data) attack 为了只让一个客户端进行攻击命中的判断，因此只有发出方的火球才做碰撞检测\n其他客户端对于该火球只有动画效果\n又由于碰撞检测是在一台客户端上进行的，因此多端之间可能会存在同步上的延迟\n为此的解决方法是：碰撞检测成功时，强制把被击中玩家移动到发起方客户端中的位置，以避免击中延迟上发生的事情\n前端 playground/skill/fireball/zbase.js\nclass FireBall extends AcGameObject { update() { if (this.move_length \u0026lt; this.eps) { this.destroy(); return false; } this.update_move(); if (this.player.character !== \u0026#34;enemy\u0026#34;) { this.update_attack(); } this.render(); } attack(player) { ... if (this.playground.mode === \u0026#34;multi mode\u0026#34;) { this.playground.mps.send_attack(player.uuid, player.x, player.y, angle, this.damage, this.uuid); } ... } ... } playground/player/zbase.js\nclass Player extends AcGameObject { ... receive_attack(x, y, angle, damage, ball_uuid, attacker) { attacker.destroy_fireball(ball_uuid); this.x = x; this.y = y; this.is_attacked(angle, damage); } ... } game/static/js/src/playground/socket/multiplayer/zbase.js\nclass MultiPlayerSocket { ... send_attack(attackee_uuid, x, y, angle, damage, ball_uuid) { let outer = this; this.ws.send(JSON.stringify({ \u0026#39;event\u0026#39;: \u0026#34;attack\u0026#34;, \u0026#39;uuid\u0026#39;: outer.uuid, \u0026#39;attackee_uuid\u0026#39;: attackee_uuid, \u0026#39;x\u0026#39;: x, \u0026#39;y\u0026#39;: y, \u0026#39;angle\u0026#39;: angle, \u0026#39;damage\u0026#39;: damage, \u0026#39;ball_uuid\u0026#39;: ball_uuid, })); } receive_attack(uuid, attackee_uuid, x, y, angle, damage, ball_uuid) { let attacker = this.get_player(uuid); let attackee = this.get_player(attackee_uuid); if (attacker \u0026amp;\u0026amp; attackee) { attackee.receive_attack(x, y, angle, damage, ball_uuid, attacker); } } } 后端 consumers/multiplayer/index.py\n... class MultiPlayer(AsyncWebsocketConsumer): ... async def attack(self, data): await self.channel_layer.group_send( self.room_name, { \u0026#39;type\u0026#39;: \u0026#34;group_send_event\u0026#34;, \u0026#39;event\u0026#39;: \u0026#34;attack\u0026#34;, \u0026#39;uuid\u0026#39;: data[\u0026#39;uuid\u0026#39;], \u0026#39;x\u0026#39;: data[\u0026#39;x\u0026#39;], \u0026#39;y\u0026#39;: data[\u0026#39;y\u0026#39;], \u0026#39;angle\u0026#39;: data[\u0026#39;angle\u0026#39;], \u0026#39;damage\u0026#39;: data[\u0026#39;damage\u0026#39;], \u0026#39;ball_uuid\u0026#39;: data[\u0026#39;ball_uuid\u0026#39;], } ) ... 游戏的小优化 多人模式下游戏没有开始前，玩家不可以移动 为此我们先引入一个状态机：'waiting' -\u0026gt; 'fighting' -\u0026gt; 'over' 来标识当前游戏进行的状态\n然后用一个 notice_board 计分板在前端显示出来\n实现的逻辑就是：游戏初始时为 waiting 状态，房间内人数满 3 人时，才会进入 fighting，角色死亡时为 over\n且发射火球，移动等行为，当且仅当玩家状态为 fighting 时，才可以做\n然后设定火球技能的 cd 为 3 秒，且在游戏进入 fighting 时，先自动进入 cd 状态\n这样就实现了初始 3 秒内，任何玩家不可攻击\njs/src/playground/notice_board/zbase.js\nclass NoticeBoard extends AcGameObject { constructor(playground) { super(); this.playground = playground; this.ctx = this.playground.game_map.ctx; this.text = \u0026#34;已就绪：0人\u0026#34;; } start() { } write(text) { this.text = text; } update() { this.render(); } render() { this.ctx.font = \u0026#34;20px serif\u0026#34;; this.ctx.fillStyle = \u0026#34;white\u0026#34;; this.ctx.textAlign = \u0026#34;center\u0026#34;; this.ctx.fillText(this.text, this.playground.width / 2, 20); } } js/src/playground/zbase.js\nclass AcGamePlayground { ... show(mode) { ... this.state = \u0026#34;waiting\u0026#34;; // waiting -\u0026gt; fighting -\u0026gt; over this.notice_board = new NoticeBoard(this); this.player_count = 0; ... } } js/src/playground/player/zbase.js\nclass Player extends AcGameObject { ... add_listening_events() { ... this.playground.game_map.$canvas.mousedown(function(e) { if (outer.playground.state !== \u0026#34;fighting\u0026#34;) return false; ... } $(window).keydown(function(e) { if (outer.playground.state !== \u0026#34;fighting\u0026#34;) return false; ... }); } start() { this.playground.player_count ++ ; this.playground.notice_board.write(\u0026#34;已就绪：\u0026#34; + this.playground.player_count + \u0026#34;人\u0026#34;); if (this.playground.player_count \u0026gt;= 3) { this.playground.state = \u0026#34;fighting\u0026#34;; this.playground.notice_board.write(\u0026#34;Fighting\u0026#34;); } ... } ... } 技能CD 给火球技能设置 3s 的 cd，实现逻辑很简单，设定一个 cool_time 变量，每次渲染的时候减去上次渲染的时间间隔\n然后 cool_time 为 0 时，技能才可以成功释放\n另外修改冷却时间，只用修改自己的即可\njs/src/playground/player/zbase.js\nclass Player extends AcGameObject { constructor(...) { ... if (this.character === \u0026#34;me\u0026#34;) { this.fireball_coldtime = 3; // 单位：s } } ... add_listening_events() { ... this.playground.game_map.$canvas.mousedown(function(e) { ... else if (e.which === 1) { ... if (outer.cur_skill === \u0026#34;fireball\u0026#34;) { ... if (outer.playground.mode === \u0026#34;multi mode\u0026#34;) { outer.playground.mps.send_shoot_fireball(tx, ty, fireball.uuid); } outer.fireball_coldtime = 3; } } ... }); $(window).keydown(function(e) { ... if (outer.fireball_coldtime \u0026gt;= outer.eps) return false; ... }); } update() { ... if (this.character === \u0026#34;me\u0026#34; \u0026amp;\u0026amp; this.playground.state === \u0026#34;fighting\u0026#34;) { this.update_coldtime(); } ... } update_coldtime() { this.fireball_coldtime -= this.timedelta / 1000; this.fireball_coldtime = Math.max(0, this.fireball_coldtime); } ... } 用图片来渲染技能CD js/src/playground/player/zbase.js\nclass Player extends AcGameObject { constructor(...) { ... if (this.character === \u0026#34;me\u0026#34;) { this.fireball_coldtime = 3; // 单位：s this.fireball_img = new Image(); this.fireball_img.src = \u0026#34;https://cdn.acwing.com/media/article/image/2021/12/02/1_9340c86053-fireball.png\u0026#34;; } } ... render() { ... if (this.character === \u0026#34;me\u0026#34; \u0026amp;\u0026amp; this.playground.state === \u0026#34;fighting\u0026#34;) { this.render_skill_coldtime(); } } render_skill_coldtime() { let scale = this.playground.scale; let x = 1.5, y = 0.9, r = 0.04; // 渲染技能图标 this.ctx.save(); this.ctx.beginPath(); this.ctx.arc(x * scale, y * scale, r * scale, 0, Math.PI * 2, false); this.ctx.stroke(); this.ctx.clip(); this.ctx.drawImage(this.fireball_img, (x - r) * scale, (y - r) * scale, r * 2 * scale, r * 2 * scale); this.ctx.restore(); // 渲染冷却指示 if (this.fireball_coldtime \u0026gt;= this.eps){ this.ctx.beginPath(); this.ctx.moveTo(x * scale, y * scale); this.ctx.arc(x * scale, y * scale, r * scale, 0 - Math.PI / 2, Math.PI * 2 * (1 - this.fireball_coldtime / 3) - Math.PI / 2, true); this.ctx.lineTo(x * scale, y * scale); this.ctx.fillStyle = \u0026#34;rgba(0, 0, 255, 0.6)\u0026#34;; this.ctx.fill(); } } ... 添加一个闪现技能 单机部分 js/src/playground/player/zbase.js\nclass Player extends AcGameObject { constructor(...) { ... if (this.character === \u0026#34;me\u0026#34;) { ... this.blink_coldtime = 5; this.blink_img = new Image(); this.blink_img.src = \u0026#34;https://cdn.acwing.com/media/article/image/2021/12/02/1_daccabdc53-blink.png\u0026#34;; } } add_listening_events() { ... this.playground.game_map.$canvas.mousedown(function(e) { ... else if (e.which === 1) { ... else if (outer.cur_skill === \u0026#34;blink\u0026#34;) { outer.blink(tx, ty); // 同步函数 if (outer.playground.mode === \u0026#34;multi mode\u0026#34;) { outer.playground.mps.send_blink(tx, ty); } outer.blink_coldtime = 5; } } outer.cur_skill = null; // 清空当前技能 }); $(window).keydown(function(e) { ... else if (e.which === 70) { // f键 if (outer.blink_coldtime \u0026gt;= outer.eps) return true; outer.cur_skill = \u0026#34;blink\u0026#34;; return false; } }); } ... blink(tx, ty) { let d = this.get_dist(this.x, this.y, tx, ty); d = Math.min(d, 0.5); let angle = Math.atan2(ty - this.y, tx - this.x); this.x += d * Math.cos(angle); this.y += d * Math.sin(angle); this.move_length = 0; // 闪现完停下来 } ... render_skill_coldtime() { ... x = 1.62, y = 0.9, r = 0.04; // 闪现技能 // 渲染技能图标 this.ctx.save(); this.ctx.beginPath(); this.ctx.arc(x * scale, y * scale, r * scale, 0, Math.PI * 2, false); this.ctx.stroke(); this.ctx.clip(); this.ctx.drawImage(this.blink_img, (x - r) * scale, (y - r) * scale, r * 2 * scale, r * 2 * scale); this.ctx.restore(); // 渲染冷却指示 if (this.blink_coldtime \u0026gt;= this.eps){ this.ctx.beginPath(); this.ctx.moveTo(x * scale, y * scale); this.ctx.arc(x * scale, y * scale, r * scale, 0 - Math.PI / 2, Math.PI * 2 * (1 - this.blink_coldtime / 5) - Math.PI / 2, true); this.ctx.lineTo(x * scale, y * scale); this.ctx.fillStyle = \u0026#34;rgba(0, 0, 255, 0.6)\u0026#34;; this.ctx.fill(); } } } 联机部分 game/static/js/src/playground/socket/multiplayer/zbase.js\nclass MultiPlayerSocket { ... send_blink(tx, ty) { let outer = this; this.ws.send(JSON.stringify({ \u0026#39;event\u0026#39;: \u0026#34;blink\u0026#34;, \u0026#39;uuid\u0026#39;: outer.uuid, \u0026#39;tx\u0026#39;: tx, \u0026#39;ty\u0026#39;: ty, })); } receive_blink(uuid, tx, ty) { let player = this.get_player(uuid); if (player) { player.blink(tx, ty); } } } consumers/multiplayer/index.py\n... class MultiPlayer(AsyncWebsocketConsumer): ... async def blink(self, data): await self.channel_layer.group_send( self.room_name, { \u0026#39;type\u0026#39;: \u0026#34;group_send_event\u0026#34;, \u0026#39;event\u0026#39;: \u0026#34;blink\u0026#34;, \u0026#39;uuid\u0026#39;: data[\u0026#39;uuid\u0026#39;], \u0026#39;tx\u0026#39;: data[\u0026#39;tx\u0026#39;], \u0026#39;ty\u0026#39;: data[\u0026#39;ty\u0026#39;], } ) 实现聊天系统ஐ 8.1 上课笔记 | 大菜狗 优化键盘绑定事件 这部分算是之前的遗留问题，先前的 keydown 监听事件绑定在了 window 上会出现一个问题\n如果在一个浏览器内打开多个 ACAPP，此时按下键位触发 keydown 事件，会被浏览器内所有的 ACAPP 都捕获到\n之前影响不大，但对此次要实现的聊天系统就有着致命的影响，即打开一个 ACAPP 的聊天栏，其他都会被打开\n所有我们要将 keydown 监听事件绑定到 canvas 上\nplayground/player/zbase.js\nclass Player extends AcGameObject { ... add_listening_events() { ... this.playground.game_map.$canvas.keydown(function(e) { if (outer.playground.state !== \u0026#34;fighting\u0026#34;) return true; if (e.which === 81) { // 键盘按下q事件 if (outer.fireball_coldtime \u0026gt;= outer.eps) return true; outer.cur_skill = \u0026#34;fireball\u0026#34;; return false; } else if (e.which === 70) { // f键 if (outer.blink_coldtime \u0026gt;= outer.eps) return true; outer.cur_skill = \u0026#34;blink\u0026#34;; return false; } }); } } playground/game-map/zbase.js\nclass GameMap extends AcGameObject { constructor(playground) { ... this.$canvas = $(`\u0026lt;canvas tabindex=0\u0026gt;\u0026lt;/canvas\u0026gt;`); ... } start() { this.$canvas.focus(); } } 本地前端 要实现两个部分： 1. 文本输入框（让用户输入要发送的信息） 2. 历史记录显示框（之前用户发送的信息的显示框）\n欲实现逻辑：用户按下 \u0026lt;Enter\u0026gt; 后，游戏界面弹出文本输入框，然后聚焦于文本输入框，且同时弹出历史记录显示框 3 秒\n然后用户输入信息后，按下 \u0026lt;Enter\u0026gt; 后发出信息，接着信息会显示在历史记录显示框最下方，并弹出历史记录显示框 3 秒\nplayground/chat_field/zbase.js\nchat field 负责管理 文本输入框 和 历史记录显示框\nclass ChatField { constructor(playground) { this.playground = playground; this.$history = $(`\u0026lt;div class=\u0026#34;ac-game-chat-field-history\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;`); this.$input = $(`\u0026lt;input type=\u0026#34;text\u0026#34; class=\u0026#34;ac-game-chat-field-input\u0026#34;\u0026gt;`); this.$history.hide(); this.$input.hide(); this.func_id = null; this.playground.$playground.append(this.$history); this.playground.$playground.append(this.$input); this.start(); } start() { this.add_listening_events(); } add_listening_events() { let outer = this; this.$input.keydown(function(e) { if (e.which === 27) { //ESC outer.hide_input(); return false; } else if (e.which === 13) { let username = outer.playground.root.settings.username; let text = outer.$input.val(); if (text) { outer.$input.val(\u0026#34;\u0026#34;); outer.add_message(username, text); } return false; } }); } show_history() { let outer = this; this.$history.fadeIn(); if (this.func_id) clearTimeout(this.func_id); this.func_id = setTimeout(function() { outer.$history.fadeOut(); outer.func_id = null; }, 3000); } render_message(message) { return $(`\u0026lt;div\u0026gt;${message}\u0026lt;/div\u0026gt;`); } add_message(username, text) { this.show_history(); let message = `[${username}] ${text}`; this.$history.append(this.render_message(message)); this.$history.scrollTop(this.$history[0].scrollHeight); } show_input() { this.show_history(); this.$input.show(); this.$input.focus(); // 输入时，聚焦于输入框 } hide_input() { this.$input.hide(); this.playground.game_map.$canvas.focus(); // 退出时，聚焦回游戏界面 } } playground/zbase.js\n把它创建出来\nclass AcGamePlayground { ... show(mode) { //打开 playground 界面 ... else if (mode === \u0026#34;multi mode\u0026#34;) { this.chat_field = new ChatField(this); ... } } } playground/player/zbase.js\n添加监听事件\nclass Player extends AcGameObject { ... add_listening_events() { ... this.playground.game_map.$canvas.keydown(function(e) { if (e.which === 13) { // enter (显示对话框) if (outer.playground.mode === \u0026#34;multi mode\u0026#34;) { outer.playground.chat_field.show_input(); return false; } } else if (e.which === 27) { // esc（关闭对话框） if (outer.playground.mode === \u0026#34;multi mode\u0026#34;) { outer.playground.char_field.hide_input(); return false; } } ... } } } game.css\n... .ac-game-chat-field-history { position: absolute; top: 66%; left: 20%; transform: translate(-50%, -50%); width: 20%; height: 32%; color: white; font-size: 2vh; padding: 5px; overflow: auto; } .ac-game-chat-field-history::-webkit-scrollbar { width: 0; } .ac-game-chat-field-input { position: absolute; top: 86%; left: 20%; transform: translate(-50%, -50%); width: 20%; height: 3vh; color: white; font-size: 2vh; background-color: rgba(222,225,230, 0.2); } 联机聊天窗 前端 playground/chat_field/zbase.js\nclass ChatField { ... add_listening_events() { ... this.$input.keydown(function(e) { ... else if (e.which === 13) { ... if (text) { ... outer.playground.mps.send_message(text); } ... } }); } ... } js/src/playground/socket/multiplayer/zbase.js\nclass MultiPlayerSocket { ... send_message(text) { let outer = this; this.ws.send(JSON.stringify({ \u0026#39;event\u0026#39;: \u0026#34;message\u0026#34;, \u0026#39;uuid\u0026#39;: outer.uuid, \u0026#39;username\u0026#39;: outer.playground.root.settings.username, \u0026#39;text\u0026#39;: text, })); } receive_message(username, text) { this.playground.chat_field.add_message(username, text); } } 后端 consumers/multiplayer/index.py\n... class MultiPlayer(AsyncWebsocketConsumer): ... async def message(self, data): await self.channel_layer.group_send( self.room_name, { \u0026#39;type\u0026#39;: \u0026#34;group_send_event\u0026#34;, \u0026#39;event\u0026#39;: \u0026#34;message\u0026#34;, \u0026#39;uuid\u0026#39;: data[\u0026#39;uuid\u0026#39;], \u0026#39;username\u0026#39;: data[\u0026#39;username\u0026#39;], \u0026#39;text\u0026#39;: data[\u0026#39;text\u0026#39;], } ) 实现匹配系统ஐ 9. 实现匹配系统 | 讲义 9.1 上课笔记 | 一只野生彩色铅笔 本章节内容是利用 thrift 创建客户端-服务端交互的接口\n然后利用该接口完成一个匹配系统\n匹配系统由一个消息队列 + 生产者-消费者模型 + 匹配池 完成\n基本与 Linux基础课 里的部分完全一致\n当时我们是拿 cpp 来写的，写了差不多 200 行\n本节会拿 py 来实现，差不多 140 行即可\nthrift 接口文件\nnamespace py match_service service Match { i32 add_player(1: i32 score, 2: string uuid, 3: string username, 4: string photo, 5: string channel_name), } 然后用该源文件生成接口文件\n服务端 配置 asgi.py 让服务端进程可以调用客户端进程里的函数\nacapp/acapp/asgi.py\nimport os import django os.environ.setdefault(\u0026#39;DJANGO_SETTINGS_MODULE\u0026#39;, \u0026#39;acapp.settings\u0026#39;) django.setup() ... from channels.layers import get_channel_layer channel_layer = get_channel_layer() ... acapp/match_system/src/main.py\n#! /usr/bin/env python3 import glob import sys sys.path.insert(0, glob.glob(\u0026#39;../../\u0026#39;)[0]) from match_server.match_service import Match from thrift.transport import TSocket from thrift.transport import TTransport from thrift.protocol import TBinaryProtocol from thrift.server import TServer from queue import Queue from time import sleep from threading import Thread from acapp.asgi import channel_layer from asgiref.sync import async_to_sync from django.core.cache import cache queue = Queue() # 消息队列 class Player: def __init__(self, score, uuid, username, photo, channel_name): self.score = score self.uuid = uuid self.username = username self.photo = photo self.channel_name = channel_name self.waiting_time = 0 # 等待时间 class Pool: def __init__(self): self.players = [] def add_player(self, player): self.players.append(player) def check_match(self, a, b): dt = abs(a.score - b.score) a_max_dif = a.waiting_time * 50 b_max_dif = b.waiting_time * 50 return dt \u0026lt;= a_max_dif and dt \u0026lt;= b_max_dif def match_success(self, ps): print(\u0026#34;Match Success: %s %s %s\u0026#34; % (ps[0].username, ps[1].username, ps[2].username)) room_name = \u0026#34;room-%s-%s-%s\u0026#34; % (ps[0].uuid, ps[1].uuid, ps[2].uuid) players = [] for p in ps: async_to_sync(channel_layer.group_add)(room_name, p.channel_name) players.append({ \u0026#39;uuid\u0026#39;: p.uuid, \u0026#39;username\u0026#39;: p.username, \u0026#39;photo\u0026#39;: p.photo, \u0026#39;hp\u0026#39;: 100, }) cache.set(room_name, players, 3600) # 有效时间：1小时 for p in ps: async_to_sync(channel_layer.group_send)( room_name, { \u0026#39;type\u0026#39;: \u0026#34;group_send_event\u0026#34;, \u0026#39;event\u0026#39;: \u0026#34;create_player\u0026#34;, \u0026#39;uuid\u0026#39;: p.uuid, \u0026#39;username\u0026#39;: p.username, \u0026#39;photo\u0026#39;: p.photo, } ) def increase_waiting_time(self): for player in self.players: player.waiting_time += 1 def match(self): while len(self.players) \u0026gt;= 3: self.players = sorted(self.players, key=lambda p: p.score) flag = False for i in range(len(self.players) - 2): a, b, c = self.players[i], self.players[i + 1], self.players[i + 2] if self.check_match(a, b) and self.check_match(a, c) and self.check_match(b, c): self.match_success([a, b, c]) self.players = self.players[:i] + self.players[i + 3:] flag = True break if not flag: break self.increase_waiting_time() class MatchHandler: def add_player(self, score, uuid, username, photo, channel_name): print(\u0026#34;Add Player: %s %d\u0026#34; % (username, score)) player = Player(score, uuid, username, photo, channel_name) queue.put(player) return 0 def get_player_from_queue(): try: return queue.get_nowait() except: return None def worker(): pool = Pool() while True: player = get_player_from_queue() if player: pool.add_player(player) else: pool.match() sleep(1) if __name__ == \u0026#39;__main__\u0026#39;: handler = MatchHandler() processor = Match.Processor(handler) transport = TSocket.TServerSocket(host=\u0026#39;127.0.0.1\u0026#39;, port=9090) tfactory = TTransport.TBufferedTransportFactory() pfactory = TBinaryProtocol.TBinaryProtocolFactory() server = TServer.TThreadedServer( processor, transport, tfactory, pfactory) Thread(target=worker, daemon=True).start() print(\u0026#39;Starting the server...\u0026#39;) server.serve() print(\u0026#39;done.\u0026#39;) 客户端 扩展数据库表，让其可以存放 rank分 的信息\ngame/models/player/player.py\n... class Player(models.Model): ... score = models.IntegerField(default=1500) ... consumers/multiplayer/index.py\nfrom channels.generic.websocket import AsyncWebsocketConsumer import json from django.conf import settings from django.core.cache import cache from thrift import Thrift from thrift.transport import TSocket from thrift.transport import TTransport from thrift.protocol import TBinaryProtocol from match_system.src.match_server.match_service import Match from game.models.player.player import Player from channels.db import database_sync_to_async class MultiPlayer(AsyncWebsocketConsumer): async def connect(self): await self.accept() async def disconnect(self, close_code): if self.room_name: await self.channel_layer.group_discard(self.room_name, self.channel_name) async def create_player(self, data): self.room_name = None self.uuid = data[\u0026#39;uuid\u0026#39;] # Make socket transport = TSocket.TSocket(\u0026#39;127.0.0.1\u0026#39;, 9090) # Buffering is critical. Raw sockets are very slow transport = TTransport.TBufferedTransport(transport) # Wrap in a protocol protocol = TBinaryProtocol.TBinaryProtocol(transport) # Create a client to use the protocol encoder client = Match.Client(protocol) def db_get_player(): return Player.objects.get(user__username=data[\u0026#39;username\u0026#39;]) player = await database_sync_to_async(db_get_player)() # Connect! transport.open() client.add_player(player.score, data[\u0026#39;uuid\u0026#39;], data[\u0026#39;username\u0026#39;], data[\u0026#39;photo\u0026#39;], self.channel_name) # Close! transport.close() async def group_send_event(self, data): if not self.room_name: keys = cache.keys(\u0026#39;*%s*\u0026#39; % (self.uuid)) if keys: self.room_name = keys[0] await self.send(text_data=json.dumps(data)) ... 项目收尾ஐ 加密、压缩js代码 安装 terser :\nsudo apt-get update sudo apt-get install npm sudo npm install terser -g terser 不仅支持文件输入，也支持标准输入。结果会输出到标准输出中。\n使用方式：\nterser xxx.js -c -m 我们将整合 js 文件的脚本修改一下即可：\nscripts/compress_game_js.sh\n#! /bin/bash JS_PATH=/home/acs/acapp/game/static/js/ JS_PATH_DIST=${JS_PATH}dist/ JS_PATH_SRC=${JS_PATH}src/ find $JS_PATH_SRC -type f -name \u0026#39;*.js\u0026#39; | sort | xargs cat | terser -c -m \u0026gt; ${JS_PATH_DIST}game.js echo \u0026#34;yes\u0026#34; | python3 manage.py collectstatic 清理监听函数 在AcAPP关闭之前触发的事件可以通过如下api添加：\nAcWingOS.api.window.on_close(func); 注意：\n同一个页面中，多个 acapp 引入的 js 代码只会加载一次，因此 AC_GAME_OBJECTS 等全局变量是同一个页面、同一个 acapp 的所有窗口共用的 各自创建的局部变量是独立的，比如 new AcGame() 创建出的对象各个窗口是独立的 我们给每一个窗口创建一个 uid 然后根据不同的 uid 进行事件解绑\nplayground/zbase.js\nclass AcGamePlayground { ... create_uuid() { let res = \u0026#34;\u0026#34;; for (let i = 0; i \u0026lt; 8; i ++ ) { let x = parseInt(Math.floor(Math.random() * 10)); //[0, 10) res += x; } return res; } start() { let outer = this; let uuid = this.create_uuid(); $(window).on(`resize.${uuid}`, function() { outer.resize(); }); if (this.root.AcWingOS) { outer.root.AcWingOS.api.window.on_close(function() { $(window).off(`resize.${uuid}`); }); } } ... } 编写每局游戏的结束界面 单独创建一个结束界面，然后游戏结束的时候渲染出该结束界面即可\n因为结束界面要覆盖在游戏界面之上，因此我们需要先修改一下游戏引擎，添加一个 late_update\n在每一帧渲染的内容最后再渲染，从而实现结束界面叠加在游戏界面之上的效果\nac_game_object/zbase.js\n... class AcGameObject { ... late_update() { // 每一帧均会执行一次，且在所有 update 执行完后才执行 } ... } ... let AC_GAME_ANIMATION = function(timestamp) { ... for (let i = 0; i \u0026lt; AC_GAME_OBJECTS.length; i ++ ) { let obj = AC_GAME_OBJECTS[i]; obj.late_update(); } ... } ... 然后我们做一个渲染出结束界面的类\nplayground/score_board/zbase.js\nclass ScoreBoard extends AcGameObject { constructor(playground) { super(); this.playground = playground; this.ctx = this.playground.game_map.ctx; this.state = null; // win-胜利；lose-失败 this.win_img = new Image(); this.win_img.src = \u0026#34;https://cdn.acwing.com/media/article/image/2021/12/17/1_8f58341a5e-win.png\u0026#34;; this.lose_img = new Image(); this.lose_img.src = \u0026#34;https://cdn.acwing.com/media/article/image/2021/12/17/1_9254b5f95e-lose.png\u0026#34;; } start() { } add_listening_events() { // 点击后，返回主页面 let outer = this; let $canvas = this.playground.game_map.$canvas; $canvas.on(\u0026#39;click\u0026#39;, function() { outer.playground.hide(); outer.playground.root.menu.show(); }); } win() { this.state = \u0026#34;win\u0026#34;; let outer = this; setTimeout(function() { outer.add_listening_events(); }, 1000); // 1秒后监听点击事件 } lose() { this.state = \u0026#34;lose\u0026#34;; let outer = this; setTimeout(function() { outer.add_listening_events(); }, 1000); // 1秒后监听点击事件 } late_update() { this.render(); // 渲染在图层最上方 } render() { let len = this.playground.height / 2; if (this.state === \u0026#34;win\u0026#34;) { this.ctx.drawImage(this.win_img, this.playground.width / 2 - len / 2, this.playground.height / 2 - len / 2, len, len); } else if (this.state === \u0026#34;lose\u0026#34;) { this.ctx.drawImage(this.lose_img, this.playground.width / 2 - len / 2, this.playground.height / 2 - len / 2, len, len); } } } 通过游戏结束的逻辑判断，渲染结束界面，同时在结束并返回主菜单的时候，重置游戏元素\n游戏元素重置\nplayground/zbase.js\nclass AcGamePlayground { ... show(mode) { // 打开 playground 界面 ... this.score_board = new ScoreBoard(this); ... } ... hide() { // 清空所有游戏元素 while (this.players \u0026amp;\u0026amp; this.players.length \u0026gt; 0) { this.players[0].destroy(); } if (this.game_map) { this.game_map.destroy(); this.game_map = null; } if (this.notice_board) { this.notice_board.destroy(); this.notice_board = null; } if (this.score_board) { this.score_board.destroy(); this.score_board = null; } this.$playground.empty(); // 清空所有html标签 this.$playground.hide(); } } 游戏结束的逻辑判断\nplayground/player/zbase.js\nclass Player extends AcGameObject { ... update() { ... this.update_win(); ... } update_win() { // 竞赛状态，且只有一名玩家，且改名玩家就是我，则胜利 if (this.playground.state === \u0026#34;fighting\u0026#34; \u0026amp;\u0026amp; this.character === \u0026#34;me\u0026#34; \u0026amp;\u0026amp; this.playground.players.length === 1) { this.playground.state = \u0026#34;over\u0026#34;; this.playground.score_board.win(); } } ... on_destroy() { // 我死亡，且游戏处于竞赛状态，则失败 if (this.character === \u0026#34;me\u0026#34; \u0026amp;\u0026amp; this.playground.state === \u0026#34;fighting\u0026#34;) { this.playground.state = \u0026#34;over\u0026#34; this.playground.score_board.lose(); } ... } } 更新战绩 这里我们完全交给后端来判断\n在处理广播的 attack 信息的时候，先前我们额外留了一个参数 hp\n围绕该 hp 进行续写，若当前房间内 hp 大于 0 的玩家少于等于 1 个\n则对于所有 hp 为 0 的玩家减 rank 分，大于 0 的玩家加 rank 分\nconsumers/multiplayer/index.py\n... class MultiPlayer(AsyncWebsocketConsumer): ... async def attack(self, data): if not self.room_name: return players = cache.get(self.room_name) if not players: return for player in players: if player[\u0026#39;uuid\u0026#39;] == data[\u0026#39;attackee_uuid\u0026#39;]: player[\u0026#39;hp\u0026#39;] -= 25 remain_cnt = 0 for player in players: if player[\u0026#39;hp\u0026#39;] \u0026gt; 0: remain_cnt += 1 if remain_cnt \u0026gt; 1: # 继续进行游戏 if self.room_name: cache.set(self.room_name, players, 3600) else: # 结算 def db_update_player_score(username, score): player = Player.objects.get(user__username=username) player.score += score player.save() for player in players: if player[\u0026#39;hp\u0026#39;] \u0026lt;= 0: await database_sync_to_async(db_update_player_score)(player[\u0026#39;username\u0026#39;], -5) else: await database_sync_to_async(db_update_player_score)(player[\u0026#39;username\u0026#39;], 10) ... ... 添加favicon.ico 这是修正一个小 BUG，之前 web 端一直没有网页显示图标，这里给他加上去\ngame/templates/multiends/web.html\n... \u0026lt;head\u0026gt; ... \u0026lt;link rel=\u0026#34;icon\u0026#34; href=\u0026#34;https://cdn.acwing.com/media/article/image/2021/12/17/1_be4c11ce5f-acapp.png\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; ... 各种环境命令 启动django项目，在~/acapp目录下执行： python3 manage.py runserver 0.0.0.0:8000 每次修改好 game/static 下的文件后，需要在~/acapp目录下运行打包文件： ./scripts/compress_game_js.sh 在定义完一个数据表之后，需要将创建的数据表更新到 django 的数据库中去： $ python3 manage.py makemigrations \u0026gt; Migrations for \u0026#39;game\u0026#39;: \u0026gt; game/migrations/0001_initial.py \u0026gt; - Create model Player $ $ python3 manage.py migrate \u0026gt; Operations to perform: \u0026gt; Apply all migrations: admin, auth, contenttypes, game, sessions \u0026gt; Running migrations: \u0026gt; Applying game.0001_initial... OK 启动nginx服务，用于域名访问： sudo /etc/init.d/nginx start 启动uwsgi服务，用于域名访问： uwsgi --ini scripts/uwsgi.ini 关闭uwsgi服务： sudo pkill -f uwsgi -9 启动 redis-server，用于一键登录： sudo redis-server /etc/redis/redis.conf 启动 Django_channels，用于联机对战，在~/acapp目录下执行： daphne -b 0.0.0.0 -p 5015 acapp.asgi:application 启动thrift服务，用于匹配系统，在~/acapp/match_system/src/目录下执行： ./main.py 版本更新，在术士之战中将 js地址 一栏更新为： // 本地文件夹中对应的文件也需要更改名字 https://app2433.acapp.acwing.com.cn/static/js/dist/game-版本号.js ","permalink":"https://xancoding.cn/posts/2022-10-29-18-23-59/","summary":"AcWing Django 框架课 | Colopen\u0026rsquo;s blog AcWing Django 框架课 WarOfWarlock 搭建工具 HTML \u0026amp; CSS \u0026amp; JavaScript \u0026amp; Django 参考资料 AcWing Django 框架课 | Colopen\u0026rsquo;s blog AcWing Django框架课 Django 项目创建 2.1上课笔记 | 栎 2.1上课笔记 | Andrew1729","title":"WarOfWarlock--AcWing Django 框架课"},{"content":"OSI模型每层的数据单元名称 第一层：物理层；二进制比特流传输；bit（比特流） 第二层：数据链路层；介质访问控制；frame（帧） 第三层：网络层；确定地址和路由选择；packet（包），又叫做分组 第四层：传输层；端到端连接；也叫作数据包。TCP的数据单元叫数据段，segment（段），而UDP协议的数据单元称为数据报（datagram） 每层有特殊叫法，这种叫法是PDU（Protocol Data Unit 协议数据单元）。物理层的PDU叫做比特流，数据链路层的-PDU叫做帧；网络层的PDU叫做包；传输层的PDU叫做段，高层的PDU叫做数据（Data） 数据链路层 以太网有一个重要的参数 $a$，它必须保持为很小的数值。这里 t 是以太网单程端到端时延， T0 是帧的发送时间。我们知道， T0 是帧长与发送速率之比，可见为了保持参数 a 不变，可以使t 与发送速率的乘积不变。在帧长一定的条件下，若数据率提高到 10 倍，可把网络电缆长度（因而使 t ）减小到原有数值的十分之一 以太网帧的最小长度 64 Byte 是由 CSMA/CD 限制所致 最早的以太网工作方式：载波多路复用/冲突检测（CSMA/CD），因为网络是共享的，即任何一个节点发送数据之前，先要侦听线路上是否有数据在传输，如果有，需要等待，如果线路可用，才可以发送。 假设A发出第一个bit位，到达B，而B也正在传输第一个bit位，于是产生冲突，冲突信号得让A在完成最后一个bit位之前到达A。规定以太网中这个一来一回的时间间隙 slot time 是51.2μs（争用期） 信号在以太网上传播信号大概是 1km 需要 5μs，以太网最大端到端时延必须小于争用期的一半（25.6μs）,这相当于以太网最大端到端长度为 5km，实际上以太网覆盖范围没有这么大 在10Mbps（指的是传输速率）的网络中，要求以太网帧最小长度为512个bits，从而让最极端的碰撞都能够被检测到。换算一下就是 64 Byte，以太网帧的最小长度为 64 Byte。 以太网帧的最大长度 1518 Byte 是为了传输效率 由于线路质量差而引起的丢包，发生在大包的概率也比小包概率大得多，所以大包在丢包率较高的线路上不是一个好的选择。 但是如果选择一个比较小的长度，传输效率又不高，拿TCP应用来说，如果选择以太网长度为 218 Byte，TCP payload = 218 - Ethernet Header - IP Header - TCP Header = 218 - 18 - 20 - 20 = 160 Byte。那有效传输效率 = 160 / 218= 73%。而如果以太网长度为 1518 ，那有效传输效率 = 1460 / 1518 = 96% 通过比较，选择较大的帧长度，有效传输效率更高，而更大的帧长度同时也会造成上述的问题，于是最终选择一个折衷的长度：1518 Byte 对应的 IP packet 就是 1500 Byte，这就是 最大传输单元MTU 的由来。 以太网的 MAC 帧格式 网络层 一个链路层帧能承载的最大数据量叫作 最大传输单元MTU，即 IP 数据报总长度（首部 + 数据部分） 数据报的分片重新组装工作在 端系统，而不是网络路由器 IP 数据报分片，其中 标识 字段标识号相同的分片属于同一数据报；最后一个片 标志 字段置0，其余片置1；偏移 字段指定该片应放在初始数据报的哪个位置，以 8 个字节为单位 IP 数据报格式： 首部长度（以4字节为单位）：因为IP数据报包含一些可变数量的选项，所以该字段用以确认IP数据报中载荷（如被封装的运输层报文段）实际开始的地方。一般的IP数据包具有 20 字节的首部（不包含选项） 数据报长度（以1字节为单位）：首部加上数据。16比特，理论上最大长度为65535字节。然而，数据报很少有超过 1500 字节的。 协议：指示该数据报的数据部分应交给哪个特定的传输层协议 首部校验和：帮助路由器检测收到的IP数据报中的比特错误。注意在每台路由器上必须重新计算校验和，因为TTL字段会变。 计算方法：在发送方，先把IP数据报首部划分成许多16位字的序列，并把检验和字段置零。用反码算术运算把所有的 16 位字相加后，将得到的和的反码写入检验和字段。接收方收到数据报后，把首部的所有 16 位字在使用反码算术想加一次，将得到的和取反码得到结果。若此结果为 0 ，说明首部未发生任何变化。 IP 广播地址：255.255.255.255，会转发给同一网络中的所有主机。路由器也会有选择地向临近的子网转发该报文（虽然它们通常不这样做） IP 数据包越短，路由器转发越快。协议 IP 规定，在互联网中所有的主机和路由器必须能够接受长度不超过 576 字节的数据报。这是规定上层交下来的数据长度有 512 字节（合理的长度），加上最长的 IP 首部 60 字节，再加上 4 字节的富余量，得到 576 字节 运输层 UDP UDP报文段格式（UDP首部只有四个字段，每个字段由2个字节构成）（首部固定 8 个字节）： 长度：UDP报文段中的字节数（首部 + 数据），以 字节 为单位 检验和：UDP计算检验和的方法和计算IP数据报首部检验和的方法相似。 在发送方，首先是先把全零放入检验和字段，再把伪首部（12个字节）以及UDP数据报看成是由许多 16 位的字串接起来的。若UDP数据部分不是偶数个字节，则要填入全零字节（但此字节不发送）。然后按二进制反码计算出这些 16 位字的和，将此和的二进制反码写入检验和字段。 在接受方，把收到的UDP用户数据报连同伪首部（以及可能的填充全零字节）一起按二进制反码求这些 16 位字的和。若结果全 1，说明无差错。 伪首部（12 字节）： 4 字节的 源IP地址 字段 4 字节的 目的IP地址 字段 1 字节的 全0 字段 1 字节的 IP首部中的协议（如UDP） 字段 2字节的 IP首部中的数据长度（IP首部 + IP数据） 字段 TCP MSS 是 TCP 报文段中的 数据字段 的最大长度，数据字段 + TCP 首部 = TCP 报文段 由于 IP 数据报所经历的路径是动态变化的，因此在某条路径上不需要分片的 MSS，如果是另一条路径，将可能需要分片。因此最佳 MSS 难以确定。 在连接建立的过程中，双方都把自己能够支持的 MSS 写入TCP MSS 可选字段，以后就按照该数值传送数据，两个传送方向可以由不同的 MSS 值 若主机未填写这一项，默认值为 536 字节 （576 字节的 IP数据报 - 20 字节 IP固定首部 - 20 字节 TCP固定首部） TCP 的有限状态机 粗实线箭头表示对客户进程的正常变迁 粗虚线箭头表示对服务器进程的正常变迁 细线箭头表示异常变迁 TCP 报文段格式 数据偏移：单位为 4 字节，它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远 4. TCP 拥塞控制 5. 三次握手 6. 四次挥手 推荐阅读 【哈工大】计算机网络 李全龙（全59讲） 【中科大】郑烇、杨坚《计算机网络（自顶向下方法 第7版，James F.Kurose，Keith W.Ross）》 计算机网络（谢希仁版）第七版答案 图解网络 | 小林coding Stanford CS144 Lab Assignment 学习笔记 | ViXbob的博客 《网络是怎样连接的》 《图解 HTTP》 《图解TCP/IP（第5版）》 《计算机网络（第8版）》 《计算机网络：自顶向下方法》 《TCP/IP详解 卷1：协议》 《Wireshark网络分析就这么简单》 《Wireshark网络分析的艺术》 \u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e ","permalink":"https://xancoding.cn/posts/2022-10-18-18-34-30/","summary":"OSI模型每层的数据单元名称 第一层：物理层；二进制比特流传输；bit（比特流） 第二层：数据链路层；介质访问控制；frame（帧） 第三层：网络","title":"计算机网络"},{"content":"分治法 分治法的关键步骤包括：\n分成子问题 递归处理子问题 子问题合并 子问题 相互独立，即子问题之间不包含公共的子问题\n分治法是一种求解问题的策略，而递归是一种实现求解算法的技术\n改进分治算法的途径有 减少子问题个数 和 增加预处理。\n在分治法处理中，实践证明，采用 平衡子问题 思想划分子问题总是有较好的结果。\n在大整数乘法和矩阵乘中，可以采取降低 乘法 的运算次数来降低时间复杂度\n分治法的设计思想是将一个难以直接解决的大问题分割成规模较小的子问题，分别解决子问题，最后将子问题的解组合起来形成原问题的解。这要求原问题和子问题 问题规模不同，问题性质相同\n动态规划 虽然动态规划算法通常用于解决具有重叠子问题的问题，但是这并不是动态规划的必要条件。\n动态规划算法的两个基本要素是 无后效性 性质和 最优子结构 性质 。\n备忘录/填表方法是 动态规划法 算法的变形\n动态规划算法基本要素的是 子问题重叠\n动态规划算法的关键步骤包括：\n确定状态和状态转移方程 确定初始状态和边界条件 确定子问题求解顺序 有重叠子问题并不是动态规划的必要条件： 这是正确的。动态规划算法的核心思想是将一个大问题分解成许多小问题，并使用这些小问题的解来构建大问题的解。通常情况下，这些小问题是相互独立的，但是如果它们之间存在重叠，也就是说它们具有相同的子问题，那么动态规划算法可以利用这些重叠来避免重复计算，从而提高效率。\n然而，并不是所有的动态规划问题都具有重叠子问题。例如，有些动态规划问题只是简单地将一个问题分解成许多相互独立的子问题，而不是使用重叠子问题来避免重复计算。\n因此，具有重叠子问题并不是动态规划算法的必要条件，但是如果存在重叠子问题，动态规划算法可以更加高效地解决问题。\n动态规划算法设计中标记函数不是必须的 标记函数是指在动态规划算法中使用的一种技巧，用于记录某些子问题是否已经被求解过。当一个子问题被解决后，标记函数可以将其标记为已解决，从而在后续的计算中避免重复计算。标记函数通常用一个数组或哈希表来实现。\n尽管标记函数在许多动态规划问题中都非常有用，但并不是所有的动态规划问题都需要使用标记函数。实际上，有些动态规划问题的状态转移方程不需要考虑子问题是否已经被求解过，因为它们的状态转移方程本身已经保证了没有重复计算的问题。\n因此，动态规划算法设计中是否需要包含标记函数，取决于具体的问题和算法设计。在一些情况下，标记函数可以提高算法的效率，但在另一些情况下，它们可能不是必需的。\n状态转移方程和标记函数是两个不同的概念，在动态规划算法中起着不同的作用。 状态转移方程是描述问题中子问题之间的转移关系，通常用来计算当前子问题的最优解。在动态规划算法中，我们将原问题分解成若干个子问题，并使用状态转移方程计算子问题的最优解，从而逐步构建出原问题的最优解。\n标记函数则是用来标记子问题的解是否已经被计算过。在动态规划算法中，由于子问题之间存在重叠，可能会重复计算同一个子问题的解，导致算法效率下降。标记函数可以用来避免这种情况的发生，当一个子问题的解已经被计算过后，我们可以将其标记为已计算，避免重复计算。\n在某些情况下，状态转移方程和标记函数可能是紧密相关的，例如在使用记忆化搜索优化动态规划算法时，我们通常会将已计算的子问题的解保存在一个表格中，作为标记函数来使用。但在其他情况下，状态转移方程和标记函数可能是相对独立的，可以根据具体问题和算法设计来灵活选择是否使用标记函数。\n贪心法 n皇后问题 不能使用贪心法解决\n贪心算法的基本要素的是 定义最优解\n问题的 最优子结构性质 是该问题可以用 动态规划 或 贪心 求解的关键特征\n回溯法 请画出用回溯法解n=3的0-1背包问题的解空间树和当三个物品的重量为{16, 15, 15}，价值为{45, 25, 25}，背包容量为30时搜索空间树 回溯法有“通用解题法”之称，它可以系统地搜索一个问题的所有解或任意解\n回溯法是一种既带系统性又带有跳跃性的搜索算法\n回溯算法在生成解空间的任一结点时，先判断该结点是否可能包含问题的解，如果肯定不包含，则跳过对该结点为根的子树的搜索，逐层向祖先结点回溯\n回溯法的解空间树有 子集树、排列树、n 叉树\n回溯法是一种 带剪枝 的穷举法，它采用了 深度优先 搜索方式，求得问题的 最优解 或所有解\n回溯法中用到的两种约束条件是 目标函数和约束函数 两种\n回溯法的效率不依赖于 确定解空间的时间\n剪枝函数 函数是回溯法中为避免无效搜索采取的策略\n分支限界法 限重 15 优先队列式分枝限界法选取扩展结点的原则是 结点的优先级\n采用最大效益优先搜索方式的算法是 分支限界法\n分支限界法求解0/1背包问题时，活结点表的组织形式是 大根堆\n常见的两种分支限界法为 队列式（FIFO）分支限界法与优先队列式分支限界法\n分支限界法在问题的解空间树中，按 广度优先 策略，从根结点出发搜索解空间树 递推式的计算 主定理 假设 $T(n)$ 是一个递归算法的时间复杂度，其中 $n$ 是输入规模。假设算法分解问题时，将其划分为 $a$ 个子问题，每个子问题的规模为原问题的 $1/b$，且每个子问题的解需要 $f(n)$ 的时间。即： $$T(n) = aT(n/b) + f(n)$$\n假设分解问题和合并子问题的过程需要常数时间 $d$，那么主定理的公式如下：\n易记（不严谨） 如果 $f(n) \u0026lt; O(n^{\\log_b(a)})$，那么 $T(n) = \\Theta(n^{\\log_b(a)})$\n如果 $f(n) = \\Theta(n^{\\log_b(a)})$，那么 $T(n) = \\Theta(n^{\\log_b(a)} \\log n)$\n如果 $f(n) \u0026gt; \\Omega(n^{\\log_b(a)})$，那么 $T(n) = \\Theta(f(n))$。\n这里的比较指的是数量级的大小\n严谨 如果 $f(n) = O(n^{\\log_b(a - \\epsilon)})$，那么 $T(n) = \\Theta(n^{\\log_b(a)})$\n如果 $f(n) = \\Theta(n^{\\log_b(a)})$，那么 $T(n) = \\Theta(n^{\\log_b(a)} \\log n)$\n如果 $f(n) = \\Omega(n^{\\log_b(a + \\epsilon)})$，且对于某个常数 $c \u0026lt; 1$ 和所有足够大的 $n$ 都有 $af(n/b) \\le cf(n)$，那么 $T(n) = \\Theta(f(n))$。\n其中 $\\epsilon \u0026gt; 0$ 是任意小的正数。这里的 $O$、$\\Theta$ 和 $\\Omega$ 表示渐进符号。\n主定理没有覆盖所有情况 如果情况一和三的渐进小于或大于不是多项式意义上的，而是logn之类的，就不能应用主定理。 P \u0026amp; NP \u0026amp; NPC \u0026amp; NP-Hard NP问题是指可以在多项式的时间里验证一个解的问题\n若一个问题可以找到一个能在多项式的时间里解决它的算法，该问题就属于P问题\nNPC问题指的是NP问题中最难的问题之一，同时也是NP问题中的一个子集，因此只要能将所有的NP问题约化为它，它就是NP问题。\n所有的P类问题都是NP问题的子集。\nP: 能在多项式时间内解决的问题\nNP: 不能在多项式时间内解决或不确定能不能在多项式时间内解决，但 能在多项式时间验证的问题\nNPC: NP完全问题， 所有NP问题在多项式时间内都能约化(Reducibility)到它的NP问题 ，即解决了此NPC问题，所有NP问题也都得到解决。\nNP hard:NP难问题， 所有NP问题在多项式时间内都能约化(Reducibility)到它的问题(不一定是NP问题)。\n其他知识点 描述算法时间增长率上限用 O 符号，增长率下限用 Ω 符号表示。\n图灵机模型的基本结构包括 纸带,读写头,有限状态自动机。\n所有可计算问题都可以用递归模型和 图灵机 模型求解\n一个基于BSP模型的并行算法，假设有p台处理器，用于计算整数数组a[0..n-1]的所有元素之和，算法的时间复杂度为 O(n/p+p)\n分支限界法与回溯法都是在问题的解空间树T上搜索问题的解，二者 求解目标不同，搜索方式也不同\n回溯法 的求解目标是找出T中满足约束条件的 所有解 ，而 分支限界法 的求解目标则是找出 满足约束条件的一个解 ，或是在满足约束条件的解中找出使某一目标函数值达到 极大或极小的解 ，即在某种意义下的 最优解 。\n回溯算法和分支限界法的问题的解空间树是 无需构造\n分支限界法与回溯法的相同点是在状态空间树上搜索，不同点之一是分支限界法采用 广度优先或最小代价优先 搜索 。\n问题的 最优子结构 是该问题可用动态规划算法或贪心算法求解的关键特征。\n简述五大算法的基本思想及算法结构 五大算法基本思想包括分治，动态规划，贪心，回溯和分支限界法。\n分治法的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。 动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。 贪心算法（也叫贪婪算法）是指在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，只做出在某种意义上的局部最优解。 回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。 分支限界法也是一种在问题的解空间树T上搜索问题解的算法。但在一般情况下，分支限界法与回溯法的求解目标不同。回溯法的求解目标是找出T中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。 五大算法的算法结构如下：\n分治法的算法结构通常包括三个步骤：分解问题，解决子问题和合并子问题解。首先，将原问题分解为若干个规模较小的子问题；然后，递归地解决这些子问题；最后，将各个子问题的解合并为原问题的解。\n动态规划法的算法结构通常包括四个步骤：分析最优解的性质并刻画其结构特征，递归地定义最优值，以自底向上或自顶向下的方式计算出最优值，根据计算最优值时得到的信息构造一个最优解。\n贪心法的算法结构通常包括两个步骤：建立数学模型来描述问题，把求解的问题分成若干个子问题。对每一子问题求解，得到子问题的局部最优解。把子问题的局部最优解合成原来解问题的一个解。\n回溯法的算法结构通常包括两个步骤：针对所给问题，确定问题的解空间；确定结点的扩展搜索规则。以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。\n分支限界法的算法结构通常包括两个步骤：在扩展结点处，先生成其所有的儿子结点（分支），然后再从当前的活结点表中选择下一个扩展对点；为了有效地选择下一扩展结点，以加速搜索的进程，在每一活结点处，计算一个函数值（限界），并根据这些已计算出的函数值，从当前活结点表中选择一个最有利的结点作为扩展结点。\n先进先出队列/优先队列搜索的设计要点是什么？ 先进先出队列（FIFO）和优先队列都是一种数据结构，它们的设计要点不同。\n先进先出队列（FIFO）的设计要点是保证元素的出队顺序与它们的入队顺序相同。也就是说，最先入队的元素应该最先出队。\n优先队列的设计要点是高效地将队列中优先级最高的那个元素弹出来（复杂度O (lgN)）。\n请叙述动态规划算法与贪心算法的异同 动态规划和贪心算法都是用来求解最优化问题的算法。它们都试图通过一系列的决策来找到问题的最优解。但它们在解决问题的方法上有所不同。\n动态规划是一种分阶段决策的方法。它将原问题分解为若干个子问题，通过求解子问题来推导出原问题的解。动态规划通常用于求解具有最优子结构性质的问题，即原问题的最优解可以由子问题的最优解推导出来。动态规划算法通常需要记录子问题的解，以避免重复计算。\n贪心算法则是一种局部最优决策的方法。它在每一步都做出当前看来最优的选择，希望这样能够导致全局最优解。贪心算法通常用于求解具有贪心选择性质的问题，即局部最优选择能够导致全局最优解。\n总之，动态规划和贪心算法都是用来求解最优化问题的算法，但它们在解决问题的方法上有所不同。动态规划通过分阶段决策来求解问题，而贪心算法则通过局部最优决策来求解问题。\n衡量算法时间效率的方法有哪两种？请叙述。 衡量算法时间效率的方法主要有两种：事后统计法和渐进时间复杂度分析。\n事后统计法：这种方法是通过运行算法并测量其实际运行时间来衡量算法的时间效率。这种方法的优点是结果直观、准确，但缺点是受到硬件、软件和数据等多种因素的影响，不具有普遍性。\n渐进时间复杂度分析：这种方法是通过分析算法的执行步骤来估计算法的时间效率。它不关心具体的常数因子，而是关注算法运行时间随着问题规模增长的增长趋势。这种方法的优点是结果具有普遍性，不受硬件、软件和数据等因素的影响，但缺点是结果不够直观、准确。\n总之，衡量算法时间效率的方法主要有事后统计法和渐进时间复杂度分析两种。它们各有优缺点，可以根据实际情况选择适当的方法来衡量算法的时间效率。\n推荐阅读 数据结构与算法 | 我的笔记 LABULADONG 的算法网站 代码随想录 x 数据结构与算法 AcWing 算法基础课 AcWing 算法提高课 AcWing 算法进阶课 OI Wiki CP Wiki LeetCode AcWing Luogo Codeforces 《大话数据结构》 《labuladong的算法小抄》 《算法竞赛进阶指南》 《算法（第4版）》 \u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e ","permalink":"https://xancoding.cn/posts/2022-10-18-17-16-53/","summary":"分治法 分治法的关键步骤包括： 分成子问题 递归处理子问题 子问题合并 子问题 相互独立，即子问题之间不包含公共的子问题 分治法是一种求解问题的策略，而递","title":"数据结构与算法"},{"content":"正则表达式是什么？ 正则表达式，又称规则表达式，通常被用来检索、替换那些符合某个规则的文本\n正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑\n为什么要学习正则表达式？ 在需要「批量处理文本」的时候，方便「查找」\u0026amp;\u0026amp;「替换」 Linux grep 命令 Python 爬虫 Everthing 搜索文件 推荐阅读 IHateRegex 正则可视化工具 Regulex 正则可视化工具 Regexper 正则可视化工具 正则可视化 正则可视化工具 regex101 在线正则测试工具 regexgen 生成与一组字符串匹配的正则表达式 any-rule 正则大全 多种实际使用场景，正则表达式带来丰富可能性 正则表达式30分钟入门教程 《正则表达式必知必会》 《精通正则表达式》 \u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e ","permalink":"https://xancoding.cn/posts/2022-10-17-12-55-47/","summary":"正则表达式是什么？ 正则表达式，又称规则表达式，通常被用来检索、替换那些符合某个规则的文本 正则表达式是对字符串操作的一种逻辑公式，就是用事先定","title":"正则表达式学习记"},{"content":"LaTex是什么？ LaTeX是一种基于ΤΕΧ的排版系统，常被用于排版期刊文章、书籍、学位论文\n推荐阅读 LaTeXLive 在线 LaTeX 公式编辑器 Overleaf 在线 LaTeX 编辑器 LaTeX 新手上路指南 TeX Live 安装与 LaTeX 基础知识普及 LaTeX-TeXlive和TeXstudio的下载、安装配置及使用 【LaTeX】新手教程：从入门到日常使用 【LaTeX】针对萌新自学者的入门教程 一份不太简短的 LATEX 介绍 《Latex入门》 \u003c!DOCTYPE HTML\u003e ","permalink":"https://xancoding.cn/posts/2022-10-17-12-55-19/","summary":"LaTex是什么？ LaTeX是一种基于ΤΕΧ的排版系统，常被用于排版期刊文章、书籍、学位论文 推荐阅读 LaTeXLive 在线 LaTeX 公式编辑器 Overleaf 在线 LaTeX 编辑器 LaTeX 新手上","title":"LaTex学习记"},{"content":"Markdown是什么？ Markdown是一种轻量级标记语言，排版语法简洁，让人们更多地关注内容本身而非排版。\n它使用易读易写的纯文本格式编写文档，可与HTML混编，可导出 HTML、PDF 以及本身的 .md 格式的文件。\n因简洁、高效、易读、易写，Markdown被大量使用，如Github、Wikipedia等网站，如各大博客平台：WordPress、Drupal、简书等\nMarkdown常用语法 转义 如果需要避免文本中的符号被当做markdown标识符而发生不必要的格式转化，可以在符号前加\\来避免。\n可被转义的特殊符号如下： 示例如下： 角标 不同于链接，这里的角标内容会被放在文末，点击可以实现跳转。\n书写格式如下：\n请参阅脚注1. [^1] [^1]: 脚注1内容。 请参阅脚注2. [^2] [^2]: 脚注2内容。 解析效果如下：\n请参阅脚注1. 1\n请参阅脚注2. 2\n段落与换行 如果行与行之间没有空行，则会被视为同一段落 如果行与行之间有空行，则会被视为不同的段落 空行是指行内什么都没有，或者只有空格和制表符 如果想在段内换行，则需要在上一行的结尾插入两个以上的空格然后按回车键 代码块 建议不要在没有输出内容的Shell命令前加$，在有输出内容的Shell命令前加上$ $ echo \u0026#34;test\u0026#34; test 引用 锚点 锚点，也称为书签，用来标记文档的特定位置，使用锚点可以跳转到当前文档或其他文档中指定的标记位置\n语法：[锚点描述](#锚点名)\n锚点名建议使用字母和数字，当然中文也是被支持的，但不排除有些网站支持得不够好 锚点名是区分英文大小写的 在锚点名中不能含有空格，也不能含有特殊字符 示例： [转义](#转义)\n转义\n表格 Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行\n语法格式如下：\n| 表头 | 表头 | | ---- | ---- | | 单元格 | 单元格 | | 单元格 | 单元格 | 表头 表头 单元格 单元格 单元格 单元格 我们可以设置表格的对齐方式：\n-: 设置内容和标题栏居右对齐。 :- 设置内容和标题栏居左对齐。 :-: 设置内容和标题栏居中对齐。 实例如下：\n| 左对齐 | 右对齐 | 居中对齐 | | :-----| ----: | :----: | | 单元格 | 单元格 | 单元格 | | 单元格 | 单元格 | 单元格 | 排版技巧 关于空格 建议中文和英文之间加空格，中/英文和数字之间也要加空格\n加空格的情况 英文标点符号与后面的字符之间需要加空格，与前面的字符之间不需要加空格：\nMore ways to shop:Visit an Apple Store, call 1-800-MY-APPLE, or find a reseller\n当在中文、英文中使用＞标识路径时，两边都需要加空格：\nErase data and settings in Settings \u0026gt; General \u0026gt; Reset \u0026gt; Erase all Content and Settings\n抹掉所有内容和设置的操作步骤：设置 \u0026gt; 通用 \u0026gt; 还原 \u0026gt; 抹掉所有内容和设置\n不加空格的情况 中文标点符号和数字、中文、英文之间不需要添加空格\n数字和百分号之间不需要添加空格\n数字和单位符号之间不需要添加空格\n英文和数字组合成的名字之间不需要添加空格\n当/表示“或”、“路径”时，与前后的字符之间均不加空格：\n小明精通“Python/Java/Go/Swift”的Hello Word打印语法\n/Volumes/warehouse/README.md\n货币符号后不加空格\n负号后不加空格\n推荐阅读 Markdown - All You Need to Know Markdown 官方教程 Markdown 指南中文版 《了不起的Markdown》 \u003c!DOCTYPE HTML\u003e 脚注1内容。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n脚注2内容。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://xancoding.cn/posts/2022-10-17-12-54-56/","summary":"Markdown是什么？ Markdown是一种轻量级标记语言，排版语法简洁，让人们更多地关注内容本身而非排版。 它使用易读易写的纯文本格式编写","title":"Markdown学习记"},{"content":" AcWing Linux 基础课 | Colopen\u0026rsquo;s blog AcWing Linux 基础课 命令行的艺术 The Missing Semester of Your CS Education Terminal 终端，一个程序，是界面上打开的黑框框本身，shell 运行于其中\nShell 常用文件管理命令 | AcWing Linux 基础课 Shell 语法 | AcWing Linux 基础课 管道、环境变量与常用命令 | AcWing Linux 基础课 常用命令 | AcWing Linux 基础课 《Bash 脚本教程》 第 1 讲 - 课程概览与 Shell | The missing semester of your CS education 第 2 讲 - Shell 工具和脚本 | The missing semester of your CS education # 帮你打造超酷的shell终端！zsh+oh my zsh+powerlevel10k Shell是什么？ Shell 是我们通过命令行与操作系统沟通的 程序，是个 命令行解释器 Shell 脚本可以直接在命令行中执行，也可以将一套逻辑组织成一个文件，方便复用 Shell 负责外界与 Linux 内核 的交互，接收用户或其他应用程序的命令，然后把这些命令转化成内核能理解的语言，传给内核，内核是真正干活的，干完之后再把结果返回用户或应用程序 Shell解释器有 sh、bash、zsh... Shell常用命令 ag xxx：搜索当前目录下的所有文件，检索xxx字符串 find /path/to/directory/ -name '*.py'：搜索某个文件路径下的所有*.py文件 history：展示当前用户的历史操作。内容存放在~/.bash_history中 grep xxx：从stdin中读入若干行数据，如果某行中包含xxx，则输出该行；否则忽略该行，用于查找文件里符合条件的字符串 Tmux \u0026amp;\u0026amp; Vim Tmux和Vim | AcWing Linux 基础课 Tmux 使用教程 | 阮一峰的网络日志 Tmux 简介与使用 | Huoty\u0026rsquo;s Blog 简明 VIM 练级攻略 | 酷壳 第 3 讲 - 编辑器 (Vim) | The missing semester of your CS education VIM 大冒险 - Game Tmux 是什么？ Tmux 是一个用于在终端窗口中运行多个终端会话的工具，即终端复用软件（terminal multiplexer）\n远程 SSH 访问服务器进行工作时。即使非正常掉线，它能保存当前工作状态，并保证当前任务继续运行。\nTmux \u0026amp;\u0026amp; Session \u0026amp;\u0026amp; Window \u0026amp;\u0026amp; Pane 一个tmux 可以有好多个session(会话) 一个session可以有好多个window(窗口) 一个window可以有好多个pane(面板) 一个session里不超过10个window是最方便的：可以用0到9迅速切换 Tmux常用命令 Ac-Terminal 下前缀键被修改成了 Ctrl + a，一般的默认情况下是 Ctrl + b\ntmux new -s \u0026lt;session-name\u0026gt;：新建会话 tmux detach $or$ Ctrl + a d：分离会话，退出当前 Tmux 窗口，但是会话和里面的进程仍然在后台运行 tmux attach -t \u0026lt;session-name\u0026gt;：重新接入某个已存在的会话 tmux kill-session -t \u0026lt;session-name\u0026gt;：杀死某个会话 tmux switch -t \u0026lt;session-name\u0026gt;：切换会话 tmux rename-session -t \u0026lt;old-name\u0026gt; \u0026lt;new-name\u0026gt;：重命名会话 tmux ls $or$ Ctrl + a s：查看当前所有的 Tmux 会话 在tmux中选中文本时，需要按住 shift 键 tmux中复制/粘贴文本： 按下 Ctrl + a 后松开手指，然后按 [ 用鼠标选中文本，被选中的文本会被自动复制到tmux的剪贴板 按下 Ctrl + a 后松开手指，然后按 ] ，会将剪贴板中的内容粘贴到光标处 Vim 是什么？ VIM 是 Linux 系统上一款文本编辑器，它是操作 Linux 的一款利器。\nVim常用命令 一般模式切换到编辑模式（常用） i : 在光标所处位置 直接 开始 a : 在光标所处位置的 下一个字符 开始 o : 在光标所处位置的 下一行 开始 r : 取代当前光标处的字符，然后开始 [ESC] : 退出编辑模式，回到一般模式 光标移动操作 n\u0026lt;Space\u0026gt; : n 为数字，光标 向右移动这一行的n个字符 n\u0026lt;Enter\u0026gt; : n 为数字，光标 向下移动n行 0 或 功能键[Home]: 光标移动到 本行开头 $ 或 功能键[End]: 光标移动到 本行末尾 :n 或 nG : n 为数字，光标移动到 第n行 G: 光标移动到 最后一行 gg : 光标移动到 第一行 查找、替换操作 /word : 向 光标之下 寻找 第一个值为 word 的字符串 ?word : 向 光标之上 寻找 第一个值为 word 的字符串 n : 重复 前一个 查找操作 N : 反向 重复 前一个 查找操作 :n1,n2s/word1/word2/g : n1 与 n2 为数字，在第 n1 行与 n2 行之间寻找 word1 这个字符串，并将该字符串 替换 为 word2 :1,$s/word1/word2/g : 将全文的 word1 替换为 word2 :1,$s/word1/word2/gc : 将全文的 word1 替换为 word2，且在替换前 要求用户确认 文本操作（可搭配 数字+\u0026lt;Enter\u0026gt;/\u0026lt;Space\u0026gt;、0、G、$ 等使用，达到预期组合效果） v : 选中文本 d : 删除选中的文本 dd : 删除当前行 y : 复制选中的文本 yy : 复制当前行 p : 将复制的数据在光标的下一行/下一个位置 粘贴 u : 撤销 Ctrl + r : 取消撤销 \u0026gt; : 将选中的文本整体 向右缩进一次 \u0026lt; : 将选中的文本整体 向左缩进一次 命令行操作 :w : 保存 :w! : 强制保存 :q : 退出 :q! : 强制退出 :wq : 保存并退出 :set paste : 设置成粘贴模式，取消代码自动缩进 :set nopaste : 取消粘贴模式，开启代码自动缩进 :set nu : 显示行号 :set nonu : 隐藏行号 :noh：关闭查找关键词高亮 Ctrl + q : 当vim卡死时，可以 取消当前正在执行的命令 SSH SSH | AcWing Linux 基础课 Adding a new SSH key to your GitHub account SSH是什么？ SSH是一种网络协议，用于计算机之间的加密登录\nSSH 免密登录 ssh-key-gen ：在本地服务器生成密钥 cd .ssh/ vim config ：定义服务器别名 Host server HostName 服务器IP地址 User 登录用户名 port 远程主机端口号，默认为 22 ssh-copy-id server：在本地服务器配置免密登录至云服务器 免密登录至docker 容器步骤同上 配置完成后，就可以直接使用 ssh server 免密登录啦 SCP SCP | AcWing Linux 基础课 SCP是什么？ SCP是一个命令行程序，可让您在计算机之间安全地复制文件和目录\nSCP 传文件 复制多个文件：scp source1 source2 LOCAL_PATH SERVER:SERVER_PATH 复制文件夹 ： scp -r ~/tmp SERVER:/home/acs/：将本地家目录中的tmp文件夹复制到服务器中的/home/acs/目录下 scp -r SERVER:homework .：将服务器中的~/homework/文件夹复制到本地的当前路径下 Git Git | AcWing Linux 基础课 Git从放弃到入门 Git从放弃到入门：状态与阶段 Git从放弃到入门：撤销操作 Git 原理入门 Learn Git Braching - Game Pro Git Online Git是什么？ Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理\nGit常用命令 常用命令 git add XX：将XX文件添加到暂存区 git commit -m \u0026quot;给自己看的备注信息\u0026quot;：将暂存区的内容提交到当前分支 git push -u (第一次需要 -u 以后不需要) ：将当前分支推送到远程仓库 git clone git@git.acwing.com:xxx/XXX.git：将远程仓库XXX下载到当前目录下 git log：查看当前分支的所有版本 git status：查看仓库状态 有时候暂存了更改，尚未提交至仓库，如何取消暂存的更改？ git restore --staged XX或git reset HEAD XX：将XX从暂存区里移除 有时候修改了本地工作目录（通常也叫工作区）的文件，如何放弃本地更改（尚未暂存）？ git checkout XX或git restore XX：将XX文件尚未加入暂存区的修改全部撤销 Git 全局设置 git config --global user.name xxx：设置全局用户名，信息记录在~/.gitconfig文件中 git config --global user.email xxx@xxx.com：设置全局邮箱地址，信息记录在~/.gitconfig文件中 git init：将当前目录配置成git仓库，信息记录在隐藏的.git文件夹中 Git 查看命令 git diff XX：查看XX文件相对于暂存区修改了哪些内容 git status：查看仓库状态 git log：查看当前分支的所有版本 git log --pretty=oneline：用一行来显示 git reflog：查看HEAD指针的移动历史（包括被回滚的版本） git branch：查看所有分支和当前所处分支 git pull ：将远程仓库的当前分支与本地仓库的当前分支合并 Git 删除命令 git rm --cached XX：将文件从仓库索引目录中删掉，不希望管理这个文件 git restore --staged xx：将xx从暂存区里移除 git checkout — XX或git restore XX：将XX文件尚未加入暂存区的修改全部撤销 Git 代码回滚 git reset --hard HEAD^或git reset --hard HEAD~ ：将代码库回滚到上一个版本 git reset --hard HEAD^^：往上回滚两次，以此类推 git reset --hard HEAD~100：往上回滚100个版本 git reset --hard 版本号：回滚到某一特定版本 Git 远程仓库 git remote add origin git@git.acwing.com:xxx/XXX.git：将本地仓库关联到远程仓库 git push -u (第一次需要-u以后不需要) ：将当前分支推送到远程仓库 git push origin branch_name：将本地的某个分支推送到远程仓库 git clone git@git.acwing.com:xxx/XXX.git：将远程仓库XXX下载到当前目录下 git push --set-upstream origin branch_name：设置本地的branch_name分支对应远程仓库的branch_name分支 git push -d origin branch_name：删除远程仓库的branch_name分支 git checkout -t origin/branch_name：将远程的branch_name分支拉取到本地 git pull：将远程仓库的当前分支与本地仓库的当前分支合并 git pull origin branch_name：将远程仓库的branch_name分支与本地仓库的当前分支合并 git branch --set-upstream-to=origin/branch_name1 branch_name2：将远程的 branch_name1分支与本地的branch_name2分支对应 Git 分支命令 git branch branch_name：创建新分支 git branch：查看所有分支和当前所处分支 git checkout -b branch_name：创建并切换到branch_name这个分支 git checkout branch_name：切换到branch_name这个分支 git merge branch_name：将分支branch_name合并到当前分支上 git branch -d branch_name：删除本地仓库的branch_name分支 git push --set-upstream origin branch_name：设置本地的branch_name分支对应远程仓库的branch_name分支 git push -d origin branch_name：删除远程仓库的branch_name分支 git checkout -t origin/branch_name：将远程的branch_name分支拉取到本地 git pull ：将远程仓库的当前分支与本地仓库的当前分支合并 git pull origin branch_name：将远程仓库的branch_name分支与本地仓库的当前分支合并 git branch --set-upstream-to=origin/branch_name1 branch_name2：将远程的 branch_name1分支与本地的branch_name2分支对应 Git stash 暂存 git stash：将工作区和暂存区中尚未提交的修改存入栈中 git stash apply：将栈顶存储的修改恢复到当前分支，但不删除栈顶元素 git stash drop：删除栈顶存储的修改 git stash pop：将栈顶存储的修改恢复到当前分支，同时删除栈顶元素 git stash list：查看栈中所有元素 Git更换远程仓库地址 git remote -v # 查看远端地址 git remote # 查看远端仓库名 git remote rm origin # 删除远程的仓库 git remote add origin https://github.com/xx/xx.git （新地址） # 重新添加远程仓库 git push --set-upstream origin master 本地项目上传到GitHub 配置ssh-key实现本地与Git服务器免密交互 ssh-keygen # 生成密钥 cat .ssh/id_rsa.pub # 复制密钥，提交到 git 服务器的 ssh 密钥中 按照下面的操作在本地文件夹配置一下Git： git config --global user.name xxx # 设置用户名 git config --global user.email xxx@xxx.com # 设置用户邮箱 git init git add . git commit -m \u0026#34;xxx\u0026#34; git remote add origin https://github.com/xxx/XXX.git # 建立连接 git push -u origin master .gitignore的作用 工程常识：缓存文件，可执行文件，编译文件 不要传到自己的 git 项目里\n.gitignore的作用就是帮助我们在git add时将我们指定的一些文件自动排除在外，不提交到git当中\n在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件\nThrift Thrift | AcWing Linux 基础课 Thrift_learning - AcGit AcWing Linux 基础课 | Colopen\u0026rsquo;s blog | Thrift thrift 官网 -\u0026gt; Tutorial -\u0026gt; tutorial.thrift Thrift是什么？ Thrift是一个轻量级、跨语言的远程过程服务调用（RPC）框架\nRPC（远程过程调用）是一个计算机通信协议，该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程\nThrift用于跨语言服务开发，它将软件栈和代码生成引擎结合在一起，以构建在 C++、Java、Python、PHP、Ruby、Erlang、Perl、Haskell、C#、Cocoa、JavaScript、Node. Js、Smalltalk、OCaml 和 Delphi 等语言之间高效、无缝地工作的服务\n例：实现一个游戏的匹配服务 基本框架 游戏应用端 game（Python3） 客户端：与 匹配系统服务器 的服务端交互 匹配系统服务器 match_system（C++） 服务端：与 游戏应用端 的客户端交互 客户端：与 数据存储服务器 的服务端交互 数据存储服务器（已经实现） 服务端：与 匹配系统服务器 的客户端交互 文件结构 |-- README.md |-- game | `-- src | |-- client.py | `-- match_client | |-- __init__.py | |-- __pycache__ | | `-- __init__.cpython-38.pyc | `-- match | |-- Match.py | |-- __init__.py | |-- __pycache__ | | |-- Match.cpython-38.pyc | | |-- __init__.cpython-38.pyc | | `-- ttypes.cpython-38.pyc | |-- constants.py | `-- ttypes.py |-- match_system | `-- src | |-- Match.o | |-- Save.o | |-- main | |-- main.cpp | |-- main.o | |-- match_server | | |-- Match.cpp | | |-- Match.h | | |-- match_types.cpp | | `-- match_types.h | |-- match_types.o | `-- save_client | |-- Save.cpp | |-- Save.h | `-- save_types.h `-- thrift |-- match.thrift `-- save.thrift 实现过程 定义接口 (thrift 文件夹用于存放接口 ) 完成 Server 端 通过match.thrift接口在match_system文件夹下生成 C++版本的服务端 thrift -r --gen cpp tutorial.thrift 将gen cpp 文件夹重命名，如：match_server（区别于之后要在此处生成的client_server） 把 Match_server.skeleton.cpp 移动到当前 src 目录下并重命名为 main.cpp 由于移动了 main.cpp 故需要修改一下 main.cpp 中头文件里关于 Match.h 的引用路径：#include \u0026quot;Match.h\u0026quot; -\u0026gt; #include \u0026quot;match_server/Match.h\u0026quot; 在main.cpp中实现具体业务逻辑 完成 Client 端 通过match.thrift接口在game文件夹下生成 python3 版本的服务端，然后通过修改得到客户端 thrift -r --gen py tutorial.thrift 删掉 Match_remote ，该文件是用 py 实现 服务端 时用的文件，此处我们只需要实现 客户端 功能，因此他没有作用，不妨删掉，让文档简洁一点 利用官网提供的模板，在src文件夹下编写 客户端 文件 client.py 持久化到云端 将 非编译文件 和 非可执行文件 提交到 git 中去（好的工程习惯） Cpp git restore --stage *.o git restore --stage main Python git restore --stage *.pyc # .pyc文件是编译文件，不加入暂存区里 git restore --stage *.swp # .swp文件是缓存文件，不加入暂存区里 注意：先运行服务器后，客户端才能正常运行 Thrift 接口 Match.thrift namespace cpp match_service struct User { 1: i32 id, 2: string name, 3: i32 scores } service Match { i32 add_user(1: User user, 2: string info), i32 remove_user(1: User user, 2: string info), } Save.thrift namespace cpp save_service service Save { /** * username: myserver的名称 * password: myserver的密码的md5值的前8位，用命令md5sum * 用户名密码验证成功会返回0，验证失败会返回1 * 验证成功后，结果会被保存到myserver:homework/lesson_6/result.txt中 */ i32 save_data(1: string username, 2: string password, 3: i32 player1_id, 4: i32 player2_id) } 各版本预览 Match_server:1.0 match_client：创建固定的User from match_client.match import Match from match_client.match.ttypes import User from thrift import Thrift from thrift.transport import TSocket from thrift.transport import TTransport from thrift.protocol import TBinaryProtocol def main(): # Make socket transport = TSocket.TSocket(\u0026#39;localhost\u0026#39;, 9090) # Buffering is critical. Raw sockets are very slow transport = TTransport.TBufferedTransport(transport) # Wrap in a protocol protocol = TBinaryProtocol.TBinaryProtocol(transport) # Create a client to use the protocol encoder client = Match.Client(protocol) # Connect! transport.open() user = User(1, \u0026#39;yxc\u0026#39;, 1500) client.add_user(user, \u0026#34;\u0026#34;) # Close! transport.close() # 调用 main 函数 if __name__ == \u0026#34;__main__\u0026#34;: main() match_server // This autogenerated skeleton file illustrates how to build a server. // You should copy it to another filename to avoid overwriting it. #include \u0026#34;match_server/Match.h\u0026#34; #include \u0026lt;thrift/protocol/TBinaryProtocol.h\u0026gt; #include \u0026lt;thrift/server/TSimpleServer.h\u0026gt; #include \u0026lt;thrift/transport/TServerSocket.h\u0026gt; #include \u0026lt;thrift/transport/TBufferTransports.h\u0026gt; #include\u0026lt;iostream\u0026gt; using namespace ::apache::thrift; using namespace ::apache::thrift::protocol; using namespace ::apache::thrift::transport; using namespace ::apache::thrift::server; using namespace ::match_service; using namespace std; class MatchHandler : virtual public MatchIf { public: MatchHandler() { // Your initialization goes here } int32_t add_user(const User\u0026amp; user, const std::string\u0026amp; info) { // Your implementation goes here printf(\u0026#34;add_user\\n\u0026#34;); return 0; } int32_t remove_user(const User\u0026amp; user, const std::string\u0026amp; info) { // Your implementation goes here printf(\u0026#34;remove_user\\n\u0026#34;); return 0; } }; int main(int argc, char **argv) { int port = 9090; ::std::shared_ptr\u0026lt;MatchHandler\u0026gt; handler(new MatchHandler()); ::std::shared_ptr\u0026lt;TProcessor\u0026gt; processor(new MatchProcessor(handler)); ::std::shared_ptr\u0026lt;TServerTransport\u0026gt; serverTransport(new TServerSocket(port)); ::std::shared_ptr\u0026lt;TTransportFactory\u0026gt; transportFactory(new TBufferedTransportFactory()); ::std::shared_ptr\u0026lt;TProtocolFactory\u0026gt; protocolFactory(new TBinaryProtocolFactory()); TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory); cout \u0026lt;\u0026lt; \u0026#34;Start Match Server\u0026#34; \u0026lt;\u0026lt; endl; server.serve(); return 0; } Match_server:2.0 match_client：根据标准输入来创建User from match_client.match import Match from match_client.match.ttypes import User from thrift import Thrift from thrift.transport import TSocket from thrift.transport import TTransport from thrift.protocol import TBinaryProtocol # 利用 python 在终端读入信息需要引入 stdin from sys import stdin # 将原来的通信 main 函数改写成operate函数，每次需要的时候调用一次建立通信传递信息 # 目的是可以一直不断处理信息 # 然后重写 main 函数，使之能不断从终端读入信息 def operate(op, user_id, user_name, score): # Make socket transport = TSocket.TSocket(\u0026#39;localhost\u0026#39;, 9090) # Buffering is critical. Raw sockets are very slow transport = TTransport.TBufferedTransport(transport) # Wrap in a protocol protocol = TBinaryProtocol.TBinaryProtocol(transport) # Create a client to use the protocol encoder client = Match.Client(protocol) # Connect! transport.open() # 针对 op 参数，分别进行 \u0026#34;增加\u0026#34; 与 \u0026#34;删出\u0026#34; 操作 user = User(user_id, user_name, score) if op == \u0026#34;add\u0026#34;: client.add_user(user, \u0026#34;\u0026#34;) else: client.remove_user(user, \u0026#34;\u0026#34;) # Close! transport.close() def main(): for line in stdin: op, user_id, user_name, score = line.split(\u0026#39; \u0026#39;) operate(op, int(user_id), user_name, int(score)) # 调用 main 函数 if __name__ == \u0026#34;__main__\u0026#34;: main() match_server：自动将用户池中前两个用户匹配到一起 // This autogenerated skeleton file illustrates how to build a server. // You should copy it to another filename to avoid overwriting it. #include \u0026#34;match_server/Match.h\u0026#34; #include \u0026lt;thrift/protocol/TBinaryProtocol.h\u0026gt; #include \u0026lt;thrift/server/TSimpleServer.h\u0026gt; #include \u0026lt;thrift/transport/TServerSocket.h\u0026gt; #include \u0026lt;thrift/transport/TBufferTransports.h\u0026gt; #include\u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; // 需要线程，引入头文件 #include \u0026lt;mutex\u0026gt; // 互斥信号量 #include \u0026lt;condition_variable\u0026gt; // 条件变量，用于 阻塞和唤醒 线程 #include \u0026lt;queue\u0026gt; // 用于模拟消息队列 #include \u0026lt;vector\u0026gt; using namespace ::apache::thrift; using namespace ::apache::thrift::protocol; using namespace ::apache::thrift::transport; using namespace ::apache::thrift::server; using namespace ::match_service; using namespace std; struct Task { // 消息队列中的元素 User user; string type; }; struct MessageQueue { // 消息队列 queue\u0026lt;Task\u0026gt; q; // 消息队列本体 mutex m; // 互斥信号量 condition_variable cv; // 条件变量，用于阻塞唤醒线程 }message_queue; class Pool { // 模拟匹配池 public: void save_result(int a, int b) { // 记录成功匹配的信息 printf(\u0026#34;Match Result: %d %d \\n\u0026#34;, a, b); } void match() { // 将匹配池中的第一、第二个用户匹配 while (users.size() \u0026gt; 1) { auto a = users[0], b = users[1]; users.erase(users.begin()); users.erase(users.begin()); save_result(a.id, b.id); } } void add(User user) { // 向匹配池中加入用户 users.push_back(user); } void remove(User user) { // 向匹配池中删除用户 for (uint32_t i = 0; i \u0026lt; users.size(); ++ i) { if (users[i].id == user.id) { users.erase(users.begin() + i); break; } } } private: vector\u0026lt;User\u0026gt; users; // 匹配池中的用户，用 vector 记录 }pool; class MatchHandler : virtual public MatchIf { public: MatchHandler() { // Your initialization goes here } int32_t add_user(const User\u0026amp; user, const std::string\u0026amp; info) { // Your implementation goes here printf(\u0026#34;add_user\\n\u0026#34;); unique_lock\u0026lt;mutex\u0026gt; lck(message_queue.m); // 访问临界区（消息队列），先上锁 message_queue.q.push({user, \u0026#34;add\u0026#34;}); // 把新消息加入消息队列 message_queue.cv.notify_all(); // 唤醒阻塞的线程 return 0; } int32_t remove_user(const User\u0026amp; user, const std::string\u0026amp; info) { // Your implementation goes here printf(\u0026#34;remove_user\\n\u0026#34;); unique_lock\u0026lt;mutex\u0026gt; lck(message_queue.m); // 访问临界区（消息队列），先上锁 message_queue.q.push({user, \u0026#34;remove\u0026#34;}); // 把新消息加入消息队列 message_queue.cv.notify_all(); // 唤醒阻塞的线程 return 0; } }; // 基于“生产者-消费者模型”的线程 void consume_task() { while(true) { unique_lock\u0026lt;mutex\u0026gt; lck(message_queue.m); // 访问临界区（消息队列），先上锁 if (message_queue.q.empty()) { message_queue.cv.wait(lck); // 这里要阻塞进程 // 避免队列为空时，一直反复运行该进程，导致一直占用临界区，而不能加入新消息 } else { auto task = message_queue.q.front(); // 取出消息队列队头元素 message_queue.q.pop(); lck.unlock(); // 临界区访问结束，直接解锁 // 避免后续没用到临界区信息，而长时间占用临界区的情况发生 if (task.type == \u0026#34;add\u0026#34;) pool.add(task.user); else if (task.type == \u0026#34;remove\u0026#34;) pool.remove(task.user); pool.match(); } } } int main(int argc, char **argv) { int port = 9090; ::std::shared_ptr\u0026lt;MatchHandler\u0026gt; handler(new MatchHandler()); ::std::shared_ptr\u0026lt;TProcessor\u0026gt; processor(new MatchProcessor(handler)); ::std::shared_ptr\u0026lt;TServerTransport\u0026gt; serverTransport(new TServerSocket(port)); ::std::shared_ptr\u0026lt;TTransportFactory\u0026gt; transportFactory(new TBufferedTransportFactory()); ::std::shared_ptr\u0026lt;TProtocolFactory\u0026gt; protocolFactory(new TBinaryProtocolFactory()); TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory); cout \u0026lt;\u0026lt; \u0026#34;Start Match Server\u0026#34; \u0026lt;\u0026lt; endl; thread matching_thread(consume_task); // 调用一个线程运行 consume_task server.serve(); return 0; } Match_server:3.0 save_client：因为一个节点只能由一个main方法作为程序的入口，所以匹配系统中的客户端和服务端写在同一个main方法中 // 需要额外引入的头文件 #include \u0026#34;save_client/Save.h\u0026#34; #include \u0026lt;thrift/transport/TSocket.h\u0026gt; #include \u0026lt;thrift/transport/TTransportUtils.h\u0026gt; // 需要额外声明的命名空间 using namespace ::save_service; //重写 save_result 内的内容，使其能够与 \u0026#34;数据存储服务器\u0026#34; 交互 void save_result(int a, int b) { // 记录成功匹配的信息 printf(\u0026#34;Match Result: %d %d\\n\u0026#34;, a, b); // Client端的板子 std::shared_ptr\u0026lt;TTransport\u0026gt; socket(new TSocket(\u0026#34;123.57.47.211\u0026#34;, 9090)); std::shared_ptr\u0026lt;TTransport\u0026gt; transport(new TBufferedTransport(socket)); std::shared_ptr\u0026lt;TProtocol\u0026gt; protocol(new TBinaryProtocol(transport)); SaveClient client(protocol); try { transport-\u0026gt;open(); //调用接口，把信息存储 \u0026#34;数据存储服务器\u0026#34; 中 int res = client.save_data(\u0026#34;acs_4888\u0026#34;, \u0026#34;07637c4c\u0026#34;, a, b); //输出匹配结果 if (!res) puts(\u0026#34;success\u0026#34;); else puts(\u0026#34;fail\u0026#34;); transport-\u0026gt;close(); } catch (TException\u0026amp; tx) { cout \u0026lt;\u0026lt; \u0026#34;ERROR: \u0026#34; \u0026lt;\u0026lt; tx.what() \u0026lt;\u0026lt; endl; } } match_server：每次只匹配分差小于 50 的用户 // This autogenerated skeleton file illustrates how to build a server. // You should copy it to another filename to avoid overwriting it. #include \u0026lt;thrift/transport/TSocket.h\u0026gt; #include \u0026lt;thrift/transport/TTransportUtils.h\u0026gt; #include \u0026#34;match_server/Match.h\u0026#34; #include \u0026#34;save_client/Save.h\u0026#34; #include \u0026lt;thrift/protocol/TBinaryProtocol.h\u0026gt; #include \u0026lt;thrift/server/TSimpleServer.h\u0026gt; #include \u0026lt;thrift/transport/TServerSocket.h\u0026gt; #include \u0026lt;thrift/transport/TBufferTransports.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; // 用于调用 sleep 函数 #include\u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; // 需要线程，引入头文件 #include \u0026lt;mutex\u0026gt; // 互斥信号量 #include \u0026lt;condition_variable\u0026gt; // 条件变量，用于 阻塞和唤醒 线程 #include \u0026lt;queue\u0026gt; // 用于模拟消息队列 #include \u0026lt;vector\u0026gt; using namespace ::apache::thrift; using namespace ::apache::thrift::protocol; using namespace ::apache::thrift::transport; using namespace ::apache::thrift::server; using namespace ::save_service; using namespace ::match_service; using namespace std; struct Task { // 消息队列中的元素 User user; string type; }; struct MessageQueue { // 消息队列 queue\u0026lt;Task\u0026gt; q; // 消息队列本体 mutex m; // 互斥信号量 condition_variable cv; // 条件变量，用于阻塞唤醒线程 }message_queue; class Pool { // 模拟匹配池 public: //重写 save_result 内的内容，使其能够与 \u0026#34;数据存储服务器\u0026#34; 交互 void save_result(int a, int b) { // 记录成功匹配的信息 printf(\u0026#34;Match Result: %d %d \\n\u0026#34;, a, b); // Client端的板子 std::shared_ptr\u0026lt;TTransport\u0026gt; socket(new TSocket(\u0026#34;123.57.47.211\u0026#34;, 9090)); std::shared_ptr\u0026lt;TTransport\u0026gt; transport(new TBufferedTransport(socket)); std::shared_ptr\u0026lt;TProtocol\u0026gt; protocol(new TBinaryProtocol(transport)); SaveClient client(protocol); try { transport-\u0026gt;open(); //调用接口，把信息存储 \u0026#34;数据存储服务器\u0026#34; 中 int res = client.save_data(\u0026#34;acs_4888\u0026#34;, \u0026#34;07637c4c\u0026#34;, a, b); //输出匹配结果 if (!res) puts(\u0026#34;success\u0026#34;); else puts(\u0026#34;fail\u0026#34;); transport-\u0026gt;close(); } catch (TException\u0026amp; tx) { cout \u0026lt;\u0026lt; \u0026#34;ERROR: \u0026#34; \u0026lt;\u0026lt; tx.what() \u0026lt;\u0026lt; endl; } } void match() { // 将匹配池中的第一、第二个用户匹配 while (users.size() \u0026gt; 1) { // 按照 rank分 排序 sort(users.begin(), users.end(), [\u0026amp;](User\u0026amp; a, User\u0026amp; b) { return a.scores \u0026lt; b.scores; }); bool flag = true; for (uint32_t i = 1; i \u0026lt; users.size(); ++ i) { auto a = users[i - 1], b = users[i]; // 两名玩家分数差小于50时进行匹配 if (b.scores - a.scores \u0026lt;= 50) { users.erase(users.begin() + i - 1, users.begin() + i + 1); save_result(a.id, b.id); flag = false; break; } } if (flag) break; // 一轮扫描后，发现没有能够匹配的用户，就停止扫描，等待下次调用 } } void add(User user) { // 向匹配池中加入用户 users.push_back(user); } void remove(User user) { // 向匹配池中删除用户 for (uint32_t i = 0; i \u0026lt; users.size(); ++ i) { if (users[i].id == user.id) { users.erase(users.begin() + i); break; } } } private: vector\u0026lt;User\u0026gt; users; // 匹配池中的用户，用 vector 记录 }pool; class MatchHandler : virtual public MatchIf { public: MatchHandler() { // Your initialization goes here } int32_t add_user(const User\u0026amp; user, const std::string\u0026amp; info) { // Your implementation goes here printf(\u0026#34;add_user\\n\u0026#34;); unique_lock\u0026lt;mutex\u0026gt; lck(message_queue.m); // 访问临界区（消息队列），先上锁 message_queue.q.push({user, \u0026#34;add\u0026#34;}); // 把新消息加入消息队列 message_queue.cv.notify_all(); // 唤醒阻塞的线程 return 0; } int32_t remove_user(const User\u0026amp; user, const std::string\u0026amp; info) { // Your implementation goes here printf(\u0026#34;remove_user\\n\u0026#34;); unique_lock\u0026lt;mutex\u0026gt; lck(message_queue.m); // 访问临界区（消息队列），先上锁 message_queue.q.push({user, \u0026#34;remove\u0026#34;}); // 把新消息加入消息队列 message_queue.cv.notify_all(); // 唤醒阻塞的线程 return 0; } }; // 基于“生产者-消费者模型”的线程 void consume_task() { while(true) { unique_lock\u0026lt;mutex\u0026gt; lck(message_queue.m); // 访问临界区（消息队列），先上锁 if (message_queue.q.empty()) { // message_queue.cv.wait(lck); // 这里要阻塞进程 // 避免队列为空时，一直反复运行该进程，导致一直占用临界区，而不能加入新消息 // 修改为每 1 秒进行一次匹配 lck.unlock(); // 直接解锁临界区资源 pool.match(); //调用 match() sleep(1); } else { auto task = message_queue.q.front(); // 取出消息队列队头元素 message_queue.q.pop(); lck.unlock(); // 临界区访问结束，直接解锁 // 避免后续没用到临界区信息，而长时间占用临界区的情况发生 if (task.type == \u0026#34;add\u0026#34;) pool.add(task.user); else if (task.type == \u0026#34;remove\u0026#34;) pool.remove(task.user); pool.match(); } } } int main(int argc, char **argv) { int port = 9090; ::std::shared_ptr\u0026lt;MatchHandler\u0026gt; handler(new MatchHandler()); ::std::shared_ptr\u0026lt;TProcessor\u0026gt; processor(new MatchProcessor(handler)); ::std::shared_ptr\u0026lt;TServerTransport\u0026gt; serverTransport(new TServerSocket(port)); ::std::shared_ptr\u0026lt;TTransportFactory\u0026gt; transportFactory(new TBufferedTransportFactory()); ::std::shared_ptr\u0026lt;TProtocolFactory\u0026gt; protocolFactory(new TBinaryProtocolFactory()); TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory); cout \u0026lt;\u0026lt; \u0026#34;Start Match Server\u0026#34; \u0026lt;\u0026lt; endl; thread matching_thread(consume_task); // 调用一个线程运行 consume_task server.serve(); return 0; } Match_server:4.0 match_server：随时间扩大匹配域，每一单位的 wt 会扩大 $50$ 分 的匹配域 // This autogenerated skeleton file illustrates how to build a server. // You should copy it to another filename to avoid overwriting it. #include \u0026lt;thrift/transport/TSocket.h\u0026gt; #include \u0026lt;thrift/transport/TTransportUtils.h\u0026gt; #include \u0026#34;match_server/Match.h\u0026#34; #include \u0026#34;save_client/Save.h\u0026#34; #include \u0026lt;thrift/protocol/TBinaryProtocol.h\u0026gt; #include \u0026lt;thrift/server/TSimpleServer.h\u0026gt; #include \u0026lt;thrift/transport/TServerSocket.h\u0026gt; #include \u0026lt;thrift/transport/TBufferTransports.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; // 用于调用 sleep 函数 #include\u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; // 需要线程，引入头文件 #include \u0026lt;mutex\u0026gt; // 互斥信号量 #include \u0026lt;condition_variable\u0026gt; // 条件变量，用于 阻塞和唤醒 线程 #include \u0026lt;queue\u0026gt; // 用于模拟消息队列 #include \u0026lt;vector\u0026gt; using namespace ::apache::thrift; using namespace ::apache::thrift::protocol; using namespace ::apache::thrift::transport; using namespace ::apache::thrift::server; using namespace ::save_service; using namespace ::match_service; using namespace std; struct Task { // 消息队列中的元素 User user; string type; }; struct MessageQueue { // 消息队列 queue\u0026lt;Task\u0026gt; q; // 消息队列本体 mutex m; // 互斥信号量 condition_variable cv; // 条件变量，用于阻塞唤醒线程 }message_queue; class Pool { // 模拟匹配池 public: void save_result(int a, int b) { // 记录成功匹配的信息 printf(\u0026#34;Match Result: %d %d \\n\u0026#34;, a, b); // Client端的板子 std::shared_ptr\u0026lt;TTransport\u0026gt; socket(new TSocket(\u0026#34;123.57.47.211\u0026#34;, 9090)); std::shared_ptr\u0026lt;TTransport\u0026gt; transport(new TBufferedTransport(socket)); std::shared_ptr\u0026lt;TProtocol\u0026gt; protocol(new TBinaryProtocol(transport)); SaveClient client(protocol); try { transport-\u0026gt;open(); //调用接口，把信息存储 \u0026#34;数据存储服务器\u0026#34; 中 int res = client.save_data(\u0026#34;acs_4888\u0026#34;, \u0026#34;07637c4c\u0026#34;, a, b); //输出匹配结果 if (!res) puts(\u0026#34;success\u0026#34;); else puts(\u0026#34;fail\u0026#34;); transport-\u0026gt;close(); } catch (TException\u0026amp; tx) { cout \u0026lt;\u0026lt; \u0026#34;ERROR: \u0026#34; \u0026lt;\u0026lt; tx.what() \u0026lt;\u0026lt; endl; } } bool check_match(uint32_t i, uint32_t j) { auto a = users[i], b = users[j]; int dt = abs(a.scores - b.scores); int a_max_dif = wt[i] * 50; int b_max_dif = wt[j] * 50; return dt \u0026lt;= a_max_dif \u0026amp;\u0026amp; dt \u0026lt;= b_max_dif; } void match() { for (uint32_t i = 0; i \u0026lt; wt.size(); ++ i) wt[i] ++; while (users.size() \u0026gt; 1) { bool flag = true; for (uint32_t i = 0; i \u0026lt; users.size(); ++ i) { for (uint32_t j = i + 1; j \u0026lt; users.size(); ++ j) { if (check_match(i, j)) { auto a = users[i], b = users[j]; users.erase(users.begin() + j); users.erase(users.begin() + i); wt.erase(wt.begin() + j); wt.erase(wt.begin() + i); save_result(a.id, b.id); flag = false; break; } if (!flag) break; } } if (flag) break; // 一轮扫描后，发现没有能够匹配的用户，就停止扫描，等待下次调用 } } void add(User user) { // 向匹配池中加入用户 users.push_back(user); wt.push_back(0); } void remove(User user) { // 向匹配池中删除用户 for (uint32_t i = 0; i \u0026lt; users.size(); ++ i) { if (users[i].id == user.id) { users.erase(users.begin() + i); wt.erase(wt.begin() + i); break; } } } private: vector\u0026lt;User\u0026gt; users; // 匹配池中的用户，用 vector 记录 vector\u0026lt;int\u0026gt; wt; // 等待时间，单位：s }pool; class MatchHandler : virtual public MatchIf { public: MatchHandler() { // Your initialization goes here } int32_t add_user(const User\u0026amp; user, const std::string\u0026amp; info) { // Your implementation goes here printf(\u0026#34;add_user\\n\u0026#34;); unique_lock\u0026lt;mutex\u0026gt; lck(message_queue.m); // 访问临界区（消息队列），先上锁 message_queue.q.push({user, \u0026#34;add\u0026#34;}); // 把新消息加入消息队列 message_queue.cv.notify_all(); // 唤醒阻塞的线程 return 0; } int32_t remove_user(const User\u0026amp; user, const std::string\u0026amp; info) { // Your implementation goes here printf(\u0026#34;remove_user\\n\u0026#34;); unique_lock\u0026lt;mutex\u0026gt; lck(message_queue.m); // 访问临界区（消息队列），先上锁 message_queue.q.push({user, \u0026#34;remove\u0026#34;}); // 把新消息加入消息队列 message_queue.cv.notify_all(); // 唤醒阻塞的线程 return 0; } }; // 基于“生产者-消费者模型”的线程 void consume_task() { while(true) { unique_lock\u0026lt;mutex\u0026gt; lck(message_queue.m); // 访问临界区（消息队列），先上锁 if (message_queue.q.empty()) { // message_queue.cv.wait(lck); // 这里要阻塞进程 // 避免队列为空时，一直反复运行该进程，导致一直占用临界区，而不能加入新消息 // 修改为每 1 秒进行一次匹配 lck.unlock(); // 直接解锁临界区资源 pool.match(); //调用 match() sleep(1); } else { auto task = message_queue.q.front(); // 取出消息队列队头元素 message_queue.q.pop(); lck.unlock(); // 临界区访问结束，直接解锁 // 避免后续没用到临界区信息，而长时间占用临界区的情况发生 if (task.type == \u0026#34;add\u0026#34;) pool.add(task.user); else if (task.type == \u0026#34;remove\u0026#34;) pool.remove(task.user); } } } int main(int argc, char **argv) { int port = 9090; ::std::shared_ptr\u0026lt;MatchHandler\u0026gt; handler(new MatchHandler()); ::std::shared_ptr\u0026lt;TProcessor\u0026gt; processor(new MatchProcessor(handler)); ::std::shared_ptr\u0026lt;TServerTransport\u0026gt; serverTransport(new TServerSocket(port)); ::std::shared_ptr\u0026lt;TTransportFactory\u0026gt; transportFactory(new TBufferedTransportFactory()); ::std::shared_ptr\u0026lt;TProtocolFactory\u0026gt; protocolFactory(new TBinaryProtocolFactory()); TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory); cout \u0026lt;\u0026lt; \u0026#34;Start Match Server\u0026#34; \u0026lt;\u0026lt; endl; thread matching_thread(consume_task); // 调用一个线程运行 consume_task server.serve(); return 0; } Usage # 启动服务端 ./match_system/src/main # 启动客户端 python3 game/src/client.py # 游戏应用端 （op id name scores） add 1 yxc 2000 add 2 xan 1500 add 3 zagy 2500 remove 3 zagy 2500 # 匹配系统服务器 add_user add_user remove_user # 等待了 10 s Match Result: 1 2 success 项目地址 Learning-Thrift Docker Docker | AcWing Linux 基础课 Docker 入门教程 | 阮一峰的网络日志 Docker是什么？ Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中,然后发布到任何流行的Linux或Windows操作系统的机器上\nDocker常用命令 镜像（images） docker images：列出本地所有镜像 docker image rm ubuntu:20.04：删除镜像ubuntu:20.04 docker commit CONTAINER_NAME IMAGE_NAME:TAG：创建某个container的镜像，TAG 为镜像标签，用以记录当前版本。 docker save -o ubuntu_20_04.tar ubuntu:20.04：将镜像ubuntu:20.04导出到本地文件ubuntu_20_04.tar中 docker load -i ubuntu_20_04.tar：将镜像ubuntu:20.04从本地文件ubuntu_20_04.tar中加载出来 容器(container) docker ps -a：查看本地的所有容器 docker start CONTAINER：启动容器 docker stop CONTAINER：停止容器 docker restart CONTAINER：重启容器 docker rm CONTAINER：删除容器 docker run -p HOST_PORT:CONTAINER_PORT --name CONTAINER_NAME -itd IMAGE_NAME:TAG：将创建并启动一个容器 -p：端口映射，将宿主机的端口和容器的端口进行映射 例：-p 20000:22 -p 8000:8000 -p 80:80 -p 443:443 22：ssh登录服务端口 8000：Django调试端口 80：用于HTTP服务 443：用于HTTPS服务 docker attach CONTAINER：进入容器 先按Ctrl-p，再按Ctrl-q可以挂起容器 Docker环境配置 scp django_lesson_1_0.tar server：将docker压缩包传至云服务器 ssh server：免密登录至云服务器 docker load -i django_lesson_1_0.tar：将docker压缩包解压缩成docker镜像 docker run -p 20000:22 8000:8000 --name django -itd django_lesson:1.0 ：利用 镜像django_lesson:1.0 创建一个命名为 django 的 docker容器并启动 docker attach my_docker_server：进入创建的docker容器（服务器） adduser acs：创建acs用户 usermod -aG sudo acs：为acs用户分配sudo权限 scp .bashrc .vimrc .tmux.conf django:：将本地服务器的bash\u0026amp;vim\u0026amp;tmux配置文件传至docker 容器 Docker项目迁移 第一步，登录容器，关闭所有运行中的任务\n第二步，登录运行容器的服务器，然后执行：\ndocker commit CONTAINER_NAME django_lesson:1.1 # 将容器保存成镜像，将CONTAINER_NAME替换成容器名称 docker stop CONTAINER_NAME # 关闭容器 docker rm CONTAINER_NAME # 删除容器 增加容器的映射端口 : 80 与 443 给运行中的容器，开通端口，是一件非常麻烦的事情\n一个比较好的解决方案 : 先把容器保存成镜像，再删掉容器，然后用镜像生成新的容器，同时打开需要的端口\n第一步，登录容器，关闭所有运行中的任务\n第二步，登录运行容器的服务器，然后执行 :\ndocker commit CONTAINER_NAME django_lesson:1.1 # 将容器保存成镜像，将CONTAINER_NAME替换成容器名称 docker stop CONTAINER_NAME # 关闭容器 docker rm CONTAINER_NAME # 删除容器 # 使用保存的镜像重新创建容器 docker run -p 20000:22 -p 8000:8000 -p 80:80 -p 443:443 --name CONTAINER_NAME -itd django_lesson:1.1 第三步，去云服务器控制台，在安全组配置中开放80和443端口\n","permalink":"https://xancoding.cn/posts/2022-10-16-14-23-58/","summary":"AcWing Linux 基础课 | Colopen\u0026rsquo;s blog AcWing Linux 基础课 命令行的艺术 The Missing Semester of Your CS Education Terminal 终端，一个程序，是界面上打开的黑框框本身，shell 运行于其中 Shell 常用文件管理命令 | AcWing Linux","title":"AcWing Linux 基础课"},{"content":"双拼是什么？ 双拼是汉语拼音输入法的一种编码方案\n使用双拼输入汉字时只需输入一个代表声母的字母，一个代表韵母的字母，就可以打出任意一个中文单字\n我的双拼学习经历 前段时间了解了双拼输入法，只是一直没有时间去学。这段时间事情慢慢少点了，准备着手开始学习。双拼只需要按键两次便可以输入一个汉字，我感觉这样的设计更为合理，要是熟练掌握，会很有节奏感，打字速度也可以得到提升。\n更换一个新的输入法，刚开始时肯定会很别扭。使用双拼进行输入，需要对要打的字的音形熟悉，不然是打不出来的。刚好重新学习一下拼音，纠正纠正我自己一些错误的发音认知。\n我准备学习小鹤双拼，找了张小鹤双拼的键位图，用作电脑桌面，打字想不起来的时候瞄一眼。\n推荐阅读 小鹤双拼 小鹤入门 ","permalink":"https://xancoding.cn/posts/2022-10-14-17-02-41/","summary":"双拼是什么？ 双拼是汉语拼音输入法的一种编码方案 使用双拼输入汉字时只需输入一个代表声母的字母，一个代表韵母的字母，就可以打出任意一个中文单字 我","title":"双拼学习记"},{"content":"管理好你自己的时间 Todo清单 我目前在用的软件是Todo清单，优势在于多设备云端同步（需要付费使用）、具备番茄钟功能、可以用来安排每日的待办清单\n安排好你的待办清单 思考以下几点：\n1. 有哪些工作需要完成？\n2.我有多少时间可以用来完成这些工作？\n3.工作事项是否有逻辑顺序以及优先级\n每一天你都会受到很多的干扰，看到APP上的一个个红点，消息通知从屏幕上弹出。注意力在一次次的查看信息中被逐渐消磨，时间也变得碎片化，难以静下心来专注于某件事。有些干扰无可避免，但只要愿意付出努力，大部分的干扰可以得到排除。\n白天我会尽量避免受到干扰，所有的社交软件，它们是工作效率的最大杀手。我控制自己在上午以及下午的大块时间中忽略来自社交网络的信息，将消息的查看集中在中午以及晚上的特定时间，做一个统一的查看。\n每天的晚上，我会花些的时间，把第二天的工作做个大致的安排，写到待办事项中，第二天再用番茄工作法进行专注执行。记得让自己的计划保持比较高的自由度，要留有足够的时间余量。\n番茄工作法 番茄工作法这个名词我之前便有听说过，但一直未尝试着去做过，直到最近从《软技能》一书中再次看到，感觉不错，便开始了尝试。在经过一个星期的体验后，它确实提高了我的效率，让我能够更好的对自己的时间做出规划。\n它的基本思路是：\n你规划出打算一天之内完成的工作，然后设置一个时长25分钟的定时器，去完成计划中的第一项任务；在这25分钟之内，你只专注于这一项任务，心无旁骛。一旦有干扰，可以用各种方法屏蔽掉干扰，但是通常你要努力保证自己完全不被打扰。总之，你不希望自己的专注的工作状态被打断。\n在25分钟结束的时候，设置一个5分钟的定时器，休息一下。这就是所谓的一个“番茄钟”。每4个番茄钟后，你都需要休息一会儿，通常为15分钟。\n值得注意的是，使用番茄工作法所要做的并不只是集中注意力25分钟这么简单。通过使用番茄工作法，你可以高效跟踪自己一天完成的番茄钟的数量，并为此设定目标。开始的几天，你可能无法对自己能完成的工作做一个很好的估计。但相信在使用番茄工作法一段时间后，你可以做到较为准确的估计，并能完成通过番茄钟的数量，评估自己完成的工作。\n通过使用番茄钟，你可以定量的描述自己的工作状态，而不再像过去那样只是凭借感觉。你可以把每周看作是由有限个番茄钟组成的，知道了自己一周大概能完成的番茄钟的数量后，你也会认识到应该如何通过设置任务的优先级，来合理分配自己的时间。你不会再过高的幻想自己会在一周的时间里完成超出自己实际许多的任务，并在每周结束时，因未能完成而感到沮丧。\n当你在一天中为自己设置了x个番茄钟的工作目标（这一目标你完全可控）并且达成的时候，你就可以知道自己一天到底可以完成多少工作，这会让自己感觉良好，更重要的是，还能让自己放松身心。它不仅能帮你完成更多的工作，还能让你尽情享受业余时间——因为你已经通过番茄钟完成了一天的任务，在剩下的时间里，你完全可以自由安排消磨时间，而不会再有任何的心理负担。\n最后的最后，一定记得要对自己的能力做一个合理的预期，你每周工作40小时并不意味着你能完成80个番茄钟。找到适合你的番茄钟数量，过度的加量会适得其反。\n推荐阅读 Todo清单 一款跨平台待办事项与时间管理应用 如何用Todo清单度过余生的每一天？ 告别社交网络有多难 社交网络名存实亡 Sunset of the social network 《软技能》 生产力篇 \u003c!DOCTYPE HTML\u003e ","permalink":"https://xancoding.cn/posts/2022-10-14-16-07-09/","summary":"管理好你自己的时间 Todo清单 我目前在用的软件是Todo清单，优势在于多设备云端同步（需要付费使用）、具备番茄钟功能、可以用来安排每日的待办","title":"我管理时间的方法"},{"content":" 这个时代不缺信息，因为信息太多了，缺的是时间\n整个互联网正在充斥着流量内容，而我们得学会如何从垃圾中找到金子\n获取信息的方式最好是主动的，摆脱算法和机器的喂养，自己去挖掘有价值的信息\n博客 Inoreader \u0026amp; RSSHub Radar 什么是RSS? RSS 英文全称为 Really Simple Syndication，即简易资讯聚合。其实叫什么并不重要，我们只用知道它是一个能让你在一个地方订阅各种感兴趣网站的工具。\nRSS的核心是资讯聚合，由用户自己决定信息源。我们可以通过订阅网站的RSS源，主动获得想要的资讯，去挖掘一些自己真正感兴趣的东西。\n如何使用RSS? 利用RSS获取信息，只需要在目标网站上找到RSS链接，并把它添加到RSS阅读器中。\n我使用的工具是Inoreader RSS 阅读器 （需翻墙） + RSSHub Radar 浏览器插件。\nInoreader 吸引我的点是它支持PC端和手机端的同步，并且PC端可以直接通过浏览器插件使用，使我在手机和电脑上都可以查看消息。\nRSSHub Radar 的出现，完美解决了不是所有的网页都提供RSS源这一痛点，它可以自动生成网站的RSS源以供订阅，非常方便。\n我通过使用RSS来订阅我感兴趣的个人博客，我订阅的博客网站在 Links 页面下的 Blog 那一栏。\n播客 小宇宙 播客也是一个很好的信息源，可以在做一些不用🧠的事时听，适合用来拓宽自己的知识面，对一些自己之前完全没有接触过的领域做一个初步的了解，抑或是单纯用以放松也不错。我的使用场景通常是在吃饭或是上下课的路上。\n我目前在使用的播客软件是小宇宙，体验不错。\n书籍 Neat Reader \u0026amp; Sumatra PDF \u0026amp; Jiumo Search 鸠摩搜索 \u0026amp; 微信读书 \u0026amp; Z-Library \u0026amp; LoreFree \u0026amp; 学校图书馆 Neat Reader 是一款EPUB阅读器，用以阅读EPUB格式的电子书，体验感不错。我会在 Z-Library or LoreFree or Jiumo Search 鸠摩搜索 上搜索得到我想要看的书的EPUB格式的电子书后，存在本地文件上，通过 Neat Reader 阅读。\n如果找不到EPUB格式的书籍，我会存 PDF 格式的，然后在 Sumatra PDF 上阅读\n手机上的话，我会使用微信读书，把找到的电子书上传到书架后进行阅读\n不过，相比于电子书，我其实还是更喜欢纸质书的阅读体验。所以，我也会隔段时间便去拿着自己的书单，去学校的图书馆找书看（当然，并不是每次图书馆都有我想要的书😭）\nChatGPT + 搜索引擎 Chrome（需翻墙） \u0026amp; AdblockPlus \u0026amp; uBlacklist | Personal Blocklist \u0026amp; ChatGPT for Google \u0026amp; Vimium 在搜索引擎体验上， Google （强推，体验极佳） \u0026gt; Bing （偶尔用用） \u0026raquo; Baidu （完全不考虑） Chrome 浏览器设置 快捷字词搜索 Chrome 浏览器可以通过在地址栏中输入快捷字词，实现在特定网站中搜索内容，或使用其他搜索引擎进行搜索\n在 Chrome 浏览器右上角找到 设置， 点击 搜索引擎，并在之后点击 管理搜索引擎和网站搜索 更改快捷键，或者新增新的快捷键 在完成上述操作后，就可以通过在地址栏中输入快捷字词实现愉快的简便搜索啦🥳 Chrome 浏览器插件 Chrome 浏览器简洁的界面深得我心，在安装一部分插件后，搜索体验更是极佳😍\n广告屏蔽 AdblockPlus 由用户手动设置拦截网页上不想看到的内容，我使用这个插件把一些网站我不想要看到的内容进行屏蔽，以获得更为简洁的体验\n屏蔽前： 屏蔽后： 小声BB：启动这个插件，在使用过程中，可能会碰到部分网页显示异常的情况，这个时候需要把该网页加入白名单来保证网页正常显示 搜索内容屏蔽 uBlacklist uBlacklist 在搜索时屏蔽特定网站，做到对低质内容的过滤\n点击 选项 在箭头所示部分增加过滤规则并保存 以下是我添加的一些过滤规则： *://www.csdn.net/* *://bbs.csdn.net/* *://blog.csdn.net/* *://zhidao.baidu.com/* *://www.cnblogs.com/* *://z.sogou.com/* *://wenku.baidu.com/* 2022-11-14 更新：不知道是为什么，最近一段时间这个插件失效了\nPersonal Blocklist 使用方法和 uBlacklist 差不多，目前使用来看效果不错\nChatGPT for Google 首先安装该拓展程序：https://chrome.google.com/webstore/detail/chatgpt-for-google/jgjaeacdkonaoafenlfkkkmbaopkbilf?hl=zh-CN 之后使用 Google 搜索时，右侧便会自动出现chatGPT的回答，如搜索C++虚函数是什么？，就会出现如下所示的结果： Vimium Vimium是一款Chrome插件，它提供了类Vim操作来控制浏览器网页。熟练掌握后，可以脱离鼠标，只使用键盘浏览页面\n这个插件我已经有一篇文章进行更为详细的讲解了，这里就不再展开来说了\n推荐阅读 知道RSS的人越少，我就越希望它能被人知道！ RSS 二十年 RSS Source | RSS订阅源推荐 Practical Google Search Tips 优化自己的信息源 中文互联网的产出在渐渐枯萎 ChatGPT 使用指南 ","permalink":"https://xancoding.cn/posts/2022-10-12-22-42-04/","summary":"这个时代不缺信息，因为信息太多了，缺的是时间 整个互联网正在充斥着流量内容，而我们得学会如何从垃圾中找到金子 获取信息的方式最好是主动的，摆脱算","title":"我获取信息的方式"},{"content":"int main() { printf(\u0026#34;Hello, World\u0026#34;); return(0); } int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello World\u0026#34;; return 0; } public class Main { public static void main(String[] args) { System.out.println(\u0026#34;Hello, World!\u0026#34;); } } echo \u0026#34;Hello, World\u0026#34; Hello, World document.write(\u0026#39;Hello, World\u0026#39;); print (\u0026#34;Hello, World\u0026#34;) ","permalink":"https://xancoding.cn/posts/2022-10-12-07-27-58/","summary":"int main() { printf(\u0026#34;Hello, World\u0026#34;); return(0); } int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello World\u0026#34;; return 0; } public class Main { public static void main(String[] args) { System.out.println(\u0026#34;Hello, World!\u0026#34;); } } echo \u0026#34;Hello, World\u0026#34; Hello, World document.write(\u0026#39;Hello, World\u0026#39;); print (\u0026#34;Hello, World\u0026#34;)","title":"Hello World"},{"content":"About me 𝑯𝒊, 𝑰\u0026rsquo;𝒎 ✨ 𝐗𝐚𝐧 ✨,𝐚 𝐂𝐒 𝐬𝐭𝐮𝐝𝐞𝐧𝐭 𝐟𝐫𝐨𝐦 𝐍𝐂𝐄𝐏𝐔.\n𝐌𝐲 ❤ 𝐡𝐨𝐛𝐛𝐢𝐞𝐬 ❤ 𝐚𝐫𝐞 𝐑𝐮𝐧𝐧𝐢𝐧𝐠, 𝐇𝐢𝐤𝐢𝐧𝐠, 𝐓𝐞𝐜𝐡𝐧𝐨𝐥𝐨𝐠𝐲, 𝐇𝐢𝐬𝐭𝐨𝐫𝐲 𝐚𝐧𝐝 𝐏𝐬𝐲𝐜𝐡𝐨𝐥𝐨𝐠𝐲.\nA ENFJ-A\nMotto The value of a college education is not the learning of many facts but the training of the mind to think.1 Do not try to change yourself.Work to improve the way you perform.2 All problems in computer science can be solved by another level of indirection.3 DRY\u0026ndash;Don’t Repeat Yourself.4 Avoid premature optimization.5 高等教育的价值在于【训练思维】，而不在于传授事实。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n不要试图改变自我，因为这样你不大可能成功。但是，你应该努力改进你的工作方式。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n计算机科学中的所有问题都可以通过增加一个间接层来解决。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n不要重复自己。（以最小化冗余的方式编写代码）\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n不要进行不成熟的优化\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://xancoding.cn/about/","summary":"About me 𝑯𝒊, 𝑰\u0026rsquo;𝒎 ✨ 𝐗𝐚𝐧 ✨,𝐚 𝐂𝐒 𝐬𝐭𝐮𝐝𝐞𝐧𝐭 𝐟𝐫𝐨𝐦 𝐍𝐂𝐄𝐏𝐔. 𝐌𝐲 ❤ 𝐡𝐨𝐛𝐛𝐢𝐞𝐬 ❤ 𝐚𝐫𝐞 𝐑𝐮𝐧𝐧𝐢𝐧𝐠, 𝐇𝐢𝐤𝐢𝐧𝐠, 𝐓","title":""},{"content":"CS https://www.learncpp.com/ CS自学指南 小林 x 图解计算机基础 图解网络 图解系统 后端开发核心知识 A project based learning search engine How to ask questions # 别像弱智一样提问 # 提问的智慧 Blogs 程序员的喵 阮一峰的网络日志 编程随想的博客 学习技术的三部曲：WHAT、HOW、WHY 用提问来促进思维——兼谈【非】技术领域的 WHAT HOW WHY 三部曲 如何完善自己的知识结构 如何挖掘网络资源[0]：为啥要写这个话题？ 如何挖掘网络资源[1]：网站的类型和使用场景 如何挖掘网络资源[2]：Google 搜索的基本语法 如何挖掘网络资源[3]：解答 Google 搜索的常见问题（FAQs） 如何【系统性学习】——从“媒介形态”聊到“DIKW 模型” 为什么独立思考这么难？ 什么是【真正的】兴趣爱好？以及它有啥好处？ 为啥俺很少看视频？——兼谈“视频”与“文本”在认知心理学方面的差异 为啥俺不常用微博？——兼谈时间管理心得 为啥俺要写这个博客——动机的自我分析 如何选择 IT 技术书籍 扫盲“社会工程学”[0]：基本常识 扫盲“社会工程学”[1]：攻击手法之【信息收集】 扫盲“社会工程学”[2]：攻击手法之【假冒身份】 扫盲“社会工程学”[3]：攻击手法之【施加影响】 扫盲“社会工程学”[4]：【综合运用】举例 扫盲“社会工程学”[5]：你该如何【防范】？ 如何成为优秀开发人员[0]：怎样算是优秀的？ 如何成为优秀开发人员[1]：关于兴趣 如何成为优秀开发人员[2]：关于自学能力 如何成为优秀开发人员[3]：设定个人发展目标和计划 如何成为优秀开发人员[4]：做正确的事 如何成为优秀开发人员[5]：正确地做事（概述） 如何成为优秀开发人员[6]：正确地做事（善用工具） 如何成为优秀开发人员[7]：正确地做事（善用自动化） “心智模式”系列：认识你自己——心智模式扫盲介绍 扫盲“货币经济学”基本概念——从“利率”到“央行货币政策” 博弈论入门教程——从基本概念到具体案例 《如何阅读一本书》——书评及内容纲要 书评：《学会提问——批判性思维指南》 书评：《人月神话》——不朽的软件工程名著 书评：《你的灯亮着吗？——找到问题的真正所在》 如何翻墙？ 扫盲 DNS 原理，兼谈“域名劫持”和“域名欺骗/域名污染” 计算机网络通讯的【系统性】扫盲——从“基本概念”到“OSI 模型” 对比4种强化域名安全的协议——DNSSEC，DNSCrypt，DNS over TLS，DNS over HTTPS “对抗专制、捍卫自由”的 N 种技术力量 扫盲文件完整性校验——关于散列值和数字签名 扫盲 netcat（网猫）的 N 种用法——从“网络诊断”到“系统入侵” 扫盲 HTTPS 和 SSL/TLS 协议[0]：引子 扫盲操作系统虚拟机[0]：概述 ","permalink":"https://xancoding.cn/links/","summary":"CS https://www.learncpp.com/ CS自学指南 小林 x 图解计算机基础 图解网络 图解系统 后端开发核心知识 A project based learning search engine How to ask questions # 别像弱智一样提问 # 提问的智慧 Blogs 程序员的喵 阮一峰的网","title":""}]