[{"content":"要求 团队合作、合理分工、按组为单位进行 报告文字内容不可拷贝粘贴现有文献，应反映小组所做的工作，有分析，实践性的选题应有具体操作或者配置过程描述，辅以截图或实验数据 所交报告中应在最后注明组员分工、参考文献，报告字数3000-6000 不同班级的小组可选择相同的题目，但重复计数（由各班学委协调），不可多于3组，且报告内容不可相同，要求独立完成各组任务 除了个别综述性的选题，其它选题要求在实际平台上实践 选题 基于网络嗅探软件（wireshark）的协议分析实验\nWireshark的深入学习与掌握，如过滤器的使用，归纳方法 通过实验阐述ARP的工作原理 利用实验结果分析ICMP协议的报文结构字段定义 基于实验数据深入分析TCP协议的连接过程原理，报文的分片等功能 从校园网发起向外网中某Web服务器的访问，记录并分析从MAC层协议、IP协议、TCP协议一直到HTTP协议的过程 基于网络嗅探软件Wireshark的协议分析实验 Wireshark 是什么？ Wirkshark 是一个功能十分强大的开源的网络数据包分析器，能够在多种平台上抓取和分析网络包\nWirkshark 可被用于检查安全问题和解决网络问题，也可供开发者调试协议的实现和学习网络协议的原理\nWireshark使用 Npcap or WinPcap 作为接口，直接与网卡进行数据报文交换\nWireshark 下载与安装 官网地址：https://www.wireshark.org/，直接点击下一步下一步安装即可 但是，我在安装过程中报了如下的错误： 排查了好久，没找到合适的解决办法\n最后，下载 WinPcap 来代替 Npcap ，成功运行。\nWireshark 基本用法 简单抓包基础步骤：选择捕获接口 -\u0026gt; 获取网络实时痕迹 -\u0026gt; 获取报文 -\u0026gt; 深入解析\n选择接口（网卡） 网络上传输的数据包需要经过网卡到达计算机，Wireshark可以捕获流经网卡的数据包\n在使用Wireshark捕获数据前，先要选择捕获接口。一台计算机可能会有不止一个网卡，此时需要选择你要捕获数据的接口。\n选择菜单栏上的 捕获-\u0026gt;选项 选择想要捕获数据的接口后，点击开始 界面说明 开始捕获后，Wireshark会把捕获到的报文显示到界面上\n显示过滤器用于设置过滤条件进行数据列表区数据过滤 数据列表区展示的是Wireshark捕获到的所有数据包的列表，每个数据包包含 编号、时间戳、源地址、目标地址、协议、长度以及数据包信息 数据详细区展示的是在数据列表区中选中的数据包的分协议展示 Frame：物理层的数据帧概况 Ethernet II：数据链路层以太网帧头部信息 Internet Protocol Version 4： 互联网层IP包头部信息 Transmission Control Protocol：传输层的数据段头部信息，此处是TCP 数据字节区展示的是选中的数据包的源数据。另外，在数据详细区选中的某层或某字段，对应的数据会在数据字节区中高亮 过滤器设置 根据我们想要抓取的数据包，对过滤器进行设置。过滤掉冗余的数据包，找到我们需要的信息\n捕获过滤器 捕获过滤器表达式作用在Wireshark捕获数据包之前，只捕获符合条件的数据包\n当需要处理大量数据时，使用捕获过滤器可以节省大量资源\n界面说明 选择菜单栏上的 捕获-\u0026gt;捕获过滤器 点击 + 即可添加新的过滤规则\nFilter Name 指代过滤器名称，用来给自己看该过滤器的过滤效果\nFilter Expression 指代过滤器表达式，需要使用 Berkeley Packet Filter 语法书写 语法规则 捕获过滤器使用 BPF 语法，表达式由多个原语组成：\n原语(primitives)：由名称或数字，以及描述它的多个限定词组成。 * 限定词(qualifiers) * Types：设置数字或者名称所指示类型，例如host www.baidu.com，如果没有指定此值，则默认使用“host”关键字 * host、post * net，设定子网， net 192.168.0.0 mask 255.255.255.0等价于net 192.168.0.0/24 * port，设置端口范围，例如port 6000-8000 * Dir：设置网络出入方向，例如dst port 80，如果没有特别指明来源或目的地，则默认使用“src or dst”作为关键字 * src、dst、src or dst、src and dst(src：源端口，dst：目标端口) * Proto：指定协议类型，例如udp，如果没有特别指明是什么协议，则默认使用所有支持的协议 * ether、fddi、tr、wlan、ip、ip6、arp、rarp、decnet、tcp、udp、icmp、igmp、icmp、igrp、pim、ah、esp、vrrp * 其他 * gateway：指明网关IP地址，等价于ether host \u0026#39;ehost\u0026#39; and not host \u0026#39;host\u0026#39; * broadcast：广播报文，例如ether broadcast或者ip broadcast * multicast：多播报文，例如ip multicast或者ip6 multicast * less、greater：小于或者大于 * 原语运算符 * 与：\u0026amp;\u0026amp;或者and * 或：||或者or * 非：!或者not 转载自：https://juejin.cn/post/6844904066229747720 应用示例 只抓取源端口或者目的端口范围6000到8000，并且是一个tcp协议或者ipv6的数据包\nsrc or dst port 6000-8000 \u0026amp;\u0026amp; tcp or ip6 只抓取IP地址为192.168.0.10的数据包\nhost 192.168.0.10 显示过滤器 显示过滤器表达式作用在在Wireshark捕获数据包之后，从已捕获的所有数据包中显示出符合条件的数据包\n显示过滤表达式在工具栏下方的“应用显示过滤器”输入框输入即可生效 基本过滤表达式 一条基本的表达式由过滤项、过滤关系、过滤值三项组成 例如：ip.addr == 192.168.1.1，其中 ip.addr 为过滤项，== 为过滤关系，192.168.1.1 为过滤值。 该表达式的意思是 找出所有ip协议中源或目标ip等于192.168.1.1的数据包 过滤项 Wireshark的过滤项是 协议.协议字段 的模式，Wireshark支持的全部协议及协议字段可查看官方说明。 以端口为例，端口出现于tcp协议中。所以有端口这个过滤项且其写法就是tcp.port Wireshark出于缩减长度的原因，有些字段没有使用协议规定的名称而是使用简写，比如Destination Port在Wireshark中写为dstport Wireshark出于简便使用的原因，增加了一些协议中没有的字段，比如tcp协议只有源端口和目标端口字段，为了简便使用Wireshark增加了tcp.port来同时代表这两个字段 实际使用时我们输入协议.后Wireshark就会有支持的字段提示 过滤关系 过滤关系指的是大于、等于、小于等等式关系，具体可以看官方给出的表 过滤值 过滤值就是设定的过滤项应该满足过滤关系的标准，比如500、5000、50000等等。\n过滤值的写法一般已经被过滤项和过滤关系设定好了，只是填下自己的期望值就可以了。\n复合过滤表达式 所谓复合过滤表达示，就是指由多条基本过滤表达式组合而成的表达示。\n基本过滤表达式的写法还是不变的，复合过滤表达示多出来的东西就只是基本过滤表达示的“连接词”，我们依然直接参照官方给出的表 常见显示过滤需求及其对应表达式 数据链路层 筛选mac地址为04:f9:38:ad:13:26的数据包----eth.src == 04:f9:38:ad:13:26 筛选源mac地址为04:f9:38:ad:13:26的数据包----eth.src == 04:f9:38:ad:13:26 网络层 筛选ip地址为192.168.1.1的数据包----ip.addr == 192.168.1.1 筛选192.168.1.0网段的数据---- ip contains \u0026#34;192.168.1\u0026#34; 筛选192.168.1.1和192.168.1.2之间的数据包----ip.addr == 192.168.1.1 \u0026amp;\u0026amp; ip.addr == 192.168.1.2 筛选从192.168.1.1到192.168.1.2的数据包----ip.src == 192.168.1.1 \u0026amp;\u0026amp; ip.dst == 192.168.1.2 传输层 筛选tcp协议的数据包----tcp 筛选除tcp协议以外的数据包----!tcp 筛选端口为80的数据包----tcp.port == 80 筛选12345端口和80端口之间的数据包----tcp.port == 12345 \u0026amp;\u0026amp; tcp.port == 80 筛选从12345端口到80端口的数据包----tcp.srcport == 12345 \u0026amp;\u0026amp; tcp.dstport == 80 应用层 特别说明----http中http.request表示请求头中的第一行（如GET index.jsp HTTP/1.1），http.response表示响应头中的第一行（如HTTP/1.1 200 OK），其他头部都用http.header_name形式。 筛选url中包含.php的http数据包----http.request.uri contains \u0026#34;.php\u0026#34; 筛选内容包含username的http数据包----http contains \u0026#34;username\u0026#34; 通过实验阐述ARP的工作原理 ARP即地址解析协议（Address Resolution Protocol），是根据IP地址获取MAC地址的一个TCP/IP协议\nARP用于解决同一个局域网上的主机或路由器的IP地址和MAC地址的映射问题\n每一台主机都设有一个 ARP高速缓存，里面存有 本局域网上 各主机和路由器的IP地址到MAC地址的映射表\nARP工作流程 当主机A要向本局域网上的某台主机B发送IP数据报时，就现在其ARP高速缓存中查找有无主机B的IP地址。若有，查出其对应的MAC地址，写入MAC帧；若没有，进行下述步骤 主机A的ARP进程在本局域网上广播一个ARP请求分组，其中有自己的IP地址到MAC地址的映射 本局域网上的所有主机运行的ARP进程都收到此ARP请求分组 主机B的IP地址与ARP请求分组中要查询的IP地址一致，就收下这个ARP请求分组，将主机A的MAC映射写入自己的ARP高速缓存，并向主机A发送ARP响应分组，同时在这个ARP响应分组中写入自己的MAC地址。由于其余所有主机的IP地址都与ARP请求分组中要查询的IP地址不一致，因此不理睬 主机A收到主机B的ARP响应分组后，就在其ARP高速缓存中写入主机B的IP地址到MAC地址的映射 实验步骤及内容 主机A\nIP地址：192.168.31.248\nMAC地址：c0:3c:59:5e:37:47\n主机B\nIP地址：192.168.31.186\nMAC地址：28:7f:cf:12:af:89\nARP命令练习 在cmd中使用ipconfig/all命令，查看自己的IP地址和MAC地址，同时让小组成员连接同一个WIFI执行相同的操作并记录 主机A IP地址和MAC地址 主机B IP地址和MAC地址 主机A使用arp -a查看ARP缓存表 主机A通过ping主机B的IP来添加动态ARP缓存表数据 我在ping主机Bip地址时碰到请求超时的问题。\n经排查，是因为windows防火墙默认设置的是不让别人ping通，通过修改防火墙相关设置解决了该问题。\n步骤：控制面板 → 系统和安全 → Windows防火墙 → 高级设置 → 入站规则 → 文件和打印机共享（回显请求 - ICMPv4-In）设置为启用 主机A使用arp -a查看ARP缓存表，发生新增一条数据 以管理员身份运行cmd，执行arp -d *，删除缓存信息 抓包分析ARP协议 当ARP缓存对应数据为空时 实验步骤 主机A执行arp -d *，删除缓存信息 主机A运行Wireshark，设置显示过滤器表达式为arp.dst.proto_ipv4 == 192.168.31.186 and arp.src.proto_ipv4 == 192.168.31.248 or icmp 主机Aping主机B的ip地址 结果分析 主机A将自己的ip地址 192.168.31.248 \u0026amp; MAC地址 c0:3c:59:5e:37:47写入请求分组，并将目的ip地址设置为192.168.31.186，目的MAC地址设置为00:00:00:00:00:00，对本局域网内的所有主机进行广播 主机A发出的ARP请求分组 主机B收下这个ARP请求分组，将主机A的MAC映射写入自己的ARP高速缓存，并向主机A发送ARP响应分组，同时在这个ARP响应分组中写入自己的MAC地址，即28:7f:cf:12:af:89 主机A收到主机B的ARP响应分组后，就在其ARP高速缓存中写入主机B的IP地址到MAC地址的映射 主机A收到的来自主机B的ARP响应分组 主机A的ARP高速缓存表 当ARP缓存对应数据不为空时 实验步骤 主机A运行Wireshark，设置显示过滤器表达式为arp.dst.proto_ipv4 == 192.168.31.186 and arp.src.proto_ipv4 == 192.168.31.248 or icmp 主机A ping主机B的ip地址 结果分析 主机A没有发出ARP请求，而主机B接受到了主机A的ICMP报文，说明主机A直接使用了高速缓存区内的对应数据，而没有发出广播\n主机A发出的报文 利用实验结果分析ICMP协议的报文结构字段定义 ICMP即互联网控制报文协议（Internet Control Message Protocol），网络设备（包括路由器）使用它来发送错误消息和指示与另一个IP 地址通信时成功或失败的操作信息\nICMP报文结构 ICMP报文格式 +0------7-------15---------------31 | Type | Code | Checksum | +--------------------------------+ | Message Body | | (Variable length) | +--------------------------------+ ICMP报文格式解释 Type：占一个字节，标识ICMP报文的类型，可以分为差错报告报文和询问报文两大类 Code：占一个字节，用于进一步区分某种类型中的不同情况 Checksum：占两个字节，检验报文在传输过程中是否出现差错 ICMP应用举例 Ping命令 「ping」是用来探测本机与网络中另一主机之间是否可达的命令\n在此次实验中，使用主机A在cmd环境下ping baidu.com，分析回送请求报文和回送回答报文\n回送请求报文 Internet Control Message Protocol Type: 8 (Echo (ping) request) Code: 0 Checksum: 0x4ae9 [correct] [Checksum Status: Good] Identifier (BE): 1 (0x0001) Identifier (LE): 256 (0x0100) Sequence Number (BE): 626 (0x0272) Sequence Number (LE): 29186 (0x7202) [Response frame: 215] Data (32 bytes) Data: 6162636465666768696a6b6c6d6e6f7071727374757677616263646566676869 [Length: 32] Type的值为 8，Code的值为 0，表示回显请求 Checksum的值为 0x4ae9，这里校验和验证正确 Identifier：识别码，用于区分不同进程的应用。由于Window系统与Linux系统发出的ping报文的字节序不一样，所以需要 BE 和 LE 两个值，而这两个值所表示的十六进制值（HEX）是相同的。这里的 BE 指的是大端字节序，在Linux中使用；LE指的是小端字节序，在Windows中使用 Sequence Number：序列号，用于对应请求与响应。这里对于 BE 和 LE 解释同上。 回送回答报文 Internet Control Message Protocol Type: 0 (Echo (ping) reply) Code: 0 Checksum: 0x52e9 [correct] [Checksum Status: Good] Identifier (BE): 1 (0x0001) Identifier (LE): 256 (0x0100) Sequence Number (BE): 626 (0x0272) Sequence Number (LE): 29186 (0x7202) [Request frame: 213] [Response time: 20.855 ms] Data (32 bytes) Data: 6162636465666768696a6b6c6d6e6f7071727374757677616263646566676869 [Length: 32] Type的值为 0，Code的值为 0，表示回送回答 Checksum的值为 0x52e9，这里校验和验证正确 Identifier：识别码，用于区分不同进程的应用 Sequence Number：序列号，用于对应请求与响应。这里的值 626 同上文 回送请求报文 Sequence Number 的值，说明这俩请求和响应是对应的 Tracert命令 「Tracert」是用来显示可能的路由（路径）和测量数据包在 IP 网络中的传输延迟的命令\n在此次实验中，使用主机A在cmd环境下tracert baidu.com，分析报文\n差错报告报文 ICMP的差错报告报文中，会把收到的需要进行差错报告的IP的数据提取出来作为ICMP报文的数据部分\nInternet Protocol Version 4, Src: 192.168.31.248, Dst: 110.242.68.66 0100 .... = Version: 4 .... 0101 = Header Length: 20 bytes (5) Differentiated Services Field: 0x00 (DSCP: CS0, ECN: Not-ECT) 0000 00.. = Differentiated Services Codepoint: Default (0) .... ..00 = Explicit Congestion Notification: Not ECN-Capable Transport (0) Total Length: 92 Identification: 0x1f2e (7982) 000. .... = Flags: 0x0 0... .... = Reserved bit: Not set .0.. .... = Don\u0026#39;t fragment: Not set ..0. .... = More fragments: Not set ...0 0000 0000 0000 = Fragment Offset: 0 Time to Live: 1 [Expert Info (Note/Sequence): \u0026#34;Time To Live\u0026#34; only 1] [\u0026#34;Time To Live\u0026#34; only 1] [Severity level: Note] [Group: Sequence] Protocol: ICMP (1) Header Checksum: 0x0000 [validation disabled] [Header checksum status: Unverified] Source Address: 192.168.31.248 Destination Address: 110.242.68.66 Internet Control Message Protocol Type: 8 (Echo (ping) request) Code: 0 Checksum: 0xf4e4 [correct] [Checksum Status: Good] Identifier (BE): 1 (0x0001) Identifier (LE): 256 (0x0100) Sequence Number (BE): 794 (0x031a) Sequence Number (LE): 6659 (0x1a03) [No response seen] [Expert Info (Warning/Sequence): No response seen to ICMP request] [No response seen to ICMP request] [Severity level: Warning] [Group: Sequence] Data (64 bytes) Data: 000000000000000000000000000000000000000000000000000000000000000000000000… [Length: 64] Internet Control Message Protocol Type: 11 (Time-to-live exceeded) Code: 0 (Time to live exceeded in transit) Checksum: 0xf4ff [correct] [Checksum Status: Good] Unused: 00000000 Internet Protocol Version 4, Src: 192.168.31.248, Dst: 110.242.68.66 0100 .... = Version: 4 .... 0101 = Header Length: 20 bytes (5) Differentiated Services Field: 0x00 (DSCP: CS0, ECN: Not-ECT) 0000 00.. = Differentiated Services Codepoint: Default (0) .... ..00 = Explicit Congestion Notification: Not ECN-Capable Transport (0) Total Length: 92 Identification: 0x1f2e (7982) 000. .... = Flags: 0x0 0... .... = Reserved bit: Not set .0.. .... = Don\u0026#39;t fragment: Not set ..0. .... = More fragments: Not set ...0 0000 0000 0000 = Fragment Offset: 0 Time to Live: 1 [Expert Info (Note/Sequence): \u0026#34;Time To Live\u0026#34; only 1] [\u0026#34;Time To Live\u0026#34; only 1] [Severity level: Note] [Group: Sequence] Protocol: ICMP (1) Header Checksum: 0x069f [validation disabled] [Header checksum status: Unverified] Source Address: 192.168.31.248 Destination Address: 110.242.68.66 Internet Control Message Protocol Type: 8 (Echo (ping) request) Code: 0 Checksum: 0xf4e4 [unverified] [in ICMP error packet] [Checksum Status: Unverified] Identifier (BE): 1 (0x0001) Identifier (LE): 256 (0x0100) Sequence Number (BE): 794 (0x031a) Sequence Number (LE): 6659 (0x1a03) Data (64 bytes) Data: 000000000000000000000000000000000000000000000000000000000000000000000000… [Length: 64] Type的值为 11，Code的值为 0，表示超时报错 图1的回送请求报文出错，图2相对应的差错报告报文，把图1报文的IP数据报的首部和数据字段的前8个字节提取出来，作为ICMP报文的数据字段 基于实验数据深入分析TCP协议功能 TCP即传输控制协议（Transmission Control Protocol），是面向连接的运输层协议\nTCP报文格式 TCP报文格式解释 源端口和目的端口：各占 2 字节，和和 IP 头部的 源地址 和 目的地址 一起唯一地标识了每个连接 序列号：占 4 字节，TCP连接中传送的数据流中的每一个字节都按顺序编号，序号字段的值指的是本报文段所发送的数据的第一个字节的序号 确认号：占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号 数据偏移：占 4 位，它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远，实际是指出TCP报文段的首部长度 保留：占 6 位，保留为今后使用，默认置0 紧急 URG(URGent)：当 URG = 1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据) 确认 ACK(ACKnowledegment)：只有当 ACK = 1 时确认号字段有效，当 ACK = 0 时确认号无效 推送 PSH(PuSH)：接收 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程，不再等到整个缓存都填满了后再向上交付 复位 RST(ReSeT)：当 RST = 1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因）必须释放连接，然后再重新建立运输连接。RST置1还用来拒绝一个非法报文或拒绝打开一个连接 同步 SYN(SYNchronization)：在连接建立时用来同步序号。当 SYN = 1 而 ACK = 0 时，表明这是一个连接请求报文段。对方若同意建立连接，则在响应的报文段中使 SYN = 1 和 ACK = 1 终止 FIN(FINish)：用来释放一个连接。FIN = 1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。 窗口：占 2 字节，指的是发送本报文段的一方的接收窗口。用于流量控制，指示接收方愿意接收的字节数量 检验和：占 2 字节，检验和字段检验的范围包括TCP首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部 选项：长度可变，最长可达 40 字节。如 最长报文段长度MSS、窗口扩大选项、时间戳选项等等 填充字段：仅仅是为了使整个TCP首部长度为 4 字节的整数倍 实验步骤 下载 TCP/UDP Socket 调试工具 在cmd中ping zhihu.com，得到ip地址为103.41.167.234 使用TCP调试工具，创建一个连接 打开Wireshark，设置显示过滤器为 ip.addr == 103.41.167.234 在TCP调试工具中，点击 连接 在TCP调试工具中，发送数据 Hello World!!!后，连接自动断开 在Wireshark中捕获到以下数据包 三次握手 一开始，客户端和服务端都处于 CLOSE 状态。先是服务端主动监听某个端口，处于 LISTEN 状态 客户端随机初始化 序列号 seq 为 x，同时把 SYN 置1，接着把报文发送给服务端。之后，TCP客户端进入 SYN-SENT 状态 服务器收到连接请求报文段后，若同意连接，将进行下述操作。首先，随机初始化自己的 序列号 seq 为 y，其次把 确认号 ack 置为 x + 1，接着 SYN 和 ACK 均置为1，最后把该报文发给客户端。这时，服务端进入SYN-RCVD 状态 客户端收到服务端报文后，还要向服务端回应最后一个应答报文。首先将应答报文的 ACK 置为1，确认号 ack 置为 y + 1，序列号 seq 置为 x + 1，最后把报文发送给服务端。之后，客户端处于ESTABLISHED 状态 服务端收到客户端的应答报文后，也进入 ESTABLISHED 状态 四次挥手 客户端打算关闭连接，此时会发送一个 TCP 首部 FIN 标志位被置为 1 的报文并指明自己当前的 序列号 seq 为 u，之后客户端进入 FIN_WAIT_1 状态 服务端收到该报文后，就向客户端发送 ACK 应答报文，指明自己当前的 序列号 seq 为 v， 确认号 ack 为 u + 1，接着服务端进入 CLOSE_WAIT 状态 客户端收到服务端的 ACK 应答报文后，之后进入 FIN_WAIT_2 状态 等待服务端处理完数据后，也向客户端发送 FIN 报文，报文的 ACK 置为 1，序列号 seq 为 w， 确认号 ack 为 u + 1，之后服务端进入 LAST_ACK 状态 客户端收到服务端的 FIN 报文后，回一个 ACK 应答报文，其中 序列号 seq 为 u + 1， 确认号 ack 为 w + 1，之后进入 TIME_WAIT 状态 服务端收到了 ACK 应答报文后，就进入了 CLOSE 状态，至此服务端已经完成连接的关闭 客户端在经过 2MSL 一段时间后，自动进入 CLOSE 状态，至此客户端也完成连接的关闭 参考 Wireshark系列之4 捕获过滤器 网络——Wireshark工具 WireShark的基本用法 Wireshark使用教程（界面说明、捕获过滤器表达式、显示过滤器表达式） 一文精讲Wireshark的抓包和分析 Wireshark简明教程，新手专用，挑实在的讲，不搞花里胡哨 WireShark网络封包抓包工具各个界面介绍 实验3.利用Wireshark分析ARP协议 如何计算IP或ICMP协议首部里的checksum字段 带你深入熟悉你所不知道的ICMP 使用Wireshark学习网络协议之ICMP 实战！我用 Wireshark 让你“看见“ TCP 4.1 TCP 三次握手与四次挥手面试题 Wireshark抓包TCP三次握手 TCP 中的三次握手和四次挥手 Wireshark配合TCP调试工具理解TCP三次握手和四次挥手过程 老生常谈的TCP三次握手和四次挥手，你会了吗？ Wireshark官方文档 ","permalink":"https://xancoding.cn/posts/wireshark/","summary":"要求 团队合作、合理分工、按组为单位进行 报告文字内容不可拷贝粘贴现有文献，应反映小组所做的工作，有分析，实践性的选题应有具体操作或者配置过程描","title":"计算机网络课程大作业"},{"content":"Vimium是什么？ Vimium是一款Chrome插件，它提供了类Vim操作来控制浏览器网页\n熟练掌握后，可以脱离鼠标，只使用键盘浏览页面\nVimium常用命令 ? 指令可以打开帮助指南，其中有大多数的指令介绍 小写字母一般是在当前页面的操作 大写字母一般是跳转到新页面的操作 页面浏览 j/k/h/l：向上/下/左/右滚动页面 d/u：向下/上滚动半屏页面 gg/G：回到顶/底部 J/K：选择左/右标签 x/X：关闭/恢复标签 r：刷新页面 gi：将焦点聚集在第一个输入框 \u0026lt;\u0026lt;/\u0026gt;\u0026gt;：移动当前标签到左/右侧边 W：把当前标签页转移到一个新的窗口 ^：跳转到上一个标签页面 g0/$：跳转到第一个/最后一个标签页面 URL操作 H/L：当前页面的浏览历史记录的后退和前进 yy：把当前页面的URL复制到剪切板 yf：选择一个URL复制到剪切板 p/P：在当前/新页面打开剪切板中的URL gu/U：跳转到当前URL的父/根目录 g + e/E：编辑当前地址栏，并在当前/新页面打开 模式切换 f/F：点击模式，为页面上所有可见的链接分配到一个好按的键位，这个时候按下相应的键位，就会打开对应的链接 i：插入模式，可以屏蔽掉vimium快捷键，使其不和网页默认快捷键冲突 v/V：视觉/行视觉 模式，用于选区 Esc：退出模式 查找操作 /：查找 n/N：向下/上查找结果 o/O：查找历史记录 \u0026amp; 书签 t/T：创建/查找标签页 常用技巧 快速定位 + 复制文本： \u0026lt;a-f\u0026gt;搜索指定关键字，并定位至起点 按v切换到视觉模式 使用h、j、k、l、b、e、w、$、Shift + w控制方向，选择范围 最后使用y复制内容至剪切板 推荐阅读 我比想象中更需要浏览器中的 Vim 模式 Vimium完全教程，各类技巧大全 Vimium教程 | Micracle\u0026rsquo;s blog Vimium如何选中网页中的内容并对其进行复制和粘贴？ ","permalink":"https://xancoding.cn/posts/vimium/","summary":"Vimium是什么？ Vimium是一款Chrome插件，它提供了类Vim操作来控制浏览器网页 熟练掌握后，可以脱离鼠标，只使用键盘浏览页面 Vi","title":"Vimium学习记"},{"content":"AcWing Web 应用课 AcWing Web 应用课 | Colopen\u0026rsquo;s blog AcWing Web 应用课 HTML 基础标签 CSS JavaScript React Vue3 MDN官方文档 Web 入门 HTML —— 构建 Web CSS —— 设计Web JavaScript —— 用户端动态脚本 React 入门 Vue 入门 Canvas 教程 VSCode 自动生成缺省的 HTML 代码框架 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 输入！，接着输入 tab 键，自动生成缺省的 HTML 代码框架 再按三下 tab 键，光标会移动到 \u0026lt;body\u0026gt; 与 \u0026lt;/body\u0026gt; 之间的空行 KOF KOF AcWing Web 应用课 | 中期项目——拳皇（上） | Vedio AcWing Web 应用课 | 中期项目——拳皇（下） | Vedio 基础操作 操作如下： 角色一: w 跳 a 左移 d 右移 j 拳击 角色二: ↑ 跳 ← 左移 → 右移 1 拳击 文件结构 |-- README.md |-- static | |-- css | | `-- base.css | |-- images | | |-- background | | | `-- 0.gif | | `-- player | | `-- kyo | | |-- 0.gif | | |-- 1.gif | | |-- 2.gif | | |-- 3.gif | | |-- 4.gif | | |-- 5.gif | | `-- 6.gif | `-- js | |-- ac_game_object | | `-- base.js | |-- base.js | |-- controller | | `-- base.js | |-- game_map | | `-- base.js | |-- player | | |-- base.js | | `-- kyo.js | `-- utils | `-- gif.js `-- templates `-- index.html 整体架构 逻辑结构 Retrieved from：https://www.acwing.com/solution/content/139831/ HTML templates/index.html\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;KOF\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;../static/css/base.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.acwing.com/static/jquery/js/jquery-3.3.1.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;kof\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import {KOF} from \u0026#39;../static/js/base.js\u0026#39;; let kof = new KOF(\u0026#39;kof\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; CSS css/base.css\n#kof { width: 1280px; height: 720px; background-image: url(\u0026#39;../images/background/0.gif\u0026#39;); background-size: 200% 100%; background-position: top; position: absolute; } #kof\u0026gt;.kof-head { width: 100%; height: 80px; position: absolute; top: 0; display: flex; align-items: center; } #kof\u0026gt;.kof-head\u0026gt;.kof-head-hp-0 { height: 40px; width: calc(50% - 60px); margin-left: 20px; border: white 5px solid; box-sizing: border-box; border-right: none; } #kof\u0026gt;.kof-head\u0026gt;.kof-head-timer { height: 60px; width: 80px; background-color: orange; border: white 5px solid; box-sizing: border-box; color: white; font-size: 30px; font-weight: 800; text-align: center; line-height: 50px; user-select: none; } #kof\u0026gt;.kof-head\u0026gt;.kof-head-hp-1 { height: 40px; width: calc(50% - 60px); border: white 5px solid; box-sizing: border-box; border-left: none; } #kof\u0026gt;.kof-head\u0026gt;.kof-head-hp-0\u0026gt;div { background-color: red; height: 100%; width: 100%; float: right; } #kof\u0026gt;.kof-head\u0026gt;.kof-head-hp-1\u0026gt;div { background-color: red; height: 100%; width: 100%; } #kof\u0026gt;.kof-head\u0026gt;.kof-head-hp-0\u0026gt;div\u0026gt;div { background-color: lightgreen; height: 100%; width: 100%; float: right; } #kof\u0026gt;.kof-head\u0026gt;.kof-head-hp-1\u0026gt;div\u0026gt;div { background-color: lightgreen; height: 100%; width: 100%; } JavaScript 逻辑结构 KOF js/base.js\nimport { GameMap } from \u0026#39;../js/game_map/base.js\u0026#39; import { Kyo } from \u0026#39;../js/player/kyo.js\u0026#39;; export class KOF { constructor(id) { this.$kof = $(\u0026#39;#\u0026#39; + id); this.game_map = new GameMap(this); this.players = [ new Kyo(this, { id: 0, x: 200, y: 0, width: 120, height: 200, color: \u0026#39;blue\u0026#39; }), new Kyo(this, { id: 1, x: 900, y: 0, width: 120, height: 200, color: \u0026#39;red\u0026#39; }) ] } } AcGameObject js/ac_game_object/base.js\nlet AC_GAME_OBJECTS = []; export class AcGameObject { constructor() { AC_GAME_OBJECTS.push(this); this.timedelta = 0; this.has_call_start = false; } start() { // 初始化 } update() { // 每一帧执行一次 } destory() { // 删除当前对象 for (let i in AC_GAME_OBJECTS) { if (AC_GAME_OBJECTS[i] === this) { AC_GAME_OBJECTS.splice(i, 1); break; } } } } let last_timestamp; // 上一次执行函数时的时刻 /** * @description 该函数每一帧执行一次 * @param {number} timestamp 当前执行函数时的时刻 */ let AC_GAME_OBJECTS_FRAME = (timestamp) =\u0026gt; { for (let obj of AC_GAME_OBJECTS) { if (!obj.has_call_start) { obj.start(); obj.has_call_start = true; } else { obj.timedelta = timestamp - last_timestamp; obj.update(); } } last_timestamp = timestamp; requestAnimationFrame(AC_GAME_OBJECTS_FRAME); } requestAnimationFrame(AC_GAME_OBJECTS_FRAME); Controller controller 控制器，读取玩家的输入 js/constroller/base.js export class Controller { // 手动实现键盘触发事件——当前按住的按键（效果不同于keydown） constructor($canvas) { this.$canvas = $canvas; this.pressed_keys = new Set(); // Set 对象允许你存储任何类型的唯一值 this.start(); } start() { let outer = this; this.$canvas.keydown(function(e){ // keydown：某个键是否被按住，事件会连续触发 outer.pressed_keys.add(e.key); }); this.$canvas.keyup(function(e){ // keyup：某个按键是否被释放 outer.pressed_keys.delete(e.key); }); } } GameMap js/game_map/base.js\nimport {AcGameObject} from \u0026#39;../ac_game_object/base.js\u0026#39; import { Controller } from \u0026#39;../controller/base.js\u0026#39;; export class GameMap extends AcGameObject { constructor(root) { super(); this.root = root; this.$canvas = $(\u0026#39;\u0026lt;canvas width=\u0026#34;1280\u0026#34; height=\u0026#34;720\u0026#34; tabindex=0\u0026gt;\u0026lt;/canvas\u0026gt;\u0026#39;); // 构造一个jQuery对象 其中，tabindex=\u0026#34;0\u0026#34;使\u0026lt;canvas\u0026gt;元素可以聚焦 this.ctx = this.$canvas[0].getContext(\u0026#39;2d\u0026#39;); // this.$canvas[0]是\u0026lt;canvas\u0026gt;元素的DOM对象 this.ctx用于画布的渲染 this.root.$kof.append(this.$canvas); this.$canvas.focus(); // 聚焦，使之可以获取输入 this.controller = new Controller(this.$canvas); // 加入血条 this.root.$kof.append($(` \u0026lt;div class=\u0026#34;kof-head\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;kof-head-hp-0\u0026#34;\u0026gt;\u0026lt;div\u0026gt;\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;kof-head-timer\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;kof-head-hp-1\u0026#34;\u0026gt;\u0026lt;div\u0026gt;\u0026lt;div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; `)); // 加入计时表 this.time_left = 60000; //单位：毫秒（因为定义的timedelta单位是ms） this.$timer = this.root.$kof.find(\u0026#39;.kof-head-timer\u0026#39;); } start() { } update() { this.update_time(); this.render(); } update_time() { this.time_left -= this.timedelta; if (this.time_left \u0026lt; 0) { // 时间到，游戏结束 this.time_left = 0; let [a, b] = this.root.players; if (a.status !== 6 \u0026amp;\u0026amp; b.status !== 6) { a.statu = b.status = 6; a.frame_current_cnt = b.frame_current_cnt = 0; a.vx = b.vx = 0; } } this.$timer.text(parseInt(this.time_left / 1000)); } render() { this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height); } } Player js/player/base.js\nimport { AcGameObject } from \u0026#39;../ac_game_object/base.js\u0026#39;; export class Player extends AcGameObject { constructor(root, info) { super(); this.root = root; this.id = info.id; this.x = info.x; this.y = info.y; this.width = info.width; this.height = info.height; this.color = info.color; this.direction = 1; this.vx = 0; this.vy = 0; this.speedx = 400; // 水平速度 this.speedy = -1000; // 跳跃初始速度 this.gravity = 50; this.ctx = this.root.game_map.ctx; this.pressed_keys = this.root.game_map.controller.pressed_keys; this.status = 3; // 0：静止， 1：向前，2：向后，3：跳跃，4：攻击，5：被攻击，6：死亡 随着项目的完善，动作会变的很多，这时用数组存储字符串代替this.status会更方便 this.animations = new Map(); // 存储GIF动画的每一帧 this.frame_current_cnt = 0; // 记录当前的帧数 this.hp = 100; this.$hp = this.root.$kof.find(`.kof-head-hp-${this.id}\u0026gt;div`); this.$hp_div = this.$hp.find(\u0026#39;div\u0026#39;); } start() { } update_control() { let w, a, d, j; if (this.id === 0) { w = this.pressed_keys.has(\u0026#39;w\u0026#39;); a = this.pressed_keys.has(\u0026#39;a\u0026#39;); d = this.pressed_keys.has(\u0026#39;d\u0026#39;); j = this.pressed_keys.has(\u0026#39;j\u0026#39;); } else { w = this.pressed_keys.has(\u0026#39;ArrowUp\u0026#39;); a = this.pressed_keys.has(\u0026#39;ArrowLeft\u0026#39;); d = this.pressed_keys.has(\u0026#39;ArrowRight\u0026#39;); j = this.pressed_keys.has(\u0026#39;1\u0026#39;); } if (this.status === 0 || this.status === 1) { // 静止状态 || 移动状态 if (j) { // 攻击 this.status = 4; this.vx = 0; this.frame_current_cnt = 0; } else if (w) { // 跳跃 if (d) { // 向右跳 this.vx = this.speedx; } else if (a) { // 向左跳 this.vx = -this.speedx; } else { // 垂直跳 this.vx = 0; } this.vy = this.speedy; this.status = 3; this.frame_current_cnt = 0; // 每次跳跃重新记录帧数，确保跳跃动画正常 } else if (d) { // 向右移动 this.vx = this.speedx; this.status = 1; } else if (a) { // 向左移动 this.vx = - this.speedx; this.status = 1; } else { // 静止 this.vx = 0; } } } update_move() { this.vy += this.gravity; this.x += this.vx * this.timedelta / 1000; this.y += this.vy * this.timedelta / 1000; // 确保两个角色不会重叠 a 是自己、b 是对手 // let [a, b] = this.root.players; // if (a !== this) [a,b] = [b, a]; // let r1 = { // x1: a.x, // y1: a.y, // x2: a.x + a.width, // y2: a.x + a.height, // }; // let r2 = { // x1: b.x, // y1: b.y, // x2: b.x + b.width, // y2: b.x + b.height, // }; // if (this.is_collusion(r1, r2)) { // b.x += this.vx * this.timedelta / 1000 / 2; // b.y += this.vy * this.timedelta / 1000 / 2; // a.x -= this.vx * this.timedelta / 1000 / 2; // a.y -= this.vy * this.timedelta / 1000 / 2; // if (this.status === 3) this.status = 0; // } // 落到平地上后静止 if (this.y \u0026gt; 450) { this.y = 450; this.vy = 0; if (this.status === 3) this.status = 0; // 因为任何时刻都有重力施加，不加这一句会导致状态只有静止状态 } // 不能超出左右边界 if (this.x \u0026lt; 0) { this.x = 0; } else if (this.x + this.width \u0026gt; this.root.game_map.$canvas.width()) { this.x = this.root.game_map.$canvas.width() - this.width; } } update_direction() { // 确保两个角色始终相对 if (this.status === 6) return; let players = this.root.players; if (players[0] \u0026amp;\u0026amp; players[1]) { let me = this, you = players[1 - this.id]; if (me.x \u0026lt; you.x) me.direction = 1; else me.direction = -1; } } is_collusion(r1, r2) { // 判断两个矩阵是否有交集 if (Math.max(r1.x1, r2.x1) \u0026gt; Math.min(r1.x2, r2.x2)) return false; if (Math.max(r1.y1, r2.y1) \u0026gt; Math.min(r1.y2,r2.y2)) return false; return true; } is_attack() { if (this.status === 6) return; // 已经倒地，无法再被攻击 this.status = 5; this.frame_current_cnt = 0; this.hp = Math.max(this.hp - 10, 0); this.$hp_div.animate({ // 血条减少，渐变 width: this.$hp.parent().width() * this.hp / 100, }, 350); this.$hp.animate({ // 血条减少，渐变 width: this.$hp.parent().width() * this.hp / 100, }, 600); if (this.hp \u0026lt;= 0) { this.status = 6; this.frame_current_cnt = 0; this.vx = 0; } } update_attack() { // 判定是否被攻击到 if (this.status === 4 \u0026amp;\u0026amp; this.frame_current_cnt === 18) { // 第18帧时动画挥出拳，判断此时是否拳头与对方有碰撞 let me = this, you = this.root.players[1 - this.id]; let r1; // 攻击判定矩形 let r2; // 敌方人物矩形 if (this.direction \u0026gt; 0) { r1 = { x1: me.x + 120, y1: me.y + 40, x2: me.x + 120 + 100, y2: me.y + 40 + 20, } } else { r1 = { x1: me.x + me.width - 120 - 100, y1: me.y + 40, x2: me.x + me.width - 120 - 100 + 100, y2: me.y + 40 + 20, } } r2 = { x1: you.x, y2: you.y, x2: you.x + you.width, y2: you.y + you.height }; if (this.is_collusion(r1, r2)) { you.is_attack(); } } } update() { this.update_attack(); this.update_direction(); this.update_control(); this.update_move(); this.render(); } render() { let status = this.status; if (this.status === 1 \u0026amp;\u0026amp; this.direction * this.vx \u0026lt; 0) status = 2; // 后退状态 let obj = this.animations.get(status); if (obj \u0026amp;\u0026amp; obj.loaded) { // GIF 已经加载完成 if (this.direction \u0026gt; 0) { // 正方向 let k = parseInt(this.frame_current_cnt / obj.frame_rate) % obj.frame_cnt; // 通过obj.frame_rate控制渲染动画的速率，方便控制动画，而不只是单纯的每一帧都渲染一次 let image = obj.gif.frames[k].image; this.ctx.drawImage(image, this.x, this.y + obj.offset_y, image.width * obj.scale, image.height * obj.scale); } else { // 反方向 通过调整坐标系来翻转方向 this.ctx.save(); this.ctx.scale(-1, 1); this.ctx.translate(-this.root.game_map.$canvas.width(), 0); let k = parseInt(this.frame_current_cnt / obj.frame_rate) % obj.frame_cnt; let image = obj.gif.frames[k].image; this.ctx.drawImage(image, this.root.game_map.$canvas.width() - this.width - this.x, this.y + obj.offset_y, image.width * obj.scale, image.height * obj.scale); // 不同于正方向时的渲染，因为此时坐标系改变，需要在对称的位置渲染 this.ctx.restore(); } } if (status === 4 || status === 5 || status === 6) { // 确保不会一直循环GIF if (this.frame_current_cnt === obj.frame_rate * (obj.frame_cnt - 1)) { // 确保此时已经播放完一次GIF动画 if (status === 6) { // 死亡倒地不起，这里的 -- 和 下面的 ++ 相抵消，使之在最后一帧不再变化 this.frame_current_cnt--; } else { this.status = 0; } } } this.frame_current_cnt++; } } js/player/kyo.js\nimport { Player } from \u0026#34;../player/base.js\u0026#34;; import {GIF} from \u0026#39;../utils/gif.js\u0026#39; export class Kyo extends Player { constructor(root, info) { super(root, info); this.init_animations(); // 初始化动画 } init_animations() { let outer = this; let offsets = [0, -22, -22, -150, 0, 0, 0]; // 偏移量 不同的动画高度不同，因此需要借助竖直方向上的偏移量将他们调整至同一水平面 for (let i = 0; i \u0026lt; 7; ++ i) { // 7个动作 let gif = GIF(); gif.load(`/static/images/player/kyo/${i}.gif`); this.animations.set(i, { // 动画 gif: gif, frame_cnt: 0, // GIF帧数 frame_rate: 5, // 每5帧过渡一次 offset_y: offsets[i], // y方向偏移量 loaded: false, // 是否加载完成 scale: 2, // 放大2倍 }); gif.onload = function() { // 加载完成 let obj = outer.animations.get(i); obj.frame_cnt = gif.frames.length; obj.loaded = true; if (i === 3) { // 调整跳跃时GIF播放速率 obj.frame_rate = 4; } } } } } GIF Loading and playing GIF image to canvas 把玩家的GIF动画渲染在canvas上 js/utils/gif.js\nconst GIF = function () { // **NOT** for commercial use. var timerID; // timer handle for set time out usage var st; // holds the stream object when loading. var interlaceOffsets = [0, 4, 2, 1]; // used in de-interlacing. var interlaceSteps = [8, 8, 4, 2]; var interlacedBufSize; // this holds a buffer to de interlace. Created on the first frame and when size changed var deinterlaceBuf; var pixelBufSize; // this holds a buffer for pixels. Created on the first frame and when size changed var pixelBuf; const GIF_FILE = { // gif file data headers GCExt: 0xF9, COMMENT: 0xFE, APPExt: 0xFF, UNKNOWN: 0x01, // not sure what this is but need to skip it in parser IMAGE: 0x2C, EOF: 59, // This is entered as decimal EXT: 0x21, }; // simple buffered stream used to read from the file var Stream = function (data) { this.data = new Uint8ClampedArray(data); this.pos = 0; var len = this.data.length; this.getString = function (count) { // returns a string from current pos of len count var s = \u0026#34;\u0026#34;; while (count--) { s += String.fromCharCode(this.data[this.pos++]) } return s; }; this.readSubBlocks = function () { // reads a set of blocks as a string var size, count, data = \u0026#34;\u0026#34;; do { count = size = this.data[this.pos++]; while (count--) { data += String.fromCharCode(this.data[this.pos++]) } } while (size !== 0 \u0026amp;\u0026amp; this.pos \u0026lt; len); return data; } this.readSubBlocksB = function () { // reads a set of blocks as binary var size, count, data = []; do { count = size = this.data[this.pos++]; while (count--) { data.push(this.data[this.pos++]); } } while (size !== 0 \u0026amp;\u0026amp; this.pos \u0026lt; len); return data; } }; // LZW decoder uncompressed each frames pixels // this needs to be optimised. // minSize is the min dictionary as powers of two // size and data is the compressed pixels function lzwDecode(minSize, data) { var i, pixelPos, pos, clear, eod, size, done, dic, code, last, d, len; pos = pixelPos = 0; dic = []; clear = 1 \u0026lt;\u0026lt; minSize; eod = clear + 1; size = minSize + 1; done = false; while (!done) { // JavaScript optimisers like a clear exit though I never use \u0026#39;done\u0026#39; apart from fooling the optimiser last = code; code = 0; for (i = 0; i \u0026lt; size; i++) { if (data[pos \u0026gt;\u0026gt; 3] \u0026amp; (1 \u0026lt;\u0026lt; (pos \u0026amp; 7))) { code |= 1 \u0026lt;\u0026lt; i } pos++; } if (code === clear) { // clear and reset the dictionary dic = []; size = minSize + 1; for (i = 0; i \u0026lt; clear; i++) { dic[i] = [i] } dic[clear] = []; dic[eod] = null; } else { if (code === eod) { done = true; return } if (code \u0026gt;= dic.length) { dic.push(dic[last].concat(dic[last][0])) } else if (last !== clear) { dic.push(dic[last].concat(dic[code][0])) } d = dic[code]; len = d.length; for (i = 0; i \u0026lt; len; i++) { pixelBuf[pixelPos++] = d[i] } if (dic.length === (1 \u0026lt;\u0026lt; size) \u0026amp;\u0026amp; size \u0026lt; 12) { size++ } } } }; function parseColourTable(count) { // get a colour table of length count Each entry is 3 bytes, for RGB. var colours = []; for (var i = 0; i \u0026lt; count; i++) { colours.push([st.data[st.pos++], st.data[st.pos++], st.data[st.pos++]]) } return colours; } function parse() { // read the header. This is the starting point of the decode and async calls parseBlock var bitField; st.pos += 6; gif.width = (st.data[st.pos++]) + ((st.data[st.pos++]) \u0026lt;\u0026lt; 8); gif.height = (st.data[st.pos++]) + ((st.data[st.pos++]) \u0026lt;\u0026lt; 8); bitField = st.data[st.pos++]; gif.colorRes = (bitField \u0026amp; 0b1110000) \u0026gt;\u0026gt; 4; gif.globalColourCount = 1 \u0026lt;\u0026lt; ((bitField \u0026amp; 0b111) + 1); gif.bgColourIndex = st.data[st.pos++]; st.pos++; // ignoring pixel aspect ratio. if not 0, aspectRatio = (pixelAspectRatio + 15) / 64 if (bitField \u0026amp; 0b10000000) { gif.globalColourTable = parseColourTable(gif.globalColourCount) } // global colour flag setTimeout(parseBlock, 0); } function parseAppExt() { // get application specific data. Netscape added iterations and terminator. Ignoring that st.pos += 1; if (\u0026#39;NETSCAPE\u0026#39; === st.getString(8)) { st.pos += 8 } // ignoring this data. iterations (word) and terminator (byte) else { st.pos += 3; // 3 bytes of string usually \u0026#34;2.0\u0026#34; when identifier is NETSCAPE st.readSubBlocks(); // unknown app extension } }; function parseGCExt() { // get GC data var bitField; st.pos++; bitField = st.data[st.pos++]; gif.disposalMethod = (bitField \u0026amp; 0b11100) \u0026gt;\u0026gt; 2; gif.transparencyGiven = bitField \u0026amp; 0b1 ? true : false; // ignoring bit two that is marked as userInput??? gif.delayTime = (st.data[st.pos++]) + ((st.data[st.pos++]) \u0026lt;\u0026lt; 8); gif.transparencyIndex = st.data[st.pos++]; st.pos++; }; function parseImg() { // decodes image data to create the indexed pixel image var deinterlace, frame, bitField; deinterlace = function (width) { // de interlace pixel data if needed var lines, fromLine, pass, toline; lines = pixelBufSize / width; fromLine = 0; if (interlacedBufSize !== pixelBufSize) { // create the buffer if size changed or undefined. deinterlaceBuf = new Uint8Array(pixelBufSize); interlacedBufSize = pixelBufSize; } for (pass = 0; pass \u0026lt; 4; pass++) { for (toLine = interlaceOffsets[pass]; toLine \u0026lt; lines; toLine += interlaceSteps[pass]) { deinterlaceBuf.set(pixelBuf.subarray(fromLine, fromLine + width), toLine * width); fromLine += width; } } }; frame = {} gif.frames.push(frame); frame.disposalMethod = gif.disposalMethod; frame.time = gif.length; frame.delay = gif.delayTime * 10; gif.length += frame.delay; if (gif.transparencyGiven) { frame.transparencyIndex = gif.transparencyIndex } else { frame.transparencyIndex = undefined } frame.leftPos = (st.data[st.pos++]) + ((st.data[st.pos++]) \u0026lt;\u0026lt; 8); frame.topPos = (st.data[st.pos++]) + ((st.data[st.pos++]) \u0026lt;\u0026lt; 8); frame.width = (st.data[st.pos++]) + ((st.data[st.pos++]) \u0026lt;\u0026lt; 8); frame.height = (st.data[st.pos++]) + ((st.data[st.pos++]) \u0026lt;\u0026lt; 8); bitField = st.data[st.pos++]; frame.localColourTableFlag = bitField \u0026amp; 0b10000000 ? true : false; if (frame.localColourTableFlag) { frame.localColourTable = parseColourTable(1 \u0026lt;\u0026lt; ((bitField \u0026amp; 0b111) + 1)) } if (pixelBufSize !== frame.width * frame.height) { // create a pixel buffer if not yet created or if current frame size is different from previous pixelBuf = new Uint8Array(frame.width * frame.height); pixelBufSize = frame.width * frame.height; } lzwDecode(st.data[st.pos++], st.readSubBlocksB()); // decode the pixels if (bitField \u0026amp; 0b1000000) { // de interlace if needed frame.interlaced = true; deinterlace(frame.width); } else { frame.interlaced = false } processFrame(frame); // convert to canvas image }; function processFrame(frame) { // creates a RGBA canvas image from the indexed pixel data. var ct, cData, dat, pixCount, ind, useT, i, pixel, pDat, col, frame, ti; frame.image = document.createElement(\u0026#39;canvas\u0026#39;); frame.image.width = gif.width; frame.image.height = gif.height; frame.image.ctx = frame.image.getContext(\u0026#34;2d\u0026#34;); ct = frame.localColourTableFlag ? frame.localColourTable : gif.globalColourTable; if (gif.lastFrame === null) { gif.lastFrame = frame } useT = (gif.lastFrame.disposalMethod === 2 || gif.lastFrame.disposalMethod === 3) ? true : false; if (!useT) { frame.image.ctx.drawImage(gif.lastFrame.image, 0, 0, gif.width, gif.height) } cData = frame.image.ctx.getImageData(frame.leftPos, frame.topPos, frame.width, frame.height); ti = frame.transparencyIndex; dat = cData.data; if (frame.interlaced) { pDat = deinterlaceBuf } else { pDat = pixelBuf } pixCount = pDat.length; ind = 0; for (i = 0; i \u0026lt; pixCount; i++) { pixel = pDat[i]; col = ct[pixel]; if (ti !== pixel) { dat[ind++] = col[0]; dat[ind++] = col[1]; dat[ind++] = col[2]; dat[ind++] = 255; // Opaque. } else if (useT) { dat[ind + 3] = 0; // Transparent. ind += 4; } else { ind += 4 } } frame.image.ctx.putImageData(cData, frame.leftPos, frame.topPos); gif.lastFrame = frame; if (!gif.waitTillDone \u0026amp;\u0026amp; typeof gif.onload === \u0026#34;function\u0026#34;) { doOnloadEvent() }// if !waitTillDone the call onload now after first frame is loaded }; // **NOT** for commercial use. function finnished() { // called when the load has completed gif.loading = false; gif.frameCount = gif.frames.length; gif.lastFrame = null; st = undefined; gif.complete = true; gif.disposalMethod = undefined; gif.transparencyGiven = undefined; gif.delayTime = undefined; gif.transparencyIndex = undefined; gif.waitTillDone = undefined; pixelBuf = undefined; // dereference pixel buffer deinterlaceBuf = undefined; // dereference interlace buff (may or may not be used); pixelBufSize = undefined; deinterlaceBuf = undefined; gif.currentFrame = 0; if (gif.frames.length \u0026gt; 0) { gif.image = gif.frames[0].image } doOnloadEvent(); if (typeof gif.onloadall === \u0026#34;function\u0026#34;) { (gif.onloadall.bind(gif))({ type: \u0026#39;loadall\u0026#39;, path: [gif] }); } if (gif.playOnLoad) { gif.play() } } function canceled() { // called if the load has been cancelled finnished(); if (typeof gif.cancelCallback === \u0026#34;function\u0026#34;) { (gif.cancelCallback.bind(gif))({ type: \u0026#39;canceled\u0026#39;, path: [gif] }) } } function parseExt() { // parse extended blocks const blockID = st.data[st.pos++]; if (blockID === GIF_FILE.GCExt) { parseGCExt() } else if (blockID === GIF_FILE.COMMENT) { gif.comment += st.readSubBlocks() } else if (blockID === GIF_FILE.APPExt) { parseAppExt() } else { if (blockID === GIF_FILE.UNKNOWN) { st.pos += 13; } // skip unknow block st.readSubBlocks(); } } function parseBlock() { // parsing the blocks if (gif.cancel !== undefined \u0026amp;\u0026amp; gif.cancel === true) { canceled(); return } const blockId = st.data[st.pos++]; if (blockId === GIF_FILE.IMAGE) { // image block parseImg(); if (gif.firstFrameOnly) { finnished(); return } } else if (blockId === GIF_FILE.EOF) { finnished(); return } else { parseExt() } if (typeof gif.onprogress === \u0026#34;function\u0026#34;) { gif.onprogress({ bytesRead: st.pos, totalBytes: st.data.length, frame: gif.frames.length }); } setTimeout(parseBlock, 0); // parsing frame async so processes can get some time in. }; function cancelLoad(callback) { // cancels the loading. This will cancel the load before the next frame is decoded if (gif.complete) { return false } gif.cancelCallback = callback; gif.cancel = true; return true; } function error(type) { if (typeof gif.onerror === \u0026#34;function\u0026#34;) { (gif.onerror.bind(this))({ type: type, path: [this] }) } gif.onload = gif.onerror = undefined; gif.loading = false; } function doOnloadEvent() { // fire onload event if set gif.currentFrame = 0; gif.nextFrameAt = gif.lastFrameAt = new Date().valueOf(); // just sets the time now if (typeof gif.onload === \u0026#34;function\u0026#34;) { (gif.onload.bind(gif))({ type: \u0026#39;load\u0026#39;, path: [gif] }) } gif.onerror = gif.onload = undefined; } function dataLoaded(data) { // Data loaded create stream and parse st = new Stream(data); parse(); } function loadGif(filename) { // starts the load var ajax = new XMLHttpRequest(); ajax.responseType = \u0026#34;arraybuffer\u0026#34;; ajax.onload = function (e) { if (e.target.status === 404) { error(\u0026#34;File not found\u0026#34;) } else if (e.target.status \u0026gt;= 200 \u0026amp;\u0026amp; e.target.status \u0026lt; 300) { dataLoaded(ajax.response) } else { error(\u0026#34;Loading error : \u0026#34; + e.target.status) } }; ajax.open(\u0026#39;GET\u0026#39;, filename, true); ajax.send(); ajax.onerror = function (e) { error(\u0026#34;File error\u0026#34;) }; this.src = filename; this.loading = true; } function play() { // starts play if paused if (!gif.playing) { gif.paused = false; gif.playing = true; playing(); } } function pause() { // stops play gif.paused = true; gif.playing = false; clearTimeout(timerID); } function togglePlay() { if (gif.paused || !gif.playing) { gif.play() } else { gif.pause() } } function seekFrame(frame) { // seeks to frame number. clearTimeout(timerID); gif.currentFrame = frame % gif.frames.length; if (gif.playing) { playing() } else { gif.image = gif.frames[gif.currentFrame].image } } function seek(time) { // time in Seconds // seek to frame that would be displayed at time clearTimeout(timerID); if (time \u0026lt; 0) { time = 0 } time *= 1000; // in ms time %= gif.length; var frame = 0; while (time \u0026gt; gif.frames[frame].time + gif.frames[frame].delay \u0026amp;\u0026amp; frame \u0026lt; gif.frames.length) { frame += 1 } gif.currentFrame = frame; if (gif.playing) { playing() } else { gif.image = gif.frames[gif.currentFrame].image } } function playing() { var delay; var frame; if (gif.playSpeed === 0) { gif.pause(); return; } else { if (gif.playSpeed \u0026lt; 0) { gif.currentFrame -= 1; if (gif.currentFrame \u0026lt; 0) { gif.currentFrame = gif.frames.length - 1 } frame = gif.currentFrame; frame -= 1; if (frame \u0026lt; 0) { frame = gif.frames.length - 1 } delay = -gif.frames[frame].delay * 1 / gif.playSpeed; } else { gif.currentFrame += 1; gif.currentFrame %= gif.frames.length; delay = gif.frames[gif.currentFrame].delay * 1 / gif.playSpeed; } gif.image = gif.frames[gif.currentFrame].image; timerID = setTimeout(playing, delay); } } var gif = { // the gif image object onload: null, // fire on load. Use waitTillDone = true to have load fire at end or false to fire on first frame onerror: null, // fires on error onprogress: null, // fires a load progress event onloadall: null, // event fires when all frames have loaded and gif is ready paused: false, // true if paused playing: false, // true if playing waitTillDone: true, // If true onload will fire when all frames loaded, if false, onload will fire when first frame has loaded loading: false, // true if still loading firstFrameOnly: false, // if true only load the first frame width: null, // width in pixels height: null, // height in pixels frames: [], // array of frames comment: \u0026#34;\u0026#34;, // comments if found in file. Note I remember that some gifs have comments per frame if so this will be all comment concatenated length: 0, // gif length in ms (1/1000 second) currentFrame: 0, // current frame. frameCount: 0, // number of frames playSpeed: 1, // play speed 1 normal, 2 twice 0.5 half, -1 reverse etc... lastFrame: null, // temp hold last frame loaded so you can display the gif as it loads image: null, // the current image at the currentFrame playOnLoad: true, // if true starts playback when loaded // functions load: loadGif, // call this to load a file cancel: cancelLoad, // call to stop loading play: play, // call to start play pause: pause, // call to pause seek: seek, // call to seek to time seekFrame: seekFrame, // call to seek to frame togglePlay: togglePlay, // call to toggle play and pause state }; return gif; } export { GIF } 状态机 0：静止 1：移动 3：跳跃 4：攻击 ","permalink":"https://xancoding.cn/posts/acwweb/","summary":"AcWing Web 应用课 AcWing Web 应用课 | Colopen\u0026rsquo;s blog AcWing Web 应用课 HTML 基础标签 CSS JavaScript React Vue3 MDN官方文档 Web 入门 HTML —— 构建 Web CSS —— 设计Web JavaScript —— 用户端动态脚本 React 入门 Vue 入门 Canvas 教程","title":"AcWing Web 应用课"},{"content":" 画图的工具并不重要，重要的其实是你应该如何形成自己的规则体系，想要为博客配图并不是一件困难的事情，比较困难的是长期坚持并且经常思考，对自己形成的规则不断改善，最终就一定能够做好。\n推荐阅读 Sketch UI 设计工具 Figma UI 设计工具 蓝湖 UI 设计工具 LucidChart 绘制 UML 图、流程图的商业软件 Excalidraw 手绘风格图表工具 Plantuml 快速编写UML图的组件 Drawio 一款开源免费的流程图绘制软件 Midjourney AI绘画 Drawio —— 一款开源免费的流程图绘制软件 AI绘画的关键词 技术文章配图指南\n编程和绘画；AI 从文本绘画；技术文章中的插图\n在 AI 绘画的世界里，怎样才算一名合格的「甲方」？\n","permalink":"https://xancoding.cn/posts/blogdrawing/","summary":"画图的工具并不重要，重要的其实是你应该如何形成自己的规则体系，想要为博客配图并不是一件困难的事情，比较困难的是长期坚持并且经常思考，对自己形","title":"如何为你的文章配图？"},{"content":"推荐阅读 Obsidian Hypothesis 使用小记 在网页上高亮批注，并可同步到 Obsidian 语雀 什么是 Zettelkasten 卡片盒笔记法？ 卢曼：与卡片盒交流 我的知识管理工具和经验 我的 Obsidian 使用经验 不要再碎片化笔记了 - 关于笔记的思考 程序员的喵喵 | Obsidian 使用 【中文字幕】Zettelkasten笔记系统的搭建 | 手把手教学 | Zettelkasten in Obsidian ","permalink":"https://xancoding.cn/posts/digitalgarden/","summary":"推荐阅读 Obsidian Hypothesis 使用小记 在网页上高亮批注，并可同步到 Obsidian 语雀 什么是 Zettelkasten 卡片盒笔记法？ 卢曼：与卡片盒交流 我的知识管理工具和经验 我的 Obsidian 使用经验 不要再碎片","title":"构建你的数字花园"},{"content":" AcWing Django 框架课 | Colopen\u0026rsquo;s blog AcWing Django 框架课 Django 项目创建 2.1上课笔记 | 栎 2.1上课笔记 | Andrew1729 启动初始项目 django-admin startproject acapp：在当前目录下创建名为acapp的django项目 python3 manage.py runserver 0.0.0.0:8000：启动项目 打开settings.py，找到ALLOWED_HOSTS=[]，修改成ALLOWED_HOSTS=[\u0026quot;自己的服务器的公网IP\u0026quot;] 通过自己的服务器公网IP:8000 打开Django页面 创建管理员登录页面 在一级acapp文件夹下，python3 manage.py startapp XXX，XXX是可以自定义的app名，这里用game示例，这时候会多一个文件夹game，树形结构如图： |-- game | |-- __init__.py | |-- admin.py # 管理员页面 | |-- apps.py # 用的不多 | |-- migrations # 存储数据库 | | `-- __init__.py | |-- models.py # 定义网站里的数据库表 | |-- tests.py | `-- views.py # 视图，即函数 python3 manage.py migrate：将所有修改更新进数据库 创建一个 管理员用户： $ python3 manage.py createsuperuser \u0026gt; Username (leave blank to use \u0026#39;acs\u0026#39;): admin \u0026gt; Email address: \u0026gt; Password: 123456 \u0026gt; Password (again): 123456 \u0026gt; Superuser created successfully. 然后利用该 管理员用户 登录 admin 页面，即可成功登陆\n创建用户登录页面 game 下的各个文件作用 templates目录：管理 html 文件 urls目录：管理路由，即链接与函数的对应关系 (接收链接，调用相对应的函数) views目录：管理 http 函数（接收浏览器请求，返回字符串至浏览器） models目录：管理数据库数据 static目录：管理静态文件 consumers目录：管理websocket函数 实现一个路由重定向 url 输入网址 -\u0026gt; acapp.urls -\u0026gt; game.urls -\u0026gt; game.views.index -\u0026gt; 展示页面 game.views\n这其中，HttpResponse()内部使用html的语法，返回的响应就直接用这个字符串作为页面，转换成html\nfrom django.http import HttpResponse def index(request): line1 = \u0026#39;\u0026lt;h1 style=\u0026#34;text-align: center\u0026#34;\u0026gt; 第一个网页 \u0026lt;/h1\u0026gt;\u0026#39; return HttpResponse(line1) game.urls\n这其中，path('PATH', function, name)的含义是，在用户访问网站的时候，如果是网站/game/PATH，就会调用function，名字为name，这是在/game/目录下的调用，所以这个PATH是在/game/的基础上的相对路径，所以他的绝对路径是网站/game/PATH\nfrom django.urls import path from game.views import index urlpatterns = [ path(\u0026#34;\u0026#34;, index, name=\u0026#34;index\u0026#34;), ] acapp.urls\n这其中，path('PATH', include('game.urls'))的含义是：在用户访问网站的时候，如果是网站/PATH，就会走到/game/urls，并根据/game/urls.py来跑路由，就是说，用户在访问网站/的时候，由于此时调用的函数是include('game.urls')，所以访问网站/相当于根据game/urls访问\nfrom django.contrib import admin from django.urls import path, include urlpatterns = [ path(\u0026#39;\u0026#39;, include(\u0026#39;game.urls\u0026#39;)), path(\u0026#39;admin/\u0026#39;, admin.site.urls), ] 然后直接打开 ip:socket 可以直接显示 index 返回的网页\n创建菜单界面 3. 创建菜单界面 | 讲义 3.1 上课笔记 | 大家好今天是 3.1 上课笔记 | 栎 构建项目框架 项目系统设计 menu：菜单页面 playground：游戏界面 settings：设置界面 项目文件结构 . |-- README.md |-- acapp | |-- __init__.py # 文件夹在加上 __init__.py 文件后，python 便可以通过 import 来引用该文件夹 | |-- asgi.py | |-- settings.py | |-- urls.py | `-- wsgi.py |-- db.sqlite3 |-- game | |-- __init__.py | |-- admin.py | |-- apps.py | |-- migrations | | `-- __init__.py | |-- models | | `-- __init__.py | |-- static | | |-- css | | | `-- game.css # 一般一个工程，只有一个 css 文件就足够了 | | |-- image | | | `-- menu | | | `-- background.gif | | `-- js | | |-- dist | | | `-- game.js | | `-- src | | `-- zbase.js # 总的 js 文件，命名以 z 开头会自动在字典序最后 | |-- templates | | `-- multiends | | `-- web.html | |-- tests.py | |-- urls | | |-- __init__.py | | |-- index.py | | |-- menu | | | |-- __init__.py | | | `-- index.py | | |-- playground | | | |-- __init__.py | | | `-- index.py | | `-- settings | | |-- __init__.py | | `-- index.py | `-- views | |-- __init__.py | |-- index.py | |-- menu | | `-- __init__.py | |-- playground | | `-- __init__.py | `-- settings | `-- __init__.py |-- manage.py `-- scripts `-- compress_game_js.sh js 文件管理 一般一个工程会有很多个 .js 源文件，为了加快网络的传输，也为了每次写新的 .js 文件不用每个 html 都额外引入一次\n考虑用一个 src 源文件夹来存储所有的 .js 源文件\n然后用 dist 文件夹来存放由 src 下所有源文件整合生成的一个目标 .js 文件\n这样既实现了快速传输的好处，也方便了后续编写 html 文件时，引入 .js 的便利\n创建一个脚本实现上述 整合 的功能 ~/acapp/scripts/compress_game_js.sh\n#! /bin/bash JS_PATH=/home/acs/acapp/game/static/js/ JS_PATH_DIST=${JS_PATH}dist/ JS_PATH_SRC=${JS_PATH}src/ find $JS_PATH_SRC -type f -name \u0026#39;*.js\u0026#39; | sort | xargs cat \u0026gt; ${JS_PATH_DIST}game.js html 文件管理 在 templates 文件夹下创建 menu、playground、settings、multiends 四个文件夹，用于存储三个模块和终端的 html 文件\n在 multiends 下创建 web.html 文件\n{% load static %} \u0026lt;!-- Django 中引入全局setting里的变量 static 的语法--\u0026gt; \u0026lt;head\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.acwing.com/static/jquery-ui-dist/jquery-ui.min.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.acwing.com/static/jquery/js/jquery-3.3.1.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- 上述两句引入 jQuery 库 --\u0026gt; \u0026lt;!-- 使用引入的变量 static 的语法如下 --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;{% static \u0026#39;css/game.css\u0026#39; %}\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;{% static \u0026#39;js/dist/game.js\u0026#39; %}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- 分别引入 css 文件和总的 js 文件 --\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body style=\u0026#34;margin: 0\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;ac_game_12345678\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; $(document).ready(function(){ let ac_game = new AcGame(\u0026#34;ac_game_12345678\u0026#34;) }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; views 视图管理 在 views 文件夹下新建三个模块的视图文件夹\n写一个 index.py 文件，目的是在 web 端被访问时，返回上面写的 web.html 文件\nfrom django.shortcuts import render def index(request): return render(request, \u0026#34;multiends/web.html\u0026#34;) urls 路由管理 /-- \u0026#34;\u0026#34; -- index / -- \u0026#34;menu/\u0026#34; -- menu.index / \u0026#34;\u0026#34; --\u0026gt; \u0026#34;game.url\u0026#34; --\u0026gt; / \\ -- \u0026#34;playground/\u0026#34; -- playground.index id:scoket -\u0026gt; \\-- \u0026#34;settings/\u0026#34; -- settings.index \\ \\ \u0026#34;/admin\u0026#34; -- 到达管理员页面 ~/acapp/acapp/urls.py\nfrom django.contrib import admin from django.urls import path, include urlpatterns = [ path(\u0026#39;\u0026#39;, include(\u0026#39;game.urls.index\u0026#39;)), path(\u0026#39;admin/\u0026#39;, admin.site.urls), ] ~/acapp/game/urls/index.py\nfrom django.urls import path, include from game.views.index import index urlpatterns = [ path(\u0026#34;\u0026#34;, index, name=\u0026#34;index\u0026#34;), path(\u0026#34;menu/\u0026#34;, include(\u0026#34;game.urls.menu.index\u0026#34;)), path(\u0026#34;playground/\u0026#34;, include(\u0026#34;game.urls.playground.index\u0026#34;)), path(\u0026#34;settings/\u0026#34;, include(\u0026#34;game.urls.settings.index\u0026#34;)) ] 网页渲染流程 根据用户的链接，首先进入acapp/urls.py，根据path再进入game/urls/index.py，再根据path进入下一层url或调用相对应的views中的index.py函数，函数接收参数，在网页端渲染templates/multiends下的web.html，html中有JS执行\n注意：本项目为前后端分离，即通过JS在client中渲染项目(动态生成页面)，而不是在server渲染项目\n修改全局配置 设置时区 修改项目的 UTC 时间为 CN 时间\n$ vim /acapp/settings.py ****** TIME_ZONE = \u0026#39;Asia/Shanghai\u0026#39; # 原来默认是 UTC ****** 添加配置文件 将新创建的 game 下的 apps.py 中的 GameConfig 加到 settings.py 下\n$ vim /acapp/settings.py ****** INSTALLED_APPS = [ \u0026#39;game.apps.GameConfig\u0026#39;, ...... ] ****** 声明将静态文件路径 STATIC_ROOT 和 MEDIA_ROOT\n$ vim /acapp/settings.py ****** import os ...... STATIC_ROOT = os.path.join(BASE_DIR, \u0026#39;static\u0026#39;) STATIC_URL = \u0026#39;/static/\u0026#39; MEDIA_ROOT = os.path.join(BASE_DIR, \u0026#39;media\u0026#39;) MEDIA_URL = \u0026#39;/media/\u0026#39; ****** 创建菜单 menu 界面 搭建菜单 menu 界面的框架 我们采用的 前后端分离式 开发，所有的 html 渲染都要求在前端完成\n开发流程就是，先在 html 里创建好一个有 id 的 div\n然后利用 js 文件，捕获到该 div，并进行 渲染\n/templates/multiends/web.html\n... \u0026lt;div id=\u0026#34;ac_game_12345678\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; $(document).ready(function(){ let ac_game = new AcGame(\u0026#34;ac_game_12345678\u0026#34;) }) \u0026lt;/script\u0026gt; ... js/src/zbase.js\nclass AcGame { constructor(id) { this.id = id; this.$ac_game = $(\u0026#39;#\u0026#39; + id); this.menu = new AcGameMenu(this); } } js/src/menu/zbase.js\nclass AcGameMenu { constructor(root) { this.root = root; this.$menu = $(` \u0026lt;div class=\u0026#34;ac-game-menu\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; `); this.root.$ac_game.append(this.$menu); } css/game.css\n.ac-game-menu { width: 100%; height: 100%; background-image: url(\u0026#39;/static/image/menu/background.gif\u0026#39;); background-size: 100% 100%; user-select: none; } 这里的 代码逻辑 如下：\nhtml 页面执行到 js 代码，利用 AcGame类 创建对象 ac_game 同时传递参数 div 的 id AcGame 开始执行构造函数，在构造函数中，捕获 html 标签，并利用 AcGameMenu类 创建对象 menu，并将整个对象作为参数下传 AcGameMenu 开始执行构造函数，然后创建 html 代码，加到捕获到的 html 代码下 最终成功渲染出背景图片 设置菜单 menu 页面的内容 主要内容就是在主页面中，显示：单人模式、多人模式、设置，三个按钮的选项 js/src/menu/zbase.js\nclass AcGameMenu { constructor(root) { this.root = root; this.$menu = $(` \u0026lt;div class=\u0026#34;ac-game-menu\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;ac-game-menu-field\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;ac-game-menu-field-item ac-game-menu-field-item-single-mode\u0026#34;\u0026gt; 单人模式 \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;ac-game-menu-field-item ac-game-menu-field-item-multi-mode\u0026#34;\u0026gt; 多人模式 \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;ac-game-menu-field-item ac-game-menu-field-item-settings-mode\u0026#34;\u0026gt; 设置 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; `); this.root.$ac_game.append(this.$menu); this.$single_mode = this.$menu.find(\u0026#39;.ac-game-menu-field-item-single-mode\u0026#39;); this.$multi_mode = this.$menu.find(\u0026#39;.ac-game-menu-field-item-multi-mode\u0026#39;); this.$settings_mode = this.$menu.find(\u0026#39;.ac-game-menu-field-item-settings-mode\u0026#39;); } } css/game.css\n.ac-game-menu { width: 100%; height: 100%; background-image: url(\u0026#39;/static/image/menu/background.gif\u0026#39;); background-size: 100% 100%; user-select: none; } .ac-game-menu-field { width: 20vw; position: relative; top: 40vh; left: 19vh; } .ac-game-menu-field-item { height: 7vh; width: 18vw; color: white; font-size: 6vh; font-style: italic; padding: 2vh; margin: 1vh 0; cursor: pointer; text-align: center; background-color: rgba(39, 21, 28, 0.6); border-radius: 10px; letter-spacing: 0.5vw; } .ac-game-menu-field-item:hover { transform: scale(1.2); transition: 100ms; } 添加 \u0026lsquo;单人模式\u0026rsquo; 监听函数 —— 打开游戏界面 功能 这里要实现的 逻辑：\n点击 \u0026lsquo;单人模式\u0026rsquo; 按钮触发 click 事件，随即触发监听函数，开始执行 关闭 menu 页面 打开 playground 页面 因此，我们先简易的实现一个 playground 页面，方便调试该功能 js/src/playground/zbase.js\nclass AcGamePlayground { constructor(root) { this.root = root; this.$playground = $(`\u0026lt;div\u0026gt;游戏界面\u0026lt;/div\u0026gt;`); this.hide(); this.root.$ac_game.append(this.$playground); this.start(); } start() { } show() { //打开 playground 界面 this.$playground.show(); } hide() { //关闭 playground 界面 this.$playground.hide(); } } 在实现监听函数功能之前，先在 /src/zbase.js 即主 js 文件下，利用 AcGamePlayground 类创建好 playground 对象\n这样我们就能在前端，渲染出两个界面了，分别是：menu 和 playground\njs/src/zbase.js\nclass AcGame { constructor(id) { this.id = id; this.$ac_game = $(\u0026#39;#\u0026#39; + id); this.menu = new AcGameMenu(this); // 把 playground 对象也建好，这样我们就同时有两个界面了 this.playground = new AcGamePlayground(this); this.start(); } start() { } } 然后，我们开始实现 ac-game-menu-field-item-single-mode 标签的 click 事件的监听函数\n其功能之前讲过了，就是关闭 menu 页面，打开 playground 页面\njs/src/menu/zbase.js\nclass AcGameMenu { constructor(root) { this.root = root; this.$menu = $(` \u0026lt;div class=\u0026#34;ac-game-menu\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;ac-game-menu-field\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;ac-game-menu-field-item ac-game-menu-field-item-single-mode\u0026#34;\u0026gt; 单人模式 \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;ac-game-menu-field-item ac-game-menu-field-item-multi-mode\u0026#34;\u0026gt; 多人模式 \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;ac-game-menu-field-item ac-game-menu-field-item-settings-mode\u0026#34;\u0026gt; 设置 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; `); this.root.$ac_game.append(this.$menu); this.$single_mode = this.$menu.find(\u0026#39;.ac-game-menu-field-item-single-mode\u0026#39;); this.$multi_mode = this.$menu.find(\u0026#39;.ac-game-menu-field-item-multi-mode\u0026#39;); this.$settings_mode = this.$menu.find(\u0026#39;.ac-game-menu-field-item-settings-mode\u0026#39;); this.start(); } start() { this.add_listening_events(); } add_listening_events() { let outer = this; this.$single_mode.click(function(){ outer.hide(); // 关闭主页面 outer.root.playground.show(); // 打开游戏界面 }); } show() { //显示menu界面 this.$menu.show(); } hide() { //隐藏menu界面 this.$menu.hide(); } } 创建游戏界面 4.1 上课笔记 | Andrew1729 若修改static文件夹下的相关文件，需在~/acapp下执行./scripts/compress_game_js.sh来打包文件\n前端的模块化引入 由于在 html 代码部分，是将整个 game.js 文件引入\n这样会导致在 game.js 中定义的变量，会变成整个网页的 全局变量（之后可能会引起变量重名的诸多问题）\n因此，我们考虑使用 模块化引入 的功能，让网页只引入在 html 中需要的部分\n修改 web.html\n\u0026lt;!-- 首先，先删掉上面整个引入 game.js 的部分 --\u0026gt; \u0026lt;!-- 然后，下方创建对象的部分，先使用模块化引入 --\u0026gt; ...... \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import {AcGame} from \u0026#34;{% static \u0026#39;js/dist/game.js\u0026#39; %}\u0026#34; $(document).ready(function(){ let ac_game = new AcGame(\u0026#34;ac_game_12345678\u0026#34;) }) \u0026lt;/script\u0026gt; ...... 此外，还有修改引入的类，在前面加上 export，如下修改 js/src/zbase.js\nexport class AcGame { ...... } 这样，在全局中，只会出现引入的模块，其他的 .js 代码不会出现在全局中\n构建游戏界面框架 static/js/src/playground/zbase.js\n...... this.$playground = $(`\u0026lt;div class=\u0026#34;ac-game-playground\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;`); ...... game.css\n...... .ac-game-playground { height: 100%; width: 100%; user-select: none; // 禁用右键弹菜单 } 实现游戏引擎框架 游戏中，物体在移动，其实现原理是：每一个动作都会渲染多张图片出来，然后图片快速的切换，从而实现动的过程\n因此，需要先实现一个游戏引擎的基类 AcGameObject ，使得每帧能渲染一张图片出来\n该基类需要具备的功能有：\nstart() 在游戏开始的第一帧时需要执行的任务（一般是创建对象） update() 在游戏开始后的每一帧均会执行的任务（一般是渲染当前对象的各种状态） on_destroy() 删掉该物体前需要执行的任务（一般是删掉动画，或者给对手加分） destroy() 删掉该物体 根据上述逻辑，我们就可以基本搭建出来一个游戏引擎的基类了，具体如下： /static/js/playground/ac_game_object/zbase.js\nlet AC_GAME_OBJECTS = []; // 用于记录当前画布中，需要渲染的对象有哪些 class AcGameObject { constructor() { AC_GAME_OBJECTS.push(this); // 将当前新建的对象，加入到全局的画布中去，参与渲染 this.has_called_start = false; // 是否执行过 start 函数 this.timedelta = 0; // 当前帧距离上一帧的时间间隔 // 该数据记录是为了后续计算速度等参数的 } start() { // 只会在第一帧执行一次 } update() { // 每一帧均会执行一次 } on_destroy() { // 在被销毁前执行一次 } destroy() { // 删掉该物体 this.on_destroy(); //删掉该物体前，执行删前的操作 // 在全局渲染物体中，找到该物体，并将其删掉 for (let i = 0; i \u0026lt; AC_GAME_OBJECTS.length; i ++ ) { if (AC_GAME_OBJECTS[i] === this) { // 三等号，在js里额外加了一层类型相等约束 AC_GAME_OBJECTS.splice(i, 1); break; } } } } let last_timestamp; let AC_GAME_ANIMATION = function(timestamp) { // 回调函数，实现：每一帧重绘时，都会执行一遍 for (let i = 0; i \u0026lt; AC_GAME_OBJECTS.length; i ++ ) { let obj = AC_GAME_OBJECTS[i]; if (!obj.has_called_start) { // 如果还未执行初始帧动作，就先执行 obj.start(); obj.has_called_start = true; } else { // 执行过初始帧，就执行每一帧的任务 obj.timedelta = timestamp - last_timestamp; obj.update(); } } last_timestamp = timestamp; // 更新最后一次时间戳 requestAnimationFrame(AC_GAME_ANIMATION); } requestAnimationFrame(AC_GAME_ANIMATION); // JS的API，可以调用1帧里面的函数。(有些浏览器的一秒帧数不一定相等) 接下来所有的一切游戏，都是基于这个引擎的基类完成的\n实现游戏地图功能 目标：实现一个每一秒都在渲染的纯黑背景\n虽然现阶段要实现的地图较为简单，但为了后期的拓展性，故还是考虑新建一个文件夹来完成\n然后在 js 中，已经封装好了一个 canvas 的 api 来帮助实现背景画布，直接调用即可\n先铺开画布，然后设置为黑色\nstatic/js/playground/zbase.js\nclass AcGamePlayground { constructor(root) { ...... // $(\u0026#39;.playground\u0026#39;)对象已经在 css 文件里渲染出高宽了 // 现在把他的高宽存下来，往下传递 this.width = this.$playground.width(); this.height = this.$playground.height(); this.game_map = new GameMap(this); ...... } ..... } static/js/playground/game-map/zbase.js\nclass GameMap extends AcGameObject { // 继承自游戏引擎基类 constructor(playground) { super(); // 自函数功能：调用基类的构造函数 this.playground = playground; this.$canvas = $(`\u0026lt;canvas\u0026gt;\u0026lt;/canvas\u0026gt;`); // 创建一个canvas的jQuery对象，就是我们要实现的画布 this.ctx = this.$canvas[0].getContext(\u0026#39;2d\u0026#39;); // jQuery对象是一个数组，第一个索引是html对象 // 设置画布的宽高 this.ctx.canvas.width = this.playground.width; this.ctx.canvas.height = this.playground.height; this.playground.$playground.append(this.$canvas); } start() { } update() { // 游戏地图每帧都要渲染 this.render(); } render() { this.ctx.fillStyle = \u0026#34;rgba(0, 0, 0, 0.2)\u0026#34;; this.ctx.fillRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height); } } 实现玩家显示功能 毛坯版玩家显示，每个玩家定义成一个圆，然后渲染在前端\n需要对于玩家类定义多个参数，以方便日后拓展：\nx 当前位置的横坐标 y 当前位置的纵坐标 radius 当前的半径 speed 当前的速度 is_me 该对象是否是当前玩家操控的对象（一是区别于 bot，二是区别于 日后联机的其他玩家） static/js/playground/zbase.js\nclass AcGamePlayground { constructor(root) { ...... this.players = []; // 存放当前游戏中的所有玩家 // 将玩家加入游戏中 this.players.push(new Player(this, this.width / 2, this.height / 2, this.height * 0.05, \u0026#34;white\u0026#34;, this.height * 0.15, true)); ...... } ..... } static/js/playground/player/zbase.js\nclass Player extends AcGameObject { constructor(playground, x, y, radius, color, speed, is_me) { super(); // 把信息都存下来 this.playground = playground; this.ctx = this.playground.game_map.ctx; this.x = x; this.y = y; this.color = color; this.speed = speed; this.radius = radius; this.is_me = is_me; // 用于浮点数运算 this.eps = 0.1; } start() { } update() { this.render(); } render() { // 渲染一个圆 this.ctx.beginPath(); this.ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI, false); this.ctx.fillStyle = this.color; this.ctx.fill(); } on_destroy() { } } 实现玩家移动功能 移动的实现逻辑很简单，就是让每帧渲染的圆的位置发生移动即可\n上述简单逻辑的实现如下：\nclass Player extends AcGameObject { constructor(....) { ... this.vx = 1; this.vy = 1; ... } ... update() { this.x += x; this.y += y; this.render(); } } 然后我们来实现一个向鼠标点击位置移动的功能\n这就需要设置一个 click 事件的监听函数，分别传递：\n鼠标点击事件 鼠标点击位置的横坐标 鼠标点击位置的纵坐标 然后开始让圆的位置逐步向鼠标点击位置进行移动\nstart() { if (this.is_me) { // 对于用户玩家，加上监听函数 this.add_listening_events(); } } add_listening_events() { let outer = this; // 把鼠标右键调出菜单栏的功能关掉 this.playground.game_map.$canvas.on(\u0026#34;contextmenu\u0026#34;, function() { return false; }); // 把右键控制移动功能加上 this.playground.game_map.$canvas.mousedown(function(e) { // 左键:1 中键:2 右键:3 if (e.which === 3) { outer.move_to(e.clientX, e.clientY); } }); } 然后，我们来实现移动功能的函数 move_to(tx, ty)\nconstructor(...){ ... this.vx = 0; // x方向上的移动速度 this.vy = 0; // y方向上的移动速度 this.move_length = 0; // 剩余移动距离 ... } ... get_dist (x1, y1, x2, y2) { // 求两点的欧几里得距离 let dx = x2 - x1; let dy = y2 - y1; return Math.sqrt(dx * dx + dy * dy); } move_to(tx, ty) { // 计算移动距离 this.move_length = this.get_dist(this.x, this.y, tx, ty); // 计算移动角度，api接口：atan2(dy, dx) let angle = Math.atan2(ty - this.y, tx - this.x); // 位移 1 个单位长度（向着矢量方向移动到单位圆上） this.vx = Math.cos(angle); // 极直互化 this.vy = Math.sin(angle); } update() { // 浮点数精度运算 if (this.move_length \u0026lt; this.eps) { this.move_length = 0; this.vx = this.vy = 0; } else { // 计算单位帧里的移动距离 let moved = Math.min(this.move_length, this.speed * this.timedelta / 1000); this.x += this.vx * moved; this.y += this.vy * moved; // 还要减掉移动的距离 this.move_length -= moved; } this.render(); } ... 这样就实现了玩家的移动功能了，可以登录 id:socket 调试该功能\n实现火球技能的功能 火球对象的建立与玩家基本一致，直接照搬，在从细节上改改即可\njs/src/playground/skill/fireball/zbase.js\nclass FireBall extends AcGameObject { constructor(playground, player, x, y, radius, vx, vy, color, speed, move_length, damage) { super(); this.playground = playground; this.ctx = this.playground.game_map.ctx; this.player = player; this.x = x; this.y = y; this.vx = vx; this.vy = vy; this.radius = radius; this.color = color; this.speed = speed; this.move_length = move.length; this.damage = damage; this.eps = 0.1; } start() { } update() { if (this.move_length \u0026lt; this.eps) { this.destroy(); return false; } else { let moved = Math.min(this.move_length, this.speed * this.timedelta / 1000); this.x += this.vx * moved; this.y += this.vy * moved; this.move_length -= moved; } this.render(); } render() { this.ctx.beginPath(); this.ctx.arc(this.x, this.y, this.radius, 0, 2 * Math * Pi, false); this.ctx.fillStyle = this.color; this.ctx.fill(); } } 然后在玩家身上实现发火球的功能\n基本实现逻辑：当前选中了火球技能，鼠标左键点击一处，向该处发射一个火球\n因此，为了知道用户是否选择了技能，需要加一个键盘触发事件监听函数，然后加一个鼠标左键触发事件监听函数\n然后发射一个火球即可\njs/src/playground/player/zbase.js\nconstructor(...) { ... this.cur_skill = null; // 记录当前选择的技能 ... } add_listening_events() { ... this.playground.game_map.$canvas.mousedown(function(e) { // 左键:1 中键:2 右键:3 if (e.which === 3) { outer.move_to(e.clientX, e.clientY); } else if (e.which === 1) { // 鼠标左键事件 if (outer.cur_skill === \u0026#34;fireball\u0026#34;) { // 当前已经选中火球技能 outer.shoot_fireball(e.clientX, e.clientY); } } outer.cur_skill = null; // 清空当前技能 }); $(window).keydown(function(e) { if (e.which === 81) { // 键盘按下事件 outer.cur_skill = \u0026#34;fireball\u0026#34;; return false; } }); } shoot_fireball(tx, ty) { // 确定火球的参数 let x = this.x, y = this.y; // 火球发射点就是当前玩家的位置 let radius = this.playground.height * 0.01; let angle = Math.atan2(ty - this.y, tx - this.x); let vx = Math.cos(angle), vy = Math.sin(angle); let color = \u0026#34;orange\u0026#34;; let speed = this.playground.height * 0.5; let move_length = this.playground.height * 1.0; let damage = this.playground.height * 0.01; new FireBall(this.playground, this, x, y, radius, vx, vy, color, speed, move_length, damage); } 这样就成功实现了玩家发射火球的功能了\n实现单人模式下的人机功能 先创建好 5 个人机 playground/zbase.js\n... //创建好 5 个人机 for (len i = 0; i \u0026lt; 5; i ++ ) { this.players.push(new Player(this, this.width / 2, this.height / 2, this.height * 0.05, \u0026#34;blue\u0026#34;, this.height * 0.15, false)); } ... 这样创建出来的 5 个人机是不会行动的\n我们写一个简易的 AI 程序，让他们也会移动\n这里实现的逻辑是：每次随机一个目的地，向目的地移动，然后再随机一个目的地，循环下去\n根据该逻辑，修改两个函数即可\nplayground/player/zbase.js\n... start() { if (this.is_me) { // 对于用户玩家，加上监听函数 this.add_listening_events(); } else { let tx = Math.random() * this.playground.width; let ty = Math.random() * this.playground.height; this.move_to(tx, ty); } } ... update() { if (this.move_length \u0026lt; this.eps) { this.move_length = 0; this.vx = this.vy = 0; if (!this.is_me) { // 如果是人机，停下来时再随机一个方向前进 let tx = Math.random() * this.playground.width; let ty = Math.random() * this.playground.height; this.move_to(tx, ty); } } ... } on_destroy() { for (let i = 0; i \u0026lt; this.playground.players.length; i ++ ) { if (this.playground.players[i] === this) { this.playground.players.splice(i, 1); } } } 实现技能命中效果（碰撞检测功能） 实现逻辑：检测两个圆的中心距离是否小于两个圆的半径之和\n小于等于时，代表发生碰撞，开始执行命中效果：\n被击中用户掉血 被击中用户收到向后击退效果 碰撞检测写在火球类里，击退效果写在玩家类里\nfireball/zbase.js\nupdate() { if (...) { ... } else { ... // 碰撞检测 for (let i = 0; i \u0026lt; this.playground.players.length; i ++ ) { let player = this.playground.players[i]; if (this.player !== player \u0026amp;\u0026amp; this.is_collision(player)) { // 碰撞发生一定是在非施法者身上 this.attack(player); // 火球命中，目标玩家执行击退效果 } } } this.render(); } get_dist(x1, y1, x2, y2) { // 获得两点的欧几里得距离 let dx = x2 - x1; let dy = y2 - y1; return Math.sqrt(dx * dx + dy * dy); } is_collision(player) { // 检测两个圆的中心距离是否小于两个圆的半径之和 let distance = this.get_dist(this.x, this.y, player.x, player.y); if (distance \u0026lt; (this.radius + player.radius)) return true; return false; } attack(player) { // 火球命中，目标玩家执行击退效果 let angle = Math.atan2(player.y - this.y, player.x - this.x); // 计算角度 player.is_attacked(angle, this.damage); // 火球命中，目标玩家执行击退效果 this.destroy(); // 火球命中后，自然消失 } 被击退的时候，原来的移动速度应该置为 0，当前的移动应该转为向被击中方向上的移动 player/zbase.js\nis_attacked(angle, damage) { this.radius -= damage; // 受伤，半径减少 if (this.radius \u0026lt; 10) { // 当半径小于10像素时，代表死亡 this.destroy(); return false; } // 开始执行击退效果 this.damage_vx = Math.cos(angle); this.damage_vy = Math.sin(angle); this.damage_speed = damage * 100; this.speed *= 0.5; // 被击中以后移动速度减半 } update() { if (this.damage_speed \u0026gt; this.eps) { // 当前仍处于击退效果中 this.vx = this.vy = 0; this.move_length = 0; this.x += this.damage_vx * this.damage_speed * this.timedelta / 1000; this.y += this.damage_vy * this.damage_speed * this.timedelta / 1000; this.damage_speed *= this.friction; // 击退速度乘以摩擦系数，已达到削减的目的 } else { ... } ... } 被击中以后的粒子效果特效 实现逻辑：被击中以后，在玩家附近随机生成一些粒子小球\n因此我们要先实现 粒子小球 对象\nstatic/js/src/playground/particle/zbase.js\nclass Particle extends AcGameObject { constructor(playground, x, y, radius, vx, vy, color, speed) { super(); this.playground = playground; this.ctx = this.playground.game_map.ctx; this.x = x; this.y = y; this.radius = radius; this.vx = vx; this.vy = vy; this.color = color; this.speed = speed; this.friction = 0.9; } start() { } update() { if (this.speed \u0026lt; this.eps) { this.destroy; return false; } this.x += this.vx * this.speed * this.timedelta / 1000; this.y += this.vy * this.speed * this.timedelta / 1000; this.speed *= this.friction; this.render(); } render() { this.ctx.beginPath(); this.ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI, false); this.ctx.fillStyle = this.color; this.ctx.fill(); } } 然后我们在被击退功能模块，实现生成粒子小球的效果\n粒子小球释放弧度为 $[0,2π)$ 的随机数 粒子小球的 x, y 分量比率根据弧度来设定 粒子小球的起始坐标应与玩家的坐标相同 粒子小球的颜色与玩家颜色相同 粒子小球的速度为玩家移动速度的 $10$ 倍 js/src/playground/player/zbase.js\nis_attacked(angle, damage) { // 粒子小球效果 for (let i = 0; i \u0026lt; 10 + Math.random() * 5; i ++ ) { let x = this.x, y = this.y; let radius = this.radius * Math.random() * 0.1; let angle = 2 * Math.PI * Math.random(); let vx = Math.cos(angle), vy = Math.sin(angle); let color = this.color; let speed = this.speed * 10; new Particle(this.playground, x, y, radius, vx, vy, color, speed); } ... } 一些小优化 人机随机颜色 js/src/playground/zbase.js\nconstructor(root) { ...... // 创建好 5 个人机 for (let i = 0; i \u0026lt; 5; i ++ ) { this.players.push(new Player(this, this.width / 2, this.height / 2, this.height * 0.05, this.get_random_color(), this.height * 0.15, false)); } ...... } get_random_color() { let colors = [\u0026#34;blue\u0026#34;, \u0026#34;red\u0026#34;, \u0026#34;pink\u0026#34;, \u0026#34;grey\u0026#34;, \u0026#34;green\u0026#34;]; return colors[Math.floor(Math.random() * 5)]; } 人机AI随机攻击操作 js/src/playground/player/zbase.js\nconstructor (...) { ... this.spent_time = 0; // 初始人机冷却攻击时间 } ... update() { this.spent_time += this.timedelta / 1000; if (!this.is_me \u0026amp;\u0026amp; this.spent_time \u0026gt; 4 \u0026amp;\u0026amp; Math.random() * 180 \u0026lt; 1) { let player = this.playground.players[Math.floor(Math.random() * this.playground.players.length)]; this.shoot_fireball(player.x, player.y); } 部署nginx与对接acappஐ 5. 部署nginx与对接acapp | 讲义 5.1 上课笔记 | Andrew1729 5.1. 上课笔记 | 菊花 Ngnix 介绍 nginx 和uwsgi的区别与作用 Nginx是什么？ Nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器\nNginx可以作为一个HTTP服务器进行网站的发布处理，另外Nginx可以作为反向代理进行负载均衡的实现\nNginx中HttpUwsgiModule的作用是与uWSGI服务器进行交换\nuWSGI是什么？ uWSGI是一个全功能的HTTP服务器，实现了WSGI、uwsgi、http等协议\n它要做的就是把HTTP协议转化成语言支持的网络协议。比如把HTTP协议转化成WSGI协议，让Python可以直接使用\nWSGI协议是Python 语言定义的 Web 服务器和 Web 应用程序或框架之间的一种简单而通用的接口\n简单来说uWSGI就是用来沟通nginx和django的一座桥梁\nNginx+uWSGI+Diango 工作流程 nginx 是对外的服务接口，外部浏览器通过url访问nginx\nnginx 接收到浏览器发送过来的http请求，将包进行解析\n分析url，如果是静态文件请求就直接访问用户给nginx配置的静态文件目录，直接返回用户请求的静态文件\n如果不是静态文件，而是一个动态的请求，那么nginx就将请求转发给uwsgi，uwsgi 接收到请求之后将包进行处理，处理成wsgi可以接受的格式，并发给wsgi，wsgi 根据请求调用应用程序的某个文件，某个文件的某个函数，最后处理完将返回值再次交给wsgi，wsgi将返回值进行打包，打包成uwsgi能够接收的格式，uwsgi接收wsgi 发送的请求，并转发给nginx, nginx最终将返回值返回给浏览器\nuwsgi服务的开启\u0026amp;\u0026amp;关闭 在~/acapp启动uwsgi服务：uwsgi --ini scripts/uwsgi.ini 关闭uwsgi服务：sudo pkill -f uwsgi -9 针对 acapp 的优化 打包脚本优化 由于现在 发布版本的脚本文件 用的是打包在根目录里的 static 文件夹\n每次修改好 static 文件夹后，不仅需要对 js 文件打包，还需要对 static 文件夹打包\n不放把 \u0026ldquo;将static文件夹打包\u0026rdquo; 的 shell 代码一起加入 js 打包脚本中，从而实现一键打包\nscripts/compress_game_js.sh\n#! /bin/bash JS_PATH=/home/acs/acapp/game/static/js/ JS_PATH_DIST=${JS_PATH}dist/ JS_PATH_SRC=${JS_PATH}src/ find $JS_PATH_SRC -type f -name \u0026#39;*.js\u0026#39; | sort | xargs cat \u0026gt; ${JS_PATH_DIST}game.js echo \u0026#34;yes\u0026#34; | python3 manage.py collectstatic 鼠标点击事件的相对偏移 由于写游戏界面的时候，玩家移动是按照鼠标相对于当前整个浏览器取的位置参数 e.clientX\n而 acapp 里，每个应用是一个小窗口，鼠标点击位置的参数应当是 相对于整个游戏窗口的位置参数\n所有会导致出现，点击的位置与移动的位置不同，这里需要做出小优化\n优化的逻辑 :\n$clientX−窗口左侧到浏览器左侧的距离=玩家的目标X$ $clientY−窗口上侧到浏览器上侧的距离=玩家的目标Y$ 这就要用到一个 js 的 API 了 : getBoundingClientRect() rectObject = object.getBoundingClientRect(); rectObject.top : 元素上边到视窗上边的距离; rectObject.right : 元素右边到视窗左边的距离; rectObject.bottom : 元素下边到视窗上边的距离; rectObject.left : 元素左边到视窗左边的距离; rectObject.width : 是元素自身的宽 rectObject.height : 是元素自身的高 player/zbase.js\n... add_listening_events() { ... this.playground.game_map.$canvas.mousedown(function(e) { // 创建 rect 对象 const rect = outer.ctx.canvas.getBoundingClientRect(); if (e.which === 3) { // 调整偏移量 outer.move_to(e.clientX - rect.left, e.clientY - rect.top); } else if (e.which === 1) { if (outer.cur_skill === \u0026#34;fireball\u0026#34;) { // 调整偏移量 outer.shoot_fireball(e.clientX - rect.left, e.clientY - rect.top); } } ... }); ... } ... 将菜单界面重新设为主界面 js/zbase.js 的注释取消，使之创建出 menu 对象\njs/playground/zbase.js 的注释取消，并设置逻辑，让 playground 打开后，才进行游戏界面初始化\nclass AcGamePlayground { constructor(root) { this.root = root; this.$playground = $(`\u0026lt;div class=\u0026#34;ac-game-playground\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;`); this.hide(); // 初始时隐藏 // 游戏界面生成代码在下面展示 playground 时执行 this.start(); } ... show() { // 打开 playground 界面 this.$playground.show(); // 开始生成游戏界面 this.root.$ac_game.append(this.$playground); this.width = this.$playground.width(); this.height = this.$playground.height(); this.game_map = new GameMap(this); this.players = []; // 存放当前游戏中的所有玩家 // 将玩家加入游戏中 this.players.push(new Player(this, this.width / 2, this.height / 2, this.height * 0.05, \u0026#34;white\u0026#34;, this.height * 0.15, true)); // 创建好 5 个人机 for (let i = 0; i \u0026lt; 5; i ++ ) { this.players.push(new Player(this, this.width / 2, this.height / 2, this.height * 0.05, this.get_random_color(), this.height * 0.15, false)); } } ... } 调整 css 文件，适应窗口 在设置 web 网页的时候，有些设置了绝对值，可能对于窗口化的 acapp 显示效果差\n将他们修改成相对数值\ngame.css\n... .ac-game-menu-field { ... top: 40%; left: 20%; } .ac-game-menu-field-item { height: 6vh; ... font-size: 4vh; ... } ... 创建账号系统 6. 创建账号系统 | 讲义\n用户名密码登录 6.1 用户名密码登录 | 讲义 6.1 上课笔记 | Andrew1729 6.1 上课笔记 | 吃饱喝足不学习 客户端请求与Django响应流程 用户在客户端通过$.ajax发送请求，根据urls路由到对应的views中的函数，处理request后返回JsonResponse 至客户端\n前期准备工作 做开发，先开启调试模式，如果不开启，服务器一旦运行错误，就只返回 Error 报错 settings.py\n... DEBUG = True ... 不过 django 自带的 User 表并不能满足我们的需求，因此我们需要自己额外建表\n创建用户表 所有的数据表都存在 models 里\n我们在 models 里创建一个 player 文件夹，用于存储所有的 player 相关的表\n然后对文件夹初始化 __init__.py，接着扩充成一个我们需要的数据表\ngame/models/player/player.py\nfrom django.db import models from django.contrib.auth.models import User class Player(models.Model): # Player 类继承自 Model 类 user = models.OneToOneField(User, on_delete=models.CASCADE) # 说明Player是从User表扩充过来的，每一个player都与一个user是一一对应关联关系 # 后一个参数是指，当user被删除后，对应的player也要被删除 # （感觉就是外键的意思） photo = models.URLField(max_length=256, blank=True) # 用于存储用户的头像的url # 指定每个player数据展示在前台的数据 def __str__(self): return str(self.user) # 展示用户的用户名 将定义的表，注册到后台 admin 页面中\ngame/admin.py\n... from game.models.player.player import Player admin.site.register(Player) 然后将创建的数据表更新到 django 的数据库中去\n$ python3 manage.py makemigrations \u0026gt; Migrations for \u0026#39;game\u0026#39;: \u0026gt; game/migrations/0001_initial.py \u0026gt; - Create model Player $ $ python3 manage.py migrate \u0026gt; Operations to perform: \u0026gt; Apply all migrations: admin, auth, contenttypes, game, sessions \u0026gt; Running migrations: \u0026gt; Applying game.0001_initial... OK 然后重启一下服务，就可以在管理员页面看到新建的数据库了\n实现客户端的类型判别（ACAPP or WEB） 由于我们实现的项目是前后端分离类型，因此对于不同的客户端，前端要控制生成不同的页面\n为了增强扩展性，故这里要实现客户端类型的判别\ny总 已经提前写好了 ACAPP 的接口，如果用户用的是 ACAPP 访问，则在新建对象 ac_game 时，会额外传递一个参数\n我们只需按照这个接口去完成扩充即可\n之后写小程序之类的同理，额外传一个接口\njs/zbase.js\nexport class AcGame { constructor(id, AcWingOS) { this.id = id; this.$ac_game = $(\u0026#39;#\u0026#39; + id); this.AcWingOS = AcWingOS; //如果是acapp端，该变量就会带着一系列y总提供的接口 this.menu = new AcGameMenu(this); this.playground = new AcGamePlayground(this); this.start(); } start() { } } 构建登录功能框架 基本逻辑 : 用户访问页面 -\u0026gt; 进入登录页面 -\u0026gt; 提交登录信息 -\u0026gt; 核对登录信息 -\u0026gt; 返回登陆结果和其他信息\n每实现一个函数，就需要实现三个部分：\nviews : 实现具体的调用数据库的逻辑 urls : 实现一个路由 js : 前端实现GET上述接口的过程 欲实现流程 :\n用户访问网站，通过先前完成的路由，访问到 web.html web.html 中的 js 部分创建了一个 AcGame 对象 AcGame 对象创建的过程中，生成了 Settings 对象 Settings 对象创建完成后，调用 Settings.start() 函数 Settings.start() 函数调用了 Settings.getinfo() 函数 Settings.getinfo() 函数中执行了 ajax 向 getinfo 接口发起一个含参数 platform 的 GET 请求 通过 urls 路由的实现，最终定位到 views/settings/getinfo.py 文件的 getinfo(request) 函数 根据传递过来的 platform 函数，实现不同的 JsonResponse 返回 Settings.getinfo() 接受到了 response 完成上述基本逻辑 views views/settings/getinfo.py\nfrom django.http import JsonResponse from game.models.player.player import Player def getinfo_acapp(request): player = Player.objects.all()[0] # 取出数据库中第一个用户(调试该功能) return JsonResponse({ \u0026#39;result\u0026#39;: \u0026#34;success\u0026#34;, \u0026#39;username\u0026#39;: player.user.username, \u0026#39;photo\u0026#39;: player.photo, }) def getinfo_web(request): player = Player.objects.all()[0] # 取出数据库中第一个用户(调试该功能) return JsonResponse({ \u0026#39;result\u0026#39;: \u0026#34;success\u0026#34;, \u0026#39;username\u0026#39;: player.user.username, \u0026#39;photo\u0026#39;: player.photo, }) def getinfo(request): # 处理请求 platform = request.GET.get(\u0026#39;platform\u0026#39;) # 根据请求的平台不同，进行不同返回处理 if platform == \u0026#34;ACAPP\u0026#34;: return getinfo_acapp(request) elif platform == \u0026#34;WEB\u0026#34;: return getinfo_web(request) urls urls/settings/index.py\nfrom django.urls import path from game.views.settings.getinfo import getinfo urlpatterns = [ path(\u0026#34;getinfo/\u0026#34;, getinfo, name=\u0026#34;settings_getinfo\u0026#34;), ] 路由建立好以后，访问 xxxx/settings/getinfo，可以看到 getinfo.py 返回的 JSON 类型的 JSONResponse\njs 网页刚访问时，应先将 menu 关闭，然后打开登录界面，随意先修改一个让 menu 初始关闭\nstatic/js/src/menu/zbase.js\nclass AcGameMenu { constructor(root) { ... this.$menu.hide(); ... } ... static/js/src/settings/zbase.js\nclass Settings { constructor(root) { this.root = root; this.platform = \u0026#34;WEB\u0026#34;; if (this.root.AcWingOS) this.platform = \u0026#34;ACAPP\u0026#34;; this.start(); } start() { this.getinfo(); } register() { // 打开注册界面 } login() { // 打开登录界面 } getinfo() { let outer = this; $.ajax({ url: \u0026#34;https://app1117.acapp.acwing.com.cn/settings/getinfo/\u0026#34;, type: \u0026#34;GET\u0026#34;, data: { platform: outer.platform, }, success: function(resp) { console.log(resp); if (resp.result === \u0026#34;success\u0026#34;) { // 登录成功，关闭登录界面，打开主菜单 outer.hide(); outer.root.menu.show(); } else { outer.login(); } } }); } hide() { } show() { } } 然后不要忘记在 根js 下创建对象\nexport class AcGame { constructor(id, AcWingOS) { ... this.settings = new Settings(this); ... } ... } 这样基本框架就完成了\n完善 HTTP 请求的函数 如果用户未登录，返回信息 \u0026ldquo;not login\u0026rdquo;\n如果用户登录，返回信息 \u0026ldquo;success\u0026rdquo; 以及用户名和头像\nviews/setting/getinfo.py\ndef getinfo_web(request): user = request.user if not user.is_authenticated: # 未登录 return JsonResponse({ \u0026#39;result\u0026#39;: \u0026#34;not login\u0026#34; }) else: # 已登录 player = Player.objects.get(user=user) return JsonResponse({ \u0026#39;result\u0026#39;: \u0026#34;success\u0026#34;, \u0026#39;username\u0026#39;: player.user.username, \u0026#39;photo\u0026#39;: player.photo, }) 注意前后台是一个登录系统，因此要先退掉后台，再测试\n将用户头像渲染到玩家上 将返回的 JsonResponse 存到 Settings 类的变量中 settings/zbase.js\nclass Settings { constructor(root) { ... this.username = \u0026#34;\u0026#34;; this.photo = \u0026#34;\u0026#34;; ... } ... getinfo() { let outer = this; $.ajax({ ... success: function(resp) { ... if (resp.result === \u0026#34;success\u0026#34;) { outer.username = resp.username; outer.photo = resp.photo; ... } .. } }); } } 然后在 Player 里把用户的头像渲染到对应的玩家上\nplayground/player/zbase.js\nclass Player { constructor(...) { ... this.img = new Image(); this.img.src = this.playground.root.settings.photo; } ... render() { if (this.is_me) { this.ctx.save(); this.ctx.beginPath(); this.ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false); this.ctx.stroke(); this.ctx.clip(); this.ctx.drawImage(this.img, this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2); this.ctx.restore(); } else { this.ctx.beginPath(); this.ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI, false); this.ctx.fillStyle = this.color; this.ctx.fill(); } } ... } 实现登录界面的前端 先完成登录界面显示的逻辑\nsettings/zbase.js\nclass Settings { ... register() { // 打开注册界面 this.$login.hide(); this.$register.show(); } login() { // 打开登录界面 this.$register.hide(); this.$login.show(); } ... hide() { this.$settings.hide(); } show() { this.$settings.show(); } } 实现前端的基础框架 settings/zbase.js\nclass Settings { constructor(root) { ... this.$settings = $(` \u0026lt;div class=\u0026#34;ac-game-settings\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-login\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-title\u0026#34;\u0026gt; 登录 \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-username\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-item\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;用户名\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-password\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-item\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; placeholder=\u0026#34;密码\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-submit\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-item\u0026#34;\u0026gt; \u0026lt;button\u0026gt;登录\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-error-message\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-option\u0026#34;\u0026gt; 注册 \u0026lt;/div\u0026gt; \u0026lt;br\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-acwing\u0026#34;\u0026gt; \u0026lt;img width=\u0026#34;30\u0026#34; src=\u0026#34;https://app165.acapp.acwing.com.cn/static/image/settings/acwing_logo.png\u0026#34;\u0026gt; \u0026lt;br\u0026gt; \u0026lt;div\u0026gt; AcWing一键登录 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-register\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-title\u0026#34;\u0026gt; 注册 \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-username\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-item\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;用户名\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-password ac-game-settings-password-first\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-item\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; placeholder=\u0026#34;密码\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-password ac-game-settings-password-second\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-item\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; placeholder=\u0026#34;确认密码\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-submit\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-item\u0026#34;\u0026gt; \u0026lt;button\u0026gt;注册\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-error-message\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-option\u0026#34;\u0026gt; 登录 \u0026lt;/div\u0026gt; \u0026lt;br\u0026gt; \u0026lt;div class=\u0026#34;ac-game-settings-acwing\u0026#34;\u0026gt; \u0026lt;img width=\u0026#34;30\u0026#34; src=\u0026#34;https://app165.acapp.acwing.com.cn/static/image/settings/acwing_logo.png\u0026#34;\u0026gt; \u0026lt;br\u0026gt; \u0026lt;div\u0026gt; AcWing一键登录 \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; `); this.$login = this.$settings.find(\u0026#34;.ac-game-settings-login\u0026#34;); this.$login_username = this.$login.find(\u0026#34;.ac-game-settings-username input\u0026#34;); this.$login_password = this.$login.find(\u0026#34;.ac-game-settings-password input\u0026#34;); this.$login_submit = this.$login.find(\u0026#34;.ac-game-settings-submit button\u0026#34;); this.$login_error_message = this.$login.find(\u0026#34;.ac-game-settings-error-message\u0026#34;); this.$login_register = this.$login.find(\u0026#34;.ac-game-settings-option\u0026#34;); this.$login.hide(); this.$register = this.$settings.find(\u0026#34;.ac-game-settings-register\u0026#34;); this.$register_username = this.$register.find(\u0026#34;.ac-game-settings-username input\u0026#34;); this.$register_password = this.$register.find(\u0026#34;.ac-game-settings-password-first input\u0026#34;); this.$register_password_confirm = this.$register.find(\u0026#34;.ac-game-settings-password-second input\u0026#34;); this.$register_submit = this.$register.find(\u0026#34;.ac-game-settings-submit button\u0026#34;); this.$register_error_message = this.$register.find(\u0026#34;.ac-game-settings-error-message\u0026#34;); this.$register_login = this.$register.find(\u0026#34;.ac-game-settings-option\u0026#34;); this.$register.hide(); this.root.$ac_game.append(this.$settings); ... } ... } 对应的 css 文件部分：\ncss/game.css\n.ac-game-settings { width: 100%; height: 100%; background-image: url(\u0026#34;/static/image/menu/background.gif\u0026#34;); background-size: 100% 100%; user-select: none; } .ac-game-settings-login { height: 41vh; width: 20vw; position: relative; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0, 0, 0, 0.7); border-radius: 5px; } .ac-game-settings-title { color: white; font-size: 3vh; text-align: center; padding-top: 2vh; margin-bottom: 2vh; } .ac-game-settings-username { display: block; height: 7vh; } .ac-game-settings-password { display: block; height: 7vh; } .ac-game-settings-submit { display: block; height: 7vh; } .ac-game-settings-acwing { display: block; height: 7vh; } .ac-game-settings-item { width: 100%; height: 100%; } .ac-game-settings-item \u0026gt; input { width: 90%; line-height: 3vh; position: relative; top: 50%; left: 50%; transform: translate(-50%, -50%); } .ac-game-settings-item \u0026gt; button { color: white; width: 90%; line-height: 3vh; position: relative; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: #4CAF50; border-radius: 5px; } .ac-game-settings-error-message { color: red; font-size: 0.8vh; display: inline; float: left; padding-left: 1vw; } .ac-game-settings-option { color: white; font-size: 2vh; display: inline; float: right; padding-right: 1vw; cursor: pointer; } .ac-game-settings-acwing \u0026gt; img { position: relative; top: 50%; left: 50%; transform: translate(-50%, -50%); cursor: pointer; display: block; } .ac-game-settings-acwing \u0026gt; div { color: white; font-size: 1.5vh; text-align: center; display: block; } .ac-game-settings-register { height: 49vh; width: 20vw; position: relative; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0, 0, 0, 0.7); border-radius: 5px; } 实现登录/注册的相互切换 class Settings { constructor(root) { ... } start() { this.getinfo(); this.add_listening_events(); } add_listening_events() { this.add_listening_events_login(); this.add_listening_events_register(); } add_listening_events_login() { let outer = this; this.$login_register.click(function() { outer.register(); // 跳到注册界面 }); } add_listening_events_register() { let outer = this; this.$register_login.click(function() { outer.login(); // 跳到登录界面 }) } ... } 实现登录功能 views/settings/login.py\nfrom django.http import JsonResponse from django.contrib.auth import authenticate, login def signin(request): data = request.GET username = data.get(\u0026#39;username\u0026#39;) password = data.get(\u0026#39;password\u0026#39;) user = authenticate(username=username, password=password) if not user: return JsonResponse({ \u0026#39;result\u0026#39;: \u0026#34;用户名或密码不正确\u0026#34; }) login(request, user) return JsonResponse({ \u0026#39;result\u0026#39;: \u0026#34;success\u0026#34; }) urls/settings/index.py\nfrom django.urls import path from game.views.settings.getinfo import getinfo from game.views.settings.login import signin urlpatterns = [ path(\u0026#34;getinfo/\u0026#34;, getinfo, name=\u0026#34;settings_getinfo\u0026#34;), path(\u0026#34;login/\u0026#34;, signin, name=\u0026#34;settings_login\u0026#34;), ] settings/zbase.js\nclass Settings{ ... add_listening_events_login() { ... this.$login_submit.click(function() { outer.login_on_remote(); }); } ... login_on_remote() { // 在远程服务器上登录 let outer = this; let username = this.$login_username.val(); let password = this.$login_password.val(); this.$login_error_message.empty(); $.ajax({ url: \u0026#34;https://app1117.acapp.acwing.com.cn/settings/login/\u0026#34;, type: \u0026#34;GET\u0026#34;, data: { username: username, password: password, }, success: function(resp) { console.log(resp); if (resp.result === \u0026#34;success\u0026#34;) { location.reload(); } else { outer.$login_error_message.html(resp.result); } } }); } } 实现登出功能 views/settings/logout.py\nfrom django.http import JsonResponse from django.contrib.auth import logout def signout(request): user = request.user if not user.is_authenticated: return JsonResponse({ \u0026#39;result\u0026#39;: \u0026#34;success\u0026#34;, }) logout(request) return JsonResponse({ \u0026#39;result\u0026#39;: \u0026#34;success\u0026#34;, }) urls/settings/index.py\n... from game.views.settings.logout import signout urlpatterns = [ ... path(\u0026#34;logout/\u0026#34;, signout, name=\u0026#34;settings_logout\u0026#34;), ] settings/zbase.js\n... login_on_remote() { // 在远程服务器上登录 let outer = this; let username = this.$login_username.val(); let password = this.$login_password.val(); this.$login_error_message.empty(); $.ajax({ url: \u0026#34;https://app1117.acapp.acwing.com.cn/settings/login/\u0026#34;, type: \u0026#34;GET\u0026#34;, data: { username: username, password: password, }, success: function(resp) { console.log(resp); if (resp.result === \u0026#34;success\u0026#34;) { location.reload(); } else { outer.$login_error_message.html(resp.result); } } }); } ... 再顺便将 menu 菜单页面里的 设置 按钮也绑定上登出功能\nmenu/zbase.js\nadd_listening_events() { let outer = this; ... this.$settings_mode.click(function() { ... outer.root.settings.logout_on_remote(); }); } 实现注册功能 views/settings/register.py\nfrom django.http import JsonResponse from django.contrib.auth import login from django.contrib.auth.models import User from game.models.player.player import Player def register(request): data = request.GET username = data.get(\u0026#34;username\u0026#34;, \u0026#34;\u0026#34;).strip() password = data.get(\u0026#34;password\u0026#34;, \u0026#34;\u0026#34;).strip() password_confirm = data.get(\u0026#34;password_confirm\u0026#34;, \u0026#34;\u0026#34;).strip() if not username or not password: return JsonResponse({ \u0026#39;result\u0026#39;: \u0026#34;用户名或密码不能为空\u0026#34;, }) if password != password_confirm: return JsonResponse({ \u0026#39;result\u0026#39;: \u0026#34;两个密码不一致\u0026#34;, }) if User.objects.filter(username=username).exists(): return JsonResponse({ \u0026#39;result\u0026#39;: \u0026#34;用户名已存在\u0026#34;, }) user = User(username=username) user.set_password(password) user.save() Player.objects.create(user=user, photo=\u0026#34;https://cdn.acwing.com/media/user/profile/photo/42832_lg_f999efc3c8.png\u0026#34;) login(request, user) return JsonResponse({ \u0026#39;result\u0026#39;: \u0026#34;success\u0026#34;, }) urls/settings/index.py\n... from game.views.settings.register import register ... urlpatterns = [ ... path(\u0026#34;register/\u0026#34;, register, name=\u0026#34;settings_register\u0026#34;), ] settings/zbase.js\n... add_listening_events_register() { ... this.$register_submit.click(function() { outer.register_on_remote(); }); } ... register_on_remote() { // 在远程服务器上注册 let outer = this; let username = this.$register_username.val(); let password = this.$register_password.val(); let password_confirm = this.$register_password_confirm.val(); this.$register_error_message.empty(); $.ajax({ url: \u0026#34;https://app1117.acapp.acwing.com.cn/settings/register/\u0026#34;, type: \u0026#34;GET\u0026#34;, data: { username: username, password: password, password_confirm: password_confirm, }, success: function(resp) { console.log(resp); if (resp.result === \u0026#34;success\u0026#34;) { location.reload(); } else { outer.$register_error_message.html(resp.result); } } }) } ... Redisஐ Redis是什么？ Redis 是一款内存高速缓存数据库\n为什么要使用Redis? 我们目前用的是Django自带的数据库Sqlite。Django是很容易将数据库迁移到mySQL的。但是存储效率不如redis，因为redis是内存数据库，所以调用东西都非常快，存的是一个一个的\u0026lt;key, value\u0026gt;，而且是单线程的\n在Django中集成Redis 安装 django_redis pip install django_redis 配置 settings.py CACHES = { \u0026#39;default\u0026#39;: { \u0026#39;BACKEND\u0026#39;: \u0026#39;django_redis.cache.RedisCache\u0026#39;, \u0026#39;LOCATION\u0026#39;: \u0026#39;redis://127.0.0.1:6379/1\u0026#39;, \u0026#34;OPTIONS\u0026#34;: { \u0026#34;CLIENT_CLASS\u0026#34;: \u0026#34;django_redis.client.DefaultClient\u0026#34;, }, }, } USER_AGENTS_CACHE = \u0026#39;default\u0026#39; 启动 redis-server sudo redis-server /etc/redis/redis.conf 在 Django 后台里操纵 Redis $ python3 manage.py shell\u0026#39; In [1]: from django.core.cache import cache # 引入redis In [2]: cache.keys(\u0026#39;*\u0026#39;) # 查询redis里所有的关键字 Out[2]: [] In [3]: cache.set(\u0026#39;yxc\u0026#39;, 1, 5) # 插入一个key-val，存在 5 s Out[3]: True In [4]: cache.keys(\u0026#39;*\u0026#39;) # 查询redis里所有的关键字 Out[4]: [\u0026#39;yxc\u0026#39;] In [5]: cache.set(\u0026#39;yxc\u0026#39;, 2, None) # 插入一个key-val，不会过期 Out[5]: True In [6]: cache.set(\u0026#39;abc\u0026#39;, 3, None) Out[6]: True In [7]: cache.keys(\u0026#39;y*\u0026#39;) Out[7]: [\u0026#39;yxc\u0026#39;] In [8]: cache.has_key(\u0026#39;abc\u0026#39;) Out[8]: True In [9]: cache.has_key(\u0026#39;abcd\u0026#39;) Out[9]: False In [10]: cache.get(\u0026#39;yxc\u0026#39;) Out[10]: 2 In [11]: cache.delete(\u0026#39;yxc\u0026#39;) Out[11]: True In [12]: cache.keys(\u0026#39;*\u0026#39;) Out[12]: [\u0026#39;abc\u0026#39;] In [13]: Web端AcWing一键登录ஐ 6.2 Web端AcWing一键登录 | 讲义 6.2 上课笔记 | Andrew1729 6.2 Web端AcWing一键登录 | Vedio Oauth2一键授权登录的基本原理：$17m30s——29m15s——32m51s$ 数据表添加openid信息：$33m20s——34m47s$ Oauth2一键授权登录的代码实现：$35m20s——1h25s——1h27m20s$ 用户点击AcWing一键登录，通过urls \u0026amp; views调用apply_code函数，将state放到redis中，将appid \u0026amp; redirect_uri \u0026amp; scope \u0026amp; state 传入apply_code_url链接，返回并重定向至apply_code_url向用户询问是否授权\n用户点击同意后，重定向至redirect_uri链接，返回参数为code和state，通过urls \u0026amp; views调用receive_code函数\n若验证state失败，直接重定向至初始界面\n若验证state成功，将appid \u0026amp; code \u0026amp; secret发送至AcWing服务器，申请授权令牌access_token和用户的openid\n若申请令牌成功，将access_token \u0026amp; openid发送至AcWing服务器，得到用户信息，创建并登录用户，最后重定向至初始界面\nAcApp端AcWing一键登录ஐ 6.3 AcApp端AcWing一键登录 | 讲义 6.3 上课笔记 | Andrew1729 6.3 Acapp端AcWing一键登录 | Vedio Oauth2一键授权登录的基本原理：$10m——12m20s——16m35s——18m$ Oauth2一键授权登录的代码实现：$19m25s——21m——23m25s——34m29s——42m10s$ 实现联机对战ஐ 7. 实现联机对战 | 讲义 7.1 上课笔记 | 大菜狗 7.2 上课笔记 | 菊花 统一长度单位 由于联机对战的时候，每个用户的客户端长宽不一样\n在之前完成的游戏界面里，我们会根据当前客户端的大小，进行渲染\n但是在联机对战的时候，应当让所有玩家的游戏界面保持同步才可以\n所有，就引入了 统一长度单位 的目标\n地图渲染 地图 16:9 等比例缩放 实现逻辑：根据当前用户的客户端大小，统一渲染成 16:9 的游戏界面，且随着用户调整窗口大小，也动态调整\njs/src/playground/zbase.js\nclass AcGamePlayground { constructor(root) { ... this.root.$ac_game.append(this.$playground);// 未来可能会多次 show 因此把创建场景挪到这里 ... } ... start() { let outer = this; $(window).resize(function() { outer.resize(); }); } resize() { this.width = this.$playground.width(); this.height = this.$playground.height(); let unit = Math.min(this.width / 16, this.height / 9); // 以最小的作为基准，渲染 this.width = unit * 16; this.height = unit * 9; this.resize(); this.scale = this.height; // resize时，其他元素的渲染大小都以当前渲染的高度为基准，存为 scale 变量 if (this.game_map) this.game_map.resize(); //如果此时地图已创建，则resize一下 } show() { // 打开 playground 界面 this.$playground.show(); this.resize(); ... } ... } js/src/playground/game_map/zbase.js\nclass GameMap extends AcGameObject { ... resize() { this.ctx.canvas.width = this.playground.width; this.ctx.canvas.height = this.playground.height; } ... } 地图居中 直接把 canvas 元素，用相对位置居中即可\ncss/game.css\n... .ac-game-playground { ... background-color: grey; } .ac-game-playground \u0026gt; canvas { position: relative; top: 50%; left: 50%; transform: translate(-50%, -50%); } 解决地图 resize 时，会出现渐变成黑色的情况 原由是因为我们的实现逻辑是：每帧会渲染一层半透明的黑色背景\n也就造就了一开始会出现灰屏的情况，解决方法很简单，直接 resize 完，强制涂一层不透明的黑色即可\njs/src/playground/game_map/zbase.js\nclass GameMap extends AcGameObject { ... resize() { this.ctx.canvas.width = this.playground.width; this.ctx.canvas.height = this.playground.height; this.ctx.fillStyle = \u0026#34;rgba(0, 0, 0, 1)\u0026#34;; // resize 完，涂一层不透明的即可 this.ctx.fillRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height); } ... } 元素渲染 地图随着尺寸等比例放大缩小的同时，地图内的其他元素也应与背景一同等比例放大缩小\n因此，我们只需把元素全部设为相对大小即可，用我们先前设置的 playground.scale 值即可\n玩家 Player 初始化的时候，转为传递 scale 的比例值\njs/src/playground/zbase.js\nclass AcGamePlayground { ... show() { // 打开 playground 界面 ... this.players.push(new Player(this, this.width / 2 / this.scale, 0.5, 0.05, \u0026#34;white\u0026#34;, 0.15, true)); for (let i = 0; i \u0026lt; 5; i ++ ) { this.players.push(new Player(this, this.width / 2 / this.scale, 0.5, 0.05, this.get_random_color(), 0.15, false)); } } } js/src/playground/player/zbase.js\nclass Player { ... start() { if (this.is_me) { ... } else { let tx = Math.random() * this.playground.width / this.playground.scale; let ty = Math.random() * this.playground.height / this.playground.scale; ... } } add_listening_events() { ... this.playground.game_map.$canvas.mousedown(function(e) { ... if (e.which === 3) { outer.move_to((e.clientX - rect.left) / outer.playground.scale, (e.clientY - rect.top) / outer.playground.scale); } else if (e.which === 1) { if (outer.cur_skill === \u0026#34;fireball\u0026#34;) { outer.shoot_fireball((e.clientX - rect.left) / outer.playground.scale, (e.clientY - rect.top) / outer.playground.scale); } } ... }); ... } shoot_fireball(tx, ty) { let x = this.x, y = this.y; let radius = 0.01; let angle = Math.atan2(ty - this.y, tx - this.x); let vx = Math.cos(angle), vy = Math.sin(angle); let color = \u0026#34;orange\u0026#34;; let speed = 0.5; let move_length = 1.0; let damage = 0.01; new FireBall(this.playground, this, x, y, radius, vx, vy, color, speed, move_length, damage); } ... update() { this.update_move(); this.render(); } update_move() { // 更新玩家移动 ... if (!this.is_me \u0026amp;\u0026amp; this.spent_time \u0026gt; 4 \u0026amp;\u0026amp; Math.random() * 180 \u0026lt; 1) { ... } if (this.damage_speed \u0026gt; this.eps) { ... } else { if (this.move_length \u0026lt; this.eps) { ... if (!this.is_me) { let tx = Math.random() * this.playground.width / this.playground.scale; let ty = Math.random() * this.playground.height / this.playground.scale; ... } } else { ... } } } render() { let scale = this.playground.scale; if (this.is_me) { ... this.ctx.arc(this.x * scale, this.y * scale, this.radius * scale, 0, Math.PI * 2, false); ... this.ctx.drawImage(this.img, (this.x - this.radius) * scale, (this.y - this.radius) * scale, this.radius * 2 * scale, this.radius * 2 * scale); ... } else { ... this.ctx.arc(this.x * scale, this.y * scale, this.radius * scale, 0, 2 * Math.PI, false); ... } } } 火球 Fireball js/src/playground/skill/fireball/zbase.js\nclass Fireball { ... render() { let scale = this.playground.scale; this.ctx.beginPath(); this.ctx.arc(this.x * scale, this.y * scale, this.radius * scale, 0, 2 * Math.PI, false); this.ctx.fillStyle = this.color; this.ctx.fill(); } } 粒子 Particle js/src/playground/particle/zbase.js\nclass Particle { ... render() { let scale = this.playground.scale; this.ctx.beginPath(); this.ctx.arc(this.x * scale, this.y * scale, this.radius * scale, 0, 2 * Math.PI, false); this.ctx.fillStyle = this.color; this.ctx.fill(); } } 增加“联机对战”模式 为了区分：用户自己，机器人，联机玩家\n需要把 is_me 改成字符串，用以表示不同 Player\nmenu/zbase.js\nclass AcGameMenu{ ... add_listening_events() { ... this.$single_mode.click(function(){ outer.hide(); outer.root.playground.show(\u0026#34;single mode\u0026#34;); }); this.$multi_mode.click(function() { outer.hide(); outer.root.playground.show(\u0026#34;multi mode\u0026#34;); }); ... } ... } playground/zbase.js\nclass Playground { ... show(mode) { // 打开 playground 界面 ... this.players.push(new Player(this, this.width / 2 / this.scale, 0.5, 0.05, \u0026#34;white\u0026#34;, 0.15, \u0026#34;me\u0026#34;, this.root.settings.username, this.root.settings.photo))); if (mode === \u0026#34;single mode\u0026#34;) { for (let i = 0; i \u0026lt; 5; i ++ ) { this.players.push(new Player(this, this.width / 2 / this.scale, 0.5, 0.05, this.get_random_color(), 0.15, \u0026#34;robot\u0026#34;)); } } else if (mode === \u0026#34;multi mode\u0026#34;) { } } ... } playground/player/zbase.js\nclass Player extends AcGameObject { constructor(playground, x, y, radius, color, speed, character, username, photo) { ... this.character = character; this.username = username; this.photo = photo; ... if (this.character !== \u0026#34;robot\u0026#34;) { this.img = new Image(); this.img.src = this.photo; } } ... // 同理，根据对应的逻辑，修改后面所有的 is_me 为 character } Django_channels 谈谈Websocket HTTP/TCP Django_channels是什么？ Django_Channels 是一个为Django 提供异步扩展的库，通常主要用来提供WebSocket 支持和后台任务\nWSS 是 Web Socket 协议的安全模式，支持 C/S 下的双向通信（HTTP协议只支持单向通信）\n配置Django_channels 安装 channels_redis pip install channels_redis 配置 acapp/asgi.py import os from channels.auth import AuthMiddlewareStack from channels.routing import ProtocolTypeRouter, URLRouter from django.core.asgi import get_asgi_application from game.routing import websocket_urlpatterns os.environ.setdefault(\u0026#39;DJANGO_SETTINGS_MODULE\u0026#39;, \u0026#39;acapp.settings\u0026#39;) application = ProtocolTypeRouter({ \u0026#34;http\u0026#34;: get_asgi_application(), \u0026#34;websocket\u0026#34;: AuthMiddlewareStack(URLRouter(websocket_urlpatterns)) }) 配置 acapp/settings.py 在 INSTALLED_APPS 中添加 channels ，添加后如下所示：\nINSTALLED_APPS = [ \u0026#39;channels\u0026#39;, \u0026#39;game.apps.GameConfig\u0026#39;, \u0026#39;django.contrib.admin\u0026#39;, \u0026#39;django.contrib.auth\u0026#39;, \u0026#39;django.contrib.contenttypes\u0026#39;, \u0026#39;django.contrib.sessions\u0026#39;, \u0026#39;django.contrib.messages\u0026#39;, \u0026#39;django.contrib.staticfiles\u0026#39;, ] 然后在文件末尾添加：\nASGI_APPLICATION = \u0026#39;acapp.asgi.application\u0026#39; CHANNEL_LAYERS = { \u0026#34;default\u0026#34;: { \u0026#34;BACKEND\u0026#34;: \u0026#34;channels_redis.core.RedisChannelLayer\u0026#34;, \u0026#34;CONFIG\u0026#34;: { \u0026#34;hosts\u0026#34;: [(\u0026#34;127.0.0.1\u0026#34;, 6379)], }, }, } 配置 game/routing.py 这一部分的作用相当于 http 的 urls 内容如下：\nfrom django.urls import path websocket_urlpatterns = [ ] 编写 game/consumers 这一部分的作用相当于 http 的 views 参考示例：\nconsumers/multiplayer/index.py\nfrom channels.generic.websocket import AsyncWebsocketConsumer import json class MultiPlayer(AsyncWebsocketConsumer): async def connect(self): await self.accept() print(\u0026#39;accept\u0026#39;) self.room_name = \u0026#34;room\u0026#34; await self.channel_layer.group_add(self.room_name, self.channel_name) async def disconnect(self, close_code): print(\u0026#39;disconnect\u0026#39;) await self.channel_layer.group_discard(self.room_name, self.channel_name); async def receive(self, text_data): data = json.loads(text_data) print(data) 启动 django_channels 在 ~/acapp 目录下执行：\ndaphne -b 0.0.0.0 -p 5015 acapp.asgi:application 建立 WSS 连接 game/routing.py\nfrom django.urls import path from game.consumers.multiplayer.index import MultiPlayer websocket_urlpatterns = [ path(\u0026#34;wss/multiplayer/\u0026#34;, MultiPlayer.as_asgi(), name=\u0026#34;wss_multiplayer\u0026#34;), ] playground/zbase.js\nclass AcGamePlayground { ... show(mode) { // 打开 playground 界面 ... if (mode === \u0026#34;single mode\u0026#34;) { ... } else if (mode === \u0026#34;multi mode\u0026#34;) { this.mps = new MultiPlayerSocket(this); this.mps.ws.onopen = function() { outer.mps.send_create_player(); }; } } } playground/socket/multiplayer/zbase.js\nclass MultiPlayerSocket { constructor(playground) { this.playground = playground; this.ws = new WebSocket(\u0026#34;wss://app1117.acapp.acwing.com.cn/wss/multiplayer/\u0026#34;); this.start(); } start() { } send_create_player() { this.ws.send(JSON.stringify({ \u0026#39;message\u0026#39;: \u0026#39;hello acapp server\u0026#39;, })); } receive_create_player() { } } 编写同步函数 一共需要完成四个通信：\n（通信的逻辑基本都是先在本地完成，然后将结果返回给服务器，服务器再分发给其他客户端，达成同步）\ncreate-player : 在所有玩家的游戏界面，创建一个新加入的玩家 move-to : 在所有玩家的游戏界面，将一个角色移动到一个位置 shoot-fireball : 在所有玩家的游戏界面，让一个角色发射一个火球 attack : 在所有玩家的游戏界面，让一个角色被攻击 一场游戏里，所有的元素（玩家，火球等）都需要唯一的标识，来方便同步\n为此，我们可以直接修改一下游戏引擎，对于每个元素都创建我们需要的唯一标识\nplayground/ac-game-object/zbase.js\nclass AcGameObject { constructor() { ... this.uuid = this.create_uuid(); } create_uuid() { let res = \u0026#34;\u0026#34;; for (let i = 0; i \u0026lt; 8; i ++ ) { let x = parseInt(Math.floor(Math.random() * 10)); // [0, 10) res += x; } return res; ... } playground/zbase.js\nclass AcGamePlayground { ... show(mode) { ... if (mode === \u0026#34;single mode\u0026#34;) { ... } else if (mode === \u0026#34;multi mode\u0026#34;) { this.mps = new MultiPlayerSocket(this); this.mps.uuid = this.players[0].uuid; this.mps.ws.onopen = function() { outer.mps.send_create_player(); }; } } ... } playground/socket/multiplayer/zbase.js\nclass MultiPlayerSocket { ... send_create_player() { let outer = this; this.ws.send(JSON.stringify({ \u0026#39;event\u0026#39;: \u0026#39;create_player\u0026#39;, \u0026#39;uuid\u0026#39;: outer.uuid, })); } } 接着，利用通信的方式，使得每个窗口内，逻辑上相同的元素，其 uid 也相同即可\n原则是：哪个窗口创建的元素，就用他创建时的 uid 作为整个项目运行时的 uid\n然后，我们打算用 redis 来实现存储每个游戏房间，以及元素，并初始默认设定每个房间上限 3 人\ncreate-player 前端 game/static/js/src/playground/socket/multiplayer/zbase.js\nclass MultiPlayerSocket { constructor(playground) { this.playground = playground; this.ws = new WebSocket(\u0026#34;wss://app1117.acapp.acwing.com.cn/wss/multiplayer/\u0026#34;); this.start(); } start() { this.receive(); } receive() { let outer = this; this.ws.onmessage = function(e) { let data = JSON.parse(e.data); let uuid = data.uuid; if (uuid === outer.uuid) return false; let event = data.event; if (event === \u0026#34;create_player\u0026#34;) { outer.receive_create_player(uuid, data.username, data.photo); } }; } send_create_player(username, photo) { let outer = this; this.ws.send(JSON.stringify({ \u0026#39;event\u0026#39;: \u0026#39;create_player\u0026#39;, \u0026#39;uuid\u0026#39;: outer.uuid, \u0026#39;username\u0026#39;: username, \u0026#39;photo\u0026#39;: photo, })); } receive_create_player(uuid, username, photo) { let player = new Player( this.playground, this.playground.width / 2 / this.playground.scale, 0.5, 0.05, \u0026#34;white\u0026#34;, 0.15, \u0026#34;enemy\u0026#34;, username, photo, ); player.uuid = uuid; this.playground.players.push(player); } } 后端 settings.py\n... ROOM_CAPACITY = 3 consumers/multiplayer/index.py\nfrom channels.generic.websocket import AsyncWebsocketConsumer import json from django.conf import settings from django.core.cache import cache class MultiPlayer(AsyncWebsocketConsumer): async def connect(self): self.room_name = None for i in range(1000): # 上限 1k 个房间 name = \u0026#34;room-%d\u0026#34; % (i) # 当前房间为空，或房间内玩家人数不到 ROOM_CAPACITY if not cache.has_key(name) or len(cache.get(name)) \u0026lt; settings.ROOM_CAPACITY: self.room_name = name break if not self.room_name: return await self.accept() if not cache.has_key(self.room_name): # 如果房间不存在，则新建房间 cache.set(self.room_name, [], 3600) # 有效期 1 小时 for player in cache.get(self.room_name): # 对该房间已存在的用户，创建到新加入的用户的游戏界面中 await self.send(text_data=json.dumps({ \u0026#39;event\u0026#39;: \u0026#34;create_player\u0026#34;, \u0026#39;uuid\u0026#39;: player[\u0026#39;uuid\u0026#39;], \u0026#39;username\u0026#39;: player[\u0026#39;username\u0026#39;], \u0026#39;photo\u0026#39;: player[\u0026#39;photo\u0026#39;], })) await self.channel_layer.group_add(self.room_name, self.channel_name) async def disconnect(self, close_code): print(\u0026#39;disconnect\u0026#39;) await self.channel_layer.group_discard(self.room_name, self.channel_name); async def create_player(self, data): players = cache.get(self.room_name) players.append({ \u0026#39;uuid\u0026#39;: data[\u0026#39;uuid\u0026#39;], \u0026#39;username\u0026#39;: data[\u0026#39;username\u0026#39;], \u0026#39;photo\u0026#39;: data[\u0026#39;photo\u0026#39;], }) cache.set(self.room_name, players, 3600) # 更新房间存在时间为 1 小时（最后一次加入一名玩家时） # 群发消息更新 await self.channel_layer.group_send( self.room_name, { \u0026#39;type\u0026#39;: \u0026#34;group_create_player\u0026#34;, # 群发该消息后，作为客户端接受者，所接受用的函数名 \u0026#39;event\u0026#39;: \u0026#34;create_player\u0026#34;, \u0026#39;uuid\u0026#39;: data[\u0026#39;uuid\u0026#39;], \u0026#39;username\u0026#39;: data[\u0026#39;username\u0026#39;], \u0026#39;photo\u0026#39;: data[\u0026#39;photo\u0026#39;], } ) async def group_create_player(self, data): await self.send(text_data=json.dumps(data)) async def receive(self, text_data): data = json.loads(text_data) event = data[\u0026#39;event\u0026#39;] if event == \u0026#34;create_player\u0026#34;: await self.create_player(data) redis 调试语句 打开 shell 交互\npython3 manage.py shell 然后用 py3 交互进行 cache 调试\nfrom django.core.cache import cache def clear(): for key in cache.keys(\u0026#39;*\u0026#39;): cache.delete(key) cache.keys(\u0026#39;*\u0026#39;) # 查询当前 redis 中所有 key cache.get(\u0026#39;room-1\u0026#39;) # 查询当前 redis 中 key 为 room-1 的值 到目前为止，便可以在不同的窗口渲染同一批玩家了\nmove-to 前端 客户端的通信的发出和接受函数\ngame/static/js/src/playground/socket/multiplayer/zbase.js\nclass MultiPlayerSocket { ... receive() { let outer = this; this.ws.onmessage = function(e) { ... else if (event === \u0026#34;move_to\u0026#34;) { outer.receive_move_to(uuid, data.tx, data.ty); } }; } send_move_to(tx, ty) { let outer = this; this.ws.send(JSON.stringify({ \u0026#39;event\u0026#39;: \u0026#39;move_to\u0026#39;, \u0026#39;uuid\u0026#39;: outer.uuid, \u0026#39;tx\u0026#39;: tx, \u0026#39;ty\u0026#39;: ty, })); } get_player(uuid) { let players = this.playground.players; for (let i = 0; i \u0026lt; players.length; i ++ ) { let player = players[i]; if (player.uuid === uuid) { return player; } } return null; } receive_move_to(uuid, tx, ty) { let player = this.get_player(uuid); if (player) { player.move_to(tx, ty); } } } 为了让游戏界面中对于要移动的元素做出移动动作，需要对 move_to 函数做出一些修改\n首先要标识出当前为多人模式，然后模式为多人模式时，每次移动都会触发一次通信\nplayground/zbase.js\nclass AcGamePlayground { ... show(mode) { ... this.mode = mode; } } playground/player/zbase.js\nclass Player extends AcGameObject { ... add_listening_events() { ... this.playground.game_map.$canvas.mousedown(function(e) { ... if (e.which === 3) { let tx = (e.clientX - rect.left) / outer.playground.scale; let ty = (e.clientY - rect.top) / outer.playground.scale; outer.move_to(tx, ty); if (outer.playground.mode === \u0026#34;multi mode\u0026#34;) { outer.playground.mps.send_move_to(tx, ty); } } ... } ... } 后端 consumers/multiplayer/index.py\nasync def move_to(self, data): await self.channel_layer.group_send( self.room_name, { \u0026#39;type\u0026#39;: \u0026#34;group_send_event\u0026#34;, \u0026#39;event\u0026#39;: \u0026#34;move_to\u0026#34;, \u0026#39;uuid\u0026#39;: data[\u0026#39;uuid\u0026#39;], \u0026#39;tx\u0026#39;: data[\u0026#39;tx\u0026#39;], \u0026#39;ty\u0026#39;: data[\u0026#39;ty\u0026#39;], } ) async def group_send_event(self, data): await self.send(text_data=json.dumps(data)) async def receive(self, text_data): data = json.loads(text_data) event = data[\u0026#39;event\u0026#39;] if event == \u0026#34;create_player\u0026#34;: await self.create_player(data) elif event == \u0026#34;move_to\u0026#34;: await self.move_to(data) shoot-fireball 前端 用一个数组来存一个玩家发射的所有火球，以便于子弹消失时，将他们找出并对应删掉\nplayground/player/zbase.js\nclass Player extends AcGameObject { constructor(playground, x, y, radius, color, speed, character, username, photo) { ... this.fireballs = []; // 存该用户发射的所有火球 } add_listening_events() { ... this.playground.game_map.$canvas.mousedown(function(e) { ... else if (e.which === 1) { let tx = (e.clientX - rect.left) / outer.playground.scale; let ty = (e.clientY - rect.top) / outer.playground.scale; if (outer.cur_skill === \u0026#34;fireball\u0026#34;) { let fireball = outer.shoot_fireball(tx, ty); if (outer.playground.mode === \u0026#34;multi mode\u0026#34;) { outer.playground.mps.send_shoot_fireball(tx, ty, fireball.uuid); } } } ... }); $(window).keydown(function(e) { if (e.which === 81) { // 键盘按下q事件 outer.cur_skill = \u0026#34;fireball\u0026#34;; return false; } }); } ... shoot_fireball(tx, ty) { ... let fireball = new FireBall(this.playground, this, x, y, radius, vx, vy, color, speed, move_length, damage); this.fireballs.push(fireball); return fireball; } destroy_fireball(uuid) { for (let i = 0; i \u0026lt; this.fireballs.length; i ++ ) { let fireball = this.fireballs[i]; if (fireball.uuid == uuid) { fireball.destroy(); break; } } } ... playground/skill/fireball/zbase.js\nclass FireBall extends AcGameObject { ... on_destory() { let fireballs = this.player.fireballs; for (let i = 0; i \u0026lt; fireballs.length; i ++ ) { if (fireballs[i] === this) { fireballs.splice(i, 1); break; } } } } game/static/js/src/playground/socket/multiplayer/zbase.js\nclass MultiPlayerSocket { ... send_shoot_fireball(tx, ty, ball_uuid) { let outer = this; this.ws.send(JSON.stringify({ \u0026#39;event\u0026#39;: \u0026#39;move_to\u0026#39;, \u0026#39;uuid\u0026#39;: outer.uuid, \u0026#39;tx\u0026#39;: tx, \u0026#39;ty\u0026#39;: ty, \u0026#39;ball_uuid\u0026#39;: ball_uuid; })); } receive_shoot_fireball(uuid, tx, ty, ball_uuid) { let player = this.get_player(uuid); if (player) { let fireball = player.shoot_fireball(tx, ty); fireball.uuid = ball_uuid; } } } 后端 consumers/multiplayer/index.py\n... class MultiPlayer(AsyncWebsocketConsumer): ... async def shoot_fireball(self, data): await self.channel_layer.group_send( self.room_name, { \u0026#39;type\u0026#39;: \u0026#34;group_send_event\u0026#34;, \u0026#39;event\u0026#39;: \u0026#34;shoot_fireball\u0026#34;, \u0026#39;uuid\u0026#39;: data[\u0026#39;uuid\u0026#39;], \u0026#39;tx\u0026#39;: data[\u0026#39;tx\u0026#39;], \u0026#39;ty\u0026#39;: data[\u0026#39;ty\u0026#39;], \u0026#39;ball_uuid\u0026#39;: data[\u0026#39;ball_uuid\u0026#39;], } ) async def receive(self, text_data): ... elif event == \u0026#34;shoot_fireball\u0026#34;: await self.shoot_fireball(data) attack 为了只让一个客户端进行攻击命中的判断，因此只有发出方的火球才做碰撞检测\n其他客户端对于该火球只有动画效果\n又由于碰撞检测是在一台客户端上进行的，因此多端之间可能会存在同步上的延迟\n为此的解决方法是：碰撞检测成功时，强制把被击中玩家移动到发起方客户端中的位置，以避免击中延迟上发生的事情\n前端 playground/skill/fireball/zbase.js\nclass FireBall extends AcGameObject { update() { if (this.move_length \u0026lt; this.eps) { this.destroy(); return false; } this.update_move(); if (this.player.character !== \u0026#34;enemy\u0026#34;) { this.update_attack(); } this.render(); } attack(player) { ... if (this.playground.mode === \u0026#34;multi mode\u0026#34;) { this.playground.mps.send_attack(player.uuid, player.x, player.y, angle, this.damage, this.uuid); } ... } ... } playground/player/zbase.js\nclass Player extends AcGameObject { ... receive_attack(x, y, angle, damage, ball_uuid, attacker) { attacker.destroy_fireball(ball_uuid); this.x = x; this.y = y; this.is_attacked(angle, damage); } ... } game/static/js/src/playground/socket/multiplayer/zbase.js\nclass MultiPlayerSocket { ... send_attack(attackee_uuid, x, y, angle, damage, ball_uuid) { let outer = this; this.ws.send(JSON.stringify({ \u0026#39;event\u0026#39;: \u0026#34;attack\u0026#34;, \u0026#39;uuid\u0026#39;: outer.uuid, \u0026#39;attackee_uuid\u0026#39;: attackee_uuid, \u0026#39;x\u0026#39;: x, \u0026#39;y\u0026#39;: y, \u0026#39;angle\u0026#39;: angle, \u0026#39;damage\u0026#39;: damage, \u0026#39;ball_uuid\u0026#39;: ball_uuid, })); } receive_attack(uuid, attackee_uuid, x, y, angle, damage, ball_uuid) { let attacker = this.get_player(uuid); let attackee = this.get_player(attackee_uuid); if (attacker \u0026amp;\u0026amp; attackee) { attackee.receive_attack(x, y, angle, damage, ball_uuid, attacker); } } } 后端 consumers/multiplayer/index.py\n... class MultiPlayer(AsyncWebsocketConsumer): ... async def attack(self, data): await self.channel_layer.group_send( self.room_name, { \u0026#39;type\u0026#39;: \u0026#34;group_send_event\u0026#34;, \u0026#39;event\u0026#39;: \u0026#34;attack\u0026#34;, \u0026#39;uuid\u0026#39;: data[\u0026#39;uuid\u0026#39;], \u0026#39;x\u0026#39;: data[\u0026#39;x\u0026#39;], \u0026#39;y\u0026#39;: data[\u0026#39;y\u0026#39;], \u0026#39;angle\u0026#39;: data[\u0026#39;angle\u0026#39;], \u0026#39;damage\u0026#39;: data[\u0026#39;damage\u0026#39;], \u0026#39;ball_uuid\u0026#39;: data[\u0026#39;ball_uuid\u0026#39;], } ) ... 游戏的小优化 多人模式下游戏没有开始前，玩家不可以移动 为此我们先引入一个状态机：'waiting' -\u0026gt; 'fighting' -\u0026gt; 'over' 来标识当前游戏进行的状态\n然后用一个 notice_board 计分板在前端显示出来\n实现的逻辑就是：游戏初始时为 waiting 状态，房间内人数满 3 人时，才会进入 fighting，角色死亡时为 over\n且发射火球，移动等行为，当且仅当玩家状态为 fighting 时，才可以做\n然后设定火球技能的 cd 为 3 秒，且在游戏进入 fighting 时，先自动进入 cd 状态\n这样就实现了初始 3 秒内，任何玩家不可攻击\njs/src/playground/notice_board/zbase.js\nclass NoticeBoard extends AcGameObject { constructor(playground) { super(); this.playground = playground; this.ctx = this.playground.game_map.ctx; this.text = \u0026#34;已就绪：0人\u0026#34;; } start() { } write(text) { this.text = text; } update() { this.render(); } render() { this.ctx.font = \u0026#34;20px serif\u0026#34;; this.ctx.fillStyle = \u0026#34;white\u0026#34;; this.ctx.textAlign = \u0026#34;center\u0026#34;; this.ctx.fillText(this.text, this.playground.width / 2, 20); } } js/src/playground/zbase.js\nclass AcGamePlayground { ... show(mode) { ... this.state = \u0026#34;waiting\u0026#34;; // waiting -\u0026gt; fighting -\u0026gt; over this.notice_board = new NoticeBoard(this); this.player_count = 0; ... } } js/src/playground/player/zbase.js\nclass Player extends AcGameObject { ... add_listening_events() { ... this.playground.game_map.$canvas.mousedown(function(e) { if (outer.playground.state !== \u0026#34;fighting\u0026#34;) return false; ... } $(window).keydown(function(e) { if (outer.playground.state !== \u0026#34;fighting\u0026#34;) return false; ... }); } start() { this.playground.player_count ++ ; this.playground.notice_board.write(\u0026#34;已就绪：\u0026#34; + this.playground.player_count + \u0026#34;人\u0026#34;); if (this.playground.player_count \u0026gt;= 3) { this.playground.state = \u0026#34;fighting\u0026#34;; this.playground.notice_board.write(\u0026#34;Fighting\u0026#34;); } ... } ... } 技能CD 给火球技能设置 3s 的 cd，实现逻辑很简单，设定一个 cool_time 变量，每次渲染的时候减去上次渲染的时间间隔\n然后 cool_time 为 0 时，技能才可以成功释放\n另外修改冷却时间，只用修改自己的即可\njs/src/playground/player/zbase.js\nclass Player extends AcGameObject { constructor(...) { ... if (this.character === \u0026#34;me\u0026#34;) { this.fireball_coldtime = 3; // 单位：s } } ... add_listening_events() { ... this.playground.game_map.$canvas.mousedown(function(e) { ... else if (e.which === 1) { ... if (outer.cur_skill === \u0026#34;fireball\u0026#34;) { ... if (outer.playground.mode === \u0026#34;multi mode\u0026#34;) { outer.playground.mps.send_shoot_fireball(tx, ty, fireball.uuid); } outer.fireball_coldtime = 3; } } ... }); $(window).keydown(function(e) { ... if (outer.fireball_coldtime \u0026gt;= outer.eps) return false; ... }); } update() { ... if (this.character === \u0026#34;me\u0026#34; \u0026amp;\u0026amp; this.playground.state === \u0026#34;fighting\u0026#34;) { this.update_coldtime(); } ... } update_coldtime() { this.fireball_coldtime -= this.timedelta / 1000; this.fireball_coldtime = Math.max(0, this.fireball_coldtime); } ... } 用图片来渲染技能CD js/src/playground/player/zbase.js\nclass Player extends AcGameObject { constructor(...) { ... if (this.character === \u0026#34;me\u0026#34;) { this.fireball_coldtime = 3; // 单位：s this.fireball_img = new Image(); this.fireball_img.src = \u0026#34;https://cdn.acwing.com/media/article/image/2021/12/02/1_9340c86053-fireball.png\u0026#34;; } } ... render() { ... if (this.character === \u0026#34;me\u0026#34; \u0026amp;\u0026amp; this.playground.state === \u0026#34;fighting\u0026#34;) { this.render_skill_coldtime(); } } render_skill_coldtime() { let scale = this.playground.scale; let x = 1.5, y = 0.9, r = 0.04; // 渲染技能图标 this.ctx.save(); this.ctx.beginPath(); this.ctx.arc(x * scale, y * scale, r * scale, 0, Math.PI * 2, false); this.ctx.stroke(); this.ctx.clip(); this.ctx.drawImage(this.fireball_img, (x - r) * scale, (y - r) * scale, r * 2 * scale, r * 2 * scale); this.ctx.restore(); // 渲染冷却指示 if (this.fireball_coldtime \u0026gt;= this.eps){ this.ctx.beginPath(); this.ctx.moveTo(x * scale, y * scale); this.ctx.arc(x * scale, y * scale, r * scale, 0 - Math.PI / 2, Math.PI * 2 * (1 - this.fireball_coldtime / 3) - Math.PI / 2, true); this.ctx.lineTo(x * scale, y * scale); this.ctx.fillStyle = \u0026#34;rgba(0, 0, 255, 0.6)\u0026#34;; this.ctx.fill(); } } ... 添加一个闪现技能 单机部分 js/src/playground/player/zbase.js\nclass Player extends AcGameObject { constructor(...) { ... if (this.character === \u0026#34;me\u0026#34;) { ... this.blink_coldtime = 5; this.blink_img = new Image(); this.blink_img.src = \u0026#34;https://cdn.acwing.com/media/article/image/2021/12/02/1_daccabdc53-blink.png\u0026#34;; } } add_listening_events() { ... this.playground.game_map.$canvas.mousedown(function(e) { ... else if (e.which === 1) { ... else if (outer.cur_skill === \u0026#34;blink\u0026#34;) { outer.blink(tx, ty); // 同步函数 if (outer.playground.mode === \u0026#34;multi mode\u0026#34;) { outer.playground.mps.send_blink(tx, ty); } outer.blink_coldtime = 5; } } outer.cur_skill = null; // 清空当前技能 }); $(window).keydown(function(e) { ... else if (e.which === 70) { // f键 if (outer.blink_coldtime \u0026gt;= outer.eps) return true; outer.cur_skill = \u0026#34;blink\u0026#34;; return false; } }); } ... blink(tx, ty) { let d = this.get_dist(this.x, this.y, tx, ty); d = Math.min(d, 0.5); let angle = Math.atan2(ty - this.y, tx - this.x); this.x += d * Math.cos(angle); this.y += d * Math.sin(angle); this.move_length = 0; // 闪现完停下来 } ... render_skill_coldtime() { ... x = 1.62, y = 0.9, r = 0.04; // 闪现技能 // 渲染技能图标 this.ctx.save(); this.ctx.beginPath(); this.ctx.arc(x * scale, y * scale, r * scale, 0, Math.PI * 2, false); this.ctx.stroke(); this.ctx.clip(); this.ctx.drawImage(this.blink_img, (x - r) * scale, (y - r) * scale, r * 2 * scale, r * 2 * scale); this.ctx.restore(); // 渲染冷却指示 if (this.blink_coldtime \u0026gt;= this.eps){ this.ctx.beginPath(); this.ctx.moveTo(x * scale, y * scale); this.ctx.arc(x * scale, y * scale, r * scale, 0 - Math.PI / 2, Math.PI * 2 * (1 - this.blink_coldtime / 5) - Math.PI / 2, true); this.ctx.lineTo(x * scale, y * scale); this.ctx.fillStyle = \u0026#34;rgba(0, 0, 255, 0.6)\u0026#34;; this.ctx.fill(); } } } 联机部分 game/static/js/src/playground/socket/multiplayer/zbase.js\nclass MultiPlayerSocket { ... send_blink(tx, ty) { let outer = this; this.ws.send(JSON.stringify({ \u0026#39;event\u0026#39;: \u0026#34;blink\u0026#34;, \u0026#39;uuid\u0026#39;: outer.uuid, \u0026#39;tx\u0026#39;: tx, \u0026#39;ty\u0026#39;: ty, })); } receive_blink(uuid, tx, ty) { let player = this.get_player(uuid); if (player) { player.blink(tx, ty); } } } consumers/multiplayer/index.py\n... class MultiPlayer(AsyncWebsocketConsumer): ... async def blink(self, data): await self.channel_layer.group_send( self.room_name, { \u0026#39;type\u0026#39;: \u0026#34;group_send_event\u0026#34;, \u0026#39;event\u0026#39;: \u0026#34;blink\u0026#34;, \u0026#39;uuid\u0026#39;: data[\u0026#39;uuid\u0026#39;], \u0026#39;tx\u0026#39;: data[\u0026#39;tx\u0026#39;], \u0026#39;ty\u0026#39;: data[\u0026#39;ty\u0026#39;], } ) 实现聊天系统ஐ 8.1 上课笔记 | 大菜狗 优化键盘绑定事件 这部分算是之前的遗留问题，先前的 keydown 监听事件绑定在了 window 上会出现一个问题\n如果在一个浏览器内打开多个 ACAPP，此时按下键位触发 keydown 事件，会被浏览器内所有的 ACAPP 都捕获到\n之前影响不大，但对此次要实现的聊天系统就有着致命的影响，即打开一个 ACAPP 的聊天栏，其他都会被打开\n所有我们要将 keydown 监听事件绑定到 canvas 上\nplayground/player/zbase.js\nclass Player extends AcGameObject { ... add_listening_events() { ... this.playground.game_map.$canvas.keydown(function(e) { if (outer.playground.state !== \u0026#34;fighting\u0026#34;) return true; if (e.which === 81) { // 键盘按下q事件 if (outer.fireball_coldtime \u0026gt;= outer.eps) return true; outer.cur_skill = \u0026#34;fireball\u0026#34;; return false; } else if (e.which === 70) { // f键 if (outer.blink_coldtime \u0026gt;= outer.eps) return true; outer.cur_skill = \u0026#34;blink\u0026#34;; return false; } }); } } playground/game-map/zbase.js\nclass GameMap extends AcGameObject { constructor(playground) { ... this.$canvas = $(`\u0026lt;canvas tabindex=0\u0026gt;\u0026lt;/canvas\u0026gt;`); ... } start() { this.$canvas.focus(); } } 本地前端 要实现两个部分： 1. 文本输入框（让用户输入要发送的信息） 2. 历史记录显示框（之前用户发送的信息的显示框）\n欲实现逻辑：用户按下 \u0026lt;Enter\u0026gt; 后，游戏界面弹出文本输入框，然后聚焦于文本输入框，且同时弹出历史记录显示框 3 秒\n然后用户输入信息后，按下 \u0026lt;Enter\u0026gt; 后发出信息，接着信息会显示在历史记录显示框最下方，并弹出历史记录显示框 3 秒\nplayground/chat_field/zbase.js\nchat field 负责管理 文本输入框 和 历史记录显示框\nclass ChatField { constructor(playground) { this.playground = playground; this.$history = $(`\u0026lt;div class=\u0026#34;ac-game-chat-field-history\u0026#34;\u0026gt;\u0026lt;/div\u0026gt;`); this.$input = $(`\u0026lt;input type=\u0026#34;text\u0026#34; class=\u0026#34;ac-game-chat-field-input\u0026#34;\u0026gt;`); this.$history.hide(); this.$input.hide(); this.func_id = null; this.playground.$playground.append(this.$history); this.playground.$playground.append(this.$input); this.start(); } start() { this.add_listening_events(); } add_listening_events() { let outer = this; this.$input.keydown(function(e) { if (e.which === 27) { //ESC outer.hide_input(); return false; } else if (e.which === 13) { let username = outer.playground.root.settings.username; let text = outer.$input.val(); if (text) { outer.$input.val(\u0026#34;\u0026#34;); outer.add_message(username, text); } return false; } }); } show_history() { let outer = this; this.$history.fadeIn(); if (this.func_id) clearTimeout(this.func_id); this.func_id = setTimeout(function() { outer.$history.fadeOut(); outer.func_id = null; }, 3000); } render_message(message) { return $(`\u0026lt;div\u0026gt;${message}\u0026lt;/div\u0026gt;`); } add_message(username, text) { this.show_history(); let message = `[${username}] ${text}`; this.$history.append(this.render_message(message)); this.$history.scrollTop(this.$history[0].scrollHeight); } show_input() { this.show_history(); this.$input.show(); this.$input.focus(); // 输入时，聚焦于输入框 } hide_input() { this.$input.hide(); this.playground.game_map.$canvas.focus(); // 退出时，聚焦回游戏界面 } } playground/zbase.js\n把它创建出来\nclass AcGamePlayground { ... show(mode) { //打开 playground 界面 ... else if (mode === \u0026#34;multi mode\u0026#34;) { this.chat_field = new ChatField(this); ... } } } playground/player/zbase.js\n添加监听事件\nclass Player extends AcGameObject { ... add_listening_events() { ... this.playground.game_map.$canvas.keydown(function(e) { if (e.which === 13) { // enter (显示对话框) if (outer.playground.mode === \u0026#34;multi mode\u0026#34;) { outer.playground.chat_field.show_input(); return false; } } else if (e.which === 27) { // esc（关闭对话框） if (outer.playground.mode === \u0026#34;multi mode\u0026#34;) { outer.playground.char_field.hide_input(); return false; } } ... } } } game.css\n... .ac-game-chat-field-history { position: absolute; top: 66%; left: 20%; transform: translate(-50%, -50%); width: 20%; height: 32%; color: white; font-size: 2vh; padding: 5px; overflow: auto; } .ac-game-chat-field-history::-webkit-scrollbar { width: 0; } .ac-game-chat-field-input { position: absolute; top: 86%; left: 20%; transform: translate(-50%, -50%); width: 20%; height: 3vh; color: white; font-size: 2vh; background-color: rgba(222,225,230, 0.2); } 联机聊天窗 前端 playground/chat_field/zbase.js\nclass ChatField { ... add_listening_events() { ... this.$input.keydown(function(e) { ... else if (e.which === 13) { ... if (text) { ... outer.playground.mps.send_message(text); } ... } }); } ... } js/src/playground/socket/multiplayer/zbase.js\nclass MultiPlayerSocket { ... send_message(text) { let outer = this; this.ws.send(JSON.stringify({ \u0026#39;event\u0026#39;: \u0026#34;message\u0026#34;, \u0026#39;uuid\u0026#39;: outer.uuid, \u0026#39;username\u0026#39;: outer.playground.root.settings.username, \u0026#39;text\u0026#39;: text, })); } receive_message(username, text) { this.playground.chat_field.add_message(username, text); } } 后端 consumers/multiplayer/index.py\n... class MultiPlayer(AsyncWebsocketConsumer): ... async def message(self, data): await self.channel_layer.group_send( self.room_name, { \u0026#39;type\u0026#39;: \u0026#34;group_send_event\u0026#34;, \u0026#39;event\u0026#39;: \u0026#34;message\u0026#34;, \u0026#39;uuid\u0026#39;: data[\u0026#39;uuid\u0026#39;], \u0026#39;username\u0026#39;: data[\u0026#39;username\u0026#39;], \u0026#39;text\u0026#39;: data[\u0026#39;text\u0026#39;], } ) 实现匹配系统ஐ 9. 实现匹配系统 | 讲义 9.1 上课笔记 | 一只野生彩色铅笔 本章节内容是利用 thrift 创建客户端-服务端交互的接口\n然后利用该接口完成一个匹配系统\n匹配系统由一个消息队列 + 生产者-消费者模型 + 匹配池 完成\n基本与 Linux基础课 里的部分完全一致\n当时我们是拿 cpp 来写的，写了差不多 200 行\n本节会拿 py 来实现，差不多 140 行即可\nthrift 接口文件\nnamespace py match_service service Match { i32 add_player(1: i32 score, 2: string uuid, 3: string username, 4: string photo, 5: string channel_name), } 然后用该源文件生成接口文件\n服务端 配置 asgi.py 让服务端进程可以调用客户端进程里的函数\nacapp/acapp/asgi.py\nimport os import django os.environ.setdefault(\u0026#39;DJANGO_SETTINGS_MODULE\u0026#39;, \u0026#39;acapp.settings\u0026#39;) django.setup() ... from channels.layers import get_channel_layer channel_layer = get_channel_layer() ... acapp/match_system/src/main.py\n#! /usr/bin/env python3 import glob import sys sys.path.insert(0, glob.glob(\u0026#39;../../\u0026#39;)[0]) from match_server.match_service import Match from thrift.transport import TSocket from thrift.transport import TTransport from thrift.protocol import TBinaryProtocol from thrift.server import TServer from queue import Queue from time import sleep from threading import Thread from acapp.asgi import channel_layer from asgiref.sync import async_to_sync from django.core.cache import cache queue = Queue() # 消息队列 class Player: def __init__(self, score, uuid, username, photo, channel_name): self.score = score self.uuid = uuid self.username = username self.photo = photo self.channel_name = channel_name self.waiting_time = 0 # 等待时间 class Pool: def __init__(self): self.players = [] def add_player(self, player): self.players.append(player) def check_match(self, a, b): dt = abs(a.score - b.score) a_max_dif = a.waiting_time * 50 b_max_dif = b.waiting_time * 50 return dt \u0026lt;= a_max_dif and dt \u0026lt;= b_max_dif def match_success(self, ps): print(\u0026#34;Match Success: %s %s %s\u0026#34; % (ps[0].username, ps[1].username, ps[2].username)) room_name = \u0026#34;room-%s-%s-%s\u0026#34; % (ps[0].uuid, ps[1].uuid, ps[2].uuid) players = [] for p in ps: async_to_sync(channel_layer.group_add)(room_name, p.channel_name) players.append({ \u0026#39;uuid\u0026#39;: p.uuid, \u0026#39;username\u0026#39;: p.username, \u0026#39;photo\u0026#39;: p.photo, \u0026#39;hp\u0026#39;: 100, }) cache.set(room_name, players, 3600) # 有效时间：1小时 for p in ps: async_to_sync(channel_layer.group_send)( room_name, { \u0026#39;type\u0026#39;: \u0026#34;group_send_event\u0026#34;, \u0026#39;event\u0026#39;: \u0026#34;create_player\u0026#34;, \u0026#39;uuid\u0026#39;: p.uuid, \u0026#39;username\u0026#39;: p.username, \u0026#39;photo\u0026#39;: p.photo, } ) def increase_waiting_time(self): for player in self.players: player.waiting_time += 1 def match(self): while len(self.players) \u0026gt;= 3: self.players = sorted(self.players, key=lambda p: p.score) flag = False for i in range(len(self.players) - 2): a, b, c = self.players[i], self.players[i + 1], self.players[i + 2] if self.check_match(a, b) and self.check_match(a, c) and self.check_match(b, c): self.match_success([a, b, c]) self.players = self.players[:i] + self.players[i + 3:] flag = True break if not flag: break self.increase_waiting_time() class MatchHandler: def add_player(self, score, uuid, username, photo, channel_name): print(\u0026#34;Add Player: %s %d\u0026#34; % (username, score)) player = Player(score, uuid, username, photo, channel_name) queue.put(player) return 0 def get_player_from_queue(): try: return queue.get_nowait() except: return None def worker(): pool = Pool() while True: player = get_player_from_queue() if player: pool.add_player(player) else: pool.match() sleep(1) if __name__ == \u0026#39;__main__\u0026#39;: handler = MatchHandler() processor = Match.Processor(handler) transport = TSocket.TServerSocket(host=\u0026#39;127.0.0.1\u0026#39;, port=9090) tfactory = TTransport.TBufferedTransportFactory() pfactory = TBinaryProtocol.TBinaryProtocolFactory() server = TServer.TThreadedServer( processor, transport, tfactory, pfactory) Thread(target=worker, daemon=True).start() print(\u0026#39;Starting the server...\u0026#39;) server.serve() print(\u0026#39;done.\u0026#39;) 客户端 扩展数据库表，让其可以存放 rank分 的信息\ngame/models/player/player.py\n... class Player(models.Model): ... score = models.IntegerField(default=1500) ... consumers/multiplayer/index.py\nfrom channels.generic.websocket import AsyncWebsocketConsumer import json from django.conf import settings from django.core.cache import cache from thrift import Thrift from thrift.transport import TSocket from thrift.transport import TTransport from thrift.protocol import TBinaryProtocol from match_system.src.match_server.match_service import Match from game.models.player.player import Player from channels.db import database_sync_to_async class MultiPlayer(AsyncWebsocketConsumer): async def connect(self): await self.accept() async def disconnect(self, close_code): if self.room_name: await self.channel_layer.group_discard(self.room_name, self.channel_name) async def create_player(self, data): self.room_name = None self.uuid = data[\u0026#39;uuid\u0026#39;] # Make socket transport = TSocket.TSocket(\u0026#39;127.0.0.1\u0026#39;, 9090) # Buffering is critical. Raw sockets are very slow transport = TTransport.TBufferedTransport(transport) # Wrap in a protocol protocol = TBinaryProtocol.TBinaryProtocol(transport) # Create a client to use the protocol encoder client = Match.Client(protocol) def db_get_player(): return Player.objects.get(user__username=data[\u0026#39;username\u0026#39;]) player = await database_sync_to_async(db_get_player)() # Connect! transport.open() client.add_player(player.score, data[\u0026#39;uuid\u0026#39;], data[\u0026#39;username\u0026#39;], data[\u0026#39;photo\u0026#39;], self.channel_name) # Close! transport.close() async def group_send_event(self, data): if not self.room_name: keys = cache.keys(\u0026#39;*%s*\u0026#39; % (self.uuid)) if keys: self.room_name = keys[0] await self.send(text_data=json.dumps(data)) ... 项目收尾ஐ 加密、压缩js代码 安装 terser :\nsudo apt-get update sudo apt-get install npm sudo npm install terser -g terser 不仅支持文件输入，也支持标准输入。结果会输出到标准输出中。\n使用方式：\nterser xxx.js -c -m 我们将整合 js 文件的脚本修改一下即可：\nscripts/compress_game_js.sh\n#! /bin/bash JS_PATH=/home/acs/acapp/game/static/js/ JS_PATH_DIST=${JS_PATH}dist/ JS_PATH_SRC=${JS_PATH}src/ find $JS_PATH_SRC -type f -name \u0026#39;*.js\u0026#39; | sort | xargs cat | terser -c -m \u0026gt; ${JS_PATH_DIST}game.js echo \u0026#34;yes\u0026#34; | python3 manage.py collectstatic 清理监听函数 在AcAPP关闭之前触发的事件可以通过如下api添加：\nAcWingOS.api.window.on_close(func); 注意：\n同一个页面中，多个 acapp 引入的 js 代码只会加载一次，因此 AC_GAME_OBJECTS 等全局变量是同一个页面、同一个 acapp 的所有窗口共用的 各自创建的局部变量是独立的，比如 new AcGame() 创建出的对象各个窗口是独立的 我们给每一个窗口创建一个 uid 然后根据不同的 uid 进行事件解绑\nplayground/zbase.js\nclass AcGamePlayground { ... create_uuid() { let res = \u0026#34;\u0026#34;; for (let i = 0; i \u0026lt; 8; i ++ ) { let x = parseInt(Math.floor(Math.random() * 10)); //[0, 10) res += x; } return res; } start() { let outer = this; let uuid = this.create_uuid(); $(window).on(`resize.${uuid}`, function() { outer.resize(); }); if (this.root.AcWingOS) { outer.root.AcWingOS.api.window.on_close(function() { $(window).off(`resize.${uuid}`); }); } } ... } 编写每局游戏的结束界面 单独创建一个结束界面，然后游戏结束的时候渲染出该结束界面即可\n因为结束界面要覆盖在游戏界面之上，因此我们需要先修改一下游戏引擎，添加一个 late_update\n在每一帧渲染的内容最后再渲染，从而实现结束界面叠加在游戏界面之上的效果\nac_game_object/zbase.js\n... class AcGameObject { ... late_update() { // 每一帧均会执行一次，且在所有 update 执行完后才执行 } ... } ... let AC_GAME_ANIMATION = function(timestamp) { ... for (let i = 0; i \u0026lt; AC_GAME_OBJECTS.length; i ++ ) { let obj = AC_GAME_OBJECTS[i]; obj.late_update(); } ... } ... 然后我们做一个渲染出结束界面的类\nplayground/score_board/zbase.js\nclass ScoreBoard extends AcGameObject { constructor(playground) { super(); this.playground = playground; this.ctx = this.playground.game_map.ctx; this.state = null; // win-胜利；lose-失败 this.win_img = new Image(); this.win_img.src = \u0026#34;https://cdn.acwing.com/media/article/image/2021/12/17/1_8f58341a5e-win.png\u0026#34;; this.lose_img = new Image(); this.lose_img.src = \u0026#34;https://cdn.acwing.com/media/article/image/2021/12/17/1_9254b5f95e-lose.png\u0026#34;; } start() { } add_listening_events() { // 点击后，返回主页面 let outer = this; let $canvas = this.playground.game_map.$canvas; $canvas.on(\u0026#39;click\u0026#39;, function() { outer.playground.hide(); outer.playground.root.menu.show(); }); } win() { this.state = \u0026#34;win\u0026#34;; let outer = this; setTimeout(function() { outer.add_listening_events(); }, 1000); // 1秒后监听点击事件 } lose() { this.state = \u0026#34;lose\u0026#34;; let outer = this; setTimeout(function() { outer.add_listening_events(); }, 1000); // 1秒后监听点击事件 } late_update() { this.render(); // 渲染在图层最上方 } render() { let len = this.playground.height / 2; if (this.state === \u0026#34;win\u0026#34;) { this.ctx.drawImage(this.win_img, this.playground.width / 2 - len / 2, this.playground.height / 2 - len / 2, len, len); } else if (this.state === \u0026#34;lose\u0026#34;) { this.ctx.drawImage(this.lose_img, this.playground.width / 2 - len / 2, this.playground.height / 2 - len / 2, len, len); } } } 通过游戏结束的逻辑判断，渲染结束界面，同时在结束并返回主菜单的时候，重置游戏元素\n游戏元素重置\nplayground/zbase.js\nclass AcGamePlayground { ... show(mode) { // 打开 playground 界面 ... this.score_board = new ScoreBoard(this); ... } ... hide() { // 清空所有游戏元素 while (this.players \u0026amp;\u0026amp; this.players.length \u0026gt; 0) { this.players[0].destroy(); } if (this.game_map) { this.game_map.destroy(); this.game_map = null; } if (this.notice_board) { this.notice_board.destroy(); this.notice_board = null; } if (this.score_board) { this.score_board.destroy(); this.score_board = null; } this.$playground.empty(); // 清空所有html标签 this.$playground.hide(); } } 游戏结束的逻辑判断\nplayground/player/zbase.js\nclass Player extends AcGameObject { ... update() { ... this.update_win(); ... } update_win() { // 竞赛状态，且只有一名玩家，且改名玩家就是我，则胜利 if (this.playground.state === \u0026#34;fighting\u0026#34; \u0026amp;\u0026amp; this.character === \u0026#34;me\u0026#34; \u0026amp;\u0026amp; this.playground.players.length === 1) { this.playground.state = \u0026#34;over\u0026#34;; this.playground.score_board.win(); } } ... on_destroy() { // 我死亡，且游戏处于竞赛状态，则失败 if (this.character === \u0026#34;me\u0026#34; \u0026amp;\u0026amp; this.playground.state === \u0026#34;fighting\u0026#34;) { this.playground.state = \u0026#34;over\u0026#34; this.playground.score_board.lose(); } ... } } 更新战绩 这里我们完全交给后端来判断\n在处理广播的 attack 信息的时候，先前我们额外留了一个参数 hp\n围绕该 hp 进行续写，若当前房间内 hp 大于 0 的玩家少于等于 1 个\n则对于所有 hp 为 0 的玩家减 rank 分，大于 0 的玩家加 rank 分\nconsumers/multiplayer/index.py\n... class MultiPlayer(AsyncWebsocketConsumer): ... async def attack(self, data): if not self.room_name: return players = cache.get(self.room_name) if not players: return for player in players: if player[\u0026#39;uuid\u0026#39;] == data[\u0026#39;attackee_uuid\u0026#39;]: player[\u0026#39;hp\u0026#39;] -= 25 remain_cnt = 0 for player in players: if player[\u0026#39;hp\u0026#39;] \u0026gt; 0: remain_cnt += 1 if remain_cnt \u0026gt; 1: # 继续进行游戏 if self.room_name: cache.set(self.room_name, players, 3600) else: # 结算 def db_update_player_score(username, score): player = Player.objects.get(user__username=username) player.score += score player.save() for player in players: if player[\u0026#39;hp\u0026#39;] \u0026lt;= 0: await database_sync_to_async(db_update_player_score)(player[\u0026#39;username\u0026#39;], -5) else: await database_sync_to_async(db_update_player_score)(player[\u0026#39;username\u0026#39;], 10) ... ... 添加favicon.ico 这是修正一个小 BUG，之前 web 端一直没有网页显示图标，这里给他加上去\ngame/templates/multiends/web.html\n... \u0026lt;head\u0026gt; ... \u0026lt;link rel=\u0026#34;icon\u0026#34; href=\u0026#34;https://cdn.acwing.com/media/article/image/2021/12/17/1_be4c11ce5f-acapp.png\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; ... 各种环境命令 启动django项目，在~/acapp目录下执行： python3 manage.py runserver 0.0.0.0:8000 每次修改好 game/static 下的文件后，需要在~/acapp目录下运行打包文件： ./scripts/compress_game_js.sh 在定义完一个数据表之后，需要将创建的数据表更新到 django 的数据库中去： $ python3 manage.py makemigrations \u0026gt; Migrations for \u0026#39;game\u0026#39;: \u0026gt; game/migrations/0001_initial.py \u0026gt; - Create model Player $ $ python3 manage.py migrate \u0026gt; Operations to perform: \u0026gt; Apply all migrations: admin, auth, contenttypes, game, sessions \u0026gt; Running migrations: \u0026gt; Applying game.0001_initial... OK 启动nginx服务，用于域名访问： sudo /etc/init.d/nginx start 启动uwsgi服务，用于域名访问： uwsgi --ini scripts/uwsgi.ini 关闭uwsgi服务： sudo pkill -f uwsgi -9 启动 redis-server，用于一键登录： sudo redis-server /etc/redis/redis.conf 启动 Django_channels，用于联机对战，在~/acapp目录下执行： daphne -b 0.0.0.0 -p 5015 acapp.asgi:application 启动thrift服务，用于匹配系统，在~/acapp/match_system/src/目录下执行： ./main.py 版本更新，在术士之战中将 js地址 一栏更新为： // 本地文件夹中对应的文件也需要更改名字 https://app2433.acapp.acwing.com.cn/static/js/dist/game-版本号.js ","permalink":"https://xancoding.cn/posts/acwdjango/","summary":"AcWing Django 框架课 | Colopen\u0026rsquo;s blog AcWing Django 框架课 Django 项目创建 2.1上课笔记 | 栎 2.1上课笔记 | Andrew1729 启动初始项目 django-admin startproject acapp：在当前目录下创建名为acapp的djan","title":"AcWing Django 框架课"},{"content":" 【哈工大】计算机网络 李全龙（全59讲） 【中科大】郑烇、杨坚《计算机网络（自顶向下方法 第7版，James F.Kurose，Keith W.Ross）》 计算机网络（谢希仁版）第七版答案 实战！我用“大白鲨”让你看见 TCP 计算机网络知识梳理 Stanford CS144 Lab Assignment 学习笔记 | ViXbob的博客 《网络是怎样连接的》 《图解 HTTP》 《图解TCP/IP（第5版）》 《计算机网络（第8版）》 《计算机网络：自顶向下方法》 《TCP/IP详解 卷1：协议》 《Wireshark网络分析就这么简单》 《Wireshark网络分析的艺术》 \u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e ","permalink":"https://xancoding.cn/posts/computernetwork/","summary":"【哈工大】计算机网络 李全龙（全59讲） 【中科大】郑烇、杨坚《计算机网络（自顶向下方法 第7版，James F.Kurose，Keith W.Ros","title":"计算机网络"},{"content":" 数据结构与算法 | 我的笔记 代码随想录 x 数据结构与算法 AcWing 算法基础课 AcWing 算法提高课 AcWing 算法进阶课 OI Wiki CP Wiki LeetCode AcWing Luogo Codeforces 《大话数据结构》 《labuladong的算法小抄》 《算法竞赛进阶指南》 《算法（第4版）》 \u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e ","permalink":"https://xancoding.cn/posts/datastructuresandalgorithms/","summary":"数据结构与算法 | 我的笔记 代码随想录 x 数据结构与算法 AcWing 算法基础课 AcWing 算法提高课 AcWing 算法进阶课 OI Wiki CP Wiki LeetCode AcWing Luogo Codeforces 《大话数据结构》 《labuladong","title":"数据结构与算法"},{"content":"正则表达式是什么？ 正则表达式，又称规则表达式，通常被用来检索、替换那些符合某个规则的文本\n正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑\n为什么要学习正则表达式？ 在需要「批量处理文本」的时候，方便「查找」\u0026amp;\u0026amp;「替换」 Linux grep 命令 Python 爬虫 Everthing 搜索文件 推荐阅读 Regulex 正则可视化工具 Regexper 正则可视化工具 正则可视化 正则可视化工具 regex101 在线正则测试工具 regexgen 生成与一组字符串匹配的正则表达式 any-rule 正则大全 多种实际使用场景，正则表达式带来丰富可能性 正则表达式30分钟入门教程 《正则表达式必知必会》 《精通正则表达式》 \u003c!DOCTYPE HTML\u003e \u003c!DOCTYPE HTML\u003e ","permalink":"https://xancoding.cn/posts/regularexpression/","summary":"正则表达式是什么？ 正则表达式，又称规则表达式，通常被用来检索、替换那些符合某个规则的文本 正则表达式是对字符串操作的一种逻辑公式，就是用事先定","title":"正则表达式学习记"},{"content":"LaTex是什么？ LaTeX是一种基于ΤΕΧ的排版系统，常被用于排版期刊文章、书籍、学位论文\n推荐阅读 LaTeXLive 在线 LaTeX 公式编辑器 Overleaf 在线 LaTeX 编辑器 LaTeX 新手上路指南 TeX Live 安装与 LaTeX 基础知识普及 【LaTeX】新手教程：从入门到日常使用 【LaTeX】针对萌新自学者的入门教程 一份不太简短的 LATEX 介绍 《Latex入门》 \u003c!DOCTYPE HTML\u003e ","permalink":"https://xancoding.cn/posts/latex/","summary":"LaTex是什么？ LaTeX是一种基于ΤΕΧ的排版系统，常被用于排版期刊文章、书籍、学位论文 推荐阅读 LaTeXLive 在线 LaTeX 公式编辑器 Overleaf 在线 LaTeX 编辑器 LaTeX 新手上","title":"LaTex学习记"},{"content":"Markdown是什么？ Markdown是一种轻量级标记语言，排版语法简洁，让人们更多地关注内容本身而非排版。它使用易读易写的纯文本格式编写文档，可与HTML混编，可导出 HTML、PDF 以及本身的 .md 格式的文件。因简洁、高效、易读、易写，Markdown被大量使用，如Github、Wikipedia等网站，如各大博客平台：WordPress、Drupal、简书等\nMarkdown常用语法 在markdown中将链接地址或邮箱地址用\u0026lt;\u0026gt;包围，则会被自动转换成可点击的链接。 书写格式如下：\n\u0026lt;https://xancoding.cn\u0026gt; \u0026lt;zag.zj.cn@gmail.com\u0026gt; 解析效果如下：\nhttps://xancoding.cn\nzag.zj.cn@gmail.com\n如果需要避免文本中的符号被当做markdown标识符而发生不必要的格式转化，可以在符号前加\\来避免。 书写格式如下：\n\\*不是斜体\\* 解析效果如下：\n*不是斜体*\n角标 不同于链接，这里的角标内容会被放在文末，点击可以实现跳转。\n书写格式如下：\n请参阅脚注1. [^1] [^1]: 脚注1内容。 请参阅脚注2. [^2] [^2]: 脚注2内容。 解析效果如下：\n请参阅脚注1. 1\n请参阅脚注2. 2\n推荐阅读 Markdown - All You Need to Know Markdown 官方教程 Markdown 指南中文版 《了不起的Markdown》 \u003c!DOCTYPE HTML\u003e 脚注1内容。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n脚注2内容。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://xancoding.cn/posts/markdown/","summary":"Markdown是什么？ Markdown是一种轻量级标记语言，排版语法简洁，让人们更多地关注内容本身而非排版。它使用易读易写的纯文本格式编写","title":"Markdown学习记"},{"content":"AcWing Linux 基础课 AcWing Linux 基础课 | Colopen\u0026rsquo;s blog AcWing Linux 基础课 命令行的艺术 The Missing Semester of Your CS Education Terminal 终端，一个程序，是界面上打开的黑框框本身，shell 运行于其中\nShell 常用文件管理命令 | AcWing Linux 基础课 Shell 语法 | AcWing Linux 基础课 管道、环境变量与常用命令 | AcWing Linux 基础课 常用命令 | AcWing Linux 基础课 《Bash 脚本教程》 第 1 讲 - 课程概览与 Shell | The missing semester of your CS education 第 2 讲 - Shell 工具和脚本 | The missing semester of your CS education 终极 Shell——ZSH 快速入门 zsh Shell是什么？ Shell 是我们通过命令行与操作系统沟通的 程序，是个 命令行解释器 Shell 脚本可以直接在命令行中执行，也可以将一套逻辑组织成一个文件，方便复用 Shell 负责外界与 Linux 内核 的交互，接收用户或其他应用程序的命令，然后把这些命令转化成内核能理解的语言，传给内核，内核是真正干活的，干完之后再把结果返回用户或应用程序 Shell解释器有 sh、bash、zsh... Shell常用命令 ag xxx：搜索当前目录下的所有文件，检索xxx字符串 find /path/to/directory/ -name '*.py'：搜索某个文件路径下的所有*.py文件 history：展示当前用户的历史操作。内容存放在~/.bash_history中 grep xxx：从stdin中读入若干行数据，如果某行中包含xxx，则输出该行；否则忽略该行，用于查找文件里符合条件的字符串 Tmux \u0026amp;\u0026amp; Vim Tmux和Vim | AcWing Linux 基础课 Tmux 使用教程 | 阮一峰的网络日志 Tmux 简介与使用 | Huoty\u0026rsquo;s Blog 简明 VIM 练级攻略 | 酷壳 第 3 讲 - 编辑器 (Vim) | The missing semester of your CS education VIM 大冒险 - Game Tmux 是什么？ Tmux 是一个用于在终端窗口中运行多个终端会话的工具，即终端复用软件（terminal multiplexer）\n远程 SSH 访问服务器进行工作时。即使非正常掉线，它能保存当前工作状态，并保证当前任务继续运行。\nTmux \u0026amp;\u0026amp; Session \u0026amp;\u0026amp; Window \u0026amp;\u0026amp; Pane 一个tmux 可以有好多个session(会话) 一个session可以有好多个window(窗口) 一个window可以有好多个pane(面板) 一个session里不超过10个window是最方便的：可以用0到9迅速切换 Tmux常用命令 Ac-Terminal 下前缀键被修改成了 Ctrl + a，一般的默认情况下是 Ctrl + b\ntmux new -s \u0026lt;session-name\u0026gt;：新建会话 tmux detach $or$ Ctrl + a d：分离会话，退出当前 Tmux 窗口，但是会话和里面的进程仍然在后台运行 tmux attach -t \u0026lt;session-name\u0026gt;：重新接入某个已存在的会话 tmux kill-session -t \u0026lt;session-name\u0026gt;：杀死某个会话 tmux switch -t \u0026lt;session-name\u0026gt;：切换会话 tmux rename-session -t \u0026lt;old-name\u0026gt; \u0026lt;new-name\u0026gt;：重命名会话 tmux ls $or$ Ctrl + a s：查看当前所有的 Tmux 会话 在tmux中选中文本时，需要按住 shift 键 tmux中复制/粘贴文本： 按下 Ctrl + a 后松开手指，然后按 [ 用鼠标选中文本，被选中的文本会被自动复制到tmux的剪贴板 按下 Ctrl + a 后松开手指，然后按 ] ，会将剪贴板中的内容粘贴到光标处 Vim 是什么？ VIM 是 Linux 系统上一款文本编辑器，它是操作 Linux 的一款利器。\nVim常用命令 一般模式切换到编辑模式（常用） i : 在光标所处位置 直接 开始 a : 在光标所处位置的 下一个字符 开始 o : 在光标所处位置的 下一行 开始 r : 取代当前光标处的字符，然后开始 [ESC] : 退出编辑模式，回到一般模式 光标移动操作 n\u0026lt;Space\u0026gt; : n 为数字，光标 向右移动这一行的n个字符 n\u0026lt;Enter\u0026gt; : n 为数字，光标 向下移动n行 0 或 功能键[Home]: 光标移动到 本行开头 $ 或 功能键[End]: 光标移动到 本行末尾 :n 或 nG : n 为数字，光标移动到 第n行 G: 光标移动到 最后一行 gg : 光标移动到 第一行 查找、替换操作 /word : 向 光标之下 寻找 第一个值为 word 的字符串 ?word : 向 光标之上 寻找 第一个值为 word 的字符串 n : 重复 前一个 查找操作 N : 反向 重复 前一个 查找操作 :n1,n2s/word1/word2/g : n1 与 n2 为数字，在第 n1 行与 n2 行之间寻找 word1 这个字符串，并将该字符串 替换 为 word2 :1,$s/word1/word2/g : 将全文的 word1 替换为 word2 :1,$s/word1/word2/gc : 将全文的 word1 替换为 word2，且在替换前 要求用户确认 文本操作（可搭配 数字+\u0026lt;Enter\u0026gt;/\u0026lt;Space\u0026gt;、0、G、$ 等使用，达到预期组合效果） v : 选中文本 d : 删除选中的文本 dd : 删除当前行 y : 复制选中的文本 yy : 复制当前行 p : 将复制的数据在光标的下一行/下一个位置 粘贴 u : 撤销 Ctrl + r : 取消撤销 \u0026gt; : 将选中的文本整体 向右缩进一次 \u0026lt; : 将选中的文本整体 向左缩进一次 命令行操作 :w : 保存 :w! : 强制保存 :q : 退出 :q! : 强制退出 :wq : 保存并退出 :set paste : 设置成粘贴模式，取消代码自动缩进 :set nopaste : 取消粘贴模式，开启代码自动缩进 :set nu : 显示行号 :set nonu : 隐藏行号 :noh：关闭查找关键词高亮 Ctrl + q : 当vim卡死时，可以 取消当前正在执行的命令 SSH SSH | AcWing Linux 基础课 Adding a new SSH key to your GitHub account SSH是什么？ SSH是一种网络协议，用于计算机之间的加密登录\nSSH 免密登录 ssh-key-gen ：在本地服务器生成密钥 cd .ssh/ vim config ：定义服务器别名 Host server HostName 服务器IP地址 User 登录用户名 port 远程主机端口号，默认为 22 ssh-copy-id server：在本地服务器配置免密登录至云服务器 免密登录至docker 容器步骤同上 配置完成后，就可以直接使用 ssh server 免密登录啦 SCP SCP | AcWing Linux 基础课 SCP是什么？ SCP是一个命令行程序，可让您在计算机之间安全地复制文件和目录\nSCP 传文件 复制多个文件：scp source1 source2 LOCAL_PATH SERVER:SERVER_PATH 复制文件夹 ： scp -r ~/tmp SERVER:/home/acs/：将本地家目录中的tmp文件夹复制到服务器中的/home/acs/目录下 scp -r SERVER:homework .：将服务器中的~/homework/文件夹复制到本地的当前路径下 Git Git | AcWing Linux 基础课 Git从放弃到入门 Git从放弃到入门：状态与阶段 Git从放弃到入门：撤销操作 Git 原理入门 Learn Git Braching - Game Pro Git Online Git是什么？ Git是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理\nGit常用命令 常用命令 git add XX：将XX文件添加到暂存区 git commit -m \u0026quot;给自己看的备注信息\u0026quot;：将暂存区的内容提交到当前分支 git push -u (第一次需要 -u 以后不需要) ：将当前分支推送到远程仓库 git clone git@git.acwing.com:xxx/XXX.git：将远程仓库XXX下载到当前目录下 git log：查看当前分支的所有版本 git status：查看仓库状态 有时候暂存了更改，尚未提交至仓库，如何取消暂存的更改？ git restore --staged XX或git reset HEAD XX：将XX从暂存区里移除 有时候修改了本地工作目录（通常也叫工作区）的文件，如何放弃本地更改（尚未暂存）？ git checkout XX或git restore XX：将XX文件尚未加入暂存区的修改全部撤销 Git 全局设置 git config --global user.name xxx：设置全局用户名，信息记录在~/.gitconfig文件中 git config --global user.email xxx@xxx.com：设置全局邮箱地址，信息记录在~/.gitconfig文件中 git init：将当前目录配置成git仓库，信息记录在隐藏的.git文件夹中 Git 查看命令 git diff XX：查看XX文件相对于暂存区修改了哪些内容 git status：查看仓库状态 git log：查看当前分支的所有版本 git log --pretty=oneline：用一行来显示 git reflog：查看HEAD指针的移动历史（包括被回滚的版本） git branch：查看所有分支和当前所处分支 git pull ：将远程仓库的当前分支与本地仓库的当前分支合并 Git 删除命令 git rm --cached XX：将文件从仓库索引目录中删掉，不希望管理这个文件 git restore --staged xx：将xx从暂存区里移除 git checkout — XX或git restore XX：将XX文件尚未加入暂存区的修改全部撤销 Git 代码回滚 git reset --hard HEAD^或git reset --hard HEAD~ ：将代码库回滚到上一个版本 git reset --hard HEAD^^：往上回滚两次，以此类推 git reset --hard HEAD~100：往上回滚100个版本 git reset --hard 版本号：回滚到某一特定版本 Git 远程仓库 git remote add origin git@git.acwing.com:xxx/XXX.git：将本地仓库关联到远程仓库 git push -u (第一次需要-u以后不需要) ：将当前分支推送到远程仓库 git push origin branch_name：将本地的某个分支推送到远程仓库 git clone git@git.acwing.com:xxx/XXX.git：将远程仓库XXX下载到当前目录下 git push --set-upstream origin branch_name：设置本地的branch_name分支对应远程仓库的branch_name分支 git push -d origin branch_name：删除远程仓库的branch_name分支 git checkout -t origin/branch_name：将远程的branch_name分支拉取到本地 git pull：将远程仓库的当前分支与本地仓库的当前分支合并 git pull origin branch_name：将远程仓库的branch_name分支与本地仓库的当前分支合并 git branch --set-upstream-to=origin/branch_name1 branch_name2：将远程的 branch_name1分支与本地的branch_name2分支对应 Git 分支命令 git branch branch_name：创建新分支 git branch：查看所有分支和当前所处分支 git checkout -b branch_name：创建并切换到branch_name这个分支 git checkout branch_name：切换到branch_name这个分支 git merge branch_name：将分支branch_name合并到当前分支上 git branch -d branch_name：删除本地仓库的branch_name分支 git push --set-upstream origin branch_name：设置本地的branch_name分支对应远程仓库的branch_name分支 git push -d origin branch_name：删除远程仓库的branch_name分支 git checkout -t origin/branch_name：将远程的branch_name分支拉取到本地 git pull ：将远程仓库的当前分支与本地仓库的当前分支合并 git pull origin branch_name：将远程仓库的branch_name分支与本地仓库的当前分支合并 git branch --set-upstream-to=origin/branch_name1 branch_name2：将远程的 branch_name1分支与本地的branch_name2分支对应 Git stash 暂存 git stash：将工作区和暂存区中尚未提交的修改存入栈中 git stash apply：将栈顶存储的修改恢复到当前分支，但不删除栈顶元素 git stash drop：删除栈顶存储的修改 git stash pop：将栈顶存储的修改恢复到当前分支，同时删除栈顶元素 git stash list：查看栈中所有元素 Git更换远程仓库地址 git remote -v # 查看远端地址 git remote # 查看远端仓库名 git remote rm origin # 删除远程的仓库 git remote add origin https://github.com/xx/xx.git （新地址） # 重新添加远程仓库 git push --set-upstream origin master 本地项目上传到GitHub 配置ssh-key实现本地与Git服务器免密交互 ssh-keygen # 生成密钥 cat .ssh/id_rsa.pub # 复制密钥，提交到 git 服务器的 ssh 密钥中 按照下面的操作在本地文件夹配置一下Git： git config --global user.name xxx # 设置用户名 git config --global user.email xxx@xxx.com # 设置用户邮箱 git init git add . git commit -m \u0026#34;xxx\u0026#34; git remote add origin https://github.com/xxx/XXX.git # 建立连接 git push -u origin master .gitignore的作用 工程常识：缓存文件，可执行文件，编译文件 不要传到自己的 git 项目里\n.gitignore的作用就是帮助我们在git add时将我们指定的一些文件自动排除在外，不提交到git当中\n在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件\nThrift Thrift | AcWing Linux 基础课 Thrift_learning - AcGit AcWing Linux 基础课 | Colopen\u0026rsquo;s blog | Thrift thrift 官网 -\u0026gt; Tutorial -\u0026gt; tutorial.thrift Thrift是什么？ Thrift是一个轻量级、跨语言的远程过程服务调用（RPC）框架\nRPC（远程过程调用）是一个计算机通信协议，该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程\nThrift用于跨语言服务开发，它将软件栈和代码生成引擎结合在一起，以构建在 C++、Java、Python、PHP、Ruby、Erlang、Perl、Haskell、C#、Cocoa、JavaScript、Node. Js、Smalltalk、OCaml 和 Delphi 等语言之间高效、无缝地工作的服务\n例：实现一个游戏的匹配服务 基本框架 游戏应用端 game（Python3） 客户端：与 匹配系统服务器 的服务端交互 匹配系统服务器 match_system（C++） 服务端：与 游戏应用端 的客户端交互 客户端：与 数据存储服务器 的服务端交互 数据存储服务器（已经实现） 服务端：与 匹配系统服务器 的客户端交互 文件结构 |-- README.md |-- game | `-- src | |-- client.py | `-- match_client | |-- __init__.py | |-- __pycache__ | | `-- __init__.cpython-38.pyc | `-- match | |-- Match.py | |-- __init__.py | |-- __pycache__ | | |-- Match.cpython-38.pyc | | |-- __init__.cpython-38.pyc | | `-- ttypes.cpython-38.pyc | |-- constants.py | `-- ttypes.py |-- match_system | `-- src | |-- Match.o | |-- Save.o | |-- main | |-- main.cpp | |-- main.o | |-- match_server | | |-- Match.cpp | | |-- Match.h | | |-- match_types.cpp | | `-- match_types.h | |-- match_types.o | `-- save_client | |-- Save.cpp | |-- Save.h | `-- save_types.h `-- thrift |-- match.thrift `-- save.thrift 实现过程 定义接口 (thrift 文件夹用于存放接口 ) 完成 Server 端 通过match.thrift接口在match_system文件夹下生成 C++版本的服务端 thrift -r --gen cpp tutorial.thrift 将gen cpp 文件夹重命名，如：match_server（区别于之后要在此处生成的client_server） 把 Match_server.skeleton.cpp 移动到当前 src 目录下并重命名为 main.cpp 由于移动了 main.cpp 故需要修改一下 main.cpp 中头文件里关于 Match.h 的引用路径：#include \u0026quot;Match.h\u0026quot; -\u0026gt; #include \u0026quot;match_server/Match.h\u0026quot; 在main.cpp中实现具体业务逻辑 完成 Client 端 通过match.thrift接口在game文件夹下生成 python3 版本的服务端，然后通过修改得到客户端 thrift -r --gen py tutorial.thrift 删掉 Match_remote ，该文件是用 py 实现 服务端 时用的文件，此处我们只需要实现 客户端 功能，因此他没有作用，不妨删掉，让文档简洁一点 利用官网提供的模板，在src文件夹下编写 客户端 文件 client.py 持久化到云端 将 非编译文件 和 非可执行文件 提交到 git 中去（好的工程习惯） Cpp git restore --stage *.o git restore --stage main Python git restore --stage *.pyc # .pyc文件是编译文件，不加入暂存区里 git restore --stage *.swp # .swp文件是缓存文件，不加入暂存区里 注意：先运行服务器后，客户端才能正常运行 Thrift 接口 Match.thrift namespace cpp match_service struct User { 1: i32 id, 2: string name, 3: i32 scores } service Match { i32 add_user(1: User user, 2: string info), i32 remove_user(1: User user, 2: string info), } Save.thrift namespace cpp save_service service Save { /** * username: myserver的名称 * password: myserver的密码的md5值的前8位，用命令md5sum * 用户名密码验证成功会返回0，验证失败会返回1 * 验证成功后，结果会被保存到myserver:homework/lesson_6/result.txt中 */ i32 save_data(1: string username, 2: string password, 3: i32 player1_id, 4: i32 player2_id) } 各版本预览 Match_server:1.0 match_client：创建固定的User from match_client.match import Match from match_client.match.ttypes import User from thrift import Thrift from thrift.transport import TSocket from thrift.transport import TTransport from thrift.protocol import TBinaryProtocol def main(): # Make socket transport = TSocket.TSocket(\u0026#39;localhost\u0026#39;, 9090) # Buffering is critical. Raw sockets are very slow transport = TTransport.TBufferedTransport(transport) # Wrap in a protocol protocol = TBinaryProtocol.TBinaryProtocol(transport) # Create a client to use the protocol encoder client = Match.Client(protocol) # Connect! transport.open() user = User(1, \u0026#39;yxc\u0026#39;, 1500) client.add_user(user, \u0026#34;\u0026#34;) # Close! transport.close() # 调用 main 函数 if __name__ == \u0026#34;__main__\u0026#34;: main() match_server // This autogenerated skeleton file illustrates how to build a server. // You should copy it to another filename to avoid overwriting it. #include \u0026#34;match_server/Match.h\u0026#34; #include \u0026lt;thrift/protocol/TBinaryProtocol.h\u0026gt; #include \u0026lt;thrift/server/TSimpleServer.h\u0026gt; #include \u0026lt;thrift/transport/TServerSocket.h\u0026gt; #include \u0026lt;thrift/transport/TBufferTransports.h\u0026gt; #include\u0026lt;iostream\u0026gt; using namespace ::apache::thrift; using namespace ::apache::thrift::protocol; using namespace ::apache::thrift::transport; using namespace ::apache::thrift::server; using namespace ::match_service; using namespace std; class MatchHandler : virtual public MatchIf { public: MatchHandler() { // Your initialization goes here } int32_t add_user(const User\u0026amp; user, const std::string\u0026amp; info) { // Your implementation goes here printf(\u0026#34;add_user\\n\u0026#34;); return 0; } int32_t remove_user(const User\u0026amp; user, const std::string\u0026amp; info) { // Your implementation goes here printf(\u0026#34;remove_user\\n\u0026#34;); return 0; } }; int main(int argc, char **argv) { int port = 9090; ::std::shared_ptr\u0026lt;MatchHandler\u0026gt; handler(new MatchHandler()); ::std::shared_ptr\u0026lt;TProcessor\u0026gt; processor(new MatchProcessor(handler)); ::std::shared_ptr\u0026lt;TServerTransport\u0026gt; serverTransport(new TServerSocket(port)); ::std::shared_ptr\u0026lt;TTransportFactory\u0026gt; transportFactory(new TBufferedTransportFactory()); ::std::shared_ptr\u0026lt;TProtocolFactory\u0026gt; protocolFactory(new TBinaryProtocolFactory()); TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory); cout \u0026lt;\u0026lt; \u0026#34;Start Match Server\u0026#34; \u0026lt;\u0026lt; endl; server.serve(); return 0; } Match_server:2.0 match_client：根据标准输入来创建User from match_client.match import Match from match_client.match.ttypes import User from thrift import Thrift from thrift.transport import TSocket from thrift.transport import TTransport from thrift.protocol import TBinaryProtocol # 利用 python 在终端读入信息需要引入 stdin from sys import stdin # 将原来的通信 main 函数改写成operate函数，每次需要的时候调用一次建立通信传递信息 # 目的是可以一直不断处理信息 # 然后重写 main 函数，使之能不断从终端读入信息 def operate(op, user_id, user_name, score): # Make socket transport = TSocket.TSocket(\u0026#39;localhost\u0026#39;, 9090) # Buffering is critical. Raw sockets are very slow transport = TTransport.TBufferedTransport(transport) # Wrap in a protocol protocol = TBinaryProtocol.TBinaryProtocol(transport) # Create a client to use the protocol encoder client = Match.Client(protocol) # Connect! transport.open() # 针对 op 参数，分别进行 \u0026#34;增加\u0026#34; 与 \u0026#34;删出\u0026#34; 操作 user = User(user_id, user_name, score) if op == \u0026#34;add\u0026#34;: client.add_user(user, \u0026#34;\u0026#34;) else: client.remove_user(user, \u0026#34;\u0026#34;) # Close! transport.close() def main(): for line in stdin: op, user_id, user_name, score = line.split(\u0026#39; \u0026#39;) operate(op, int(user_id), user_name, int(score)) # 调用 main 函数 if __name__ == \u0026#34;__main__\u0026#34;: main() match_server：自动将用户池中前两个用户匹配到一起 // This autogenerated skeleton file illustrates how to build a server. // You should copy it to another filename to avoid overwriting it. #include \u0026#34;match_server/Match.h\u0026#34; #include \u0026lt;thrift/protocol/TBinaryProtocol.h\u0026gt; #include \u0026lt;thrift/server/TSimpleServer.h\u0026gt; #include \u0026lt;thrift/transport/TServerSocket.h\u0026gt; #include \u0026lt;thrift/transport/TBufferTransports.h\u0026gt; #include\u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; // 需要线程，引入头文件 #include \u0026lt;mutex\u0026gt; // 互斥信号量 #include \u0026lt;condition_variable\u0026gt; // 条件变量，用于 阻塞和唤醒 线程 #include \u0026lt;queue\u0026gt; // 用于模拟消息队列 #include \u0026lt;vector\u0026gt; using namespace ::apache::thrift; using namespace ::apache::thrift::protocol; using namespace ::apache::thrift::transport; using namespace ::apache::thrift::server; using namespace ::match_service; using namespace std; struct Task { // 消息队列中的元素 User user; string type; }; struct MessageQueue { // 消息队列 queue\u0026lt;Task\u0026gt; q; // 消息队列本体 mutex m; // 互斥信号量 condition_variable cv; // 条件变量，用于阻塞唤醒线程 }message_queue; class Pool { // 模拟匹配池 public: void save_result(int a, int b) { // 记录成功匹配的信息 printf(\u0026#34;Match Result: %d %d \\n\u0026#34;, a, b); } void match() { // 将匹配池中的第一、第二个用户匹配 while (users.size() \u0026gt; 1) { auto a = users[0], b = users[1]; users.erase(users.begin()); users.erase(users.begin()); save_result(a.id, b.id); } } void add(User user) { // 向匹配池中加入用户 users.push_back(user); } void remove(User user) { // 向匹配池中删除用户 for (uint32_t i = 0; i \u0026lt; users.size(); ++ i) { if (users[i].id == user.id) { users.erase(users.begin() + i); break; } } } private: vector\u0026lt;User\u0026gt; users; // 匹配池中的用户，用 vector 记录 }pool; class MatchHandler : virtual public MatchIf { public: MatchHandler() { // Your initialization goes here } int32_t add_user(const User\u0026amp; user, const std::string\u0026amp; info) { // Your implementation goes here printf(\u0026#34;add_user\\n\u0026#34;); unique_lock\u0026lt;mutex\u0026gt; lck(message_queue.m); // 访问临界区（消息队列），先上锁 message_queue.q.push({user, \u0026#34;add\u0026#34;}); // 把新消息加入消息队列 message_queue.cv.notify_all(); // 唤醒阻塞的线程 return 0; } int32_t remove_user(const User\u0026amp; user, const std::string\u0026amp; info) { // Your implementation goes here printf(\u0026#34;remove_user\\n\u0026#34;); unique_lock\u0026lt;mutex\u0026gt; lck(message_queue.m); // 访问临界区（消息队列），先上锁 message_queue.q.push({user, \u0026#34;remove\u0026#34;}); // 把新消息加入消息队列 message_queue.cv.notify_all(); // 唤醒阻塞的线程 return 0; } }; // 基于“生产者-消费者模型”的线程 void consume_task() { while(true) { unique_lock\u0026lt;mutex\u0026gt; lck(message_queue.m); // 访问临界区（消息队列），先上锁 if (message_queue.q.empty()) { message_queue.cv.wait(lck); // 这里要阻塞进程 // 避免队列为空时，一直反复运行该进程，导致一直占用临界区，而不能加入新消息 } else { auto task = message_queue.q.front(); // 取出消息队列队头元素 message_queue.q.pop(); lck.unlock(); // 临界区访问结束，直接解锁 // 避免后续没用到临界区信息，而长时间占用临界区的情况发生 if (task.type == \u0026#34;add\u0026#34;) pool.add(task.user); else if (task.type == \u0026#34;remove\u0026#34;) pool.remove(task.user); pool.match(); } } } int main(int argc, char **argv) { int port = 9090; ::std::shared_ptr\u0026lt;MatchHandler\u0026gt; handler(new MatchHandler()); ::std::shared_ptr\u0026lt;TProcessor\u0026gt; processor(new MatchProcessor(handler)); ::std::shared_ptr\u0026lt;TServerTransport\u0026gt; serverTransport(new TServerSocket(port)); ::std::shared_ptr\u0026lt;TTransportFactory\u0026gt; transportFactory(new TBufferedTransportFactory()); ::std::shared_ptr\u0026lt;TProtocolFactory\u0026gt; protocolFactory(new TBinaryProtocolFactory()); TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory); cout \u0026lt;\u0026lt; \u0026#34;Start Match Server\u0026#34; \u0026lt;\u0026lt; endl; thread matching_thread(consume_task); // 调用一个线程运行 consume_task server.serve(); return 0; } Match_server:3.0 save_client：因为一个节点只能由一个main方法作为程序的入口，所以匹配系统中的客户端和服务端写在同一个main方法中 // 需要额外引入的头文件 #include \u0026#34;save_client/Save.h\u0026#34; #include \u0026lt;thrift/transport/TSocket.h\u0026gt; #include \u0026lt;thrift/transport/TTransportUtils.h\u0026gt; // 需要额外声明的命名空间 using namespace ::save_service; //重写 save_result 内的内容，使其能够与 \u0026#34;数据存储服务器\u0026#34; 交互 void save_result(int a, int b) { // 记录成功匹配的信息 printf(\u0026#34;Match Result: %d %d\\n\u0026#34;, a, b); // Client端的板子 std::shared_ptr\u0026lt;TTransport\u0026gt; socket(new TSocket(\u0026#34;123.57.47.211\u0026#34;, 9090)); std::shared_ptr\u0026lt;TTransport\u0026gt; transport(new TBufferedTransport(socket)); std::shared_ptr\u0026lt;TProtocol\u0026gt; protocol(new TBinaryProtocol(transport)); SaveClient client(protocol); try { transport-\u0026gt;open(); //调用接口，把信息存储 \u0026#34;数据存储服务器\u0026#34; 中 int res = client.save_data(\u0026#34;acs_4888\u0026#34;, \u0026#34;07637c4c\u0026#34;, a, b); //输出匹配结果 if (!res) puts(\u0026#34;success\u0026#34;); else puts(\u0026#34;fail\u0026#34;); transport-\u0026gt;close(); } catch (TException\u0026amp; tx) { cout \u0026lt;\u0026lt; \u0026#34;ERROR: \u0026#34; \u0026lt;\u0026lt; tx.what() \u0026lt;\u0026lt; endl; } } match_server：每次只匹配分差小于 50 的用户 // This autogenerated skeleton file illustrates how to build a server. // You should copy it to another filename to avoid overwriting it. #include \u0026lt;thrift/transport/TSocket.h\u0026gt; #include \u0026lt;thrift/transport/TTransportUtils.h\u0026gt; #include \u0026#34;match_server/Match.h\u0026#34; #include \u0026#34;save_client/Save.h\u0026#34; #include \u0026lt;thrift/protocol/TBinaryProtocol.h\u0026gt; #include \u0026lt;thrift/server/TSimpleServer.h\u0026gt; #include \u0026lt;thrift/transport/TServerSocket.h\u0026gt; #include \u0026lt;thrift/transport/TBufferTransports.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; // 用于调用 sleep 函数 #include\u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; // 需要线程，引入头文件 #include \u0026lt;mutex\u0026gt; // 互斥信号量 #include \u0026lt;condition_variable\u0026gt; // 条件变量，用于 阻塞和唤醒 线程 #include \u0026lt;queue\u0026gt; // 用于模拟消息队列 #include \u0026lt;vector\u0026gt; using namespace ::apache::thrift; using namespace ::apache::thrift::protocol; using namespace ::apache::thrift::transport; using namespace ::apache::thrift::server; using namespace ::save_service; using namespace ::match_service; using namespace std; struct Task { // 消息队列中的元素 User user; string type; }; struct MessageQueue { // 消息队列 queue\u0026lt;Task\u0026gt; q; // 消息队列本体 mutex m; // 互斥信号量 condition_variable cv; // 条件变量，用于阻塞唤醒线程 }message_queue; class Pool { // 模拟匹配池 public: //重写 save_result 内的内容，使其能够与 \u0026#34;数据存储服务器\u0026#34; 交互 void save_result(int a, int b) { // 记录成功匹配的信息 printf(\u0026#34;Match Result: %d %d \\n\u0026#34;, a, b); // Client端的板子 std::shared_ptr\u0026lt;TTransport\u0026gt; socket(new TSocket(\u0026#34;123.57.47.211\u0026#34;, 9090)); std::shared_ptr\u0026lt;TTransport\u0026gt; transport(new TBufferedTransport(socket)); std::shared_ptr\u0026lt;TProtocol\u0026gt; protocol(new TBinaryProtocol(transport)); SaveClient client(protocol); try { transport-\u0026gt;open(); //调用接口，把信息存储 \u0026#34;数据存储服务器\u0026#34; 中 int res = client.save_data(\u0026#34;acs_4888\u0026#34;, \u0026#34;07637c4c\u0026#34;, a, b); //输出匹配结果 if (!res) puts(\u0026#34;success\u0026#34;); else puts(\u0026#34;fail\u0026#34;); transport-\u0026gt;close(); } catch (TException\u0026amp; tx) { cout \u0026lt;\u0026lt; \u0026#34;ERROR: \u0026#34; \u0026lt;\u0026lt; tx.what() \u0026lt;\u0026lt; endl; } } void match() { // 将匹配池中的第一、第二个用户匹配 while (users.size() \u0026gt; 1) { // 按照 rank分 排序 sort(users.begin(), users.end(), [\u0026amp;](User\u0026amp; a, User\u0026amp; b) { return a.scores \u0026lt; b.scores; }); bool flag = true; for (uint32_t i = 1; i \u0026lt; users.size(); ++ i) { auto a = users[i - 1], b = users[i]; // 两名玩家分数差小于50时进行匹配 if (b.scores - a.scores \u0026lt;= 50) { users.erase(users.begin() + i - 1, users.begin() + i + 1); save_result(a.id, b.id); flag = false; break; } } if (flag) break; // 一轮扫描后，发现没有能够匹配的用户，就停止扫描，等待下次调用 } } void add(User user) { // 向匹配池中加入用户 users.push_back(user); } void remove(User user) { // 向匹配池中删除用户 for (uint32_t i = 0; i \u0026lt; users.size(); ++ i) { if (users[i].id == user.id) { users.erase(users.begin() + i); break; } } } private: vector\u0026lt;User\u0026gt; users; // 匹配池中的用户，用 vector 记录 }pool; class MatchHandler : virtual public MatchIf { public: MatchHandler() { // Your initialization goes here } int32_t add_user(const User\u0026amp; user, const std::string\u0026amp; info) { // Your implementation goes here printf(\u0026#34;add_user\\n\u0026#34;); unique_lock\u0026lt;mutex\u0026gt; lck(message_queue.m); // 访问临界区（消息队列），先上锁 message_queue.q.push({user, \u0026#34;add\u0026#34;}); // 把新消息加入消息队列 message_queue.cv.notify_all(); // 唤醒阻塞的线程 return 0; } int32_t remove_user(const User\u0026amp; user, const std::string\u0026amp; info) { // Your implementation goes here printf(\u0026#34;remove_user\\n\u0026#34;); unique_lock\u0026lt;mutex\u0026gt; lck(message_queue.m); // 访问临界区（消息队列），先上锁 message_queue.q.push({user, \u0026#34;remove\u0026#34;}); // 把新消息加入消息队列 message_queue.cv.notify_all(); // 唤醒阻塞的线程 return 0; } }; // 基于“生产者-消费者模型”的线程 void consume_task() { while(true) { unique_lock\u0026lt;mutex\u0026gt; lck(message_queue.m); // 访问临界区（消息队列），先上锁 if (message_queue.q.empty()) { // message_queue.cv.wait(lck); // 这里要阻塞进程 // 避免队列为空时，一直反复运行该进程，导致一直占用临界区，而不能加入新消息 // 修改为每 1 秒进行一次匹配 lck.unlock(); // 直接解锁临界区资源 pool.match(); //调用 match() sleep(1); } else { auto task = message_queue.q.front(); // 取出消息队列队头元素 message_queue.q.pop(); lck.unlock(); // 临界区访问结束，直接解锁 // 避免后续没用到临界区信息，而长时间占用临界区的情况发生 if (task.type == \u0026#34;add\u0026#34;) pool.add(task.user); else if (task.type == \u0026#34;remove\u0026#34;) pool.remove(task.user); pool.match(); } } } int main(int argc, char **argv) { int port = 9090; ::std::shared_ptr\u0026lt;MatchHandler\u0026gt; handler(new MatchHandler()); ::std::shared_ptr\u0026lt;TProcessor\u0026gt; processor(new MatchProcessor(handler)); ::std::shared_ptr\u0026lt;TServerTransport\u0026gt; serverTransport(new TServerSocket(port)); ::std::shared_ptr\u0026lt;TTransportFactory\u0026gt; transportFactory(new TBufferedTransportFactory()); ::std::shared_ptr\u0026lt;TProtocolFactory\u0026gt; protocolFactory(new TBinaryProtocolFactory()); TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory); cout \u0026lt;\u0026lt; \u0026#34;Start Match Server\u0026#34; \u0026lt;\u0026lt; endl; thread matching_thread(consume_task); // 调用一个线程运行 consume_task server.serve(); return 0; } Match_server:4.0 match_server：随时间扩大匹配域，每一单位的 wt 会扩大 $50$ 分 的匹配域 // This autogenerated skeleton file illustrates how to build a server. // You should copy it to another filename to avoid overwriting it. #include \u0026lt;thrift/transport/TSocket.h\u0026gt; #include \u0026lt;thrift/transport/TTransportUtils.h\u0026gt; #include \u0026#34;match_server/Match.h\u0026#34; #include \u0026#34;save_client/Save.h\u0026#34; #include \u0026lt;thrift/protocol/TBinaryProtocol.h\u0026gt; #include \u0026lt;thrift/server/TSimpleServer.h\u0026gt; #include \u0026lt;thrift/transport/TServerSocket.h\u0026gt; #include \u0026lt;thrift/transport/TBufferTransports.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; // 用于调用 sleep 函数 #include\u0026lt;iostream\u0026gt; #include \u0026lt;thread\u0026gt; // 需要线程，引入头文件 #include \u0026lt;mutex\u0026gt; // 互斥信号量 #include \u0026lt;condition_variable\u0026gt; // 条件变量，用于 阻塞和唤醒 线程 #include \u0026lt;queue\u0026gt; // 用于模拟消息队列 #include \u0026lt;vector\u0026gt; using namespace ::apache::thrift; using namespace ::apache::thrift::protocol; using namespace ::apache::thrift::transport; using namespace ::apache::thrift::server; using namespace ::save_service; using namespace ::match_service; using namespace std; struct Task { // 消息队列中的元素 User user; string type; }; struct MessageQueue { // 消息队列 queue\u0026lt;Task\u0026gt; q; // 消息队列本体 mutex m; // 互斥信号量 condition_variable cv; // 条件变量，用于阻塞唤醒线程 }message_queue; class Pool { // 模拟匹配池 public: void save_result(int a, int b) { // 记录成功匹配的信息 printf(\u0026#34;Match Result: %d %d \\n\u0026#34;, a, b); // Client端的板子 std::shared_ptr\u0026lt;TTransport\u0026gt; socket(new TSocket(\u0026#34;123.57.47.211\u0026#34;, 9090)); std::shared_ptr\u0026lt;TTransport\u0026gt; transport(new TBufferedTransport(socket)); std::shared_ptr\u0026lt;TProtocol\u0026gt; protocol(new TBinaryProtocol(transport)); SaveClient client(protocol); try { transport-\u0026gt;open(); //调用接口，把信息存储 \u0026#34;数据存储服务器\u0026#34; 中 int res = client.save_data(\u0026#34;acs_4888\u0026#34;, \u0026#34;07637c4c\u0026#34;, a, b); //输出匹配结果 if (!res) puts(\u0026#34;success\u0026#34;); else puts(\u0026#34;fail\u0026#34;); transport-\u0026gt;close(); } catch (TException\u0026amp; tx) { cout \u0026lt;\u0026lt; \u0026#34;ERROR: \u0026#34; \u0026lt;\u0026lt; tx.what() \u0026lt;\u0026lt; endl; } } bool check_match(uint32_t i, uint32_t j) { auto a = users[i], b = users[j]; int dt = abs(a.scores - b.scores); int a_max_dif = wt[i] * 50; int b_max_dif = wt[j] * 50; return dt \u0026lt;= a_max_dif \u0026amp;\u0026amp; dt \u0026lt;= b_max_dif; } void match() { for (uint32_t i = 0; i \u0026lt; wt.size(); ++ i) wt[i] ++; while (users.size() \u0026gt; 1) { bool flag = true; for (uint32_t i = 0; i \u0026lt; users.size(); ++ i) { for (uint32_t j = i + 1; j \u0026lt; users.size(); ++ j) { if (check_match(i, j)) { auto a = users[i], b = users[j]; users.erase(users.begin() + j); users.erase(users.begin() + i); wt.erase(wt.begin() + j); wt.erase(wt.begin() + i); save_result(a.id, b.id); flag = false; break; } if (!flag) break; } } if (flag) break; // 一轮扫描后，发现没有能够匹配的用户，就停止扫描，等待下次调用 } } void add(User user) { // 向匹配池中加入用户 users.push_back(user); wt.push_back(0); } void remove(User user) { // 向匹配池中删除用户 for (uint32_t i = 0; i \u0026lt; users.size(); ++ i) { if (users[i].id == user.id) { users.erase(users.begin() + i); wt.erase(wt.begin() + i); break; } } } private: vector\u0026lt;User\u0026gt; users; // 匹配池中的用户，用 vector 记录 vector\u0026lt;int\u0026gt; wt; // 等待时间，单位：s }pool; class MatchHandler : virtual public MatchIf { public: MatchHandler() { // Your initialization goes here } int32_t add_user(const User\u0026amp; user, const std::string\u0026amp; info) { // Your implementation goes here printf(\u0026#34;add_user\\n\u0026#34;); unique_lock\u0026lt;mutex\u0026gt; lck(message_queue.m); // 访问临界区（消息队列），先上锁 message_queue.q.push({user, \u0026#34;add\u0026#34;}); // 把新消息加入消息队列 message_queue.cv.notify_all(); // 唤醒阻塞的线程 return 0; } int32_t remove_user(const User\u0026amp; user, const std::string\u0026amp; info) { // Your implementation goes here printf(\u0026#34;remove_user\\n\u0026#34;); unique_lock\u0026lt;mutex\u0026gt; lck(message_queue.m); // 访问临界区（消息队列），先上锁 message_queue.q.push({user, \u0026#34;remove\u0026#34;}); // 把新消息加入消息队列 message_queue.cv.notify_all(); // 唤醒阻塞的线程 return 0; } }; // 基于“生产者-消费者模型”的线程 void consume_task() { while(true) { unique_lock\u0026lt;mutex\u0026gt; lck(message_queue.m); // 访问临界区（消息队列），先上锁 if (message_queue.q.empty()) { // message_queue.cv.wait(lck); // 这里要阻塞进程 // 避免队列为空时，一直反复运行该进程，导致一直占用临界区，而不能加入新消息 // 修改为每 1 秒进行一次匹配 lck.unlock(); // 直接解锁临界区资源 pool.match(); //调用 match() sleep(1); } else { auto task = message_queue.q.front(); // 取出消息队列队头元素 message_queue.q.pop(); lck.unlock(); // 临界区访问结束，直接解锁 // 避免后续没用到临界区信息，而长时间占用临界区的情况发生 if (task.type == \u0026#34;add\u0026#34;) pool.add(task.user); else if (task.type == \u0026#34;remove\u0026#34;) pool.remove(task.user); } } } int main(int argc, char **argv) { int port = 9090; ::std::shared_ptr\u0026lt;MatchHandler\u0026gt; handler(new MatchHandler()); ::std::shared_ptr\u0026lt;TProcessor\u0026gt; processor(new MatchProcessor(handler)); ::std::shared_ptr\u0026lt;TServerTransport\u0026gt; serverTransport(new TServerSocket(port)); ::std::shared_ptr\u0026lt;TTransportFactory\u0026gt; transportFactory(new TBufferedTransportFactory()); ::std::shared_ptr\u0026lt;TProtocolFactory\u0026gt; protocolFactory(new TBinaryProtocolFactory()); TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory); cout \u0026lt;\u0026lt; \u0026#34;Start Match Server\u0026#34; \u0026lt;\u0026lt; endl; thread matching_thread(consume_task); // 调用一个线程运行 consume_task server.serve(); return 0; } Usage # 启动服务端 ./match_system/src/main # 启动客户端 python3 game/src/client.py # 游戏应用端 （op id name scores） add 1 yxc 2000 add 2 xan 1500 add 3 zagy 2500 remove 3 zagy 2500 # 匹配系统服务器 add_user add_user remove_user # 等待了 10 s Match Result: 1 2 success 项目地址 Learning-Thrift Docker Docker | AcWing Linux 基础课 Docker 入门教程 | 阮一峰的网络日志 Docker是什么？ Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中,然后发布到任何流行的Linux或Windows操作系统的机器上\nDocker常用命令 镜像（images） docker images：列出本地所有镜像 docker image rm ubuntu:20.04：删除镜像ubuntu:20.04 docker commit CONTAINER_NAME IMAGE_NAME:TAG：创建某个container的镜像，TAG 为镜像标签，用以记录当前版本。 docker save -o ubuntu_20_04.tar ubuntu:20.04：将镜像ubuntu:20.04导出到本地文件ubuntu_20_04.tar中 docker load -i ubuntu_20_04.tar：将镜像ubuntu:20.04从本地文件ubuntu_20_04.tar中加载出来 容器(container) docker ps -a：查看本地的所有容器 docker start CONTAINER：启动容器 docker stop CONTAINER：停止容器 docker restart CONTAINER：重启容器 docker rm CONTAINER：删除容器 docker run -p HOST_PORT:CONTAINER_PORT --name CONTAINER_NAME -itd IMAGE_NAME:TAG：将创建并启动一个容器 -p：端口映射，将宿主机的端口和容器的端口进行映射 例：-p 20000:22 -p 8000:8000 -p 80:80 -p 443:443 22：ssh登录服务端口 8000：Django调试端口 80：用于HTTP服务 443：用于HTTPS服务 docker attach CONTAINER：进入容器 先按Ctrl-p，再按Ctrl-q可以挂起容器 Docker环境配置 scp django_lesson_1_0.tar server：将docker压缩包传至云服务器 ssh server：免密登录至云服务器 docker load -i django_lesson_1_0.tar：将docker压缩包解压缩成docker镜像 docker run -p 20000:22 8000:8000 --name django -itd django_lesson:1.0 ：利用 镜像django_lesson:1.0 创建一个命名为 django 的 docker容器并启动 docker attach my_docker_server：进入创建的docker容器（服务器） adduser acs：创建acs用户 usermod -aG sudo acs：为acs用户分配sudo权限 scp .bashrc .vimrc .tmux.conf django：将本地服务器的bash\u0026amp;vim\u0026amp;tmux配置文件传至docker 容器 Docker项目迁移 第一步，登录容器，关闭所有运行中的任务\n第二步，登录运行容器的服务器，然后执行：\ndocker commit CONTAINER_NAME django_lesson:1.1 # 将容器保存成镜像，将CONTAINER_NAME替换成容器名称 docker stop CONTAINER_NAME # 关闭容器 docker rm CONTAINER_NAME # 删除容器 增加容器的映射端口 : 80 与 443 给运行中的容器，开通端口，是一件非常麻烦的事情\n一个比较好的解决方案 : 先把容器保存成镜像，再删掉容器，然后用镜像生成新的容器，同时打开需要的端口\n第一步，登录容器，关闭所有运行中的任务\n第二步，登录运行容器的服务器，然后执行 :\ndocker commit CONTAINER_NAME django_lesson:1.1 # 将容器保存成镜像，将CONTAINER_NAME替换成容器名称 docker stop CONTAINER_NAME # 关闭容器 docker rm CONTAINER_NAME # 删除容器 # 使用保存的镜像重新创建容器 docker run -p 20000:22 -p 8000:8000 -p 80:80 -p 443:443 --name CONTAINER_NAME -itd django_lesson:1.1 第三步，去云服务器控制台，在安全组配置中开放80和443端口\n","permalink":"https://xancoding.cn/posts/acwlinux/","summary":"AcWing Linux 基础课 AcWing Linux 基础课 | Colopen\u0026rsquo;s blog AcWing Linux 基础课 命令行的艺术 The Missing Semester of Your CS Education Terminal 终端，一个程序，是界面上打开的黑框框本身，shell 运行于其中 Shell 常用文件管理","title":"AcWing Linux 基础课"},{"content":"双拼学习记 前段时间了解了双拼输入法，只是一直没有时间去学。这段时间事情慢慢少点了，准备着手开始学习。双拼只需要按键两次便可以输入一个汉字，我感觉这样的设计更为合理，要是熟练掌握，会很有节奏感，打字速度也可以得到提升。\n更换一个新的输入法，刚开始时肯定会很别扭。使用双拼进行输入，需要对要打的字的音形熟悉，不然是打不出来的。刚好重新学习一下拼音，纠正纠正我自己一些错误的发音认知。\n我准备学习小鹤双拼，找了张小鹤双拼的键位图，用作电脑桌面，打字想不起来的时候瞄一眼。\n推荐阅读 小鹤双拼 小鹤入门 双拼学习记 双拼这点东西，up居然讲了十分钟——十分钟了解双拼到底是啥 ","permalink":"https://xancoding.cn/posts/doublespell/","summary":"双拼学习记 前段时间了解了双拼输入法，只是一直没有时间去学。这段时间事情慢慢少点了，准备着手开始学习。双拼只需要按键两次便可以输入一个汉字，我","title":"双拼学习记"},{"content":"安排好你的待办清单 思考以下几点：\n1. 有哪些工作需要完成？\n2.我有多少时间可以用来完成这些工作？\n3.工作事项是否有逻辑顺序以及优先级\n每一天你都会受到很多的干扰，看到APP上的一个个红点，消息通知从屏幕上弹出。注意力在一次次的查看信息中被逐渐消磨，时间也变得碎片化，难以静下心来专注于某件事。有些干扰无可避免，但只要愿意付出努力，大部分的干扰可以得到排除。\n白天我会尽量避免受到干扰，所有的社交软件，它们是工作效率的最大杀手。我控制自己在上午以及下午的大块时间中忽略来自社交网络的信息，将消息的查看集中在中午以及晚上的特定时间，做一个统一的查看。\n每天的晚上，我会花些的时间，把第二天的工作做个大致的安排，写到待办事项中，第二天再用番茄工作法进行专注执行。记得让自己的计划保持比较高的自由度，要留有足够的时间余量。\n番茄工作法 番茄工作法这个名词我之前便有听说过，但一直未尝试着去做过，直到最近从《软技能》一书中再次看到，感觉不错，便开始了尝试。在经过一个星期的体验后，它确实提高了我的效率，让我能够更好的对自己的时间做出规划。\n它的基本思路是：\n你规划出打算一天之内完成的工作，然后设置一个时长25分钟的定时器，去完成计划中的第一项任务；在这25分钟之内，你只专注于这一项任务，心无旁骛。一旦有干扰，可以用各种方法屏蔽掉干扰，但是通常你要努力保证自己完全不被打扰。总之，你不希望自己的专注的工作状态被打断。\n在25分钟结束的时候，设置一个5分钟的定时器，休息一下。这就是所谓的一个“番茄钟”。每4个番茄钟后，你都需要休息一会儿，通常为15分钟。\n值得注意的是，使用番茄工作法所要做的并不只是集中注意力25分钟这么简单。通过使用番茄工作法，你可以高效跟踪自己一天完成的番茄钟的数量，并为此设定目标。开始的几天，你可能无法对自己能完成的工作做一个很好的估计。但相信在使用番茄工作法一段时间后，你可以做到较为准确的估计，并能完成通过番茄钟的数量，评估自己完成的工作。\n通过使用番茄钟，你可以定量的描述自己的工作状态，而不再像过去那样只是凭借感觉。你可以把每周看作是由有限个番茄钟组成的，知道了自己一周大概能完成的番茄钟的数量后，你也会认识到应该如何通过设置任务的优先级，来合理分配自己的时间。你不会再过高的幻想自己会在一周的时间里完成超出自己实际许多的任务，并在每周结束时，因未能完成而感到沮丧。\n当你在一天中为自己设置了x个番茄钟的工作目标（这一目标你完全可控）并且达成的时候，你就可以知道自己一天到底可以完成多少工作，这会让自己感觉良好，更重要的是，还能让自己放松身心。它不仅能帮你完成更多的工作，还能让你尽情享受业余时间——因为你已经通过番茄钟完成了一天的任务，在剩下的时间里，你完全可以自由安排消磨时间，而不会再有任何的心理负担。\n最后的最后，一定记得要对自己的能力做一个合理的预期，你每周工作40小时并不意味着你能完成80个番茄钟。找到适合你的番茄钟数量，过度的加量会适得其反。\n推荐阅读 Todo清单 一款跨平台待办事项与时间管理应用 如何用Todo清单度过余生的每一天？ 告别社交网络有多难 社交网络名存实亡 Sunset of the social network 《软技能》 生产力篇 \u003c!DOCTYPE HTML\u003e ","permalink":"https://xancoding.cn/posts/timemanagement/","summary":"安排好你的待办清单 思考以下几点： 1. 有哪些工作需要完成？ 2.我有多少时间可以用来完成这些工作？ 3.工作事项是否有逻辑顺序以及优先级 每一天你都会","title":"我管理时间的方法"},{"content":" 这个时代不缺信息，因为信息太多了，缺的是时间\n整个互联网正在充斥着流量内容，而我们得学会如何从垃圾中找到金子\n获取信息的方式最好是主动的，摆脱算法和机器的喂养，自己去挖掘有价值的信息\nRSS Inoreader \u0026amp; RSSHub Radar 什么是RSS? RSS 英文全称为 Really Simple Syndication，即简易资讯聚合。其实叫什么并不重要，我们只用知道它是一个能让你在一个地方订阅各种感兴趣网站的工具。\nRSS的核心是资讯聚合，由用户自己决定信息源。我们可以通过订阅网站的RSS源，主动获得想要的资讯，去挖掘一些自己真正感兴趣的东西。\n如何使用RSS? 利用RSS获取信息，只需要在目标网站上找到RSS链接，并把它添加到RSS阅读器中。\n我使用的工具是Inoreader RSS 阅读器 + RSSHub Radar 浏览器插件。\nInoreader 吸引我的点是它支持PC端和手机端的同步，并且PC端可以直接通过浏览器插件使用，使我在手机和电脑上都可以查看消息。\nRSSHub Radar 的出现，完美解决了不是所有的网页都提供RSS源这一痛点，它可以自动生成网站的RSS源以供订阅，非常方便。\n我使用RSS主要用来订阅我感兴趣的个人博客，我订阅的博客网站在 Links 页面下的 博客 那一栏。\n播客 小宇宙 播客也是一个很好的信息源，可以在做一些不用🧠的事时听。我的使用场景通常是在吃饭或是上下课的路上。我使用的播客软件是小宇宙，体验不错。\n书籍 Neat Reader \u0026amp; Sumatra PDF \u0026amp; Z-Library \u0026amp; LoreFree \u0026amp; 学校图书馆 读书，是治愈迷茫最好的良药。\nNeat Reader 是一款EPUB阅读器，用以阅读EPUB格式的电子书，体验感不错。我会在 Z-Library or LoreFree 上搜索得到我想要看的书的EPUB格式的电子书后，存在本地文件上，通过 Neat Reader 阅读。\n如果找不到EPUB格式的书籍，我会存 PDF 格式的，然后在 Sumatra PDF 上阅读\n不过，相比于电子书，我其实还是更喜欢纸质书的阅读体验。所以，我也会隔段时间便去拿着自己的书单，去学校的图书馆找书看。\n搜索引擎 Google \u0026amp; AdblockPlus \u0026amp; uBlacklist Chrome 浏览器提供的Google 搜索是我目前体验感最好的搜索引擎，Microsoft Edge 浏览器提供的 Bing 搜索 体验感也还不错。\nAdblockPlus 浏览器插件 由用户主动设置拦截网页上不想看到的内容，下图是我对知乎页面的屏蔽后的结果，我使用这个插件把知乎和B站的推荐内容屏蔽，以获得更为简洁的体验\nuBlacklist 浏览器插件 在搜索时屏蔽特定网站，做到对低质内容的过滤，我屏蔽了CSDN和百度知道\n*://www.csdn.net/* *://bbs.csdn.net/* *://blog.csdn.net/* *://zhidao.baidu.com/* Chrome 浏览器还可以通过在地址栏中输入快捷字词，快速搜索特定网站，或使用其他搜索引擎，我通过设置它将知乎和B站作为搜索引擎使用。在我想寻找某条信息时，只需在地址栏输入关键字 zh or bi 即可搜索。\n经过如下配置\n就可以通过在地址栏中输入快捷字词实现简便搜索啦\n在手机端，我是使用桌面小工具来达到只使用APP搜索功能目的。\n推荐阅读 知道RSS的人越少，我就越希望它能被人知道！ RSS 二十年 RSS Source | RSS订阅源推荐 Practical Google Search Tips 优化自己的信息源 中文互联网的产出在渐渐枯萎 ","permalink":"https://xancoding.cn/posts/getinfo/","summary":"这个时代不缺信息，因为信息太多了，缺的是时间 整个互联网正在充斥着流量内容，而我们得学会如何从垃圾中找到金子 获取信息的方式最好是主动的，摆脱算","title":"我获取信息的方式"},{"content":"int main() { printf(\u0026#34;Hello, World\u0026#34;); return(0); } int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello World\u0026#34;; return 0; } public class Main { public static void main(String[] args) { System.out.println(\u0026#34;Hello, World!\u0026#34;); } } echo \u0026#34;Hello, World\u0026#34; Hello, World document.write(\u0026#39;Hello, World\u0026#39;); print (\u0026#34;Hello, World\u0026#34;) ","permalink":"https://xancoding.cn/posts/helloworld/","summary":"int main() { printf(\u0026#34;Hello, World\u0026#34;); return(0); } int main() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello World\u0026#34;; return 0; } public class Main { public static void main(String[] args) { System.out.println(\u0026#34;Hello, World!\u0026#34;); } } echo \u0026#34;Hello, World\u0026#34; Hello, World document.write(\u0026#39;Hello, World\u0026#39;); print (\u0026#34;Hello, World\u0026#34;)","title":"Hello World"},{"content":"About me 𝑯𝒊, 𝑰\u0026rsquo;𝒎 ✨ 𝐗𝐚𝐧 ✨,𝐚 𝐂𝐒 𝐬𝐭𝐮𝐝𝐞𝐧𝐭 𝐟𝐫𝐨𝐦 𝐍𝐂𝐄𝐏𝐔.\n𝐌𝐲 ❤ 𝐡𝐨𝐛𝐛𝐢𝐞𝐬 ❤ 𝐚𝐫𝐞 𝐑𝐮𝐧𝐧𝐢𝐧𝐠, 𝐇𝐢𝐤𝐢𝐧𝐠, 𝐓𝐞𝐜𝐡𝐧𝐨𝐥𝐨𝐠𝐲, 𝐇𝐢𝐬𝐭𝐨𝐫𝐲 𝐚𝐧𝐝 𝐏𝐬𝐲𝐜𝐡𝐨𝐥𝐨𝐠𝐲.\nLife Insights THINK MORE THINK INDEPENDENTLY LESS IS MORE DOING AND READING 背书一定要大声读出来 学习三部曲：WHAT HOW WHY 不要担心错过某条消息——会被你错过的消息，多半不重要，不看也罢；真正重要的消息，你自然不会错过。 Motto The value of a college education is not the learning of many facts but the training of the mind to think.1 Do not try to change yourself.Work to improve the way you perform.2 Projects Blog 搭建工具 Hugo \u0026amp; GitHub Pages \u0026amp; Twikoo Theme：PaperMod 各页面简介 Home：联系方式 \u0026amp; 文章 Tags：文章标签 Archives：文章归档 About：作者简介 \u0026amp; 博客简介 Search：搜索文章 参考资料 Sulv\u0026rsquo;s Blog 3rd\u0026rsquo;s Blog 田少晗的个人博客 WarOfWarlock 搭建工具 HTML \u0026amp; CSS \u0026amp; JavaScript \u0026amp; Django 参考资料 AcWing Django 框架课 | Colopen\u0026rsquo;s blog AcWing Django框架课 Equipment Electronic product PHILIPS 飞利浦台灯 品慧二代66137 —— 京东 179元 三星SAMSUNG 64G U盘 —— 京东 88元 联想拯救者 R7000 —— 京东 6199元 微星 MSI 23.8英寸显示器 —— 京东 833 元 漫步者 W820NB 头戴式蓝牙耳机 —— 京东 299 元 小米显示器挂灯 —— 京东 199元 RK100 有线/蓝牙/无线2.4G三模机械键盘 —— 京东 229元 SAMSUNG 64GB U盘 —— 京东 87 元 小米充电宝 20000mAh 22.5W —— 京东 149元 小米 原装二合一数据线 1m —— 京东 27元 Run COROS高驰 PACE2 竞技运动手表 —— 闲鱼 1200元 特步国人竞速 短裤、背心 —— 闲鱼 259元 QINKUNG长袖 M码 —— 闲鱼 78元 QINKUNG短袖 M码 —— 官网 169元 QINKUNG手套 —— 官网 30元 Nike运动帽 679421 —— 闲鱼 110元 飞影PB 国庆配色 260mm —— 闲鱼 450元 Nike React Infinity Run 白蓝 260mm —— 闲鱼 271元 锐步 Energy3 260mm —— 闲鱼 450元 Outdoor 三峰出雨衣 15D —— 闲鱼 112元 BLACK ICE 黑冰 户外运动P棉服 F8001 S码 —— 淘宝 543元 闲鱼 499元 THERMOS 膳魔师 JNL-502-PRW 珠光白 500mL —— 京东 80元 Snow monster 雪地野人户外手套 —— 闲鱼 120元 Hoka羚羊4 260mm —— 京东 599元 强氧登山包羚羊36L （2 - 3日短线徒步 ） —— 闲鱼 220元 奈特科尔NITECORE头灯 NU25 —— 闲鱼 133元 outdoor research OR 手套 —— 淘宝 58元 Outdoor research VERGLAS 雪套 L码 —— 闲鱼 89元 ROCLKSOLID 美利奴羊毛保暖内衣套装 M码 —— 淘宝 198元 Keith凯斯纯钛饭盒 Ti5328 1000mL —— 闲鱼 179元 Keith凯斯钛杯 Ti3240 350mL —— 闲鱼 79元 钛途TiTo纯钛叉勺 —— 淘宝 19元 凯乐石9A攀岩裤KG520220 金鱼黄 170/74A —— 闲鱼 199元 凯乐石远征者pro 三合一冲锋衣 M码 —— 闲鱼 460元 Osprey小鹰水袋 3L —— 闲鱼 230元 First aid kit Outdoor Trauma 塑料镊子 1把：伤口的精细化处理 安全别针 10枚：固定三角巾纱布止血带等 剪刀 1把：剪开绷带线条等各种用途 创口贴 10片：小创口的止血处理 酒精棉片 10片：对伤口用品的擦拭消毒 碘伏棉片 4片：伤口的消毒、消炎 医用棉签 20根：日常护理使用 三角绷带 1包：胳膊骨折的固定，头部出血的处理 止血带 1卷：压迫伤口止血，固定骨折部位 PBT绷带 1卷：伤口的包扎止血 无纺布胶带 1卷：固定绷带纱布等敷料 纱布片 2片：可与伤口直接接触 Medicine 麝香壮骨膏 4贴：扭伤 挫伤 急救毯 1张：失温 云南白药 2罐：跌打损伤，淤血肿痛，肌肉酸痛及风湿疼痛 板蓝根颗粒 2包：肺胃热盛所致的咽喉肿痛、口咽干燥 Dormitory 运动损伤 创口贴 9片：小创口的止血处理 云南白药 2罐：跌打损伤，淤血肿痛，肌肉酸痛及风湿疼痛 麝香壮骨膏 5贴：扭伤 挫伤 双氯芬酸二乙胺乳胶剂：缓解肌肉、软组织和关节的轻至中度疼痛。如：缓解肌肉、软组织的扭伤、拉伤、挫伤、劳损、腰背部损伤引起的疼痛以及关节疼痛等，也可用于骨关节炎的对症治疗\n外用。按照痛处面积大小，使用本品适量，轻轻揉搓，使本品渗透皮肤，一日3-4 次 胃痛 乳酶生片 100片：促进消化和止泻\n一次2-3片，一日3次，饭前服 健脾颗粒 12袋：健脾开胃 一次1袋，一日2次 三九胃泰颗粒 1袋：上腹隐痛，饱胀，反酸，恶心，呕吐，纳减，心口嘈杂\n开水冲服。一次1袋，一日2次 午时茶颗粒 3袋：恶寒发热、头痛身楚、胸脘满闷、恶心呕吐、腹痛腹泻\n开水冲服。一次1袋，一日1~2次 上火 桂林西瓜霜：急、慢性咽炎，扁桃体炎，口腔炎，口腔溃疡，牙龈炎 外用。敷于患处，每次适量，一日数次 金喉健喷雾剂：风热所致咽痛、咽干、咽喉红肿、牙龈肿痛、口腔溃疡 喷患处。每次适量，一日数次 维生素B2片：口腔溃疡 口服。一次1-2片，一日3次 口炎清颗粒 4袋：阴虚火旺所致的口腔炎症 口服。一次2袋，一日1～2次 皮肤感染 丁酸氢化可的松软膏 2管：过敏性皮炎、脂溢性皮炎、湿疹、瘙痒症和神经性皮炎\n局部外用。取适量本品涂于患处，每日2次。 莫匹罗星软膏 2管：局部外用抗生素，适用于革兰阳性球菌引起的皮肤感染，例如：脓疱病、疖肿、毛囊炎等原发性皮肤感染及湿疹合并感染、溃疡合并感染、创伤合并感染等继发性皮肤感染 外用。局部涂于患处，必要时，患处可用敷料包扎或敷盖，每日3次，5天一疗程。必要时可重复一疗程 感冒 阿奇霉素片 6片：支气管炎、肺炎等下呼吸道感染，鼻窦炎、咽炎、扁桃体炎等上呼吸道感染 每日口服给药一次，整片吞服 三九感冒灵胶囊 10粒：感冒引起的头痛，发热，鼻塞，流涕，咽痛等 口服。一次2粒，一日3次 酚麻美敏片 20片：普通感冒或流行性感冒引起的发热、头痛、四肢酸痛、喷嚏、流鼻涕、鼻塞、咳嗽、咽痛等症状 口服。一次1~2片，每6小时服1次。 24小时内不超过4次 对乙酰氨基酚释缓片：普通感冒或流行感冒引起的发热，轻中度疼痛如头痛、关节痛、偏头痛、牙痛、肌肉痛、神经痛、痛经 口服。成人一次1～2片，若持续发热或疼痛，每8小时一次，24小时不超过3次 盐酸阿比多尔颗粒 12袋：A、B型流感病毒等引起的上呼吸道感染 口服。一次2袋，一日3次，服用5日 Fitness program 采取三分化训练模式，意思是三天以内训练全身，中间也可以比较自由的加入休息日\nDay 1：Chest \u0026amp; Triceps 热身：着重注意胸部肩部颈部以及下背部，热身时间不要超过5分钟。 钻石俯卧撑：每组数量20，做不到20的就做到极限。一共3组。组间休息90秒。 作为最经典的徒手练胸动作，钻石俯卧撑可以在一开始给予胸肌很好的充血感。 动作要点： 注意双脚并拢，脚尖稳定怼地面。 注意髋关节的稳定，尽量保证腿部以及身体呈一条直线。 腹部核心肌群需要全程用力，尽量保证脊柱的中立。 整体动作需要尽量放慢，下降时要抵抗万有引力，上升时要抵抗身体的惯性。重点是胸部肌肉的感受度。 下降到极限时下巴离地面距离要尽可能小。但是千万不要勉强，要保证肩部以及手肘动作不要变形。 火箭俯卧撑：每组数量15，做不到15的就做到极限。一共3组。组间休息90秒。 这是普通俯卧撑的升级强化版，额外强化了对于上胸部的刺激。 动作要点： 注意双脚并拢，双腿伸直，前脚掌稳定怼地面。 髋关节的角度需要固定在120度左右，需要借助下背及核心力量保证腰部和臀部全程稳定避免受伤。（可以参考罗马尼亚硬拉时腰部以及脊椎的位置） 整体动作需要尽量放慢，仔细感受上胸的收缩。（如果动作过快可能会磕歪门牙） 下降到极限时下巴离地面距离也要尽可能小，但同样不可勉强。 推荐在双拳下垫上两块绞干的小毛巾，增加水平方向上的摩擦力，可以更好的发力。 臂屈伸：每组数量12，做不到12的就做到极限。一共4组。组间休息90秒。 动作要点： 这个动作需要保证肩关节的稳定，不可耸肩。 挺胸抬头。 下降时一定要放慢动作，且不可过分下降，不然会给肩关节过大的压力。 Day 2：Back \u0026amp; Biceps 热身：着重注意背部，肩部以及颈部。热身时间不超过5分钟。 仰卧夹背：每组数量12，做不到12的就做到极限。一共3组。组间休息90秒。 这个动作主要训练上背部。 动作要点： 想要充分发挥训练效果的话，推荐在肌肉收缩到顶峰的时候停留2秒。 双腿弯曲，双脚稳定踩在地面。 仅仅利用上背部肌肉发力使身体抬起，腹部核心肌群需要出力保持脊柱不弯曲。 直臂下拉徒手版：每组数量12，做不到12的就做到极限。一共3组。组间休息90秒。 这个动作可以训练到中背部以及背阔肌。 动作要点： 做这个动作有一个前提是地板必须光滑。个人经验是双脚各踩半张A4纸，可以大大减少摩擦力。同时双手洗一下并擦干，再做这个动作可以大大增加手掌和地面的摩擦力。 双臂需要伸直以避免二头肌借力。 肩关节需要稳定住，不然在收缩至顶峰的时候肩膀容易拉伤。 Superman：每组数量12，做不到12的就做到极限。一共3组。组间休息90秒。 这个动作对于下背部的刺激十分到位，而且避免了卷腹。 和仰卧夹背一样，推荐在肌肉收缩到顶峰的时候停留2秒。让超人多飞一会。 Day 3：Hips \u0026amp; Legs \u0026amp; Shoulders 热身：着重注意大腿，腰部，肩膀，斜方肌以及颈部。 无负重深蹲：主要看臀腿肌群的感受度，不超过20次下蹲。一共3组，组间休息90秒。 动作要点： 两脚距离稍比臀宽，脚尖稍稍朝外，身体重量平均分配在两脚掌，保持后背挺直 身体下降时，膝盖不超过脚尖的垂直高度，臀部的往下就像是往板凳上坐一样 与此同时将双手打直往前，维持在胸部的高度 往下时尽全力，注意保持挺胸，后背挺直，逐渐检查自己的膝盖不超过脚尖 臀桥：每组15下，一共3组，组间休息90秒。 动作要点： 注意双臂贴合地面，脚后跟怼地。 同样注意下背部及脊椎的位置，尽量保持中立位（不要驼背）。 肩膀保持稳定不参与发力。 最高点躯干与大腿在同一直线。 顶峰停留2秒。 箭蹲跳：每组90秒，一共三组，休息30秒。 动作要点： 注意膝盖不要触及地面。 动作不宜过快，标准至上。 注意“跳”和“蹲”是两个分开但是连贯的动作。不要混淆了。 单臂侧平举：每侧 RM 8-12，一共4组（两侧算一组） 这个动作可以用到哑铃或者弹力带，也可以请出我们的书包，或者一大包垃圾。 动作要点： 手臂不需要完全伸直，运动过程中手肘朝向后上方，这样可以增加运动路径。 由于是单侧动作，核心肌群需要发力以稳定身体平衡。 动作不宜过快，特别当你拿的重物是书包，过快容易晃来晃去。 Diet BreakFast 6：30 三个鸡蛋 + 馒头 + 豆浆 Extra meal 9：00 牛奶 + 咖啡 + 坚果 Lunch 11：00 三两米饭 + 蔬菜（西兰花）+ 鱼肉 or 鸡胸肉 or 牛肉 Extra meal 2：30 燕麦 + 玉米 or 红薯 + 香蕉 Dinner 5：00 三两米饭 + 蔬菜（西兰花）+ 鱼肉 or 鸡胸肉 or 牛肉 Extra meal 9：00 燕麦 + 全麦面包 + 香蕉 高等教育的价值在于【训练思维】，而不在于传授事实。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n不要试图改变自我，因为这样你不大可能成功。但是，你应该努力改进你的工作方式。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://xancoding.cn/about/","summary":"About me 𝑯𝒊, 𝑰\u0026rsquo;𝒎 ✨ 𝐗𝐚𝐧 ✨,𝐚 𝐂𝐒 𝐬𝐭𝐮𝐝𝐞𝐧𝐭 𝐟𝐫𝐨𝐦 𝐍𝐂𝐄𝐏𝐔.\n𝐌𝐲 ❤ 𝐡𝐨𝐛𝐛𝐢𝐞𝐬 ❤ 𝐚𝐫𝐞 𝐑𝐮𝐧𝐧𝐢𝐧𝐠, 𝐇𝐢𝐤𝐢𝐧𝐠, 𝐓𝐞𝐜𝐡𝐧𝐨𝐥𝐨𝐠𝐲, 𝐇𝐢𝐬𝐭𝐨𝐫𝐲 𝐚𝐧𝐝 𝐏𝐬𝐲𝐜𝐡𝐨𝐥𝐨𝐠𝐲.\nLife Insights THINK MORE THINK INDEPENDENTLY LESS IS MORE DOING AND READING 背书一定要大声读出来 学习三部曲：WHAT HOW WHY 不要担心错过某条消息——会被你错过的消息，多半不重要，不看也罢；真正重要的消息，你自然不会错过。 Motto The value of a college education is not the learning of many facts but the training of the mind to think.1 Do not try to change yourself.Work to improve the way you perform.","title":""},{"content":"CS CS自学指南 小林 x 图解计算机基础 Blogs Stephen Wolfram Seeking the Productive Life: Some Details of My Personal Infrastructure 杨 飞 自 选 作 品 集 面向信仰编程 为什么这么设计 Go 语言设计与实现 Owen 的博客 收集发人深省的话 探索互联网上高质量的内容 程序员的喵 阮一峰的网络日志 编程随想的博客（需翻墙） 学习技术的三部曲：WHAT、HOW、WHY 用提问来促进思维——兼谈【非】技术领域的 WHAT HOW WHY 三部曲 如何完善自己的知识结构 如何挖掘网络资源[0]：为啥要写这个话题？ 如何挖掘网络资源[1]：网站的类型和使用场景 如何挖掘网络资源[2]：Google 搜索的基本语法 如何挖掘网络资源[3]：解答 Google 搜索的常见问题（FAQs） 如何【系统性学习】——从“媒介形态”聊到“DIKW 模型” 为什么独立思考这么难？ 什么是【真正的】兴趣爱好？以及它有啥好处？ 为啥俺很少看视频？——兼谈“视频”与“文本”在认知心理学方面的差异 为啥俺不常用微博？——兼谈时间管理心得 为啥俺要写这个博客——动机的自我分析 如何选择 IT 技术书籍 扫盲“社会工程学”[0]：基本常识 扫盲“社会工程学”[1]：攻击手法之【信息收集】 扫盲“社会工程学”[2]：攻击手法之【假冒身份】 扫盲“社会工程学”[3]：攻击手法之【施加影响】 扫盲“社会工程学”[4]：【综合运用】举例 扫盲“社会工程学”[5]：你该如何【防范】？ 如何成为优秀开发人员[0]：怎样算是优秀的？ 如何成为优秀开发人员[1]：关于兴趣 如何成为优秀开发人员[2]：关于自学能力 如何成为优秀开发人员[3]：设定个人发展目标和计划 如何成为优秀开发人员[4]：做正确的事 如何成为优秀开发人员[5]：正确地做事（概述） 如何成为优秀开发人员[6]：正确地做事（善用工具） 如何成为优秀开发人员[7]：正确地做事（善用自动化） “心智模式”系列：认识你自己——心智模式扫盲介绍 扫盲“货币经济学”基本概念——从“利率”到“央行货币政策” 博弈论入门教程——从基本概念到具体案例 《如何阅读一本书》——书评及内容纲要 书评：《学会提问——批判性思维指南》 书评：《人月神话》——不朽的软件工程名著 书评：《你的灯亮着吗？——找到问题的真正所在》 如何翻墙？ 扫盲 DNS 原理，兼谈“域名劫持”和“域名欺骗/域名污染” 计算机网络通讯的【系统性】扫盲——从“基本概念”到“OSI 模型” 对比4种强化域名安全的协议——DNSSEC，DNSCrypt，DNS over TLS，DNS over HTTPS “对抗专制、捍卫自由”的 N 种技术力量 扫盲文件完整性校验——关于散列值和数字签名 扫盲 netcat（网猫）的 N 种用法——从“网络诊断”到“系统入侵” 扫盲 HTTPS 和 SSL/TLS 协议[0]：引子 扫盲操作系统虚拟机[0]：概述 Tools Exercism 在线练习编程语言 怪异英文生成器 生成比较好看的英文字体，支持复制粘贴 Color Hunt 设计师和艺术家的调色板 Game-icons 游戏图标在线存储库 Movies 海洋之歌 狼行者 凯尔经的秘密 狐狸与我 白日梦想家 Outdoor 入门指南 登山者Black\n户外运动安全手册（上） 户外运动安全手册（下） 洋葱式穿着/户外运动穿什么 户外必备10要素\u0026ndash;可能拯救你生命的十件户外必需品 户外装备选购终极指南 户外急救/户外医疗包 烛逢\n户外运动三层穿衣法 | 烛逢 在野外找路-六只脚｜烛逢 六只脚进阶篇 | 烛逢 两步路使用教学｜烛逢 两步路路网\n下载豌豆荚 在豌豆荚中搜索两步路，下载 v6.7.2版本 在应用商店中关闭自动更新 登山装备清单 B站UP主 History 集思屋 安州牧 唠点历史 小约翰可汗 历史调研室 Outdoor 登山者Black Mew_喵喵 秘密仙人掌 Cartoon 安迪视频 动漫作业本 海贼王 chissy 探险活宝 Community V2EX 面向程序员、极客人群的分享交流社区 Medium 网络文章发布平台 文章质量高 Buzzing 国外社交媒体聚合热榜 中文标题 HackerNews 技术热点话题 新闻社区 小众软件论坛 分享免费、小巧、有趣、实用软件 ","permalink":"https://xancoding.cn/links/","summary":"CS CS自学指南 小林 x 图解计算机基础 Blogs Stephen Wolfram Seeking the Productive Life: Some Details of My Personal Infrastructure 杨 飞 自 选 作 品 集 面向信仰编程 为什么这么设计 Go 语言设计与实现 Owen 的博客 收集发人深省的话 探索互联网上高质量的内容 程序员的喵 阮一峰的网络日志 编程随想的博客（需翻墙） 学习技术的三部曲：WHAT、HOW、WHY 用提问来促进思维——兼谈【非】技术领域的 WHAT HOW WHY 三部曲 如何完善自己的知识结构 如何挖掘网络资源[0]：为啥要写这个话题？ 如何挖掘网络资源[1]：网站的类型和使用场景 如何挖掘网络资源[2]：Google 搜索的基本语法 如何挖掘网络资源[3]：解答 Google 搜索的常见问题（FAQs） 如何【系统性学习】——从“媒介形态”聊到“DIKW 模型” 为什么独立思考这么难？ 什么是【真正的】兴趣爱好？以及它有啥好处？ 为啥俺很少看视频？——兼谈“视频”与“文本”在认知心理学方面的差异 为啥俺不常用微博？——兼谈时间管理心得 为啥俺要写这个博客——动机的自我分析 如何选择 IT 技术书籍 扫盲“社会工程学”[0]：基本常识 扫盲“社会工程学”[1]：攻击手法之【信息收集】 扫盲“社会工程学”[2]：攻击手法之【假冒身份】 扫盲“社会工程学”[3]：攻击手法之【施加影响】 扫盲“社会工程学”[4]：【综合运用】举例 扫盲“社会工程学”[5]：你该如何【防范】？ 如何成为优秀开发人员[0]：怎样算是优秀的？ 如何成为优秀开发人员[1]：关于兴趣 如何成为优秀开发人员[2]：关于自学能力 如何成为优秀开发人员[3]：设定个人发展目标和计划 如何成为优秀开发人员[4]：做正确的事 如何成为优秀开发人员[5]：正确地做事（概述） 如何成为优秀开发人员[6]：正确地做事（善用工具） 如何成为优秀开发人员[7]：正确地做事（善用自动化） “心智模式”系列：认识你自己——心智模式扫盲介绍 扫盲“货币经济学”基本概念——从“利率”到“央行货币政策” 博弈论入门教程——从基本概念到具体案例 《如何阅读一本书》——书评及内容纲要 书评：《学会提问——批判性思维指南》 书评：《人月神话》——不朽的软件工程名著 书评：《你的灯亮着吗？——找到问题的真正所在》 如何翻墙？ 扫盲 DNS 原理，兼谈“域名劫持”和“域名欺骗/域名污染” 计算机网络通讯的【系统性】扫盲——从“基本概念”到“OSI 模型” 对比4种强化域名安全的协议——DNSSEC，DNSCrypt，DNS over TLS，DNS over HTTPS “对抗专制、捍卫自由”的 N 种技术力量 扫盲文件完整性校验——关于散列值和数字签名 扫盲 netcat（网猫）的 N 种用法——从“网络诊断”到“系统入侵” 扫盲 HTTPS 和 SSL/TLS 协议[0]：引子 扫盲操作系统虚拟机[0]：概述 Tools Exercism 在线练习编程语言 怪异英文生成器 生成比较好看的英文字体，支持复制粘贴 Color Hunt 设计师和艺术家的调色板 Game-icons 游戏图标在线存储库 Movies 海洋之歌 狼行者 凯尔经的秘密 狐狸与我 白日梦想家 Outdoor 入门指南 登山者Black","title":""}]