<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>C++ 学习路线 | Xan's Blog</title><meta name=keywords content="Tech,C++,新技能"><meta name=description content="入门 当您在 IDE 中创建新项目时，大多数 IDE 会为您设置两种不同的构建配置：发布配置和调试配置，开发程序时使用调试构建配置。当您准备好将可执行文件发布"><meta name=author content="
作者:&nbsp;Xan"><link rel=canonical href=https://xancoding.cn/posts/learning-cpp/><link crossorigin=anonymous href=/assets/css/stylesheet.3aa01cbced85ddebdb26eab94916f476145cedd3e7231731a39f34d88d6f410a.css integrity="sha256-OqAcvO2F3evbJuq5SRb0dhRc7dPnIxcxo5802I1vQQo=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://xancoding.cn/img/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://xancoding.cn/img/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://xancoding.cn/img/favicon.ico><link rel=apple-touch-icon href=https://xancoding.cn/img/favicon.ico><link rel=mask-icon href=https://xancoding.cn/img/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["[[","]]"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"})</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style><link rel=stylesheet href=//cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.css><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="C++ 学习路线"><meta property="og:description" content="入门 当您在 IDE 中创建新项目时，大多数 IDE 会为您设置两种不同的构建配置：发布配置和调试配置，开发程序时使用调试构建配置。当您准备好将可执行文件发布"><meta property="og:type" content="article"><meta property="og:url" content="https://xancoding.cn/posts/learning-cpp/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-11-15T12:54:07+08:00"><meta property="article:modified_time" content="2022-11-15T12:54:07+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="C++ 学习路线"><meta name=twitter:description content="入门 当您在 IDE 中创建新项目时，大多数 IDE 会为您设置两种不同的构建配置：发布配置和调试配置，开发程序时使用调试构建配置。当您准备好将可执行文件发布"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://xancoding.cn/posts/"},{"@type":"ListItem","position":3,"name":"C++ 学习路线","item":"https://xancoding.cn/posts/learning-cpp/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"C++ 学习路线","name":"C\u002b\u002b 学习路线","description":"入门 当您在 IDE 中创建新项目时，大多数 IDE 会为您设置两种不同的构建配置：发布配置和调试配置，开发程序时使用调试构建配置。当您准备好将可执行文件发布","keywords":["Tech","C++","新技能"],"articleBody":"入门 当您在 IDE 中创建新项目时，大多数 IDE 会为您设置两种不同的构建配置：发布配置和调试配置，开发程序时使用调试构建配置。当您准备好将可执行文件发布给其他人时，或者想要测试性能时，请使用发布构建配置 Debug：调试版本， 包含调试信息，所以 容量比Release大很多， 并且不进行任何优化（优化会使调试复杂化，因为源代码和生成的指令间关系会更复杂），便于程序员调试 Release：发布版本， 不对源代码进行调试，编译时对应用程序的速度进行优化，使得程序在代码大小和运行速度上都是最优的 对于 CLion 用户，您可以添加 Release：按 Alt+Ctrl+S 调出 Settings \u003e Build，Execution，Deployment \u003e CMake \u003e 单击 Profiles 部分中的 + 按钮，将自动添加 Release 选项 禁用编译器扩展以确保您的程序（和编码实践）保持符合 C++ 标准并且可以在任何系统上运行 CLion 使用 CMake 构建项目。 将行 set(CMAKE_CXX_EXTENSIONS OFF) 添加到 CMakeList.txt 以禁用扩展 将你的警告级别调到最大，尤其是在你学习的时候。它将帮助您识别可能的问题 在 Clion（从 2021.3 版本开始）中，要将警告级别调到最高，您可以按 Alt+Ctrl+S 调出 Settings ，然后选择 Editor \u003e Inspections \u003e C/C++，然后手动选中所有框，或者在窗口的右侧，在矩形的 severity 框中选择错误，然后在另一个框中选择 In All Scopes 选择语言标准：在专业环境中，通常选择比最新标准低一个或两个版本的语言标准（例如，现在 C++20 已经出来了，这意味着 C++14 或 C++17）。这样做通常是为了确保编译器制造商有机会解决缺陷，以便更好地理解新功能的最佳实践。在相关的情况下，这也有助于确保更好的跨平台兼容性，因为某些平台上的编译器可能不会立即为更新的语言标准提供全面支持。启用 C++17 语言标准（或更高版本）后，您应该能够在没有任何警告或错误的情况下编译以下代码 #include #include #include #include #include namespace a:🅱️:c { inline constexpr std::string_view str{ \"hello\" }; } template std::tuple","wordCount":"26737","inLanguage":"en","datePublished":"2022-11-15T12:54:07+08:00","dateModified":"2022-11-15T12:54:07+08:00","author":[{"@type":"Person","name":"Xan"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://xancoding.cn/posts/learning-cpp/"},"publisher":{"@type":"Organization","name":"Xan's Blog","logo":{"@type":"ImageObject","url":"https://xancoding.cn/img/favicon.ico"}}}</script><script src=https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://xancoding.cn accesskey=h title="Xan's Blog (Alt + H)"><img src=https://xancoding.cn/img/Headshot.jpg alt aria-label=logo height=35>Xan's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://xancoding.cn/ title=Home><span>Home</span></a></li><li><a href=https://xancoding.cn/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://xancoding.cn/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://xancoding.cn/links/ title=Links><span>Links</span></a></li><li><a href=https://xancoding.cn/about/ title=About><span>About</span></a></li><li><a href=https://xancoding.cn/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://xancoding.cn>Home</a>&nbsp;»&nbsp;<a href=https://xancoding.cn/posts/>Posts</a></div><h1 class=post-title>C++ 学习路线</h1><div class=post-meta>&nbsp;<span title='2022-11-15 12:54:07 +0800 +0800'>2022-11-15</span>&nbsp;|&nbsp;<a href=https://github.com/Xancoding/Blog/tree/main/content/posts/learning-cpp.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e5%85%a5%e9%97%a8 aria-label=入门>入门</a></li><li><a href=#c-%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86 aria-label="C++ 基础知识">C++ 基础知识</a><ul><li><a href=#%e6%b3%a8%e9%87%8a aria-label=注释>注释</a></li><li><a href=#%e5%86%99%e5%9c%a8%e5%89%8d%e9%9d%a2 aria-label=写在前面>写在前面</a></li><li><a href=#%e5%8d%95%e8%a1%8c%e6%b3%a8%e9%87%8a aria-label=单行注释>单行注释</a></li><li><a href=#%e5%a4%9a%e8%a1%8c%e6%b3%a8%e9%87%8a aria-label=多行注释>多行注释</a></li><li><a href=#%e5%88%9d%e5%a7%8b%e5%8c%96 aria-label=初始化>初始化</a></li><li><a href=#stdendl-vs-n aria-label="std::endl vs ‘\n’">std::endl vs ‘\n’</a></li><li><a href=#%e4%bb%a3%e7%a0%81%e7%9a%84%e5%8f%af%e8%af%bb%e6%80%a7 aria-label=代码的可读性>代码的可读性</a></li></ul></li><li><a href=#c-%e5%9f%ba%e7%a1%80%e5%87%bd%e6%95%b0%e5%92%8c%e6%96%87%e4%bb%b6 aria-label="C++ 基础：函数和文件">C++ 基础：函数和文件</a><ul><li><a href=#%e5%87%bd%e6%95%b0%e8%bf%94%e5%9b%9e%e5%80%bc aria-label=函数返回值>函数返回值</a></li><li><a href=#%e5%89%8d%e5%90%91%e5%a3%b0%e6%98%8e%e5%92%8c%e5%ae%9a%e4%b9%89 aria-label=前向声明和定义>前向声明和定义</a></li><li><a href=#%e5%85%b7%e6%9c%89%e5%a4%9a%e4%b8%aacpp%e6%96%87%e4%bb%b6%e7%9a%84%e7%a8%8b%e5%ba%8f aria-label=具有多个cpp文件的程序>具有多个cpp文件的程序</a><ul><li><a href=#cpp-%e6%96%87%e4%bb%b6 aria-label=".cpp 文件">.cpp 文件</a></li><li><a href=#h-%e6%96%87%e4%bb%b6 aria-label=".h 文件">.h 文件</a><ul><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88-iostream-%e6%b2%a1%e6%9c%89-h-%e6%89%a9%e5%b1%95%e5%90%8d aria-label="为什么 iostream 没有 .h 扩展名？">为什么 iostream 没有 .h 扩展名？</a></li><li><a href=#include%e6%9d%a5%e8%87%aa%e5%85%b6%e4%bb%96%e7%9b%ae%e5%bd%95%e7%9a%84%e5%a4%b4%e6%96%87%e4%bb%b6 aria-label=Include来自其他目录的头文件>Include来自其他目录的头文件</a></li><li><a href=#headers-may-include-other-headers aria-label="Headers may include other headers">Headers may include other headers</a></li><li><a href=#include-%e5%a4%b4%e6%96%87%e4%bb%b6%e9%a1%ba%e5%ba%8f aria-label="include 头文件顺序">include 头文件顺序</a></li><li><a href=#header-file-best-practices aria-label="Header file best practices">Header file best practices</a></li><li><a href=#header-guards aria-label="Header guards">Header guards</a><ul><li><a href=#summary aria-label=Summary>Summary</a></li></ul></li><li><a href=#pragma-once aria-label="pragma once">pragma once</a></li></ul></li></ul></li><li><a href=#%e5%91%bd%e5%90%8d%e5%86%b2%e7%aa%81%e5%92%8c%e5%91%bd%e5%90%8d%e7%a9%ba%e9%97%b4%e4%bb%8b%e7%bb%8d aria-label=命名冲突和命名空间介绍>命名冲突和命名空间介绍</a><ul><li><a href=#%e5%91%bd%e5%90%8d%e5%86%b2%e7%aa%81 aria-label=命名冲突>命名冲突</a></li><li><a href=#%e5%91%bd%e5%90%8d%e7%a9%ba%e9%97%b4 aria-label=命名空间>命名空间</a></li></ul></li><li><a href=#%e9%a2%84%e5%a4%84%e7%90%86%e5%99%a8%e7%ae%80%e4%bb%8b aria-label=预处理器简介>预处理器简介</a><ul><li><a href=#includes aria-label=Includes>Includes</a></li><li><a href=#macro-defines aria-label="Macro defines">Macro defines</a></li><li><a href=#conditional-compilation aria-label="Conditional compilation">Conditional compilation</a></li></ul></li><li><a href=#%e5%a6%82%e4%bd%95%e5%ae%8c%e6%88%90%e4%bd%a0%e7%9a%84%e7%ac%ac%e4%b8%80%e4%b8%aa%e7%a8%8b%e5%ba%8f aria-label=如何完成你的第一个程序>如何完成你的第一个程序</a></li></ul></li><li><a href=#%e8%b0%83%e8%af%95-c-%e7%a8%8b%e5%ba%8f aria-label="调试 C++ 程序">调试 C++ 程序</a><ul><li><a href=#%e8%b0%83%e8%af%95%e8%bf%87%e7%a8%8b aria-label=调试过程>调试过程</a></li><li><a href=#%e8%b0%83%e8%af%95%e7%ad%96%e7%95%a5 aria-label=调试策略>调试策略</a><ul><li><a href=#%e8%b0%83%e8%af%95%e7%ad%96%e7%95%a5-1%e6%b3%a8%e9%87%8a%e6%8e%89%e4%bd%a0%e7%9a%84%e4%bb%a3%e7%a0%81 aria-label="调试策略 1：注释掉你的代码">调试策略 1：注释掉你的代码</a></li><li><a href=#%e8%b0%83%e8%af%95%e7%ad%96%e7%95%a5-2%e9%aa%8c%e8%af%81%e4%bb%a3%e7%a0%81%e6%b5%81 aria-label="调试策略 2：验证代码流">调试策略 2：验证代码流</a></li><li><a href=#%e8%b0%83%e8%af%95%e7%ad%96%e7%95%a5-3%e6%89%93%e5%8d%b0%e5%80%bc aria-label="调试策略 3：打印值">调试策略 3：打印值</a></li><li><a href=#%e6%9d%a1%e4%bb%b6%e5%8c%96%e8%b0%83%e8%af%95%e4%bb%a3%e7%a0%81 aria-label=条件化调试代码>条件化调试代码</a></li><li><a href=#%e4%bd%bf%e7%94%a8%e6%97%a5%e5%bf%97 aria-label=使用日志>使用日志</a></li></ul></li><li><a href=#%e4%bd%bf%e7%94%a8%e9%9b%86%e6%88%90%e8%b0%83%e8%af%95%e5%99%a8stepping%e6%ad%a5%e8%bf%9b aria-label=使用集成调试器：Stepping（步进）>使用集成调试器：Stepping（步进）</a><ul><li><a href=#step-into aria-label="Step into">Step into</a></li><li><a href=#step-over aria-label="Step over">Step over</a></li><li><a href=#step-out aria-label="Step out">Step out</a></li></ul></li><li><a href=#%e4%bd%bf%e7%94%a8%e9%9b%86%e6%88%90%e8%b0%83%e8%af%95%e5%99%a8running-and-breakpoints%e8%bf%90%e8%a1%8c%e5%92%8c%e6%96%ad%e7%82%b9 aria-label="使用集成调试器：Running and breakpoints（运行和断点）">使用集成调试器：Running and breakpoints（运行和断点）</a><ul><li><a href=#run-to-cursor aria-label="Run to cursor">Run to cursor</a></li><li><a href=#breakpoints aria-label=Breakpoints>Breakpoints</a></li></ul></li><li><a href=#%e4%bd%bf%e7%94%a8%e9%9b%86%e6%88%90%e8%b0%83%e8%af%95%e5%99%a8%e8%b0%83%e7%94%a8%e5%a0%86%e6%a0%88 aria-label=使用集成调试器：调用堆栈>使用集成调试器：调用堆栈</a></li><li><a href=#%e5%9c%a8%e9%97%ae%e9%a2%98%e6%88%90%e4%b8%ba%e9%97%ae%e9%a2%98%e4%b9%8b%e5%89%8d%e5%8f%91%e7%8e%b0%e9%97%ae%e9%a2%98 aria-label=在问题成为问题之前发现问题>在问题成为问题之前发现问题</a><ul><li><a href=#%e9%87%8d%e6%9e%84%e4%bd%a0%e7%9a%84%e4%bb%a3%e7%a0%81 aria-label=重构你的代码>重构你的代码</a></li><li><a href=#%e7%ba%a6%e6%9d%9f aria-label=约束>约束</a></li></ul></li></ul></li><li><a href=#%e5%9f%ba%e6%9c%ac%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b aria-label=基本数据类型>基本数据类型</a><ul><li><a href=#%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e5%a4%a7%e5%b0%8f aria-label=数据类型大小>数据类型大小</a></li><li><a href=#%e6%97%a0%e7%ac%a6%e5%8f%b7%e6%95%b4%e6%95%b0%e5%92%8c%e6%9c%89%e7%ac%a6%e5%8f%b7%e6%95%b4%e6%95%b0 aria-label=无符号整数和有符号整数>无符号整数和有符号整数</a></li><li><a href=#%e5%9b%ba%e5%ae%9a%e5%ae%bd%e5%ba%a6%e6%95%b4%e6%95%b0%e5%92%8c-size_t aria-label="固定宽度整数和 size_t">固定宽度整数和 size_t</a><ul><li><a href=#fixed-width-%e6%95%b4%e6%95%b0 aria-label="Fixed-width 整数">Fixed-width 整数</a></li><li><a href=#fast-and-least-%e6%95%b4%e6%95%b0 aria-label="Fast and least 整数">Fast and least 整数</a></li><li><a href=#stdint8_t-%e5%92%8c-stduint8_t-%e5%8f%af%e8%83%bd%e8%a1%a8%e7%8e%b0%e5%be%97%e5%83%8f%e5%ad%97%e7%ac%a6%e8%80%8c%e4%b8%8d%e6%98%af%e6%95%b4%e6%95%b0 aria-label="std::int8_t 和 std::uint8_t 可能表现得像字符而不是整数">std::int8_t 和 std::uint8_t 可能表现得像字符而不是整数</a></li><li><a href=#best-practice aria-label="Best practice">Best practice</a></li><li><a href=#size_t aria-label=size_t>size_t</a></li></ul></li><li><a href=#%e6%b5%ae%e7%82%b9%e6%95%b0ieee-754 aria-label="浮点数（IEEE 754）">浮点数（IEEE 754）</a><ul><li><a href=#%e6%b5%ae%e7%82%b9%e8%8c%83%e5%9b%b4%e5%92%8c%e6%b5%ae%e7%82%b9%e7%b2%be%e5%ba%a6 aria-label=浮点范围和浮点精度>浮点范围和浮点精度</a></li><li><a href=#%e8%88%8d%e5%85%a5%e8%af%af%e5%b7%ae aria-label=舍入误差>舍入误差</a></li><li><a href=#nan-%e5%92%8c-inf aria-label="NaN 和 Inf">NaN 和 Inf</a></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></li><li><a href=#%e5%b8%83%e5%b0%94%e5%80%bc aria-label=布尔值>布尔值</a></li><li><a href=#chars aria-label=Chars>Chars</a></li><li><a href=#%e9%80%9a%e8%bf%87-static_cast-%e8%bf%90%e7%ae%97%e7%ac%a6%e8%bf%9b%e8%a1%8c%e6%98%be%e5%bc%8f%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2 aria-label="通过 static_cast 运算符进行显式类型转换">通过 static_cast 运算符进行显式类型转换</a></li><li><a href=#%e5%b8%b8%e9%87%8f%e5%92%8c%e7%ac%a6%e5%8f%b7%e5%b8%b8%e9%87%8f aria-label=常量和符号常量>常量和符号常量</a><ul><li><a href=#const-variables aria-label="const variables">const variables</a></li><li><a href=#%e7%ac%a6%e5%8f%b7%e5%b8%b8%e9%87%8f aria-label=符号常量>符号常量</a></li><li><a href=#%e5%af%b9%e4%ba%8e%e7%ac%a6%e5%8f%b7%e5%b8%b8%e9%87%8f%e6%9b%b4%e5%96%9c%e6%ac%a2%e5%b8%b8%e9%87%8f%e5%8f%98%e9%87%8f%e8%80%8c%e4%b8%8d%e6%98%af%e7%b1%bb%e5%af%b9%e8%b1%a1%e5%ae%8f aria-label=对于符号常量，更喜欢常量变量而不是类对象宏>对于符号常量，更喜欢常量变量而不是类对象宏</a></li></ul></li><li><a href=#%e7%bc%96%e8%af%91%e6%97%b6%e5%b8%b8%e9%87%8f%e5%b8%b8%e9%87%8f%e8%a1%a8%e8%be%be%e5%bc%8f%e5%92%8c-constexpr aria-label="编译时常量、常量表达式和 constexpr">编译时常量、常量表达式和 constexpr</a><ul><li><a href=#constant-expressions aria-label="Constant expressions">Constant expressions</a></li><li><a href=#compile-time-constants aria-label="Compile-time constants">Compile-time constants</a></li><li><a href=#compile-time-const aria-label="Compile-time const">Compile-time const</a></li><li><a href=#runtime-const aria-label="Runtime const">Runtime const</a></li><li><a href=#constexpr-%e5%85%b3%e9%94%ae%e5%ad%97 aria-label="constexpr 关键字">constexpr 关键字</a></li></ul></li><li><a href=#literals aria-label=Literals>Literals</a></li><li><a href=#%e5%8d%81%e8%bf%9b%e5%88%b6%e4%ba%8c%e8%bf%9b%e5%88%b6%e5%8d%81%e5%85%ad%e8%bf%9b%e5%88%b6%e5%92%8c%e5%85%ab%e8%bf%9b%e5%88%b6 aria-label=十进制、二进制、十六进制和八进制>十进制、二进制、十六进制和八进制</a><ul><li><a href=#%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%96%87%e5%ad%97%e5%92%8c%e6%95%b0%e5%ad%97%e5%88%86%e9%9a%94%e7%ac%a6 aria-label=二进制文字和数字分隔符>二进制文字和数字分隔符</a></li><li><a href=#%e4%bb%a5%e5%8d%81%e8%bf%9b%e5%88%b6%e5%85%ab%e8%bf%9b%e5%88%b6%e6%88%96%e5%8d%81%e5%85%ad%e8%bf%9b%e5%88%b6%e8%be%93%e5%87%ba%e5%80%bc aria-label=以十进制、八进制或十六进制输出值>以十进制、八进制或十六进制输出值</a></li><li><a href=#%e4%bb%a5%e4%ba%8c%e8%bf%9b%e5%88%b6%e8%be%93%e5%87%ba%e5%80%bc aria-label=以二进制输出值>以二进制输出值</a></li></ul></li><li><a href=#stdstring aria-label=std::string>std::string</a><ul><li><a href=#%e4%bd%bf%e7%94%a8-stdgetline-%e8%be%93%e5%85%a5%e6%96%87%e6%9c%ac aria-label="使用 std::getline() 输入文本">使用 std::getline() 输入文本</a></li><li><a href=#%e5%ad%97%e7%ac%a6%e4%b8%b2%e9%95%bf%e5%ba%a6 aria-label=字符串长度>字符串长度</a></li><li><a href=#stdstring-%e7%9a%84%e5%88%9d%e5%a7%8b%e5%8c%96%e5%92%8c%e5%a4%8d%e5%88%b6%e5%bc%80%e9%94%80%e5%be%88%e5%a4%a7 aria-label="std::string 的初始化和复制开销很大">std::string 的初始化和复制开销很大</a></li><li><a href=#literals-forstdstring--stdstring_view aria-label="Literals for std::string &amp;amp; std::string_view">Literals for <code>std::string</code> & <code>std::string_view</code></a></li><li><a href=#constexpr-%e5%ad%97%e7%ac%a6%e4%b8%b2 aria-label="Constexpr 字符串">Constexpr 字符串</a></li></ul></li><li><a href=#stdstring_view aria-label=std::string_view>std::string_view</a><ul><li><a href=#stdstring_view-c17 aria-label="std::string_view C++17">std::string_view C++17</a></li><li><a href=#constexpr-stdstring_view aria-label="constexpr std::string_view">constexpr std::string_view</a></li><li><a href=#stdstring--stdstring_view aria-label="std::string &amp;amp; std::string_view">std::string & std::string_view</a></li></ul></li></ul></li><li><a href=#operators%e6%93%8d%e4%bd%9c%e7%ac%a6 aria-label=Operators（操作符）>Operators（操作符）</a><ul><li><a href=#----%e8%bf%90%e7%ae%97%e7%ac%a6 aria-label=", &amp;amp; ? : 运算符"><code>,</code> & <code>? :</code> 运算符</a></li><li><a href=#%e6%af%94%e8%be%83%e6%b5%ae%e7%82%b9%e6%95%b0%e5%a4%a7%e5%b0%8f aria-label=比较浮点数大小>比较浮点数大小</a></li><li><a href=#%e9%80%bb%e8%be%91-xor-%e8%bf%90%e7%ae%97%e7%ac%a6 aria-label="逻辑 XOR 运算符">逻辑 XOR 运算符</a></li></ul></li><li><a href=#%e4%bd%8d%e6%93%8d%e4%bd%9c aria-label=位操作>位操作</a><ul><li><a href=#%e4%bd%8d%e6%a0%87%e5%bf%97-and-%e4%bd%8d%e6%93%8d%e4%bd%9c-via-stdbitset aria-label="位标志 and 位操作 via std::bitset">位标志 and 位操作 via std::bitset</a></li><li><a href=#%e6%8c%89%e4%bd%8d%e8%bf%90%e7%ae%97%e7%ac%a6 aria-label=按位运算符>按位运算符</a></li><li><a href=#%e4%bd%8d%e6%8e%a9%e7%a0%81 aria-label=位掩码>位掩码</a><ul><li><a href=#%e5%9c%a8-c14-%e4%b8%ad%e5%ae%9a%e4%b9%89%e4%bd%8d%e6%8e%a9%e7%a0%81 aria-label="在 C++14 中定义位掩码">在 C++14 中定义位掩码</a></li><li><a href=#%e5%9c%a8-c11-%e6%88%96%e6%9b%b4%e6%97%a9%e7%89%88%e6%9c%ac%e4%b8%ad%e5%ae%9a%e4%b9%89%e4%bd%8d%e6%8e%a9%e7%a0%81 aria-label="在 C++11 或更早版本中定义位掩码">在 C++11 或更早版本中定义位掩码</a></li><li><a href=#testing-a-bit aria-label="Testing a bit">Testing a bit</a></li><li><a href=#setting-a-bit aria-label="Setting a bit">Setting a bit</a></li><li><a href=#resetting-a-bit aria-label="Resetting a bit">Resetting a bit</a></li><li><a href=#flipping-a-bit aria-label="Flipping a bit">Flipping a bit</a></li></ul></li><li><a href=#%e4%bd%8d%e6%8e%a9%e7%a0%81%e5%92%8c-stdbitset aria-label="位掩码和 std::bitset">位掩码和 std::bitset</a></li><li><a href=#summary-1 aria-label=Summary>Summary</a></li></ul></li><li><a href=#%e8%bf%90%e7%ae%97%e7%ac%a6%e9%87%8d%e8%bd%bd aria-label=运算符重载>运算符重载</a><ul><li><a href=#%e4%bd%95%e6%97%b6%e4%bd%bf%e7%94%a8%e6%99%ae%e9%80%9a%e5%87%bd%e6%95%b0%e5%8f%8b%e5%85%83%e5%87%bd%e6%95%b0%e6%88%96%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0%e9%87%8d%e8%bd%bd%e8%bf%90%e7%ae%97%e7%ac%a6 aria-label=何时使用普通函数、友元函数或成员函数重载运算符>何时使用普通函数、友元函数或成员函数重载运算符</a></li><li><a href=#%e6%9c%80%e5%b0%8f%e5%8c%96%e6%af%94%e8%be%83%e5%86%97%e4%bd%99 aria-label=最小化比较冗余>最小化比较冗余</a></li><li><a href=#%e6%b5%85%e6%8b%b7%e8%b4%9d%e4%b8%8e%e6%b7%b1%e6%8b%b7%e8%b4%9d aria-label=浅拷贝与深拷贝>浅拷贝与深拷贝</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=入门>入门<a hidden class=anchor aria-hidden=true href=#入门>#</a></h1><ol><li>当您在 IDE 中创建新项目时，大多数 IDE 会为您设置两种不同的构建配置：发布配置和调试配置，开发程序时使用调试构建配置。当您准备好将可执行文件发布给其他人时，或者想要测试性能时，请使用发布构建配置<ol><li>Debug：<strong>调试版本，</strong> 包含调试信息，所以 <strong>容量比Release大很多，</strong> 并且不进行任何优化（优化会使调试复杂化，因为源代码和生成的指令间关系会更复杂），便于程序员调试</li><li>Release：<strong>发布版本，</strong> 不对源代码进行调试，编译时对应用程序的速度进行优化，<strong>使得程序在代码大小和运行速度上都是最优的</strong></li></ol></li></ol><pre tabindex=0><code>对于 CLion 用户，您可以添加 Release：按 Alt+Ctrl+S 调出 Settings &gt; Build，Execution，Deployment &gt; CMake &gt; 单击 Profiles 部分中的 + 按钮，将自动添加 Release 选项
</code></pre><ol start=2><li><strong>禁用编译器扩展</strong>以确保您的程序（和编码实践）保持符合 C++ 标准并且可以在任何系统上运行</li></ol><pre tabindex=0><code>CLion 使用 CMake 构建项目。
将行 set(CMAKE_CXX_EXTENSIONS OFF) 添加到 CMakeList.txt 以禁用扩展
</code></pre><ol start=3><li><strong>将你的警告级别调到最大</strong>，尤其是在你学习的时候。它将帮助您识别可能的问题</li></ol><pre tabindex=0><code>在 Clion（从 2021.3 版本开始）中，要将警告级别调到最高，您可以按 Alt+Ctrl+S 调出 Settings ，然后选择 Editor &gt; Inspections &gt; C/C++，然后手动选中所有框，或者在窗口的右侧，在矩形的 severity 框中选择错误，然后在另一个框中选择 In All Scopes
</code></pre><ol start=4><li><strong>选择语言标准</strong>：在专业环境中，通常选择比最新标准低一个或两个版本的语言标准（例如，现在 C++20 已经出来了，这意味着 C++14 或 C++17）。这样做通常是为了确保编译器制造商有机会解决缺陷，以便更好地理解新功能的最佳实践。在相关的情况下，这也有助于确保更好的跨平台兼容性，因为某些平台上的编译器可能不会立即为更新的语言标准提供全面支持。启用 C++17 语言标准（或更高版本）后，您应该能够在没有任何警告或错误的情况下编译以下代码</li></ol><pre tabindex=0><code>#include &lt;array&gt;
#include &lt;iostream&gt;
#include &lt;string_view&gt;
#include &lt;tuple&gt;
#include &lt;type_traits&gt;

namespace a:🅱️:c
{
    inline constexpr std::string_view str{ &#34;hello&#34; };
}

template &lt;class... T&gt;
std::tuple&lt;std::size_t, std::common_type_t&lt;T...&gt;&gt; sum(T... args)
{
    return { sizeof...(T), (args + ...) };
}

int main()
{
    auto [iNumbers, iSum]{ sum(1, 2, 3) };
    std::cout &lt;&lt; a:🅱️:c::str &lt;&lt; &#39; &#39; &lt;&lt; iNumbers &lt;&lt; &#39; &#39; &lt;&lt; iSum &lt;&lt; &#39;\n&#39;;

    std::array arr{ 1, 2, 3 };

    std::cout &lt;&lt; std::size(arr) &lt;&lt; &#39;\n&#39;;

    return 0;
}
</code></pre><h1 id=c-基础知识>C++ 基础知识<a hidden class=anchor aria-hidden=true href=#c-基础知识>#</a></h1><h2 id=注释>注释<a hidden class=anchor aria-hidden=true href=#注释>#</a></h2><h2 id=写在前面>写在前面<a hidden class=anchor aria-hidden=true href=#写在前面>#</a></h2><ol><li>通常，注释应该用于三件事<ol><li>在库、程序或函数级别，使用注释来<strong>描述作用</strong></li><li>在库、程序或函数内部，使用注释来描述<strong>如何操作</strong></li><li>在语句级别，使用注释来<strong>描述原因</strong></li></ol></li><li>注释是一种很好的方式来提醒自己（或告诉别人）你做出一个决定而不是另一个决定的原因</li><li>注释您的代码，像在对不知道代码功能的人说话一样写您的注释。不要假设你会记得你为什么做出特定的选择</li></ol><h2 id=单行注释>单行注释<a hidden class=anchor aria-hidden=true href=#单行注释>#</a></h2><ol><li>在行的右侧添加注释会使代码和注释都难以阅读，尤其是在行很长的情况下。如果行相当短，评论可以简单地对齐（通常是一个制表位），像这样：</li></ol><pre tabindex=0><code>std::cout &lt;&lt; &#34;Hello world!\n&#34;;                 // std::cout lives in the iostream library
std::cout &lt;&lt; &#34;It is very nice to meet you!\n&#34;; // this is much easier to read
std::cout &lt;&lt; &#34;Yeah!\n&#34;;                        // don&#39;t you think so?
</code></pre><ol start=2><li>但是，如果行很长，将注释放在右边会使行变得很长。在这种情况下，单行注释通常放在它正在注释的行之上：</li></ol><pre tabindex=0><code>// std::cout lives in the iostream library
std::cout &lt;&lt; &#34;Hello world!\n&#34;;

// this is much easier to read
std::cout &lt;&lt; &#34;It is very nice to meet you!\n&#34;;

// don&#39;t you think so?
std::cout &lt;&lt; &#34;Yeah!\n&#34;;
</code></pre><ol start=3><li>Commenting out code</li></ol><pre tabindex=0><code>//    std::cout &lt;&lt; 1;
</code></pre><h2 id=多行注释>多行注释<a hidden class=anchor aria-hidden=true href=#多行注释>#</a></h2><ol><li>Explaining code</li></ol><pre tabindex=0><code>/* This is a multi-line comment.
 * the matching asterisks to the left
 * can make this easier to read
 */
</code></pre><ol start=2><li>Commenting out code</li></ol><pre tabindex=0><code>/*
    std::cout &lt;&lt; 1;
    std::cout &lt;&lt; 2;
    std::cout &lt;&lt; 3;
*/
</code></pre><h2 id=初始化>初始化<a hidden class=anchor aria-hidden=true href=#初始化>#</a></h2><ol><li>Default initialization：默认初始化</li></ol><pre tabindex=0><code>int a; // no initializer
</code></pre><ol start=2><li>Copy initialization：在现代 C++ 中用的不多</li></ol><pre tabindex=0><code>int width = 5; // copy initialization of value 5 into variable width
</code></pre><ol start=3><li>Direct initialization：当在括号内提供初始化程序时，这称为直接初始化。最初引入直接初始化是为了更有效地初始化复杂对象。但是，与复制初始化一样，直接初始化在现代 C++ 中使用不多</li></ol><pre tabindex=0><code>int width( 5 ); // direct initialization of value 5 into variable width
</code></pre><ol start=4><li>Brace initialization：在 C++ 中初始化对象的现代方法是使用一种利用大括号的初始化形式&ndash;<strong>大括号初始化</strong>（也称为统一初始化或列表初始化）。引入大括号初始化是为了提供在大多数情况下都有效的<strong>更一致的初始化语法</strong>（这就是为什么它有时被称为“统一初始化”）。此外，大括号初始化提供了<strong>一种使用值列表初始化对象的方法</strong>（这就是为什么它有时被称为“列表初始化”）。大括号初始化有三种形式：</li></ol><pre tabindex=0><code>int width { 5 }; // direct brace initialization of value 5 into variable width (preferred)
int height = { 6 }; // copy brace initialization of value 6 into variable height
int depth {}; // value initialization 
</code></pre><p><strong>大括号初始化</strong>有一个额外的好处：它不允许“缩小转换”。这意味着如果您尝试使用变量无法安全保存的值来初始化变量，<strong>编译器将产生错误，迫使您在继续之前解决这个问题</strong>。例如：</p><pre tabindex=0><code>int width { 4.5 }; // error: a number with a fractional value can&#39;t fit into an int
</code></pre><h2 id=stdendl-vs-n>std::endl vs ‘\n’<a hidden class=anchor aria-hidden=true href=#stdendl-vs-n>#</a></h2><p>使用 std::endl 可能有点低效，因为它实际上做了两个工作：它将光标移动到控制台的下一行，并确保任何缓存的输出立即显示在屏幕上（这称为刷新输出）。当使用 std::cout 将文本写入控制台时，std::cout 通常会刷新输出（如果不刷新，通常也无关紧要），因此让 std::endl 执行刷新很少重要</p><p>因此，通常首选使用“\n”字符。 ‘\n’ 字符将光标移动到控制台的下一行，但不请求刷新，因此在刷新不会发生的情况下它会执行得更好。 ‘\n’ 字符也更易于阅读，因为它更短并且可以嵌入到现有文本中</p><p>这是一个以两种不同方式使用“\n”的示例：</p><pre tabindex=0><code>#include &lt;iostream&gt; // for std::cout

int main()
{
    int x{ 5 };
    std::cout &lt;&lt; &#34;x is equal to: &#34; &lt;&lt; x &lt;&lt; &#39;\n&#39;; // Using &#39;\n&#39; standalone
    std::cout &lt;&lt; &#34;And that&#39;s all, folks!\n&#34;; // Using &#39;\n&#39; embedded into a double-quoted piece of text (note: no single quotes when used this way)
    return 0;
}
</code></pre><p>这打印：</p><pre tabindex=0><code>x is equal to: 5
And that&#39;s all, folks!
</code></pre><p><strong>将文本输出到控制台时，优先使用“\n”而不是 std::endl</strong></p><h2 id=代码的可读性>代码的可读性<a hidden class=anchor aria-hidden=true href=#代码的可读性>#</a></h2><ol><li>您的行的长度不应超过 80 个字符</li></ol><pre tabindex=0><code>int main()
{
    std::cout &lt;&lt; &#34;This is a really, really, really, really, really, really, really, &#34;
        &#34;really long line\n&#34;; // one extra indentation for continuation line

    std::cout &lt;&lt; &#34;This is another really, really, really, really, really, really, really, &#34;
                 &#34;really long line\n&#34;; // text aligned with the previous line for continuation line

    std::cout &lt;&lt; &#34;This one is short\n&#34;;
}
</code></pre><p>如果用操作符（例如 &#171; 或 +）拆分长行，则应将操作符放在下一行的开头，而不是当前行的结尾</p><pre tabindex=0><code>std::cout &lt;&lt; 3 + 4
    + 5 + 6
    * 7 * 8;
</code></pre><p>许多编辑器都有一个内置功能（或插件/扩展），可以在给定的列（例如 80 个字符）处显示一行（称为“列指南”），因此您可以轻松查看行何时变得太长</p><p><strong>Clion column guide</strong> : File > Settings > Editor > Code Style > General > 在 &ldquo;Visual guides&rdquo; 矩形框中键入 80 并应用更改
2. 使用空格通过对齐值或注释或在代码块之间添加间距来使您的代码更易于阅读</p><pre tabindex=0><code>cost          = 57;
pricePerItem  = 24;
value         = 5;
numberOfItems = 17;

std::cout &lt;&lt; &#34;Hello world!\n&#34;;                  // cout lives in the iostream library
std::cout &lt;&lt; &#34;It is very nice to meet you!\n&#34;;  // these comments are easier to read
std::cout &lt;&lt; &#34;Yeah!\n&#34;;                         // especially when all lined up

// cout lives in the iostream library
std::cout &lt;&lt; &#34;Hello world!\n&#34;;

// these comments are easier to read
std::cout &lt;&lt; &#34;It is very nice to meet you!\n&#34;;

// when separated by whitespace
std::cout &lt;&lt; &#34;Yeah!\n&#34;;
</code></pre><h1 id=c-基础函数和文件>C++ 基础：函数和文件<a hidden class=anchor aria-hidden=true href=#c-基础函数和文件>#</a></h1><h2 id=函数返回值>函数返回值<a hidden class=anchor aria-hidden=true href=#函数返回值>#</a></h2><p>C++标准只定义了3种状态码的含义：0、EXIT_SUCCESS、EXIT_FAILURE。 0 和 EXIT_SUCCESS 都表示程序执行成功。 EXIT_FAILURE 表示程序没有成功执行</p><p>EXIT_SUCCESS 和 EXIT_FAILURE 是 <code>&lt;cstdlib></code> 标头中定义的预处理器宏：</p><pre tabindex=0><code>#include &lt;cstdlib&gt; // for EXIT_SUCCESS and EXIT_FAILURE

int main()
{
    return EXIT_SUCCESS;
}
</code></pre><p>如果你想最大限度地提高可移植性，你应该只使用 0 或 EXIT_SUCCESS 来指示成功终止，或者使用 EXIT_FAILURE 来指示不成功终止</p><h2 id=前向声明和定义>前向声明和定义<a hidden class=anchor aria-hidden=true href=#前向声明和定义>#</a></h2><p>对于以下每个程序，说明它们是编译失败、链接失败、两者都失败，还是编译和链接成功。如果您不确定，请尝试编译它们！</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span><span style=color:#fff;font-weight:700>int</span> add(<span style=color:#fff;font-weight:700>int</span> x, <span style=color:#fff;font-weight:700>int</span> y);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;3 + 4 + 5 = &#34;</span> &lt;&lt; add(<span style=color:#ff0;font-weight:700>3</span>, <span style=color:#ff0;font-weight:700>4</span>, <span style=color:#ff0;font-weight:700>5</span>) &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> add(<span style=color:#fff;font-weight:700>int</span> x, <span style=color:#fff;font-weight:700>int</span> y)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> x + y;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Doesn’t compile. The compiler will complain that the add() called in main() does not have the same number of parameters as the one that was forward declared.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span><span style=color:#fff;font-weight:700>int</span> add(<span style=color:#fff;font-weight:700>int</span> x, <span style=color:#fff;font-weight:700>int</span> y);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;3 + 4 + 5 = &#34;</span> &lt;&lt; add(<span style=color:#ff0;font-weight:700>3</span>, <span style=color:#ff0;font-weight:700>4</span>, <span style=color:#ff0;font-weight:700>5</span>) &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> add(<span style=color:#fff;font-weight:700>int</span> x, <span style=color:#fff;font-weight:700>int</span> y, <span style=color:#fff;font-weight:700>int</span> z)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> x + y + z;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Doesn’t compile. The compiler will complain that it can’t find a matching add() function that takes 3 arguments, because the add() function that was forward declared only takes 2 arguments.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span><span style=color:#fff;font-weight:700>int</span> add(<span style=color:#fff;font-weight:700>int</span> x, <span style=color:#fff;font-weight:700>int</span> y);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;3 + 4 = &#34;</span> &lt;&lt; add(<span style=color:#ff0;font-weight:700>3</span>, <span style=color:#ff0;font-weight:700>4</span>) &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> add(<span style=color:#fff;font-weight:700>int</span> x, <span style=color:#fff;font-weight:700>int</span> y, <span style=color:#fff;font-weight:700>int</span> z)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> x + y + z;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Doesn’t link. The compiler will match the forward declaration of add to the function call to add() in main(). However, no add() function that takes two parameters was ever implemented (we only implemented one that took 3 parameters), so the linker will complain.</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span><span style=color:#fff;font-weight:700>int</span> add(<span style=color:#fff;font-weight:700>int</span> x, <span style=color:#fff;font-weight:700>int</span> y, <span style=color:#fff;font-weight:700>int</span> z);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;3 + 4 + 5 = &#34;</span> &lt;&lt; add(<span style=color:#ff0;font-weight:700>3</span>, <span style=color:#ff0;font-weight:700>4</span>, <span style=color:#ff0;font-weight:700>5</span>) &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> add(<span style=color:#fff;font-weight:700>int</span> x, <span style=color:#fff;font-weight:700>int</span> y, <span style=color:#fff;font-weight:700>int</span> z)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> x + y + z;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Compiles and links. The function call to add() matches the forward declaration, the implemented function also matches.</p><h2 id=具有多个cpp文件的程序>具有多个cpp文件的程序<a hidden class=anchor aria-hidden=true href=#具有多个cpp文件的程序>#</a></h2><h3 id=cpp-文件>.cpp 文件<a hidden class=anchor aria-hidden=true href=#cpp-文件>#</a></h3><p>编译器会单独编译每个文件。它不知道其他代码文件的内容，也不记得它从以前编译的代码文件中看到的任何内容。这种有限的可见性和短内存是有意的，因此文件可能具有名称相同的函数或变量而不会相互冲突。</p><p>C++ 语言支持"分别编译"（separatecompilation）。也就是说，一个程序所有的内容，可以分成不同的部分分别放在不同的 .cpp 文件里。.cpp 文件里的东西都是相对独立的，在编译（compile）时不需要与其他文件互通，只需要在编译成目标文件后再与其他的目标文件做一次链接（link）就行了。比如，在文件 a.cpp 中定义了一个全局函数 &ldquo;void a(){}"，而在文件 b.cpp 中需要调用这个函数。即使这样，文件 a.cpp 和文件 b.cpp 并不需要相互知道对方的存在，而是可以分别地对它们进行编译，编译成目标文件之后再链接，整个程序就可以运行了</p><p>这是怎么实现的呢？从写程序的角度来讲，很简单。在文件 b.cpp 中，在调用 &ldquo;void a()&rdquo; 函数之前，先<strong>声明一下</strong>这个函数 &ldquo;voida();"，就可以了。这是因为编译器在编译 b.cpp 的时候会生成一个符号表（symbol table），像 &ldquo;void a()&rdquo; 这样的看不到定义的符号，就会被存放在这个表中。再进行链接的时候，编译器就会在别的目标文件中去寻找这个符号的定义。一旦找到了，程序也就可以顺利地生成了</p><h3 id=h-文件>.h 文件<a hidden class=anchor aria-hidden=true href=#h-文件>#</a></h3><p>考虑一下，如果有一个很常用的函数 &ldquo;void f() {}"，在整个程序中的许多 .cpp 文件中都会被调用，那么，我们就只需要在一个文件中定义这个函数，而在其他的文件中声明这个函数就可以了。一个函数还好对付，声明起来也就一句话。但是，如果函数多了，比如是一大堆的数学函数，有好几百个，那怎么办？</p><p>头文件允许我们将声明放在一个位置，然后在我们需要的地方导入它们。这可以在多文件程序中节省大量的输入</p><p>头文件通常只包含函数和变量声明，而不包含函数和变量定义（否则可能会导致违反单一定义规则）。<strong>符号常量</strong>是一个例外</p><p>使用双引号 <code>""</code> 包括您编写的或预期在当前目录中找到的头文件</p><p>使用尖括号 <code>&lt;></code> 来包含编译器、操作系统或您在系统其他位置安装的第三方库附带的标头</p><h4 id=为什么-iostream-没有-h-扩展名>为什么 iostream 没有 .h 扩展名？<a hidden class=anchor aria-hidden=true href=#为什么-iostream-没有-h-扩展名>#</a></h4><p>首次创建 C++ 时，标准库中的所有文件都以 .h 后缀结尾。生活是一致的，而且很好。 cout 和 cin 的原始版本在 iostream.h 中声明。当 ANSI 委员会对该语言进行标准化时，他们决定将标准库中使用的所有名称移动到 std 命名空间中，以帮助避免与用户定义的标识符发生命名冲突。然而，这带来了一个问题：如果他们将所有名称移动到 std 名称空间中，那么旧程序（包括 iostream.h）将不再工作！</p><p>为解决此问题，引入了一组缺少 .h 扩展名的新头文件。这些新的头文件定义了 std 命名空间内的所有名称。这样，包含 <code>#include &lt;iostream.h></code> 的旧程序不需要重写，新程序可以 <code>#include &lt;iostream></code></p><h4 id=include来自其他目录的头文件>Include来自其他目录的头文件<a hidden class=anchor aria-hidden=true href=#include来自其他目录的头文件>#</a></h4><p>一种（不好的）方法是在#include 行中包含一个指向您要包含的头文件的相对路径。例如：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&#34;headers/myHeader.h&#34;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&#34;../moreHeaders/myOtherHeader.h&#34;</span><span style=color:#0f0;font-weight:700>
</span></span></span></code></pre></div><p>虽然这会编译（假设文件存在于那些相对目录中），但这种方法的缺点是它需要您在代码中反映您的目录结构。如果您更新了目录结构，您的代码将不再有效</p><p><strong>更好的方法</strong>是告诉你的编译器或 IDE 你在其他位置有一堆头文件，这样当它在当前目录中找不到它们时就会去那里寻找。这通常可以通过在 IDE 项目设置中设置包含路径或搜索目录来完成</p><p>这种方法的好处是，如果您更改了目录结构，您只需更改一个编译器或 IDE 设置，而不是每个代码文件</p><h4 id=headers-may-include-other-headers>Headers may include other headers<a hidden class=anchor aria-hidden=true href=#headers-may-include-other-headers>#</a></h4><p>当您的代码文件 <code>#includes</code> 第一个头文件时，您还将获得第一个头文件包含的任何其他头文件（以及那些包含的任何头文件，等等）。这些额外的头文件有时称为传递包含，因为它们是隐式包含而不是显式包含</p><p>每个文件都应该 <code>显式#include</code> 它需要编译的所有头文件。不要依赖从其他标头传递过来的标头</p><h4 id=include-头文件顺序>include 头文件顺序<a hidden class=anchor aria-hidden=true href=#include-头文件顺序>#</a></h4><p>如果你的头文件写得正确并且<code>#include</code>了他们需要的一切，那么包含的顺序应该无关紧要</p><p>现在考虑以下场景：假设 header A 需要 header B 的声明，但忘记包含它。在我们的代码文件中，如果我们在 header A 之前包含 header B，我们的代码仍然可以编译！这是因为编译器会先编译 B 中的所有声明，然后再编译 A 中依赖于这些声明的代码</p><p>但是，如果我们首先包含 header A，那么编译器会报错，因为 A 的代码将在编译器看到 B 的声明之前编译。这实际上是更可取的，因为错误已经浮出水面，然后我们可以修复它.</p><p>为了最大限度地提高编译器标记缺少包含的机会，请按以下方式命令您的<code>#includes</code>：</p><ol><li>The paired header file</li><li>Other headers from your project</li><li>3rd party library headers</li><li>Standard library headers</li></ol><p>The headers for each grouping should be sorted alphabetically（按字母顺序排序）.</p><p>这样，如果您的某个用户定义的 Header 缺少第 3 方库或标准库 Header 的<code>#include</code>，则更有可能导致编译错误，因此您可以修复它</p><h4 id=header-file-best-practices>Header file best practices<a hidden class=anchor aria-hidden=true href=#header-file-best-practices>#</a></h4><ol><li>始终 include header guards</li><li>不要在头文件中定义变量和函数（全局常量是一个例外）</li><li>为头文件指定与其关联的源文件相同的名称（例如，grades.h 与 grades.cpp 配对）</li><li>每个头文件应该有一个特定的工作，并且尽可能独立。例如，您可以将与功能 A 相关的所有声明放在 A.h 中，将与功能 B 相关的所有声明放在 B.h 中。这样如果你以后只关心 A，你可以只 include A.h 而不会得到任何与 B 相关的东西</li><li>请注意您需要为代码文件中使用的功能显式包含哪些 header</li><li>您编写的每个 header 都应该自行编译（它应该<code>#include</code> 它需要的每个依赖项）</li><li>仅 <code>#include</code> 您需要的内容（不要仅仅因为可以就包含所有内容）</li><li>不要<code>#include</code> .cpp 文件</li></ol><h4 id=header-guards>Header guards<a hidden class=anchor aria-hidden=true href=#header-guards>#</a></h4><p>使用头文件，很容易导致头文件中的定义被多次包含的情况。当一个头文件 <code>#includes</code> 另一个头文件（这很常见）时，就会发生重复定义</p><p>Example:</p><p>square.h:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007f7f>// We shouldn&#39;t be including function definitions in header files
</span></span></span><span style=display:flex><span><span style=color:#007f7f>// But for the sake of this example, we will
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>int</span> getSquareSides()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>4</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>geometry.h:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&#34;square.h&#34;</span><span style=color:#0f0;font-weight:700>
</span></span></span></code></pre></div><p>main.cpp:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&#34;square.h&#34;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&#34;geometry.h&#34;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在预处理完所有 <code>#includes</code> 之后，main.cpp 最终看起来像这样：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> getSquareSides()  <span style=color:#007f7f>// from square.h
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>{
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>4</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> getSquareSides() <span style=color:#007f7f>// from geometry.h (via square.h)
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>{
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>4</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们可以通过一种称为 <code>Header guards</code> 的机制来避免上述问题。<code>Header guards</code> 是采用以下形式的条件编译指令：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#ifndef SOME_UNIQUE_NAME_HERE
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#define SOME_UNIQUE_NAME_HERE
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#007f7f>// your declarations (and certain types of definitions) here
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#endif
</span></span></span></code></pre></div><p>当此标头为<code>#included</code> 时，预处理器会检查之前是否定义了 <code>SOME_UNIQUE_NAME_HERE</code>。如果这是我们第一次包含此标头，则不会定义 <code>SOME_UNIQUE_NAME_HERE</code>。因此，它 <code>#defines SOME_UNIQUE_NAME_HERE</code> 并包含文件的内容。如果标头再次包含到同一个文件中，<code>SOME_UNIQUE_NAME_HERE</code> 将在第一次包含标头的内容时已经定义，并且标头的内容将被忽略</p><p><strong>你所有的头文件都应该有头文件保护</strong>。 <code>SOME_UNIQUE_NAME_HERE</code> 可以是您想要的任何名称，但按照惯例设置为头文件的完整文件名，全部大写，使用下划线作为空格或标点符号</p><p>在大型程序中，可能有两个单独的头文件（包含在不同的目录中）最终具有相同的文件名（例如 <code>directoryA\config.h</code> 和 <code>directoryB\config.h</code>）。如果仅文件名用于包含保护（例如 <code>CONFIG_H</code>），这两个文件最终可能会使用相同的保护名称。如果发生这种情况，任何包含（直接或间接）这两个 config.h 文件的文件将不会收到要包含的包含文件的内容。这可能会导致编译错误</p><p>由于这种保护名称冲突的可能性，许多开发人员建议在标头保护中使用更复杂/唯一的名称。一些好的建议是 <code>&lt;PROJECT>_&lt;PATH>_&lt;FILE>_H</code> 、<code>&lt;FILE>_&lt;LARGE RANDOM NUMBER>_H</code> 或 <code>&lt;FILE>_&lt;CREATION DATE>_H </code>的命名约定</p><h5 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h5><p>标头保护旨在确保给定标头文件的内容不会被多次复制到任何<strong>单个文件</strong>中，以防止重复定义</p><p>请注意，重复声明是可以的，因为一个声明可以多次声明而不会发生意外——但即使您的头文件由所有声明（无定义）组成，包含头文件保护仍然是 Best Practice</p><p>Note that header guards do <em>not</em> prevent the contents of a header file from being copied (once) into separate project files. This is a good thing, because we often need to reference the contents of a given header from different project files</p><h4 id=pragma-once>pragma once<a hidden class=anchor aria-hidden=true href=#pragma-once>#</a></h4><p>现代编译器使用 <code>#pragma</code> 指令支持一种更简单的替代形式的标头保护：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#pragma once
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#007f7f>// your code here
</span></span></span></code></pre></div><p><code>#pragma once</code> 与标头保护具有相同的目的，并且具有更短且不易出错的额外好处。对于大多数项目，<code>#pragma once</code> 工作正常，许多开发人员更喜欢使用它们而不是标头保护。然而，<code>#pragma once</code> 并不是 C++ 语言的正式部分（而且可能永远不会是，因为它无法以在所有情况下都可靠工作的方式实现）</p><p>为了最大的可移植性，优先使用 <code>header guards</code> 而不是 <code>#pragma once</code></p><h2 id=命名冲突和命名空间介绍>命名冲突和命名空间介绍<a hidden class=anchor aria-hidden=true href=#命名冲突和命名空间介绍>#</a></h2><h3 id=命名冲突>命名冲突<a hidden class=anchor aria-hidden=true href=#命名冲突>#</a></h3><p>大多数命名冲突发生在两种情况下：</p><p>两个（或更多）同名函数（或全局变量）被引入到属于同一程序的不同文件中。这将导致<strong>链接器错误</strong></p><p>两个（或更多）同名函数（或全局变量）被引入到同一个文件中。这将导致<strong>编译器错误</strong></p><h3 id=命名空间>命名空间<a hidden class=anchor aria-hidden=true href=#命名空间>#</a></h3><p><strong>命名空间</strong>是一个区域，允许您在其中声明名称以消除歧义。命名空间为在其中声明的名称提供一个作用域区域（称为命名空间作用域）——这仅仅意味着在命名空间内声明的任何名称都不会被误认为是其他作用域中的相同名称</p><p><strong>命名空间</strong>通常用于对大型项目中的相关标识符进行分组，以帮助确保它们不会无意中与其他标识符发生冲突。例如，如果您将所有数学函数放在一个名为 math 的命名空间中，那么您的数学函数将不会与 math 命名空间之外的同名函数发生冲突</p><p>在 C++ 中，任何未在类、函数或命名空间内定义的名称都被视为隐式定义的命名空间的一部分，称为<strong>全局命名空间</strong>（有时也称为全局范围）</p><p>只有声明和定义语句可以出现在全局命名空间中。这意味着我们可以在全局命名空间中定义变量，尽管通常应该避免这种情况。这也意味着其他类型的语句（例如表达式语句）不能放在全局命名空间中（全局变量的初始化器是一个例外）：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt; // handled by preprocessor</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#007f7f>// All of the following statements are part of the global namespace
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>void</span> foo();    <span style=color:#007f7f>// okay: function forward declaration in the global namespace
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>int</span> x;         <span style=color:#007f7f>// compiles but strongly discouraged: uninitialized variable definition in the global namespace
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>int</span> y { <span style=color:#ff0;font-weight:700>5</span> };   <span style=color:#007f7f>// compiles but discouraged: variable definition with initializer in the global namespace
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>x = <span style=color:#ff0;font-weight:700>5</span>;         <span style=color:#007f7f>// compile error: executable statements are not allowed in the global namespace
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()     <span style=color:#007f7f>// okay: function definition in the global namespace
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>{
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>void</span> goo();    <span style=color:#007f7f>// okay: another function forward declaration in the global namespace
</span></span></span></code></pre></div><p>在最初设计 C++ 时，C++ 标准库中的所有标识符（包括 std::cin 和 std::cout）都可以在没有 std:: 前缀的情况下使用（它们是全局命名空间的一部分）。但是，这意味着标准库中的任何标识符都可能与您为自己的标识符选择的任何名称（也在全局命名空间中定义）发生冲突。当您#include 标准库中的新文件时，正在运行的代码可能会突然出现命名冲突。或者更糟的是，在一个版本的 C++ 下编译的程序可能无法在未来的 C++ 版本下编译，因为引入标准库的新标识符可能与已经编写的代码发生命名冲突。因此，C++ 将标准库中的所有功能移动到名为“std”（标准的缩写）的命名空间中</p><p>std::cout 的名字并不是真正的 std::cout。它实际上只是 cout，而 std 是标识符 cout 所属的命名空间的名称。因为 cout 是在 std 命名空间中定义的，所以名称 cout 不会与我们在全局命名空间中创建的任何名为 cout 的对象或函数发生冲突</p><h2 id=预处理器简介>预处理器简介<a hidden class=anchor aria-hidden=true href=#预处理器简介>#</a></h2><p>在编译之前，代码文件会经历一个称为翻译的阶段。翻译阶段会发生很多事情，让您的代码准备好进行编译（如果您好奇，可以在此处找到翻译阶段列表）。应用了翻译的代码文件称为翻译单元</p><p>最值得注意的翻译阶段涉及预处理器。预处理器最好被认为是一个单独的程序，它可以处理每个代码文件中的文本</p><p>当预处理器运行时，它会扫描代码文件（从上到下），寻找预处理器指令。预处理程序指令（通常简称为 <strong>指令（Directives）</strong>）是以# 符号开头并以换行符（不是分号）结尾的指令。这些指令告诉预处理器执行某些文本操作任务。请注意，预处理器不理解 C++ 语法——相反，指令有自己的语法（在某些情况下类似于 C++ 语法，而在其他情况下，则不太相似）</p><p>请注意，预处理器不会以任何方式修改原始代码文件——相反，预处理器所做的所有文本更改都会在每次编译代码文件时临时发生在内存中或使用临时文件</p><h3 id=includes>Includes<a hidden class=anchor aria-hidden=true href=#includes>#</a></h3><p>当您 <code>#include</code> 一个文件时，预处理器会用 include 文件的内容替换 <code>#include</code> 指令。然后对 include 的内容进行预处理（连同文件的其余部分），然后进行编译</p><h3 id=macro-defines>Macro defines<a hidden class=anchor aria-hidden=true href=#macro-defines>#</a></h3><p><code>#define</code> 指令可用于创建 <strong>宏</strong></p><p>有两种基本类型的宏：<strong>类对象宏</strong>和<strong>类函数宏</strong></p><p><strong>类函数宏</strong>的行为类似于函数，并且具有相似的目的。它们的使用通常被认为是危险的，它们几乎可以做的任何事情都可以通过一个正常的函数来完成</p><p><strong>类对象宏</strong>可以通过以下两种方式之一定义：</p><pre tabindex=0><code>#define identifier
#define identifier substitution_text
</code></pre><p><strong>替换文本</strong>的类对象宏被用作（在 C 中）将名称分配给文字的一种方式。这不再是必需的，因为 C++ 中提供了更好的方法（Const 变量和符号常量）。带有替换文本的类对象宏现在通常只能在遗留代码中看到</p><p><strong>没有替换文本</strong>的类对象宏：标识符的任何进一步出现都将被删除并被替换为任何东西！</p><p>与带有替换文本的类对象宏不同，这种形式的宏通常被认为可以使用。</p><h3 id=conditional-compilation>Conditional compilation<a hidden class=anchor aria-hidden=true href=#conditional-compilation>#</a></h3><p><strong>条件编译预处理器指令</strong>允许您指定在什么条件下编译或不编译。有很多不同的条件编译指令，但我们在这里只介绍目前使用最多的三个：<code>#ifdef</code>、<code>#ifndef</code> 和 <code>#endif</code></p><p><code>#ifdef</code> 预处理器指令允许预处理器检查标识符是否先前已被<code>#defined</code>。如果是，编译 <code>#ifdef</code> 和匹配的 <code>#endif</code> 之间的代码。如果不是，代码将被忽略</p><p>考虑以下程序：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#define PRINT_JOE
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#ifdef PRINT_JOE
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;Joe</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>; <span style=color:#007f7f>// will be compiled since PRINT_JOE is defined
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#0f0;font-weight:700>#endif
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#ifdef PRINT_BOB
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;Bob</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>; <span style=color:#007f7f>// will be ignored since PRINT_BOB is not defined
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#0f0;font-weight:700>#endif
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>因为 <code>PRINT_JOE</code> 已被 <code>#defined</code>，<code>std::cout &lt;&lt; "Joe\n"</code> 行将被编译。因为 <code>PRINT_BOB</code> 尚未被 <code>#defined</code>，<code>std::cout &lt;&lt; "Bob\n" </code>行将被忽略</p><p><code>#ifndef</code> 与 <code>#ifdef</code> 相反，因为它允许您检查标识符是否尚未 <code>#defined</code></p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#ifndef PRINT_BOB
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;Bob</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#endif
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>该程序打印 <code>“Bob”</code>，因为 <code>PRINT_BOB</code> 从未被 <code>#defined</code></p><p>条件编译的一个更常见的用途是使用 <code>#if 0</code> 将代码块排除在编译之外（就像它在注释块中一样）：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;Joe</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#if 0</span><span style=color:#007f7f> // Don&#39;t compile anything starting here
</span></span></span><span style=display:flex><span><span style=color:#007f7f>    std::cout &lt;&lt; &#34;Bob\n&#34;;
</span></span></span><span style=display:flex><span><span style=color:#007f7f>    std::cout &lt;&lt; &#34;Steve\n&#34;;
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#0f0;font-weight:700>#endif // until this point
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这也提供了一种方便的方法来**“注释掉”包含多行注释的代码**（由于多行注释是不可嵌套的，因此不能使用另一个多行注释来注释掉）：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;Joe</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#if 0</span><span style=color:#007f7f> // Don&#39;t compile anything starting here
</span></span></span><span style=display:flex><span><span style=color:#007f7f>    std::cout &lt;&lt; &#34;Bob\n&#34;;
</span></span></span><span style=display:flex><span><span style=color:#007f7f>    /* Some
</span></span></span><span style=display:flex><span><span style=color:#007f7f>     * multi-line
</span></span></span><span style=display:flex><span><span style=color:#007f7f>     * comment here
</span></span></span><span style=display:flex><span><span style=color:#007f7f>     */
</span></span></span><span style=display:flex><span><span style=color:#007f7f>    std::cout &lt;&lt; &#34;Steve\n&#34;;
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#0f0;font-weight:700>#endif // until this point
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>类对象宏不影响其他预处理器指令，宏只会导致普通代码的文本替换。其他预处理器命令将被忽略</strong></p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#define FOO 9 </span><span style=color:#007f7f>// Here&#39;s a macro substitution
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#ifdef FOO </span><span style=color:#007f7f>// This FOO does not get replaced because it’s part of another preprocessor directive
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    std::cout &lt;&lt; FOO; <span style=color:#007f7f>// This FOO gets replaced with 9 because it&#39;s part of the normal code
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#0f0;font-weight:700>#endif
</span></span></span></code></pre></div><p>指令在编译前解析，逐个文件地从上到下解析</p><pre tabindex=0><code>#include &lt;iostream&gt;

void foo()
{
#define MY_NAME &#34;Alex&#34;
}

int main()
{
	std::cout &lt;&lt; &#34;My name is: &#34; &lt;&lt; MY_NAME;

	return 0;
}
</code></pre><p>即使看起来 <code>#define MY_NAME “Alex”</code> 是在函数 <code>foo</code> 中定义的，预处理器也不会注意到，因为它不理解像函数这样的 C++ 概念。因此，该程序的行为与 <code>#define MY_NAME “Alex”</code> 在函数 <code>foo</code> 之前或之后立即定义的程序相同。为了一般的可读性，您通常希望在函数之外 <code>#define</code> 标识符</p><p>预处理器完成后，该文件中所有定义的标识符都将被丢弃。这意味着指令<strong>仅从定义点到定义它们的文件末尾有效</strong>。<strong>一个代码文件中定义的指令不会影响同一项目中的其他代码文件</strong></p><p>考虑以下示例：</p><p>function.cpp:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>void</span> doSomething()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#ifdef PRINT
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;Printing!&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#endif
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#ifndef PRINT
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;Not printing!&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#endif
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>}
</span></span></code></pre></div><p>main.cpp:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#fff;font-weight:700>void</span> doSomething(); <span style=color:#007f7f>// forward declaration for function doSomething()
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#define PRINT
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    doSomething();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面的程序会打印：</p><pre tabindex=0><code>Not printing!
</code></pre><p>尽管 <code>PRINT</code> 是在 <code>main.cpp</code> 中定义的，但这对 <code>function.cpp</code> 中的任何代码都没有任何影响（<code>PRINT</code> 只是从定义点到 <code>main.cpp</code> 末尾的 <code>#defined</code>）</p><h2 id=如何完成你的第一个程序>如何完成你的第一个程序<a hidden class=anchor aria-hidden=true href=#如何完成你的第一个程序>#</a></h2><ol><li>Design（设计）<ol><li>定义目标。将此表示为面向用户的结果通常很有用，例如：<ul><li>允许用户组织姓名和相关电话号码的列表</li><li>模拟球从塔上掉落到地面需要多长时间</li></ul></li><li>定义需求。既指您的解决方案需要遵守的约束（例如预算、时间线、空间、内存等），也指程序为满足用户需求而必须展示的能力。请注意，您的要求同样应该关注“什么”，而不是“如何”。例如：<ul><li>应保存电话号码，以便日后调用</li><li>用户应该能够输入塔的高度</li></ul></li><li>定义您的工具、目标和备份计划<ol><li>定义您的程序将运行的目标架构 和/或 操作系统</li><li>确定您将使用的工具集</li><li>确定您是单独编写程序还是作为团队的一部分编写程序’</li><li>定义您的测试/反馈/发布策略</li><li>确定您将如何备份您的代码</li></ol></li><li>将困难问题分解为简单问题。如果发现其中一个项目（功能）太难实现，只需将该项目拆分为多个子项目/子功能。最终，您应该达到程序中的每个功能都可以轻松实现的地步</li><li>弄清楚事件的顺序</li></ol></li><li>Implementation（实现）<ol><li>概述您的主要功能。</li></ol><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#007f7f>// Get first number from user
</span></span></span><span style=display:flex><span><span style=color:#007f7f>//    getUserInput();
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    <span style=color:#007f7f>// Get mathematical operation from user
</span></span></span><span style=display:flex><span><span style=color:#007f7f>//    getMathematicalOperation();
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    <span style=color:#007f7f>// Get second number from user
</span></span></span><span style=display:flex><span><span style=color:#007f7f>//    getUserInput();
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    <span style=color:#007f7f>// Calculate result
</span></span></span><span style=display:flex><span><span style=color:#007f7f>//    calculateResult();
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    <span style=color:#007f7f>// Print result
</span></span></span><span style=display:flex><span><span style=color:#007f7f>//    printResult();
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=2><li>实现各个功能。对于每个函数，您将做三件事：<ol><li>定义函数原型（输入和输出）</li><li>编写函数</li><li>测试功能</li></ol></li><li>最终测试。一旦你的程序“完成”，最后一步就是测试整个程序并确保它按预期工作。如果它不起作用，请修复它</li></ol></li><li>Words of advice when writing programs（忠告）<ol><li><strong>Keep your programs simple to start</strong>.让你的第一个目标尽可能简单，一些你绝对可以实现的目标</li><li><strong>Add features over time</strong>.一旦您的简单程序运行良好并且运行良好，您就可以向其添加功能</li><li><strong>Focus on one area at a time</strong>.不要试图一次编写所有代码，也不要将注意力分散到多个任务上。一次专注于一项任务</li><li><strong>Test each piece of code as you go</strong>.编写一段代码，然后立即编译并测试它。如果它不起作用，您将确切地知道问题出在哪里，并且很容易修复。确定代码有效后，移至下一段并重复。完成代码的编写可能需要更长的时间，但是当您完成后，整个事情应该可以正常工作，并且您不必花费两倍的时间来弄清楚为什么它不起作用</li><li><strong>Don’t invest in perfecting early code</strong>.让你的功能最低限度地工作，然后继续。不要以完美为目标——重要的程序从来都不是完美的，而且总有更多的事情可以做来改进它们。达到“足够好”并继续前进</li></ol></li></ol><h1 id=调试-c-程序>调试 C++ 程序<a hidden class=anchor aria-hidden=true href=#调试-c-程序>#</a></h1><h2 id=调试过程>调试过程<a hidden class=anchor aria-hidden=true href=#调试过程>#</a></h2><ol><li>找到问题的根本原因（通常是不起作用的代码行）</li><li>确保您了解问题发生的原因</li><li>确定您将如何解决问题</li><li>修复问题</li><li>重新测试以确保问题已解决并且没有出现新问题</li></ol><h2 id=调试策略>调试策略<a hidden class=anchor aria-hidden=true href=#调试策略>#</a></h2><p>观察程序运行时的行为，并尝试从中诊断问题</p><ol><li>弄清楚如何<strong>重现问题</strong></li><li>运行程序并收集信息以<strong>缩小问题所在的范围</strong></li><li>重复前面的步骤，<strong>直到找到问题</strong></li></ol><h3 id=调试策略-1注释掉你的代码>调试策略 1：注释掉你的代码<a hidden class=anchor aria-hidden=true href=#调试策略-1注释掉你的代码>#</a></h3><p>如果您的程序表现出错误行为，减少必须搜索的代码量的一种方法是注释掉一些代码并查看问题是否仍然存在。如果问题仍然存在，则注释掉的代码不负责任</p><h3 id=调试策略-2验证代码流>调试策略 2：验证代码流<a hidden class=anchor aria-hidden=true href=#调试策略-2验证代码流>#</a></h3><p>另一个在更复杂的程序中常见的问题是程序调用一个函数的次数太多或太少（包括根本不调用）</p><p>在这种情况下，将语句放在函数的顶部以打印函数的名称会很有帮助。这样，当程序运行时，您可以看到调用了哪些函数</p><p>当<strong>出于调试目的打印信息时</strong>，使用 <code>std::cerr</code> 而不是 <code>std::cout</code>。这样做的一个原因是 std::cout 可能被缓冲，这意味着在您要求 std::cout 输出信息和它实际输出信息之间可能会有一个暂停。如果您使用 std::cout 进行输出，然后您的程序随后立即崩溃，则 std::cout 可能已经或可能还没有实际输出。这可能会误导您了解问题出在哪里。另一方面，std::cerr 是无缓冲<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>的，这意味着您发送给它的任何内容都会立即输出。这有助于确保所有调试输出尽快出现（以一些性能为代价，我们在调试时通常不关心）</p><p>使用 std::cerr 还有助于明确输出的信息是针对错误情况而不是正常情况</p><p>添加临时调试语句时，不缩进它们会很有帮助。这使它们更容易在以后找到并移除</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> getValue()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>std::cerr &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;getValue() called</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>4</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>std::cerr &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;main() called</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>    std::cout &lt;&lt; getValue;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=调试策略-3打印值>调试策略 3：打印值<a hidden class=anchor aria-hidden=true href=#调试策略-3打印值>#</a></h3><p>对于某些类型的错误，程序可能会计算或传递错误的值。</p><p>我们还可以输出变量（包括参数）或表达式的值，以确保它们是正确的。</p><p>For example:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> add(<span style=color:#fff;font-weight:700>int</span> x, <span style=color:#fff;font-weight:700>int</span> y)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>std::cerr &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;add() called (x=&#34;</span> &lt;&lt; x &lt;&lt;<span style=color:#0ff;font-weight:700>&#34;, y=&#34;</span> &lt;&lt; y &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;)</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> x + y;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>void</span> printResult(<span style=color:#fff;font-weight:700>int</span> z)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;The answer is: &#34;</span> &lt;&lt; z &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> getUserInput()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;Enter a number: &#34;</span>;
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>int</span> x{};
</span></span><span style=display:flex><span>	std::cin &gt;&gt; x;
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> x;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>int</span> x{ getUserInput() };
</span></span><span style=display:flex><span>std::cerr &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;main::x = &#34;</span> &lt;&lt; x &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>int</span> y{ getUserInput() };
</span></span><span style=display:flex><span>std::cerr &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;main::y = &#34;</span> &lt;&lt; y &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	std::cout &lt;&lt; x &lt;&lt; <span style=color:#0ff;font-weight:700>&#34; + &#34;</span> &lt;&lt; y &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>int</span> z{ add(x, <span style=color:#ff0;font-weight:700>5</span>) };
</span></span><span style=display:flex><span>std::cerr &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;main::z = &#34;</span> &lt;&lt; z &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>	printResult(z);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>现在我们将得到输出：</p><pre tabindex=0><code>Enter a number: 4
main::x = 4
Enter a number: 3
main::y = 3
add() called (x=4, y=5)
main::z = 9
The answer is: 9
</code></pre><p>虽然为诊断目的向程序添加调试语句是一种常见的基本技术，也是一种功能性技术（尤其是当调试器由于某种原因不可用时），但由于多种原因它并不是很好：</p><ol><li>调试语句使您的代码混乱。</li><li>调试语句使程序的输出混乱。</li><li>调试语句必须在完成后删除，这使得它们不可重用。</li><li>调试语句需要修改您的代码以添加和删除，这可能会引入新的错误。</li></ol><h3 id=条件化调试代码>条件化调试代码<a hidden class=anchor aria-hidden=true href=#条件化调试代码>#</a></h3><p>一种更容易在整个程序中禁用和启用调试的方法是使用预处理器指令使调试语句有条件：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#define ENABLE_DEBUG </span><span style=color:#007f7f>// comment out to disable debugging
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> getUserInput()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#ifdef ENABLE_DEBUG
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>std::cerr &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;getUserInput() called</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#endif
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;Enter a number: &#34;</span>;
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>int</span> x{};
</span></span><span style=display:flex><span>	std::cin &gt;&gt; x;
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> x;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#ifdef ENABLE_DEBUG
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>std::cerr &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;main() called</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#endif
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>    <span style=color:#fff;font-weight:700>int</span> x{ getUserInput() };
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;You entered: &#34;</span> &lt;&lt; x;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>现在我们可以通过注释/取消注释#define ENABLE_DEBUG 来启用调试。这使我们能够重用以前添加的调试语句，然后在用完它们后将它们禁用，而不必从代码中实际删除它们</p><p>这解决了必须删除调试语句的问题以及这样做的风险，但代价是代码更加混乱。这种方法的另一个缺点是，如果您输入错误（例如拼错“DEBUG”）或忘记将标头包含到代码文件中，则可能无法启用该文件的部分或全部调试</p><h3 id=使用日志>使用日志<a hidden class=anchor aria-hidden=true href=#使用日志>#</a></h3><p>通过预处理器进行条件化调试的另一种方法是将调试信息发送到日志文件。日志文件是记录软件中发生的事件的文件（通常存储在磁盘上）。将信息写入日志文件的过程称为日志记录。大多数应用程序和操作系统都会写入可用于帮助诊断发生的问题的日志文件</p><p>日志文件有几个优点。因为写入日志文件的信息与程序的输出是分开的，所以可以避免将正常输出和调试输出混合在一起造成的混乱。日志文件也可以很容易地发送给其他人进行诊断——所以如果有人使用你的软件有问题，你可以让他们把日志文件发给你，这可能会帮助你找到问题所在的线索</p><p>虽然您可以编写自己的代码来创建日志文件并将输出发送给它们，但最好还是使用许多现有的第三方日志记录工具之一</p><p>Using the <a href=https://github.com/SergiusTheBest/plog>plog</a> logger：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;plog/Log.h&gt; // Step 1: include the logger headers</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;plog/Initializers/RollingFileInitializer.h&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> getUserInput()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	PLOGD &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;getUserInput() called&#34;</span>; <span style=color:#007f7f>// PLOGD is defined by the plog library
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;Enter a number: &#34;</span>;
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>int</span> x{};
</span></span><span style=display:flex><span>	std::cin &gt;&gt; x;
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> x;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	plog::init(plog::debug, <span style=color:#0ff;font-weight:700>&#34;Logfile.txt&#34;</span>); <span style=color:#007f7f>// Step 2: initialize the logger
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>	PLOGD &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;main() called&#34;</span>; <span style=color:#007f7f>// Step 3: Output to the log as if you were writing to the console
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>int</span> x{ getUserInput() };
</span></span><span style=display:flex><span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;You entered: &#34;</span> &lt;&lt; x;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这是上述记录器的输出（在 <code>Logfile.txt</code> 文件中）：</p><pre tabindex=0><code>2018-12-26 20:03:33.295 DEBUG [4752] [main@14] main() called
2018-12-26 20:03:33.296 DEBUG [4752] [getUserInput@4] getUserInput() called
</code></pre><p>您如何包含、初始化和使用记录器将根据您选择的特定记录器而有所不同</p><p>请注意，使用此方法也不需要条件编译指令，因为大多数记录器都有减少/消除将输出写入日志的方法。这使得代码更容易阅读，因为条件编译行增加了很多混乱。使用 plog，可以通过将 init 语句更改为以下内容来暂时禁用日志记录：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>plog::init(plog::none , <span style=color:#0ff;font-weight:700>&#34;Logfile.txt&#34;</span>); <span style=color:#007f7f>// plog::none eliminates writing of most messages, essentially turning logging off
</span></span></span></code></pre></div><h2 id=使用集成调试器stepping步进>使用集成调试器：Stepping（步进）<a hidden class=anchor aria-hidden=true href=#使用集成调试器stepping步进>#</a></h2><p>当您运行您的程序时，执行从 main 函数的顶部开始，然后逐个语句按顺序执行，直到程序结束。在你的程序运行的任何时间点，程序都在跟踪很多事情：你正在使用的变量的值，调用了哪些函数（这样当这些函数返回时，程序就会知道在哪里返回），以及程序中的当前执行点（因此它知道接下来要执行哪个语句）。所有这些跟踪信息都称为您的程序状态（或简称为状态）</p><p><strong>Stepping</strong> 是一组相关调试器功能的名称，这些功能让我们逐条语句地执行（单步执行）我们的代码</p><p>箭头标记表示接下来将执行所指向的行</p><h3 id=step-into>Step into<a hidden class=anchor aria-hidden=true href=#step-into>#</a></h3><p><strong>步入</strong> 命令执行程序正常执行路径中的下一条语句，然后暂停程序的执行，以便我们可以使用调试器检查程序的状态。如果正在执行的语句包含一个函数调用，step into 会使程序跳转到被调用函数的顶部，并在那里暂停</p><h3 id=step-over>Step over<a hidden class=anchor aria-hidden=true href=#step-over>#</a></h3><p>同<strong>步入</strong>命令一样，<strong>步过</strong>命令执行程序正常执行路径中的下一条语句。然而，step into 将输入函数调用并逐行执行它们，step over 将不间断地执行整个函数，并在函数执行后将控制权返回给您</p><p>step over 命令提供了一种方便的方法来跳过函数，当您确定它们已经工作或现在对调试它们不感兴趣时</p><h3 id=step-out>Step out<a hidden class=anchor aria-hidden=true href=#step-out>#</a></h3><p>与其他两个步进命令不同，<strong>步出</strong> 命令不只是执行下一行代码。相反，它<strong>执行当前正在执行的函数中的所有剩余代码</strong>，然后在函数返回时将控制权返回给您</p><p>当你不小心进入了一个你不想调试的函数时，这个命令最有用</p><h2 id=使用集成调试器running-and-breakpoints运行和断点>使用集成调试器：Running and breakpoints（运行和断点）<a hidden class=anchor aria-hidden=true href=#使用集成调试器running-and-breakpoints运行和断点>#</a></h2><h3 id=run-to-cursor>Run to cursor<a hidden class=anchor aria-hidden=true href=#run-to-cursor>#</a></h3><p>第一个有用的命令通常称为<strong>运行到光标</strong>。此运行到光标命令执行程序，直到执行到达光标选择的语句。然后它将控制权返回给您，以便您可以从那时开始进行调试</p><h3 id=breakpoints>Breakpoints<a hidden class=anchor aria-hidden=true href=#breakpoints>#</a></h3><p><strong>断点</strong> 是一个特殊的标记，它告诉调试器在调试模式下运行时在断点处停止执行程序</p><h2 id=使用集成调试器调用堆栈>使用集成调试器：调用堆栈<a hidden class=anchor aria-hidden=true href=#使用集成调试器调用堆栈>#</a></h2><p>调用堆栈是为到达当前执行点而调用的所有活动函数的列表。调用堆栈包括每个调用的函数的条目，以及函数返回时将返回到哪一行代码。每当调用一个新函数时，该函数就会被添加到调用堆栈的顶部。当前函数返回给调用者时，它会从调用栈的顶部移除，控制权会返回到它下面的函数</p><p>调用堆栈窗口是一个显示当前调用堆栈的调试器窗口</p><p>函数名称后的行号显示了每个函数中要执行的下一行</p><p>由于调用堆栈的顶部条目代表当前正在执行的函数，因此此处的行号显示了执行恢复时将执行的下一行。调用堆栈中的其余条目表示将在某个时间点返回的函数，因此这些条目的行号表示函数返回后将执行的下一条语句</p><h2 id=在问题成为问题之前发现问题>在问题成为问题之前发现问题<a hidden class=anchor aria-hidden=true href=#在问题成为问题之前发现问题>#</a></h2><h3 id=重构你的代码>重构你的代码<a hidden class=anchor aria-hidden=true href=#重构你的代码>#</a></h3><p>当您向程序添加新功能（“行为更改”）时，您会发现某些功能的长度会增加。随着函数越来越长，它们变得越来越复杂，也越来越难以理解</p><p>解决此问题的一种方法是将单个长函数分解为多个较短的函数。这种在不改变代码行为的情况下对代码进行结构更改的过程（通常是为了使您的程序更有组织性、模块化或性能）称为<strong>重构</strong></p><p>一个函数占据一个垂直屏幕的代码通常被认为太长了——如果你必须滚动才能阅读整个函数，函数的可理解性会显着下降。但越短越好 &ndash; 少于十行的功能是好的。少于五行的函数就更好了</p><p>更改代码时，<strong>进行行为更改或结构更改</strong>，然后重新测试正确性。同时进行行为和结构更改往往会导致更多错误以及更难发现的错误</p><h3 id=约束>约束<a hidden class=anchor aria-hidden=true href=#约束>#</a></h3><p>基于约束的技术涉及添加一些额外的代码（如果需要，可以在非调试构建中编译出来）以检查是否违反了某些假设或期望集</p><p>例如，如果我们正在编写一个函数来计算一个数字的阶乘，它需要一个非负参数，该函数可以检查以确保调用者在继续之前传递了一个非负数。如果调用者传入一个负数，那么该函数可能会立即出错，而不是产生一些不确定的结果，从而有助于确保立即发现问题</p><p>一种常见的方法是通过 assert 和 static_assert</p><h1 id=基本数据类型>基本数据类型<a hidden class=anchor aria-hidden=true href=#基本数据类型>#</a></h1><h2 id=数据类型大小>数据类型大小<a hidden class=anchor aria-hidden=true href=#数据类型大小>#</a></h2><p>数据类型的大小取决于编译器和计算机体系结构！</p><p>C++ 仅保证每个基本数据类型都具有最小大小<div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/26/6381d2545c3fa.png><img src=https://bu.dusays.com/2022/11/26/6381d2545c3fa.png alt=1></a></div></p><p>为了获得最大的兼容性，您不应假设变量大于指定的最小大小</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;bool:</span><span style=color:#0ff;font-weight:700>\t\t</span><span style=color:#0ff;font-weight:700>&#34;</span> &lt;&lt; <span style=color:#fff;font-weight:700>sizeof</span>(<span style=color:#fff;font-weight:700>bool</span>) &lt;&lt; <span style=color:#0ff;font-weight:700>&#34; bytes</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;char:</span><span style=color:#0ff;font-weight:700>\t\t</span><span style=color:#0ff;font-weight:700>&#34;</span> &lt;&lt; <span style=color:#fff;font-weight:700>sizeof</span>(<span style=color:#fff;font-weight:700>char</span>) &lt;&lt; <span style=color:#0ff;font-weight:700>&#34; bytes</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;wchar_t:</span><span style=color:#0ff;font-weight:700>\t</span><span style=color:#0ff;font-weight:700>&#34;</span> &lt;&lt; <span style=color:#fff;font-weight:700>sizeof</span>(<span style=color:#fff;font-weight:700>wchar_t</span>) &lt;&lt; <span style=color:#0ff;font-weight:700>&#34; bytes</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;char16_t:</span><span style=color:#0ff;font-weight:700>\t</span><span style=color:#0ff;font-weight:700>&#34;</span> &lt;&lt; <span style=color:#fff;font-weight:700>sizeof</span>(<span style=color:#fff;font-weight:700>char16_t</span>) &lt;&lt; <span style=color:#0ff;font-weight:700>&#34; bytes</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;char32_t:</span><span style=color:#0ff;font-weight:700>\t</span><span style=color:#0ff;font-weight:700>&#34;</span> &lt;&lt; <span style=color:#fff;font-weight:700>sizeof</span>(<span style=color:#fff;font-weight:700>char32_t</span>) &lt;&lt; <span style=color:#0ff;font-weight:700>&#34; bytes</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;short:</span><span style=color:#0ff;font-weight:700>\t\t</span><span style=color:#0ff;font-weight:700>&#34;</span> &lt;&lt; <span style=color:#fff;font-weight:700>sizeof</span>(<span style=color:#fff;font-weight:700>short</span>) &lt;&lt; <span style=color:#0ff;font-weight:700>&#34; bytes</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;int:</span><span style=color:#0ff;font-weight:700>\t\t</span><span style=color:#0ff;font-weight:700>&#34;</span> &lt;&lt; <span style=color:#fff;font-weight:700>sizeof</span>(<span style=color:#fff;font-weight:700>int</span>) &lt;&lt; <span style=color:#0ff;font-weight:700>&#34; bytes</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;long:</span><span style=color:#0ff;font-weight:700>\t\t</span><span style=color:#0ff;font-weight:700>&#34;</span> &lt;&lt; <span style=color:#fff;font-weight:700>sizeof</span>(<span style=color:#fff;font-weight:700>long</span>) &lt;&lt; <span style=color:#0ff;font-weight:700>&#34; bytes</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;long long:</span><span style=color:#0ff;font-weight:700>\t</span><span style=color:#0ff;font-weight:700>&#34;</span> &lt;&lt; <span style=color:#fff;font-weight:700>sizeof</span>(<span style=color:#fff;font-weight:700>long</span> <span style=color:#fff;font-weight:700>long</span>) &lt;&lt; <span style=color:#0ff;font-weight:700>&#34; bytes</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;float:</span><span style=color:#0ff;font-weight:700>\t\t</span><span style=color:#0ff;font-weight:700>&#34;</span> &lt;&lt; <span style=color:#fff;font-weight:700>sizeof</span>(<span style=color:#fff;font-weight:700>float</span>) &lt;&lt; <span style=color:#0ff;font-weight:700>&#34; bytes</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;double:</span><span style=color:#0ff;font-weight:700>\t\t</span><span style=color:#0ff;font-weight:700>&#34;</span> &lt;&lt; <span style=color:#fff;font-weight:700>sizeof</span>(<span style=color:#fff;font-weight:700>double</span>) &lt;&lt; <span style=color:#0ff;font-weight:700>&#34; bytes</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;long double:</span><span style=color:#0ff;font-weight:700>\t</span><span style=color:#0ff;font-weight:700>&#34;</span> &lt;&lt; <span style=color:#fff;font-weight:700>sizeof</span>(<span style=color:#fff;font-weight:700>long</span> <span style=color:#fff;font-weight:700>double</span>) &lt;&lt; <span style=color:#0ff;font-weight:700>&#34; bytes</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>下面是我的 x64 机器的输出，使用 Clion：</p><pre tabindex=0><code>bool:           1 bytes
char:           1 bytes
wchar_t:        2 bytes
char16_t:       2 bytes
char32_t:       4 bytes
short:          2 bytes
int:            4 bytes
long:           4 bytes
long long:      8 bytes
float:          4 bytes
double:         8 bytes
long double:    16 bytes
</code></pre><p>如果您使用不同类型的机器或不同的编译器，您的结果可能会有所不同。请注意，您不能对 void 类型使用 sizeof 运算符，因为它没有大小（这样做会导致编译错误）</p><h2 id=无符号整数和有符号整数>无符号整数和有符号整数<a hidden class=anchor aria-hidden=true href=#无符号整数和有符号整数>#</a></h2><p>有符号整数范围：<div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/26/6381d81f385fa.png><img src=https://bu.dusays.com/2022/11/26/6381d81f385fa.png alt=1></a></div></p><p>无符号整数范围：<div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/26/6381d91f961eb.png><img src=https://bu.dusays.com/2022/11/26/6381d91f961eb.png alt=1></a></div></p><p>如果无符号整数超出范围，则将其除以大于该类型的最大数，只保留余数</p><p>在 C++ 的数学运算中（例如算术或比较），如果使用一个有符号整数和一个无符号整数，则<strong>有符号整数将转换为无符号整数</strong>。并且无符号整数不能存储负数，这会导致数据丢失</p><p>在保存整数（甚至应该是非负的整数）和数学运算时，有符号数优于无符号数。避免混合有符号和无符号数字</p><p>在 C++ 中仍然有一些情况必须使用无符号数：</p><p>首先，在处理位操作时首选无符号数。当需要明确定义的环绕行为时，它们也很有用（在某些算法中很有用，例如加密和随机数生成）</p><p>其次，无符号数的使用在某些情况下仍然是不可避免的，主要是那些与数组索引有关的情况。。在这些情况下，无符号值可以转换为有符号值</p><h2 id=固定宽度整数和-size_t>固定宽度整数和 size_t<a hidden class=anchor aria-hidden=true href=#固定宽度整数和-size_t>#</a></h2><h3 id=fixed-width-整数>Fixed-width 整数<a hidden class=anchor aria-hidden=true href=#fixed-width-整数>#</a></h3><p>为什么整数变量的大小不固定？</p><p>这可以追溯到 C，当时计算机速度很慢，性能是最受关注的问题。 C 选择有意保留整数的大小，以便编译器实现者可以选择在目标计算机体系结构上表现最佳的 int 大小</p><p>C99 定义了一组固定宽度的整数（在 stdint.h 头文件中），保证在任何体系结构上都具有相同的大小</p><p>C++ 正式采用这些固定宽度整数作为 C++11 的一部分。可以通过包含 <code>&lt;cstdint></code> 头文件来访问它们，它们在 std 命名空间内定义</p><p><div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/26/6381dcb67d0e0.png><img src=https://bu.dusays.com/2022/11/26/6381dcb67d0e0.png alt=1></a></div></p><h3 id=fast-and-least-整数>Fast and least 整数<a hidden class=anchor aria-hidden=true href=#fast-and-least-整数>#</a></h3><p>The fast 类型（<code>std::int_fast#_t</code> 和 <code>std::uint_fast#_t</code>）提供最快的有符号/无符号整数类型，宽度至少为 # 位（其中 # = 8、16、32 或 64）。例如，<code>std::int_fast32_t</code> 将为您提供最快的至少 32 位的有符号整数类型</p><p>The least 类型（<code>std::int_least#_t</code> 和 <code>std::uint_least#_t</code>）提供宽度至少为 # 位（其中 # = 8、16、32 或 64）的最小有符号/无符号整数类型。例如，<code>std::uint_least32_t</code> 将为您提供至少 32 位的最小无符号整数类型</p><p>示例：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;cstdint&gt; // for fixed-width integers</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;least 8:  &#34;</span> &lt;&lt; <span style=color:#fff;font-weight:700>sizeof</span>(std::<span style=color:#fff;font-weight:700>int_least8_t</span>) * <span style=color:#ff0;font-weight:700>8</span> &lt;&lt; <span style=color:#0ff;font-weight:700>&#34; bits</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;least 16: &#34;</span> &lt;&lt; <span style=color:#fff;font-weight:700>sizeof</span>(std::<span style=color:#fff;font-weight:700>int_least16_t</span>) * <span style=color:#ff0;font-weight:700>8</span> &lt;&lt; <span style=color:#0ff;font-weight:700>&#34; bits</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;least 32: &#34;</span> &lt;&lt; <span style=color:#fff;font-weight:700>sizeof</span>(std::<span style=color:#fff;font-weight:700>int_least32_t</span>) * <span style=color:#ff0;font-weight:700>8</span> &lt;&lt; <span style=color:#0ff;font-weight:700>&#34; bits</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;fast 8:  &#34;</span> &lt;&lt; <span style=color:#fff;font-weight:700>sizeof</span>(std::<span style=color:#fff;font-weight:700>int_fast8_t</span>) * <span style=color:#ff0;font-weight:700>8</span> &lt;&lt; <span style=color:#0ff;font-weight:700>&#34; bits</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;fast 16: &#34;</span> &lt;&lt; <span style=color:#fff;font-weight:700>sizeof</span>(std::<span style=color:#fff;font-weight:700>int_fast16_t</span>) * <span style=color:#ff0;font-weight:700>8</span> &lt;&lt; <span style=color:#0ff;font-weight:700>&#34; bits</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;fast 32: &#34;</span> &lt;&lt; <span style=color:#fff;font-weight:700>sizeof</span>(std::<span style=color:#fff;font-weight:700>int_fast32_t</span>) * <span style=color:#ff0;font-weight:700>8</span> &lt;&lt; <span style=color:#0ff;font-weight:700>&#34; bits</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Result：</p><pre tabindex=0><code>least 8:  8 bits
least 16: 16 bits
least 32: 32 bits

fast 8:  8 bits
fast 16: 16 bits
fast 32: 32 bits
</code></pre><p>然而，这些快速且最小的整数有其自身的缺点：首先，真正使用它们的程序员并不多，不熟悉会导致错误。其次，快速类型会导致与我们在 4 字节整数中看到的相同类型的内存浪费。最严重的是，由于快速/最小整数的大小可能会有所不同，因此您的程序可能会在解析为不同大小的架构上表现出不同的行为</p><h3 id=stdint8_t-和-stduint8_t-可能表现得像字符而不是整数>std::int8_t 和 std::uint8_t 可能表现得像字符而不是整数<a hidden class=anchor aria-hidden=true href=#stdint8_t-和-stduint8_t-可能表现得像字符而不是整数>#</a></h3><p>由于 C++ 规范中的疏忽，大多数编译器分别将 std::int8_t 和 std::uint8_t（以及相应的快速和最小固定宽度类型）定义为 signed char 和 unsigned char 类型，并将其视为相同的类型。这意味着这些 8 位类型的行为可能（或可能不）与其他固定宽度类型不同，这可能会导致错误。此行为是系统相关的，因此在一种体系结构上正确运行的程序可能无法编译或在另一种体系结构上正确运行</p><p>为了保持一致性，最好完全避免使用 std::int8_t 和 std::uint8_t（以及相关的快速和最少类型）（改用 std::int16_t 或 std::uint16_t）</p><p>8 位固定宽度整数类型通常被视为字符而不是整数值（这可能因系统而异）。大多数情况下首选 16 位固定整数类型</p><h3 id=best-practice>Best practice<a hidden class=anchor aria-hidden=true href=#best-practice>#</a></h3><p>我们的立场是正确比快速更好，在编译时失败比运行时更好——因此，我们建议避免使用快速/最少的类型，而使用固定宽度的类型。如果您后来发现需要支持无法编译固定宽度类型的平台，那么您可以在此时决定如何迁移您的程序（并彻底测试）</p><ol><li>当整数的大小无关紧要时，首选 int（例如，数字将始终适合 2 字节有符号整数的范围）。例如，如果您要求用户输入他们的年龄，或者从 1 数到 10，则 int 是 16 位还是 32 位都没有关系（数字将适合任何一种方式）。这将涵盖您可能遇到的绝大多数情况</li><li>存储需要保证范围的数量时，首选 <code>std::int#_t</code></li><li>在进行位操作或需要明确定义的环绕行为时，首选 <code>std::uint#_t</code></li><li>尽可能避免以下情况：<ol><li>存储数量的无符号类型</li><li>8 位固定宽度整数类型</li><li>Fast and least 整数类型</li><li>任何特定于编译器的固定宽度整数——例如，Visual Studio 定义了 <code>__int8</code>、<code>__int16</code> ……</li></ol></li></ol><h3 id=size_t>size_t<a hidden class=anchor aria-hidden=true href=#size_t>#</a></h3><p>sizeof（以及许多返回大小或长度值的函数）返回一个 std::size_t 类型的值。 std::size_t 被定义为无符号整数类型，通常用于表示对象的大小或长度</p><p>有趣的是，我们可以使用 sizeof 运算符（返回 std::size_t 类型的值）来询问 std::size_t 本身的大小：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;cstddef&gt; // std::size_t</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	std::cout &lt;&lt; <span style=color:#fff;font-weight:700>sizeof</span>(std::size_t) &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>就像整数的大小会因系统而异一样，std::size_t 的大小也会有所不同。 std::size_t 保证为无符号且至少为 16 位，但在大多数系统上将等同于应用程序的地址宽度。也就是说，对于 32 位应用程序，std::size_t 通常是 32 位无符号整数，而对于 64 位应用程序，size_t 通常是 64 位无符号整数。 size_t 被定义为足够大以容纳系统上可创建的最大对象的大小（以字节为单位）。例如，如果 std::size_t 为 4 字节宽，则系统上可创建的最大对象不能大于 4,294,967,295 字节，因为 4,294,967,295 是 4 字节无符号整数可以存储的最大数字。这只是对象大小的上限，实际大小限制可能会更低，具体取决于您使用的编译器</p><p>根据定义，任何大小（以字节为单位）大于 size_t 可以容纳的最大整数值的对象都被视为格式错误（并将导致编译错误），因为 sizeof 运算符将无法在不环绕的情况下返回大小</p><h2 id=浮点数ieee-754>浮点数（IEEE 754）<a hidden class=anchor aria-hidden=true href=#浮点数ieee-754>#</a></h2><h3 id=浮点范围和浮点精度>浮点范围和浮点精度<a hidden class=anchor aria-hidden=true href=#浮点范围和浮点精度>#</a></h3><p><div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/26/63820f12cc479.png><img src=https://bu.dusays.com/2022/11/26/63820f12cc479.png alt=1></a></div></p><p>使用浮点文字时，始终至少包含一位小数（即使小数为 0）。这有助于编译器理解该数字是浮点数而不是整数</p><pre tabindex=0><code>int x{5}; // 5 means integer
double y{5.0}; // 5.0 is a floating point literal (no suffix means double type by default)
float z{5.0f}; // 5.0 is a floating point literal, f suffix means float type
</code></pre><p>始终确保字面量的类型与分配给它们或用于初始化的变量的类型相匹配。否则会导致不必要的转换，可能会导致精度损失</p><p>确保在应该使用浮点文字的地方不使用整数文字。这包括初始化浮点对象或为浮点对象赋值、进行浮点运算以及调用需要浮点值的函数</p><p><div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/26/6382110b7d067.png><img src=https://bu.dusays.com/2022/11/26/6382110b7d067.png alt></a></div></p><p>输出浮点数时，std::cout 的默认精度为 6——也就是说，它假定所有浮点变量仅对 6 位有效（浮点数的最小精度），因此它将截断之后的任何内容</p><p>浮点变量的精度位数取决于大小（浮点数的精度低于双精度数）和存储的特定值（某些值的精度高于其他值）。浮点值的精度在 6 到 9 位之间，大多数浮点值至少有 7 位有效数字。双精度值的精度在 15 到 18 位之间，大多数双精度值至少有 16 位有效数字。 Long double 的最小精度为 15、18 或 33 位有效数字，具体取决于它占用的字节数</p><h3 id=舍入误差>舍入误差<a hidden class=anchor aria-hidden=true href=#舍入误差>#</a></h3><p>我们可以使用名为 std::setprecision() 的输出操纵器函数覆盖 std::cout 显示的默认精度。输出操纵器改变数据的输出方式，并在 iomanip 标头中定义</p><pre tabindex=0><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt; // for output manipulator std::setprecision()

int main()
{
    std::cout &lt;&lt; std::setprecision(16); // show 16 digits of precision
    std::cout &lt;&lt; 3.33333333333333333333333333333333333333f &lt;&lt;&#39;\n&#39;; // f suffix means float
    std::cout &lt;&lt; 3.33333333333333333333333333333333333333 &lt;&lt; &#39;\n&#39;; // no suffix means double

    return 0;
}
</code></pre><p>在使用需要比变量所能容纳的精度更高的浮点数时，必须小心</p><p><strong>除非空间非常宝贵，否则最好使用 double over float，因为 float 缺乏精度通常会导致不准确</strong></p><p>值 123456789.0 具有 10 位有效数字，但浮点值通常具有 7 位精度（而 123456792 的结果仅精确到 7 位有效数字）。我们失去了一些精度！当由于无法精确存储数字而导致精度丢失时，这称为<strong>舍入误差</strong></p><p>数学运算（例如加法和乘法）往往会使舍入误差增大。所以即使0.1在第17位有效位有舍入误差，但是当我们加上0.1十次时，舍入误差已经爬到第16位有效位了。继续操作会导致此错误变得越来越严重</p><h3 id=nan-和-inf>NaN 和 Inf<a hidden class=anchor aria-hidden=true href=#nan-和-inf>#</a></h3><p>有两种特殊类别的浮点数。第一个是 <code>Inf</code>，代表无穷大。 Inf 可以是正数或负数。第二个是 <code>NaN</code>，代表“不是数字”。有几种不同类型的 NaN（我们不会在这里讨论）。 NaN 和 Inf 仅在编译器对浮点数使用特定格式 (IEEE 754) 时可用</p><h3 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h3><p>总而言之，关于浮点数你应该记住两件事：</p><p>浮点数对于存储非常大或非常小的数字很有用，包括带有小数部分的数字</p><p>浮点数通常有小的舍入误差，即使数字的有效数字少于精度也是如此。很多时候这些都没有引起注意，因为它们太小了，而且因为输出的数字被截断了。但是，浮点数的比较可能不会给出预期的结果。对这些值执行数学运算将导致舍入误差变大</p><h2 id=布尔值>布尔值<a hidden class=anchor aria-hidden=true href=#布尔值>#</a></h2><p>如果您希望 std::cout 打印“true”或“false”而不是 0 或 1，您可以使用 std::boolalpha。这是一个例子：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#fff;font-weight:700>true</span> &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#fff;font-weight:700>false</span> &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    std::cout &lt;&lt; std::boolalpha; <span style=color:#007f7f>// print bools as true or false
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#fff;font-weight:700>true</span> &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#fff;font-weight:700>false</span> &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>您可以使用 std::noboolalpha 将其关闭</p><p>您不能使用除 0 1 外的整数初始化布尔值：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>bool</span> b{ <span style=color:#ff0;font-weight:700>4</span> }; <span style=color:#007f7f>// error: narrowing conversions disallowed
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	std::cout &lt;&lt; b;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>但是，在任何可以将整数转换为布尔值的上下文中，整数 0 将转换为 false，而任何其他整数将转换为 true</p><p>事实证明，std::cin 只接受布尔变量的两个输入：0 和 1（不是 true 或 false）。任何其他输入都会导致 std::cin 无声地失败。在这种情况下，因为我们输入了 true，所以 std::cin 默默地失败了。失败的输入也会将变量清零，因此 b 也被赋值 false。因此，当 std::cout 打印 b 的值时，它打印 0</p><p>要允许 std::cin 接受“false”和“true”作为输入，必须启用 std::boolalpha 选项：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>bool</span> b{};
</span></span><span style=display:flex><span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;Enter a boolean value: &#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#007f7f>// Allow the user to enter &#39;true&#39; or &#39;false&#39; for boolean values
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	<span style=color:#007f7f>// This is case-sensitive, so True or TRUE will not work
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	std::cin &gt;&gt; std::boolalpha;
</span></span><span style=display:flex><span>	std::cin &gt;&gt; b;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;You entered: &#34;</span> &lt;&lt; b &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>但是，当启用 std::boolalpha 时，“0”和“1”将不再被视为布尔值</p><h2 id=chars>Chars<a hidden class=anchor aria-hidden=true href=#chars>#</a></h2><p>char 数据类型旨在保存单个字符。字符可以是单个字母、数字、符号或空格</p><p>char 数据类型是整数类型，这意味着基础值存储为整数。类似于布尔值 0 被解释为 false 而非零被解释为 true 的方式，char 变量存储的整数被解释为 ASCII 字符</p><p>Char 由 C++ 定义为大小始终为 1 个字节。默认情况下，char 可以是有符号的或无符号的（尽管它通常是有符号的）。如果您使用 chars 来保存 ASCII 字符，则不需要指定符号（因为有符号和无符号字符都可以保存 0 到 127 之间的值）</p><p>如果您使用 char 来保存小整数（除非您明确优化空间，否则您不应该这样做），您应该始终指定它是有符号的还是无符号的。 signed char 可以保存 -128 到 127 之间的数字。unsigned char 可以保存 0 到 255 之间的数字</p><p><strong>将单个字符放在单引号中（ e.g. <code>'t'</code> or <code>'\n'</code>, not <code>"t"</code> or <code>"\n"</code>）这有助于编译器更有效地进行优化</strong></p><p>出于向后兼容性的原因，许多 C++ 编译器支持多字符文字，即包含多个字符（例如“56”）的字符文字。如果支持，它们具有实现定义的值（意味着它因编译器而异）。因为它们不是 C++ 标准的一部分，而且它们的值也没有严格定义，所以应该避免使用多字符文字</p><p>ASCII 之外最著名的映射是 Unicode 标准，它将超过 144,000 个整数映射到许多不同语言的字符。由于 Unicode 包含如此多的代码点，因此单个 Unicode 代码点需要 32 位来表示一个字符（称为 UTF-32）。但是，Unicode 字符也可以使用多个 16 位或 8 位字符（分别称为 UTF-16 和 UTF-8）进行编码</p><p>char16_t 和 char32_t 添加到 C++11 以提供对 16 位和 32 位 Unicode 字符的明确支持。 C++20 中添加了 char8_t</p><p>您不需要使用 char8_t、char16_t 或 char32_t，除非您计划让您的程序与 Unicode 兼容</p><p>同时，在处理字符（和字符串）时，您应该只使用 ASCII 字符。使用来自其他字符集的字符可能会导致您的字符显示不正确</p><h2 id=通过-static_cast-运算符进行显式类型转换>通过 static_cast 运算符进行显式类型转换<a hidden class=anchor aria-hidden=true href=#通过-static_cast-运算符进行显式类型转换>#</a></h2><pre tabindex=0><code>static_cast&lt;new_type&gt;(expression)
</code></pre><p><code>static_cast</code> 将表达式中的值作为输入，并返回转换为 <code>new_type</code> 指定类型（例如 int、bool、char、double）的值</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>void</span> print(<span style=color:#fff;font-weight:700>int</span> x)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	std::cout &lt;&lt; x;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	print( <span style=color:#fff;font-weight:700>static_cast</span>&lt;<span style=color:#fff;font-weight:700>int</span>&gt;(<span style=color:#ff0;font-weight:700>5.5</span>) ); <span style=color:#007f7f>// explicitly convert double value 5.5 to an int
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=常量和符号常量>常量和符号常量<a hidden class=anchor aria-hidden=true href=#常量和符号常量>#</a></h2><h3 id=const-variables>const variables<a hidden class=anchor aria-hidden=true href=#const-variables>#</a></h3><p>Const 变量必须在定义它们时进行初始化，然后不能通过赋值更改该值</p><p>Const 变量可以从其他变量（包括非常量变量）初始化</p><p>命名时以 “k” 开头, 大小写混合,例如：</p><pre tabindex=0><code>const int kDaysInAWeek = 7;
</code></pre><h3 id=符号常量>符号常量<a hidden class=anchor aria-hidden=true href=#符号常量>#</a></h3><p>符号常量指的是<strong>被赋予常量值的名称</strong>。<code>const variables</code> 是一种符号常量，因为变量有一个名称（它的标识符）和一个常量值</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#define MAX_STUDENTS_PER_CLASS 30
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;The class has &#34;</span> &lt;&lt; MAX_STUDENTS_PER_CLASS &lt;&lt; <span style=color:#0ff;font-weight:700>&#34; students.</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>编译此程序时，预处理器会将 MAX_STUDENTS_PER_CLASS 替换为字面值 30，然后编译器会将其编译为您的可执行文件</p><p>因为类对象宏有一个名字，并且替换文本是一个常量值，所以带有替换文本的类对象宏也是符号常量</p><h3 id=对于符号常量更喜欢常量变量而不是类对象宏>对于符号常量，更喜欢常量变量而不是类对象宏<a hidden class=anchor aria-hidden=true href=#对于符号常量更喜欢常量变量而不是类对象宏>#</a></h3><p>首先，因为宏是由预处理器解析的，所有出现的宏都在编译之前被定义的值替换。如果您正在调试代码，您将看不到实际值（例如 30）——您只会看到符号常量的名称（例如 MAX_STUDENTS_PER_CLASS）。因为这些#defined 值不是变量，所以您无法在调试器中添加监视来查看它们的值。如果您想知道 MAX_STUDENTS_PER_CLASS 解析为什么值，您必须找到 MAX_STUDENTS_PER_CLASS 的定义（可能在不同的文件中）。这会使您的程序更难调试</p><p>其次，宏可能与普通代码有命名冲突</p><p>第三，宏不遵循正常的作用域规则，这意味着在极少数情况下，在程序的一部分中定义的宏可能会与在程序的另一部分中编写的代码发生冲突，而它不应该与之交互</p><h2 id=编译时常量常量表达式和-constexpr>编译时常量、常量表达式和 constexpr<a hidden class=anchor aria-hidden=true href=#编译时常量常量表达式和-constexpr>#</a></h2><h3 id=constant-expressions>Constant expressions<a hidden class=anchor aria-hidden=true href=#constant-expressions>#</a></h3><p>常量表达式是可以在编译时由编译器求值的表达式。要成为常量表达式，表达式中的所有值必须在编译时已知（并且所有调用的运算符和函数必须支持编译时求值）</p><p>在编译时对常量表达式求值会使我们的编译时间变长（因为编译器必须做更多的工作），但这样的表达式只需要求值一次（而不是每次程序运行时）。生成的可执行文件速度更快，使用的内存更少</p><h3 id=compile-time-constants>Compile-time constants<a hidden class=anchor aria-hidden=true href=#compile-time-constants>#</a></h3><p>编译时常量是其值在编译时已知的常量。文字（例如“1”、“2.3”和“Hello, world!”）是一种编译时常量</p><p>Const 变量可能是也可能不是编译时常量</p><h3 id=compile-time-const>Compile-time const<a hidden class=anchor aria-hidden=true href=#compile-time-const>#</a></h3><p>如果 const 变量的初始值设定项是常量表达式，则它是编译时常量</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>const</span> <span style=color:#fff;font-weight:700>int</span> x { <span style=color:#ff0;font-weight:700>3</span> };  <span style=color:#007f7f>// x is a compile-time const
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	<span style=color:#fff;font-weight:700>const</span> <span style=color:#fff;font-weight:700>int</span> y { <span style=color:#ff0;font-weight:700>4</span> };  <span style=color:#007f7f>// y is a compile-time const
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>const</span> <span style=color:#fff;font-weight:700>int</span> z { x + y }; <span style=color:#007f7f>// x + y is a compile-time expression
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>	std::cout &lt;&lt; z &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>因为 x 和 y 的初始化值是常量表达式，所以 x 和 y 是编译时常量。这意味着 x + y 也是常量表达式。所以当编译器编译这个程序时，它可以计算 x + y 的值，并将常量表达式替换为结果文字 7</p><h3 id=runtime-const>Runtime const<a hidden class=anchor aria-hidden=true href=#runtime-const>#</a></h3><p>任何使用非常量表达式初始化的 const 变量都是运行时常量。运行时常量是其初始化值直到运行时才知道的常量</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> getNumber()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;Enter a number: &#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>int</span> y{};
</span></span><span style=display:flex><span>    std::cin &gt;&gt; y;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> y;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>const</span> <span style=color:#fff;font-weight:700>int</span> x{ <span style=color:#ff0;font-weight:700>3</span> };           <span style=color:#007f7f>// x is a compile time constant
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>const</span> <span style=color:#fff;font-weight:700>int</span> y{ getNumber() }; <span style=color:#007f7f>// y is a runtime constant
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>const</span> <span style=color:#fff;font-weight:700>int</span> z{ x + y };       <span style=color:#007f7f>// x + y is a runtime expression
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    std::cout &lt;&lt; z &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;     <span style=color:#007f7f>// this is also a runtime expression
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>即使 y 是常量，初始化值（getNumber() 的返回值）直到运行时才知道。因此，y 是运行时常量，而不是编译时常量。因此，表达式 x + y 是一个运行时表达式</p><h3 id=constexpr-关键字>constexpr 关键字<a hidden class=anchor aria-hidden=true href=#constexpr-关键字>#</a></h3><p>当你声明一个 const 变量时，编译器会隐式地跟踪它是运行时常量还是编译时常量。在大多数情况下，除了优化目的之外，这无关紧要，但有一些奇怪的情况，C++ 需要编译时常量而不是运行时常量</p><p>因为编译时常量通常允许更好的优化（并且几乎没有缺点），所以我们通常希望尽可能使用编译时常量</p><p>我们可以寻求编译器的帮助，以确保我们得到一个我们期望的编译时常量。为此，我们在变量声明中使用 constexpr 关键字而不是 const。 constexpr（“常量表达式”的缩写）变量只能是编译时常量。如果 constexpr 变量的初始化值不是常量表达式，编译器会出错</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> five()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>5</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>constexpr</span> <span style=color:#fff;font-weight:700>double</span> gravity { <span style=color:#ff0;font-weight:700>9.8</span> }; <span style=color:#007f7f>// ok: 9.8 is a constant expression
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> <span style=color:#fff;font-weight:700>int</span> sum { <span style=color:#ff0;font-weight:700>4</span> + <span style=color:#ff0;font-weight:700>5</span> };      <span style=color:#007f7f>// ok: 4 + 5 is a constant expression
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> <span style=color:#fff;font-weight:700>int</span> something { sum };  <span style=color:#007f7f>// ok: sum is a constant expression
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;Enter your age: &#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>int</span> age{};
</span></span><span style=display:flex><span>    std::cin &gt;&gt; age;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>constexpr</span> <span style=color:#fff;font-weight:700>int</span> myAge { age };      <span style=color:#007f7f>// compile error: age is not a constant expression
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> <span style=color:#fff;font-weight:700>int</span> f { five() };       <span style=color:#007f7f>// compile error: return value of five() is not a constant expression
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>任何在初始化后不应修改且其初始值设定项在编译时已知的变量都应声明为 <code>constexpr</code></p><p>任何在初始化后不应修改且其初始值设定项在编译时未知的变量都应声明为 <code>const</code></p><h2 id=literals>Literals<a hidden class=anchor aria-hidden=true href=#literals>#</a></h2><p>文字是直接插入代码中的未命名值。例如：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>5</span>;                   <span style=color:#007f7f>// 5 is an integer literal
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>bool</span> myNameIsAlex { <span style=color:#fff;font-weight:700>true</span> }; <span style=color:#007f7f>// true is a boolean literal
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>std::cout &lt;&lt; <span style=color:#ff0;font-weight:700>3.4</span>;           <span style=color:#007f7f>// 3.4 is a double literal
</span></span></span></code></pre></div><p>如对象有类型一样，所有文字都有类型。文字的类型是从文字的值推导出来的</p><h2 id=十进制二进制十六进制和八进制>十进制、二进制、十六进制和八进制<a hidden class=anchor aria-hidden=true href=#十进制二进制十六进制和八进制>#</a></h2><h3 id=二进制文字和数字分隔符>二进制文字和数字分隔符<a hidden class=anchor aria-hidden=true href=#二进制文字和数字分隔符>#</a></h3><p>在 C++14 之前，不支持二进制文字。然而，十六进制文字为我们提供了一个有用的解决方法（您可能仍会在现有代码库中看到）：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>int</span> bin{};    <span style=color:#007f7f>// assume 16-bit ints
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    bin = <span style=color:#ff0;font-weight:700>0x0001</span>; <span style=color:#007f7f>// assign binary 0000 0000 0000 0001 to the variable
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    bin = <span style=color:#ff0;font-weight:700>0x0002</span>; <span style=color:#007f7f>// assign binary 0000 0000 0000 0010 to the variable
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    bin = <span style=color:#ff0;font-weight:700>0x0004</span>; <span style=color:#007f7f>// assign binary 0000 0000 0000 0100 to the variable
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    bin = <span style=color:#ff0;font-weight:700>0x0008</span>; <span style=color:#007f7f>// assign binary 0000 0000 0000 1000 to the variable
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    bin = <span style=color:#ff0;font-weight:700>0x0010</span>; <span style=color:#007f7f>// assign binary 0000 0000 0001 0000 to the variable
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    bin = <span style=color:#ff0;font-weight:700>0x0020</span>; <span style=color:#007f7f>// assign binary 0000 0000 0010 0000 to the variable
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    bin = <span style=color:#ff0;font-weight:700>0x0040</span>; <span style=color:#007f7f>// assign binary 0000 0000 0100 0000 to the variable
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    bin = <span style=color:#ff0;font-weight:700>0x0080</span>; <span style=color:#007f7f>// assign binary 0000 0000 1000 0000 to the variable
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    bin = <span style=color:#ff0;font-weight:700>0x00FF</span>; <span style=color:#007f7f>// assign binary 0000 0000 1111 1111 to the variable
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    bin = <span style=color:#ff0;font-weight:700>0x00B3</span>; <span style=color:#007f7f>// assign binary 0000 0000 1011 0011 to the variable
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    bin = <span style=color:#ff0;font-weight:700>0xF770</span>; <span style=color:#007f7f>// assign binary 1111 0111 0111 0000 to the variable
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在 C++14 中，我们可以通过使用 0b 前缀来使用二进制文字：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>int</span> bin{};        <span style=color:#007f7f>// assume 16-bit ints
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    bin = <span style=color:#ff0;font-weight:700>0b1</span>;        <span style=color:#007f7f>// assign binary 0000 0000 0000 0001 to the variable
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    bin = <span style=color:#ff0;font-weight:700>0b11</span>;       <span style=color:#007f7f>// assign binary 0000 0000 0000 0011 to the variable
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    bin = <span style=color:#ff0;font-weight:700>0b1010</span>;     <span style=color:#007f7f>// assign binary 0000 0000 0000 1010 to the variable
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    bin = <span style=color:#ff0;font-weight:700>0b11110000</span>; <span style=color:#007f7f>// assign binary 0000 0000 1111 0000 to the variable
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>由于长文本可能难以阅读，C++14 还添加了使用引号 (‘) 作为数字分隔符的功能（分隔符不能出现在值的第一位数字之前）（数字分隔符纯粹是视觉上的，不会以任何方式影响字面值）</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>int</span> bin { <span style=color:#ff0;font-weight:700>0b1011&#39;0010</span> };  <span style=color:#007f7f>// assign binary 1011 0010 to the variable
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>long</span> value { <span style=color:#ff0;font-weight:700>2&#39;132&#39;673&#39;462</span> }; <span style=color:#007f7f>// much easier to read than 2132673462
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=以十进制八进制或十六进制输出值>以十进制、八进制或十六进制输出值<a hidden class=anchor aria-hidden=true href=#以十进制八进制或十六进制输出值>#</a></h3><p>默认情况下，C++ 以十进制形式输出值。但是，您可以通过使用 std::dec、std::oct 和 std::hex I/O 操纵器更改输出格式：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>int</span> x { <span style=color:#ff0;font-weight:700>12</span> };
</span></span><span style=display:flex><span>    std::cout &lt;&lt; x &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>; <span style=color:#007f7f>// decimal (by default)
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    std::cout &lt;&lt; std::hex &lt;&lt; x &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>; <span style=color:#007f7f>// hexadecimal
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    std::cout &lt;&lt; x &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>; <span style=color:#007f7f>// now hexadecimal
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    std::cout &lt;&lt; std::oct &lt;&lt; x &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>; <span style=color:#007f7f>// octal
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    std::cout &lt;&lt; std::dec &lt;&lt; x &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>; <span style=color:#007f7f>// return to decimal
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    std::cout &lt;&lt; x &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>; <span style=color:#007f7f>// decimal
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=以二进制输出值>以二进制输出值<a hidden class=anchor aria-hidden=true href=#以二进制输出值>#</a></h3><p>以二进制形式输出值有点困难，因为 std::cout 没有内置此功能。幸运的是，C++ 标准库包含一个名为 std::bitset 的类型，它将为我们完成此操作（在 <code>&lt;bitset></code> 标头中）。要使用 std::bitset，我们可以定义一个 std::bitset 变量并告诉 std::bitset 我们要存储多少位。位数必须是编译时常量。 std::bitset 可以用无符号整数值（任何格式，包括十进制、八进制、十六进制或二进制）初始化</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;bitset&gt; // for std::bitset</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#007f7f>// std::bitset&lt;8&gt; means we want to store 8 bits
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	std::bitset&lt;<span style=color:#ff0;font-weight:700>8</span>&gt; bin1{ <span style=color:#ff0;font-weight:700>0b1100&#39;0101</span> }; <span style=color:#007f7f>// binary literal for binary 1100 0101
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	std::bitset&lt;<span style=color:#ff0;font-weight:700>8</span>&gt; bin2{ <span style=color:#ff0;font-weight:700>0xC5</span> }; <span style=color:#007f7f>// hexadecimal literal for binary 1100 0101
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>	std::cout &lt;&lt; bin1 &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span> &lt;&lt; bin2 &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>	std::cout &lt;&lt; std::bitset&lt;<span style=color:#ff0;font-weight:700>4</span>&gt;{ <span style=color:#ff0;font-weight:700>0b1010</span> } &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>; <span style=color:#007f7f>// create a temporary std::bitset and print it
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=stdstring>std::string<a hidden class=anchor aria-hidden=true href=#stdstring>#</a></h2><h3 id=使用-stdgetline-输入文本>使用 std::getline() 输入文本<a hidden class=anchor aria-hidden=true href=#使用-stdgetline-输入文本>#</a></h3><p>事实证明，当使用 operator&#187; 从 std::cin 中提取字符串时，operator&#187; 只返回它遇到的第一个空格之前的字符。任何其他字符都留在 std::cin 中，等待下一次提取</p><p>要将整行输入读入字符串，最好改用 <code>std::getline()</code> 函数。 std::getline() 需要两个参数：第一个是 std::cin，第二个是您的字符串变量</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;string&gt; // For std::string and std::getline</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;Enter your full name: &#34;</span>;
</span></span><span style=display:flex><span>    std::string name{};
</span></span><span style=display:flex><span>    std::getline(std::cin &gt;&gt; std::ws, name); <span style=color:#007f7f>// read a full line of text into name
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;Enter your age: &#34;</span>;
</span></span><span style=display:flex><span>    std::string age{};
</span></span><span style=display:flex><span>    std::getline(std::cin &gt;&gt; std::ws, age); <span style=color:#007f7f>// read a full line of text into age
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;Your name is &#34;</span> &lt;&lt; name &lt;&lt; <span style=color:#0ff;font-weight:700>&#34; and your age is &#34;</span> &lt;&lt; age &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>std::ws</code> 输入操纵器告诉 std::cin 在提取之前<strong>忽略任何前导空格</strong>。前导空白是出现在字符串开头的任何空白字符（空格、制表符、换行符）</p><p>如果使用 <code>std::getline()</code> 读取字符串，请使用 <code>std::cin >> std::ws</code> 输入操纵器忽略前导空格</p><p>将提取运算符 (&#187;) 与 std::cin 一起使用会忽略前导空格</p><p>std::getline() 不会忽略前导空格，除非您使用输入操纵器 std::ws</p><h3 id=字符串长度>字符串长度<a hidden class=anchor aria-hidden=true href=#字符串长度>#</a></h3><p>如果我们想知道 std::string 中有多少个字符，我们可以向 std::string 对象询问它的长度。注意 std::string::length() 返回一个无符号整数值（很可能是 size_t 类型）。如果你想将长度分配给一个 int 变量，你应该对其进行 static_cast 以避免编译器关于有符号/无符号转换的警告：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> length { <span style=color:#fff;font-weight:700>static_cast</span>&lt;<span style=color:#fff;font-weight:700>int</span>&gt;(name.length()) };
</span></span></code></pre></div><h3 id=stdstring-的初始化和复制开销很大>std::string 的初始化和复制开销很大<a hidden class=anchor aria-hidden=true href=#stdstring-的初始化和复制开销很大>#</a></h3><p>每当初始化 std::string 时，都会生成用于初始化它的字符串的副本。每当 std::string 按值传递给 std::string 参数时，都会生成另一个副本。不要按值传递 std::string，因为生成 std::string 的副本开销很大。更喜欢 std::string_view 参数</p><h3 id=literals-forstdstring--stdstring_view>Literals for <code>std::string</code> & <code>std::string_view</code><a hidden class=anchor aria-hidden=true href=#literals-forstdstring--stdstring_view>#</a></h3><p>双引号字符串文字（比如“Hello, world!”）默认是 C 风格的字符串</p><p>我们可以通过在双引号字符串文字后使用 s 后缀来创建类型为 std::string 的字符串文字</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;string&gt;      // for std::string</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;string_view&gt; // for std::string_view</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>using</span> <span style=color:#fff;font-weight:700>namespace</span> std::literals; <span style=color:#007f7f>// easiest way to access the s and sv suffixes
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;foo</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;   <span style=color:#007f7f>// no suffix is a C-style string literal
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;goo</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>s;  <span style=color:#007f7f>// s suffix is a std::string literal
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;moo</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>sv; <span style=color:#007f7f>// sv suffix is a std::string_view literal
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>“s”后缀位于命名空间 std::literals::string_literals 中。“sv”后缀位于命名空间 std::literals::string_view_literals 中。访问文字后缀的最简单方法是通过使用指令使用命名空间 std::literals。这是可以使用整个命名空间的例外情况之一，因为其中定义的后缀不太可能与您的任何代码冲突</p><p>你可能不需要经常使用 std::string 文字（因为用 C 风格的字符串文字初始化 std::string 对象很好），但我们会在以后的课程中看到一些使用 std 的情况::string literals 而不是 C 风格的 string literals 使事情变得更容易</p><h3 id=constexpr-字符串>Constexpr 字符串<a hidden class=anchor aria-hidden=true href=#constexpr-字符串>#</a></h3><p>如果您尝试定义一个 constexpr std::string，您的编译器可能会产生一个错误</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;string&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>using</span> <span style=color:#fff;font-weight:700>namespace</span> std::literals;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>constexpr</span> std::string name{ <span style=color:#0ff;font-weight:700>&#34;Alex&#34;</span>s }; <span style=color:#007f7f>// compile error
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;My name is: &#34;</span> &lt;&lt; name;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>发生这种情况是因为 constexpr std::string 在 C++17 或更早版本中不受支持，并且在 C++20 中仅提供最低限度的支持。如果您需要 constexpr 字符串，请改用 std::string_view</p><h2 id=stdstring_view>std::string_view<a hidden class=anchor aria-hidden=true href=#stdstring_view>#</a></h2><h3 id=stdstring_view-c17>std::string_view C++17<a hidden class=anchor aria-hidden=true href=#stdstring_view-c17>#</a></h3><p>为了解决 std::string 初始化（或复制）成本高昂的问题，C++17 引入了 std::string_view（位于 &lt;string_view> 标头中）。 std::string_view 提供对现有字符串（C 风格字符串文字、std::string 或 char 数组）的只读访问，而无需制作副本</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;string_view&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>void</span> printSV(std::string_view str) <span style=color:#007f7f>// now a std::string_view
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>{
</span></span><span style=display:flex><span>    std::cout &lt;&lt; str &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    std::string_view s{ <span style=color:#0ff;font-weight:700>&#34;Hello, world!&#34;</span> }; <span style=color:#007f7f>// now a std::string_view
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    printSV(s);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>当我们用 C 风格的字符串文字“Hello, world!”初始化 std::string_view s 时，s 提供对“Hello, world!”的只读访问。无需复制字符串。当我们将 s 传递给 printSV() 时，参数 str 从 s 初始化。这使我们能够通过 str 访问“Hello, world!”，不用再次复制字符串</p><p>当您需要只读字符串时，尤其是对于函数参数，优先使用 std::string_view 而不是 std::string</p><h3 id=constexpr-stdstring_view>constexpr std::string_view<a hidden class=anchor aria-hidden=true href=#constexpr-stdstring_view>#</a></h3><p>std::string_view 完全支持 constexpr：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;string_view&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>constexpr</span> std::string_view s{ <span style=color:#0ff;font-weight:700>&#34;Hello, world!&#34;</span> };
</span></span><span style=display:flex><span>    std::cout &lt;&lt; s &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>; <span style=color:#007f7f>// s will be replaced with &#34;Hello, world!&#34; at compile-time
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=stdstring--stdstring_view>std::string & std::string_view<a hidden class=anchor aria-hidden=true href=#stdstring--stdstring_view>#</a></h3><p>可以使用 std::string 初始值设定项创建 std::string_view，并且 std::string 将隐式转换为 std::string_view：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;string&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;string_view&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>void</span> printSV(std::string_view str)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    std::cout &lt;&lt; str &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    std::string s{ <span style=color:#0ff;font-weight:700>&#34;Hello, world&#34;</span> };
</span></span><span style=display:flex><span>    std::string_view sv{ s }; <span style=color:#007f7f>// Initialize a std::string_view from a std::string
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    std::cout &lt;&lt; sv &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    printSV(s); <span style=color:#007f7f>// implicitly convert a std::string to std::string_view
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>因为 std::string 复制了它的初始化器（这开销很大），C++ 不允许将 std::string_view 隐式转换为 std::string。但是，我们可以使用 std::string_view 初始值设定项显式创建 std::string，或者我们可以使用 static_cast 将现有的 std::string_view 转换为 std::string</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;string&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;string_view&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>void</span> printString(std::string str)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    std::cout &lt;&lt; str &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  std::string_view sv{ <span style=color:#0ff;font-weight:700>&#34;balloon&#34;</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  std::string str{ sv }; <span style=color:#007f7f>// okay, we can create std::string using std::string_view initializer
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>  <span style=color:#007f7f>// printString(sv);   // compile error: won&#39;t implicitly convert std::string_view to a std::string
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>  printString(<span style=color:#fff;font-weight:700>static_cast</span>&lt;std::string&gt;(sv)); <span style=color:#007f7f>// okay, we can explicitly cast a std::string_view to a std::string
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>  <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=operators操作符>Operators（操作符）<a hidden class=anchor aria-hidden=true href=#operators操作符>#</a></h1><h2 id=----运算符><code>,</code> & <code>? :</code> 运算符<a hidden class=anchor aria-hidden=true href=#----运算符>#</a></h2><p>C++ 没有定义函数参数或运算符操作数的计算顺序</p><p>不要在给定语句中多次使用具有副作用的变量。如果这样做，结果可能是未定义的</p><p>逗号在所有运算符中的优先级最低，甚至低于赋值</p><p>请注意， <code>? :</code> 运算符的优先级非常低。如果除了将结果分配给变量之外做任何事情，整个 <code>? :</code> 运算符也需要用括号括起来</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std::cout &lt;&lt; ((x &gt; y) ? x : y) &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span></code></pre></div><p>如果在上述情况下我们不将整个条件运算符括起来会发生什么。因为 &#171; 运算符的优先级高于 ?: 运算符，所以语句：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std::cout &lt;&lt; (x &gt; y) ? x : y &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span></code></pre></div><p>将评估为：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>(std::cout &lt;&lt; (x &gt; y)) ? x : y &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span></code></pre></div><h2 id=比较浮点数大小>比较浮点数大小<a hidden class=anchor aria-hidden=true href=#比较浮点数大小>#</a></h2><p>进行浮点相等的最常见方法涉及使用一个函数来查看两个数字是否几乎相同。如果它们“足够接近”，那么我们称它们相等。用于表示“足够接近”的值传统上称为 epsilon。 Epsilon 通常被定义为一个小的正数（例如 0.00000001，有时写作 1e-8）</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;cmath&gt; // for std::abs()</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#007f7f>// epsilon is an absolute value
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>bool</span> approximatelyEqualAbs(<span style=color:#fff;font-weight:700>double</span> a, <span style=color:#fff;font-weight:700>double</span> b, <span style=color:#fff;font-weight:700>double</span> absEpsilon)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#007f7f>// if the distance between a and b is less than absEpsilon, then a and b are &#34;close enough&#34;
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>return</span> std::abs(a - b) &lt;= absEpsilon;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>虽然这个功能可以工作，但不是很好。 0.00001 的 epsilon 适用于 1.0 左右的输入，对于 0.0000001 左右的输入太大，对于 10,000 这样的输入太小</p><p>著名计算机科学家唐纳德·高德纳 (Donald Knuth) 在他的著作“计算机编程的艺术，第二卷：半数值算法 (Addison-Wesley, 1969)”一书中提出了以下方法：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;algorithm&gt; // std::max</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;cmath&gt; // std::abs</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#007f7f>// return true if the difference between a and b is within epsilon percent of the larger of a and b
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>bool</span> approximatelyEqualRel(<span style=color:#fff;font-weight:700>double</span> a, <span style=color:#fff;font-weight:700>double</span> b, <span style=color:#fff;font-weight:700>double</span> relEpsilon)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> (std::abs(a - b) &lt;= (std::max(std::abs(a), std::abs(b)) * relEpsilon));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在这种情况下，epsilon 不是绝对数字，而是相对于 a 或 b 的大小。在 &lt;= 运算符的左侧，std::abs(a - b) 告诉我们 a 和 b 之间的距离为正数。在 &lt;= 运算符的右侧，我们需要计算我们愿意接受的“足够接近”的最大值。为此，该算法选择 a 和 b 中较大的一个（作为数字总体大小的粗略指标），然后将其乘以 relEpsilon。在此函数中，relEpsilon 表示百分比。例如，如果我们想说“足够接近”意味着 a 和 b 在 a 和 b 中较大者的 1% 以内，我们传入 0.01 (1% = 1/100 = 0.01) 的 relEpsilon。 relEpsilon 的值可以根据情况调整为最合适的值（例如，0.002 的 epsilon 表示在 0.2% 以内）</p><p>要执行不等式 (!=) 而不是相等，只需调用此函数并使用逻辑 NOT 运算符 (!) 翻转结果：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#fff;font-weight:700>if</span> (!approximatelyEqualRel(a, b, <span style=color:#ff0;font-weight:700>0.001</span>))
</span></span><span style=display:flex><span>    std::cout &lt;&lt; a &lt;&lt; <span style=color:#0ff;font-weight:700>&#34; is not equal to &#34;</span> &lt;&lt; b &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span></code></pre></div><p>虽然 approximatelyEqualRel() 函数适用于大多数情况，但它并不完美，尤其是当数字接近零时：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;algorithm&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;cmath&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#007f7f>// return true if the difference between a and b is within epsilon percent of the larger of a and b
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>bool</span> approximatelyEqualRel(<span style=color:#fff;font-weight:700>double</span> a, <span style=color:#fff;font-weight:700>double</span> b, <span style=color:#fff;font-weight:700>double</span> relEpsilon)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> (std::abs(a - b) &lt;= (std::max(std::abs(a), std::abs(b)) * relEpsilon));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#007f7f>// a is really close to 1.0, but has rounding errors, so it&#39;s slightly smaller than 1.0
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	<span style=color:#fff;font-weight:700>double</span> a{ <span style=color:#ff0;font-weight:700>0.1</span> + <span style=color:#ff0;font-weight:700>0.1</span> + <span style=color:#ff0;font-weight:700>0.1</span> + <span style=color:#ff0;font-weight:700>0.1</span> + <span style=color:#ff0;font-weight:700>0.1</span> + <span style=color:#ff0;font-weight:700>0.1</span> + <span style=color:#ff0;font-weight:700>0.1</span> + <span style=color:#ff0;font-weight:700>0.1</span> + <span style=color:#ff0;font-weight:700>0.1</span> + <span style=color:#ff0;font-weight:700>0.1</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#007f7f>// First, let&#39;s compare a (almost 1.0) to 1.0.
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	std::cout &lt;&lt; approximatelyEqualRel(a, <span style=color:#ff0;font-weight:700>1.0</span>, <span style=color:#ff0;font-weight:700>1e-8</span>) &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#007f7f>// Second, let&#39;s compare a-1.0 (almost 0.0) to 0.0
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	std::cout &lt;&lt; approximatelyEqualRel(a-<span style=color:#ff0;font-weight:700>1.0</span>, <span style=color:#ff0;font-weight:700>0.0</span>, <span style=color:#ff0;font-weight:700>1e-8</span>) &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这会返回：</p><pre tabindex=0><code>1
0
</code></pre><p>避免这种情况的一种方法是同时使用绝对 epsilon（如我们在第一种方法中所做的）和相对 epsilon（如我们在 Knuth 的方法中所做的）：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007f7f>// return true if the difference between a and b is less than absEpsilon, or within relEpsilon percent of the larger of a and b
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>bool</span> approximatelyEqualAbsRel(<span style=color:#fff;font-weight:700>double</span> a, <span style=color:#fff;font-weight:700>double</span> b, <span style=color:#fff;font-weight:700>double</span> absEpsilon, <span style=color:#fff;font-weight:700>double</span> relEpsilon)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#007f7f>// Check if the numbers are really close -- needed when comparing numbers near zero.
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>double</span> diff{ std::abs(a - b) };
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>if</span> (diff &lt;= absEpsilon)
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>return</span> <span style=color:#fff;font-weight:700>true</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#007f7f>// Otherwise fall back to Knuth&#39;s algorithm
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>return</span> (diff &lt;= (std::max(std::abs(a), std::abs(b)) * relEpsilon));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在这个算法中，我们首先检查 a 和 b 在绝对值上是否接近，这处理了 a 和 b 都接近于零的情况。 absEpsilon 参数应设置为非常小的值（例如 1e-12）。如果失败，则我们使用相对 epsilon 回退到 Knuth 的算法</p><p>浮点数的比较是一个困难的话题，并且没有适用于所有情况的“一刀切”算法。但是，absEpsilon 为 1e-12 和 relEpsilon 为 1e-8 的 approximatesEqualAbsRel() 应该足以处理您将遇到的大多数情况</p><h2 id=逻辑-xor-运算符>逻辑 XOR 运算符<a hidden class=anchor aria-hidden=true href=#逻辑-xor-运算符>#</a></h2><p>C++ 不提供逻辑 XOR 运算符。与逻辑或或逻辑与不同，逻辑异或不能进行短路评估。因此，从逻辑 OR 和逻辑 AND 运算符中创建逻辑 XOR 运算符具有挑战性。但是，您可以使用不等运算符 (!=) 轻松模拟逻辑 XOR：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#fff;font-weight:700>if</span> (a != b) ... <span style=color:#007f7f>// a XOR b, assuming a and b are Booleans
</span></span></span></code></pre></div><p>这可以扩展到多个操作数，如下所示：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#fff;font-weight:700>if</span> (a != b != c != d) ... <span style=color:#007f7f>// a XOR b XOR c XOR d, assuming a, b, c, and d are Booleans
</span></span></span></code></pre></div><p>请注意，上述 XOR 模式仅在操作数为布尔值（而非整数）时才有效。如果您需要一种适用于非布尔操作数的逻辑 XOR 形式，您可以将它们静态转换为布尔值：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#fff;font-weight:700>if</span> (<span style=color:#fff;font-weight:700>static_cast</span>&lt;<span style=color:#fff;font-weight:700>bool</span>&gt;(a) != <span style=color:#fff;font-weight:700>static_cast</span>&lt;<span style=color:#fff;font-weight:700>bool</span>&gt;(b) != <span style=color:#fff;font-weight:700>static_cast</span>&lt;<span style=color:#fff;font-weight:700>bool</span>&gt;(c) != <span style=color:#fff;font-weight:700>static_cast</span>&lt;<span style=color:#fff;font-weight:700>bool</span>&gt;(d)) ... <span style=color:#007f7f>// a XOR b XOR c XOR d, for any type that can be converted to bool
</span></span></span></code></pre></div><h1 id=位操作>位操作<a hidden class=anchor aria-hidden=true href=#位操作>#</a></h1><h2 id=位标志-and-位操作-via-stdbitset>位标志 and 位操作 via std::bitset<a hidden class=anchor aria-hidden=true href=#位标志-and-位操作-via-stdbitset>#</a></h2><p>要定义一组位标志，我们通常会使用适当大小的无符号整数（8 位、16 位、32 位等……取决于我们有多少标志），或 std::bitset</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;bitset&gt; // for std::bitset</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span>std::bitset&lt;<span style=color:#ff0;font-weight:700>8</span>&gt; mybitset {}; <span style=color:#007f7f>// 8 bits in size means room for 8 flags
</span></span></span></code></pre></div><p>位操作是您应该明确使用无符号整数（或 std::bitset）的少数情况之一</p><p>std::bitset 提供了 4 个可用于位操作的关键函数：</p><ul><li>test() 允许我们查询某个位是 0 还是 1</li><li>set() 允许我们打开一个位（如果位已经打开，这将不执行任何操作）</li><li>reset() 允许我们关闭一个位（如果该位已经关闭，这将不执行任何操作）</li><li>flip() 允许我们将位值从 0 翻转为 1，反之亦然</li></ul><p>这些函数中的每一个都将我们要操作的位的位置作为它们唯一的参数</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;bitset&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    std::bitset&lt;<span style=color:#ff0;font-weight:700>8</span>&gt; bits{ <span style=color:#ff0;font-weight:700>0b0000&#39;0101</span> }; <span style=color:#007f7f>// we need 8 bits, start with bit pattern 0000 0101
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    bits.set(<span style=color:#ff0;font-weight:700>3</span>); <span style=color:#007f7f>// set bit position 3 to 1 (now we have 0000 1101)
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    bits.flip(<span style=color:#ff0;font-weight:700>4</span>); <span style=color:#007f7f>// flip bit 4 (now we have 0001 1101)
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    bits.reset(<span style=color:#ff0;font-weight:700>4</span>); <span style=color:#007f7f>// set bit 4 back to 0 (now we have 0000 1101)
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;All the bits: &#34;</span> &lt;&lt; bits &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;Bit 3 has value: &#34;</span> &lt;&lt; bits.test(<span style=color:#ff0;font-weight:700>3</span>) &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;Bit 4 has value: &#34;</span> &lt;&lt; bits.test(<span style=color:#ff0;font-weight:700>4</span>) &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=按位运算符>按位运算符<a hidden class=anchor aria-hidden=true href=#按位运算符>#</a></h2><p><div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/27/638344de90243.png><img src=https://bu.dusays.com/2022/11/27/638344de90243.png alt></a></div>为避免意外，请使用无符号操作数或 std::bitset 的按位运算符</p><p>在计算按位 XOR 时，如果一列中有奇数个 1 位，则该列的结果为 1</p><h2 id=位掩码>位掩码<a hidden class=anchor aria-hidden=true href=#位掩码>#</a></h2><p>位掩码是一组预定义的位，用于选择哪些特定位将被后续操作修改。位掩码阻止按位运算符接触我们不想修改的位，并允许访问我们确实想要修改的位</p><p>最简单的一组位掩码是为每个位位置定义一个位掩码。我们用 0 来屏蔽我们不关心的位，用 1 来表示我们想要修改的位</p><p>尽管位掩码可以是文字，但它们通常被定义为符号常量，因此可以为它们指定一个有意义的名称并易于重用</p><h3 id=在-c14-中定义位掩码>在 C++14 中定义位掩码<a hidden class=anchor aria-hidden=true href=#在-c14-中定义位掩码>#</a></h3><p>因为 C++14 支持二进制文字，所以定义这些位掩码很容易：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;cstdint&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask0{ <span style=color:#ff0;font-weight:700>0b0000&#39;0001</span> }; <span style=color:#007f7f>// represents bit 0
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask1{ <span style=color:#ff0;font-weight:700>0b0000&#39;0010</span> }; <span style=color:#007f7f>// represents bit 1
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask2{ <span style=color:#ff0;font-weight:700>0b0000&#39;0100</span> }; <span style=color:#007f7f>// represents bit 2
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask3{ <span style=color:#ff0;font-weight:700>0b0000&#39;1000</span> }; <span style=color:#007f7f>// represents bit 3
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask4{ <span style=color:#ff0;font-weight:700>0b0001&#39;0000</span> }; <span style=color:#007f7f>// represents bit 4
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask5{ <span style=color:#ff0;font-weight:700>0b0010&#39;0000</span> }; <span style=color:#007f7f>// represents bit 5
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask6{ <span style=color:#ff0;font-weight:700>0b0100&#39;0000</span> }; <span style=color:#007f7f>// represents bit 6
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask7{ <span style=color:#ff0;font-weight:700>0b1000&#39;0000</span> }; <span style=color:#007f7f>// represents bit 7
</span></span></span></code></pre></div><h3 id=在-c11-或更早版本中定义位掩码>在 C++11 或更早版本中定义位掩码<a hidden class=anchor aria-hidden=true href=#在-c11-或更早版本中定义位掩码>#</a></h3><p>由于 C++11 不支持二进制文字，我们必须使用其他方法来设置符号常量</p><p>第一种方法是使用十六进制文字：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask0{ <span style=color:#ff0;font-weight:700>0x01</span> }; <span style=color:#007f7f>// hex for 0000 0001
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask1{ <span style=color:#ff0;font-weight:700>0x02</span> }; <span style=color:#007f7f>// hex for 0000 0010
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask2{ <span style=color:#ff0;font-weight:700>0x04</span> }; <span style=color:#007f7f>// hex for 0000 0100
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask3{ <span style=color:#ff0;font-weight:700>0x08</span> }; <span style=color:#007f7f>// hex for 0000 1000
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask4{ <span style=color:#ff0;font-weight:700>0x10</span> }; <span style=color:#007f7f>// hex for 0001 0000
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask5{ <span style=color:#ff0;font-weight:700>0x20</span> }; <span style=color:#007f7f>// hex for 0010 0000
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask6{ <span style=color:#ff0;font-weight:700>0x40</span> }; <span style=color:#007f7f>// hex for 0100 0000
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask7{ <span style=color:#ff0;font-weight:700>0x80</span> }; <span style=color:#007f7f>// hex for 1000 0000
</span></span></span></code></pre></div><p>另一种更简单的方法是使用左移运算符将一位移动到正确的位置：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask0{ <span style=color:#ff0;font-weight:700>1</span> &lt;&lt; <span style=color:#ff0;font-weight:700>0</span> }; <span style=color:#007f7f>// 0000 0001
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask1{ <span style=color:#ff0;font-weight:700>1</span> &lt;&lt; <span style=color:#ff0;font-weight:700>1</span> }; <span style=color:#007f7f>// 0000 0010
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask2{ <span style=color:#ff0;font-weight:700>1</span> &lt;&lt; <span style=color:#ff0;font-weight:700>2</span> }; <span style=color:#007f7f>// 0000 0100
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask3{ <span style=color:#ff0;font-weight:700>1</span> &lt;&lt; <span style=color:#ff0;font-weight:700>3</span> }; <span style=color:#007f7f>// 0000 1000
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask4{ <span style=color:#ff0;font-weight:700>1</span> &lt;&lt; <span style=color:#ff0;font-weight:700>4</span> }; <span style=color:#007f7f>// 0001 0000
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask5{ <span style=color:#ff0;font-weight:700>1</span> &lt;&lt; <span style=color:#ff0;font-weight:700>5</span> }; <span style=color:#007f7f>// 0010 0000
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask6{ <span style=color:#ff0;font-weight:700>1</span> &lt;&lt; <span style=color:#ff0;font-weight:700>6</span> }; <span style=color:#007f7f>// 0100 0000
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask7{ <span style=color:#ff0;font-weight:700>1</span> &lt;&lt; <span style=color:#ff0;font-weight:700>7</span> }; <span style=color:#007f7f>// 1000 0000
</span></span></span></code></pre></div><h3 id=testing-a-bit>Testing a bit<a hidden class=anchor aria-hidden=true href=#testing-a-bit>#</a></h3><p>要确定某个位是开还是关，我们使用 <code>&</code> 结合相应位的位掩码：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;cstdint&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask0{ <span style=color:#ff0;font-weight:700>0b0000&#39;0001</span> }; <span style=color:#007f7f>// represents bit 0
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	<span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask1{ <span style=color:#ff0;font-weight:700>0b0000&#39;0010</span> }; <span style=color:#007f7f>// represents bit 1
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	<span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask2{ <span style=color:#ff0;font-weight:700>0b0000&#39;0100</span> }; <span style=color:#007f7f>// represents bit 2
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	<span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask3{ <span style=color:#ff0;font-weight:700>0b0000&#39;1000</span> }; <span style=color:#007f7f>// represents bit 3
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	<span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask4{ <span style=color:#ff0;font-weight:700>0b0001&#39;0000</span> }; <span style=color:#007f7f>// represents bit 4
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	<span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask5{ <span style=color:#ff0;font-weight:700>0b0010&#39;0000</span> }; <span style=color:#007f7f>// represents bit 5
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	<span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask6{ <span style=color:#ff0;font-weight:700>0b0100&#39;0000</span> }; <span style=color:#007f7f>// represents bit 6
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	<span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask7{ <span style=color:#ff0;font-weight:700>0b1000&#39;0000</span> }; <span style=color:#007f7f>// represents bit 7
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>	std::<span style=color:#fff;font-weight:700>uint8_t</span> flags{ <span style=color:#ff0;font-weight:700>0b0000&#39;0101</span> }; <span style=color:#007f7f>// 8 bits in size means room for 8 flags
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;bit 0 is &#34;</span> &lt;&lt; ((flags &amp; mask0) ? <span style=color:#0ff;font-weight:700>&#34;on</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span> : <span style=color:#0ff;font-weight:700>&#34;off</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>);
</span></span><span style=display:flex><span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;bit 1 is &#34;</span> &lt;&lt; ((flags &amp; mask1) ? <span style=color:#0ff;font-weight:700>&#34;on</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span> : <span style=color:#0ff;font-weight:700>&#34;off</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=setting-a-bit>Setting a bit<a hidden class=anchor aria-hidden=true href=#setting-a-bit>#</a></h3><p>要设置（打开）位，我们将按位或等于（运算符 <code>|=</code>）与相应位的位掩码结合使用：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;cstdint&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask0{ <span style=color:#ff0;font-weight:700>0b0000&#39;0001</span> }; <span style=color:#007f7f>// represents bit 0
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask1{ <span style=color:#ff0;font-weight:700>0b0000&#39;0010</span> }; <span style=color:#007f7f>// represents bit 1
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask2{ <span style=color:#ff0;font-weight:700>0b0000&#39;0100</span> }; <span style=color:#007f7f>// represents bit 2
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask3{ <span style=color:#ff0;font-weight:700>0b0000&#39;1000</span> }; <span style=color:#007f7f>// represents bit 3
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask4{ <span style=color:#ff0;font-weight:700>0b0001&#39;0000</span> }; <span style=color:#007f7f>// represents bit 4
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask5{ <span style=color:#ff0;font-weight:700>0b0010&#39;0000</span> }; <span style=color:#007f7f>// represents bit 5
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask6{ <span style=color:#ff0;font-weight:700>0b0100&#39;0000</span> }; <span style=color:#007f7f>// represents bit 6
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask7{ <span style=color:#ff0;font-weight:700>0b1000&#39;0000</span> }; <span style=color:#007f7f>// represents bit 7
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    std::<span style=color:#fff;font-weight:700>uint8_t</span> flags{ <span style=color:#ff0;font-weight:700>0b0000&#39;0101</span> }; <span style=color:#007f7f>// 8 bits in size means room for 8 flags
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;bit 1 is &#34;</span> &lt;&lt; ((flags &amp; mask1) ? <span style=color:#0ff;font-weight:700>&#34;on</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span> : <span style=color:#0ff;font-weight:700>&#34;off</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    flags |= mask1; <span style=color:#007f7f>// turn on bit 1
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;bit 1 is &#34;</span> &lt;&lt; ((flags &amp; mask1) ? <span style=color:#0ff;font-weight:700>&#34;on</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span> : <span style=color:#0ff;font-weight:700>&#34;off</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们还可以使用按位或同时打开多个位：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>flags |= (mask4 | mask5); <span style=color:#007f7f>// turn bits 4 and 5 on at the same time
</span></span></span></code></pre></div><h3 id=resetting-a-bit>Resetting a bit<a hidden class=anchor aria-hidden=true href=#resetting-a-bit>#</a></h3><p>要清除位（关闭），我们同时使用 <code>&=</code> 和 <code>~</code> ：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;cstdint&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask0{ <span style=color:#ff0;font-weight:700>0b0000&#39;0001</span> }; <span style=color:#007f7f>// represents bit 0
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask1{ <span style=color:#ff0;font-weight:700>0b0000&#39;0010</span> }; <span style=color:#007f7f>// represents bit 1
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask2{ <span style=color:#ff0;font-weight:700>0b0000&#39;0100</span> }; <span style=color:#007f7f>// represents bit 2
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask3{ <span style=color:#ff0;font-weight:700>0b0000&#39;1000</span> }; <span style=color:#007f7f>// represents bit 3
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask4{ <span style=color:#ff0;font-weight:700>0b0001&#39;0000</span> }; <span style=color:#007f7f>// represents bit 4
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask5{ <span style=color:#ff0;font-weight:700>0b0010&#39;0000</span> }; <span style=color:#007f7f>// represents bit 5
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask6{ <span style=color:#ff0;font-weight:700>0b0100&#39;0000</span> }; <span style=color:#007f7f>// represents bit 6
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask7{ <span style=color:#ff0;font-weight:700>0b1000&#39;0000</span> }; <span style=color:#007f7f>// represents bit 7
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    std::<span style=color:#fff;font-weight:700>uint8_t</span> flags{ <span style=color:#ff0;font-weight:700>0b0000&#39;0101</span> }; <span style=color:#007f7f>// 8 bits in size means room for 8 flags
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;bit 2 is &#34;</span> &lt;&lt; ((flags &amp; mask2) ? <span style=color:#0ff;font-weight:700>&#34;on</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span> : <span style=color:#0ff;font-weight:700>&#34;off</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    flags &amp;= ~mask2; <span style=color:#007f7f>// turn off bit 2
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;bit 2 is &#34;</span> &lt;&lt; ((flags &amp; mask2) ? <span style=color:#0ff;font-weight:700>&#34;on</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span> : <span style=color:#0ff;font-weight:700>&#34;off</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们可以同时关闭多个位：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>flags &amp;= ~(mask4 | mask5); <span style=color:#007f7f>// turn bits 4 and 5 off at the same time
</span></span></span></code></pre></div><h3 id=flipping-a-bit>Flipping a bit<a hidden class=anchor aria-hidden=true href=#flipping-a-bit>#</a></h3><p>要切换位状态，我们使用 <code>^=</code>：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;cstdint&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask0{ <span style=color:#ff0;font-weight:700>0b0000&#39;0001</span> }; <span style=color:#007f7f>// represents bit 0
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask1{ <span style=color:#ff0;font-weight:700>0b0000&#39;0010</span> }; <span style=color:#007f7f>// represents bit 1
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask2{ <span style=color:#ff0;font-weight:700>0b0000&#39;0100</span> }; <span style=color:#007f7f>// represents bit 2
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask3{ <span style=color:#ff0;font-weight:700>0b0000&#39;1000</span> }; <span style=color:#007f7f>// represents bit 3
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask4{ <span style=color:#ff0;font-weight:700>0b0001&#39;0000</span> }; <span style=color:#007f7f>// represents bit 4
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask5{ <span style=color:#ff0;font-weight:700>0b0010&#39;0000</span> }; <span style=color:#007f7f>// represents bit 5
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask6{ <span style=color:#ff0;font-weight:700>0b0100&#39;0000</span> }; <span style=color:#007f7f>// represents bit 6
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask7{ <span style=color:#ff0;font-weight:700>0b1000&#39;0000</span> }; <span style=color:#007f7f>// represents bit 7
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    std::<span style=color:#fff;font-weight:700>uint8_t</span> flags{ <span style=color:#ff0;font-weight:700>0b0000&#39;0101</span> }; <span style=color:#007f7f>// 8 bits in size means room for 8 flags
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;bit 2 is &#34;</span> &lt;&lt; ((flags &amp; mask2) ? <span style=color:#0ff;font-weight:700>&#34;on</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span> : <span style=color:#0ff;font-weight:700>&#34;off</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>);
</span></span><span style=display:flex><span>    flags ^= mask2; <span style=color:#007f7f>// flip bit 2
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;bit 2 is &#34;</span> &lt;&lt; ((flags &amp; mask2) ? <span style=color:#0ff;font-weight:700>&#34;on</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span> : <span style=color:#0ff;font-weight:700>&#34;off</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>);
</span></span><span style=display:flex><span>    flags ^= mask2; <span style=color:#007f7f>// flip bit 2
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;bit 2 is &#34;</span> &lt;&lt; ((flags &amp; mask2) ? <span style=color:#0ff;font-weight:700>&#34;on</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span> : <span style=color:#0ff;font-weight:700>&#34;off</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们可以同时翻转多个位：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>flags ^= (mask4 | mask5); <span style=color:#007f7f>// flip bits 4 and 5 at the same time
</span></span></span></code></pre></div><h2 id=位掩码和-stdbitset>位掩码和 std::bitset<a hidden class=anchor aria-hidden=true href=#位掩码和-stdbitset>#</a></h2><p>std::bitset 支持全套位运算符。因此，尽管使用函数（测试、设置、重置和翻转）修改单个位更容易，但如果需要，您可以使用按位运算符和位掩码</p><p>函数只允许您一次修改单个位。按位运算符允许您一次修改多个位</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;cstdint&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;bitset&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>constexpr</span> std::bitset&lt;<span style=color:#ff0;font-weight:700>8</span>&gt; mask0{ <span style=color:#ff0;font-weight:700>0b0000&#39;0001</span> }; <span style=color:#007f7f>// represents bit 0
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	<span style=color:#fff;font-weight:700>constexpr</span> std::bitset&lt;<span style=color:#ff0;font-weight:700>8</span>&gt; mask1{ <span style=color:#ff0;font-weight:700>0b0000&#39;0010</span> }; <span style=color:#007f7f>// represents bit 1
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	<span style=color:#fff;font-weight:700>constexpr</span> std::bitset&lt;<span style=color:#ff0;font-weight:700>8</span>&gt; mask2{ <span style=color:#ff0;font-weight:700>0b0000&#39;0100</span> }; <span style=color:#007f7f>// represents bit 2
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	<span style=color:#fff;font-weight:700>constexpr</span> std::bitset&lt;<span style=color:#ff0;font-weight:700>8</span>&gt; mask3{ <span style=color:#ff0;font-weight:700>0b0000&#39;1000</span> }; <span style=color:#007f7f>// represents bit 3
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	<span style=color:#fff;font-weight:700>constexpr</span> std::bitset&lt;<span style=color:#ff0;font-weight:700>8</span>&gt; mask4{ <span style=color:#ff0;font-weight:700>0b0001&#39;0000</span> }; <span style=color:#007f7f>// represents bit 4
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	<span style=color:#fff;font-weight:700>constexpr</span> std::bitset&lt;<span style=color:#ff0;font-weight:700>8</span>&gt; mask5{ <span style=color:#ff0;font-weight:700>0b0010&#39;0000</span> }; <span style=color:#007f7f>// represents bit 5
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	<span style=color:#fff;font-weight:700>constexpr</span> std::bitset&lt;<span style=color:#ff0;font-weight:700>8</span>&gt; mask6{ <span style=color:#ff0;font-weight:700>0b0100&#39;0000</span> }; <span style=color:#007f7f>// represents bit 6
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	<span style=color:#fff;font-weight:700>constexpr</span> std::bitset&lt;<span style=color:#ff0;font-weight:700>8</span>&gt; mask7{ <span style=color:#ff0;font-weight:700>0b1000&#39;0000</span> }; <span style=color:#007f7f>// represents bit 7
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>	std::bitset&lt;<span style=color:#ff0;font-weight:700>8</span>&gt; flags{ <span style=color:#ff0;font-weight:700>0b0000&#39;0101</span> }; <span style=color:#007f7f>// 8 bits in size means room for 8 flags
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;bit 1 is &#34;</span> &lt;&lt; (flags.test(<span style=color:#ff0;font-weight:700>1</span>) ? <span style=color:#0ff;font-weight:700>&#34;on</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span> : <span style=color:#0ff;font-weight:700>&#34;off</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>);
</span></span><span style=display:flex><span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;bit 2 is &#34;</span> &lt;&lt; (flags.test(<span style=color:#ff0;font-weight:700>2</span>) ? <span style=color:#0ff;font-weight:700>&#34;on</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span> : <span style=color:#0ff;font-weight:700>&#34;off</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	flags ^= (mask1 | mask2); <span style=color:#007f7f>// flip bits 1 and 2
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;bit 1 is &#34;</span> &lt;&lt; (flags.test(<span style=color:#ff0;font-weight:700>1</span>) ? <span style=color:#0ff;font-weight:700>&#34;on</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span> : <span style=color:#0ff;font-weight:700>&#34;off</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>);
</span></span><span style=display:flex><span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;bit 2 is &#34;</span> &lt;&lt; (flags.test(<span style=color:#ff0;font-weight:700>2</span>) ? <span style=color:#0ff;font-weight:700>&#34;on</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span> : <span style=color:#0ff;font-weight:700>&#34;off</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	flags |= (mask1 | mask2); <span style=color:#007f7f>// turn bits 1 and 2 on
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;bit 1 is &#34;</span> &lt;&lt; (flags.test(<span style=color:#ff0;font-weight:700>1</span>) ? <span style=color:#0ff;font-weight:700>&#34;on</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span> : <span style=color:#0ff;font-weight:700>&#34;off</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>);
</span></span><span style=display:flex><span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;bit 2 is &#34;</span> &lt;&lt; (flags.test(<span style=color:#ff0;font-weight:700>2</span>) ? <span style=color:#0ff;font-weight:700>&#34;on</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span> : <span style=color:#0ff;font-weight:700>&#34;off</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	flags &amp;= ~(mask1 | mask2); <span style=color:#007f7f>// turn bits 1 and 2 off
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;bit 1 is &#34;</span> &lt;&lt; (flags.test(<span style=color:#ff0;font-weight:700>1</span>) ? <span style=color:#0ff;font-weight:700>&#34;on</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span> : <span style=color:#0ff;font-weight:700>&#34;off</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>);
</span></span><span style=display:flex><span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;bit 2 is &#34;</span> &lt;&lt; (flags.test(<span style=color:#ff0;font-weight:700>2</span>) ? <span style=color:#0ff;font-weight:700>&#34;on</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span> : <span style=color:#0ff;font-weight:700>&#34;off</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=summary-1>Summary<a hidden class=anchor aria-hidden=true href=#summary-1>#</a></h2><ol><li>query bit states</li></ol><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#fff;font-weight:700>if</span> (flags &amp; option4) ... <span style=color:#007f7f>// if option4 is set, do something
</span></span></span></code></pre></div><ol start=2><li>set bits (turn on)</li></ol><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>flags |= option4; <span style=color:#007f7f>// turn option 4 on.
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>flags |= (option4 | option5); <span style=color:#007f7f>// turn options 4 and 5 on.
</span></span></span></code></pre></div><ol start=3><li>clear bits (turn off)</li></ol><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>flags &amp;= ~option4; <span style=color:#007f7f>// turn option 4 off
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>flags &amp;= ~(option4 | option5); <span style=color:#007f7f>// turn options 4 and 5 off
</span></span></span></code></pre></div><ol start=4><li>flip bit states</li></ol><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>flags ^= option4; <span style=color:#007f7f>// flip option4 from on to off, or vice versa
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>flags ^= (option4 | option5); <span style=color:#007f7f>// flip options 4 and 5
</span></span></span></code></pre></div><h1 id=运算符重载>运算符重载<a hidden class=anchor aria-hidden=true href=#运算符重载>#</a></h1><h2 id=何时使用普通函数友元函数或成员函数重载运算符>何时使用普通函数、友元函数或成员函数重载运算符<a hidden class=anchor aria-hidden=true href=#何时使用普通函数友元函数或成员函数重载运算符>#</a></h2><ol><li>在处理不修改左操作数的二元运算符（例如 operator+）时，通常首选普通或友元函数版本，因为它适用于所有参数类型（即使左操作数不是类对象，或者是一个不可修改的类）。普通或友元函数版本具有“对称”的额外好处，因为所有操作数都成为显式参数（而不是左操作数成为 <code>*this</code> 而右操作数成为显式参数）</li><li>在处理确实修改左操作数的二元运算符时（例如 operator+=），通常首选成员函数版本。在这些情况下，最左边的操作数将始终是类类型，并且让被修改的对象成为 <code>*this</code> 指向的对象是很自然的。因为最右边的操作数成为一个显式参数，所以不会混淆谁正在修改和谁正在评估</li><li>一元运算符通常也作为成员函数重载，因为成员函数版本没有参数</li><li>以下经验法则可以帮助您确定哪种形式最适合给定情况：<ol><li>如果要重载赋值 (=)、下标 ([])、函数调用 (()) 或成员选择 (->)，请将其作为成员函数进行重载</li><li>如果要重载一元运算符，请将其作为成员函数</li><li>如果要重载不修改其左操作数的二元运算符（例如 operator+），请将其作为普通函数（首选）或友元函数</li><li>如果您正在重载修改其左操作数的二元运算符，但您不能将成员添加到左操作数的类定义中（例如，operator&#171;，它有一个 ostream 类型的左操作数），请像往常一样这样做函数（首选）或友元函数</li><li>如果您正在重载修改其左操作数的二元运算符（例如 operator+=），并且您可以修改左操作数的定义，请将其作为成员函数进行</li></ol></li></ol><h2 id=最小化比较冗余>最小化比较冗余<a hidden class=anchor aria-hidden=true href=#最小化比较冗余>#</a></h2><p>也就是说我们只需要实现<code>operator==</code>和<code>operator&lt;</code>的逻辑，其他四个比较运算符就可以根据这两个来定义了！这是一个更新的 <code>Cents</code> 示例，说明了这一点：</p><pre tabindex=0><code>#include &lt;iostream&gt;

class Cents
{
private:
    int m_cents;

public:
    Cents(int cents)
        : m_cents{ cents }
    {}

    friend bool operator== (const Cents&amp; c1, const Cents&amp; c2) { return c1.m_cents == c2.m_cents; };
    friend bool operator!= (const Cents&amp; c1, const Cents&amp; c2) { return !(operator==(c1, c2)); };

    friend bool operator&lt; (const Cents&amp; c1, const Cents&amp; c2) { return c1.m_cents &lt; c2.m_cents; };
    friend bool operator&gt; (const Cents&amp; c1, const Cents&amp; c2) { return operator&lt;(c2, c1); };

    friend bool operator&lt;= (const Cents&amp; c1, const Cents&amp; c2) { return !(operator&gt;(c1, c2)); };
    friend bool operator&gt;= (const Cents&amp; c1, const Cents&amp; c2) { return !(operator&lt;(c1, c2)); };

};

int main()
{
    Cents dime{ 10 };
    Cents nickel{ 5 };

    if (nickel &gt; dime)
        std::cout &lt;&lt; &#34;a nickel is greater than a dime.\n&#34;;
    if (nickel &gt;= dime)
        std::cout &lt;&lt; &#34;a nickel is greater than or equal to a dime.\n&#34;;
    if (nickel &lt; dime)
        std::cout &lt;&lt; &#34;a dime is greater than a nickel.\n&#34;;
    if (nickel &lt;= dime)
        std::cout &lt;&lt; &#34;a dime is greater than or equal to a nickel.\n&#34;;
    if (nickel == dime)
        std::cout &lt;&lt; &#34;a dime is equal to a nickel.\n&#34;;
    if (nickel != dime)
        std::cout &lt;&lt; &#34;a dime is not equal to a nickel.\n&#34;;

    return 0;
}
</code></pre><p>这样，如果我们需要更改某些内容，我们只需要更新 operator== 和 operator&lt; 而不是所有六个比较运算符！</p><h2 id=浅拷贝与深拷贝>浅拷贝与深拷贝<a hidden class=anchor aria-hidden=true href=#浅拷贝与深拷贝>#</a></h2><p>编译器提供的默认复制构造函数和默认赋值运算符如下所示：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;cassert&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>class</span> Fraction
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>private</span>:
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>int</span> m_numerator { <span style=color:#ff0;font-weight:700>0</span> };
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>int</span> m_denominator { <span style=color:#ff0;font-weight:700>1</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>public</span>:
</span></span><span style=display:flex><span>    <span style=color:#007f7f>// Default constructor
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    Fraction(<span style=color:#fff;font-weight:700>int</span> numerator = <span style=color:#ff0;font-weight:700>0</span>, <span style=color:#fff;font-weight:700>int</span> denominator = <span style=color:#ff0;font-weight:700>1</span>)
</span></span><span style=display:flex><span>        : m_numerator{ numerator }
</span></span><span style=display:flex><span>        , m_denominator{ denominator }
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        assert(denominator != <span style=color:#ff0;font-weight:700>0</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#007f7f>// Possible implementation of implicit copy constructor
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    Fraction(<span style=color:#fff;font-weight:700>const</span> Fraction&amp; f)
</span></span><span style=display:flex><span>        : m_numerator{ f.m_numerator }
</span></span><span style=display:flex><span>        , m_denominator{ f.m_denominator }
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#007f7f>// Possible implementation of implicit assignment operator
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    Fraction&amp; <span style=color:#fff;font-weight:700>operator</span>= (<span style=color:#fff;font-weight:700>const</span> Fraction&amp; fraction)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#007f7f>// self-assignment guard
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>        <span style=color:#fff;font-weight:700>if</span> (<span style=color:#fff;font-weight:700>this</span> == &amp;fraction)
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>return</span> *<span style=color:#fff;font-weight:700>this</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#007f7f>// do the copy
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>        m_numerator = fraction.m_numerator;
</span></span><span style=display:flex><span>        m_denominator = fraction.m_denominator;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#007f7f>// return the existing object so we can chain this operator
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>        <span style=color:#fff;font-weight:700>return</span> *<span style=color:#fff;font-weight:700>this</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>friend</span> std::ostream&amp; <span style=color:#fff;font-weight:700>operator</span>&lt;&lt;(std::ostream&amp; out, <span style=color:#fff;font-weight:700>const</span> Fraction&amp; f1)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>	out &lt;&lt; f1.m_numerator &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;/&#39;</span> &lt;&lt; f1.m_denominator;
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> out;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>请注意，因为这些默认版本可以很好地复制此类，所以在这种情况下真的没有理由编写我们自己的这些函数版本</p><p>然而，在设计处理动态分配内存的类时，成员（浅）复制会给我们带来很多麻烦！这是因为指针的浅拷贝只是复制指针的地址——它不分配任何内存或复制指向的内容！</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>输出不是直接写入的，它存储在缓冲区中，直到缓冲区被刷新。输出到文件或终端历来很慢（终端或控制台仍然很慢），逐个字符地写入是低效率的，写入一大块字节要有效得多。若 cerr 被缓冲，那么如果程序以非正常方式崩溃，您可能会将有用的调试信息卡在缓冲区中，而不是打印到 stderr。stdout 是行缓冲的，即在您编写换行符或显式刷新缓冲区之前，输出不会发送到操作系统。通常，std::endl 函数通过插入换行符并刷新流来工作。读取 stdcin 会刷新 stdcout&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://xancoding.cn/tags/tech/>Tech</a></li><li><a href=https://xancoding.cn/tags/c++/>C++</a></li><li><a href=https://xancoding.cn/tags/%E6%96%B0%E6%8A%80%E8%83%BD/>新技能</a></li></ul><nav class=paginav><a class=prev href=https://xancoding.cn/posts/assembly-language/><span class=title>« Prev</span><br><span>汇编语言</span></a>
<a class=next href=https://xancoding.cn/posts/linux-network-programming/><span class=title>Next »</span><br><span>Linux 网络编程</span></a></nav></footer><div><div class=pagination__title><span class=pagination__title-h style=font-size:20px>💬评论</span><hr></div><div id=tcomment></div><script src=https://cdn.staticfile.org/twikoo/1.6.7/twikoo.all.min.js></script>
<script>twikoo.init({envId:"https://twikoo.xancoding.cn/",el:"#tcomment",lang:"zh-CN",region:"ap-beijing",path:window.TWIKOO_MAGIC_PATH||window.location.pathname})</script></div></article></main><footer class=footer><span>&copy; 2023 <a href=https://xancoding.cn>Xan's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>