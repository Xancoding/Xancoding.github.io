<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on Xan&#39;s Blog</title>
    <link>https://zagxuy.github.io/posts/</link>
    <description>Recent content in Posts on Xan&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 09 Oct 2022 18:42:06 +0800</lastBuildDate><atom:link href="https://zagxuy.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Sort</title>
      <link>https://zagxuy.github.io/posts/sort/</link>
      <pubDate>Sun, 09 Oct 2022 18:42:06 +0800</pubDate>
      
      <guid>https://zagxuy.github.io/posts/sort/</guid>
      <description>排序
插入排序 直接插入排序 稳定 将 a[i]插入前面已经排好序的 a[1]~a[i - 1]中 在 a[0] 处设置岗哨，使 a[0] == a[i] 避免查找插入位置时对下标越界的检查 将 a[i]依次与 a[i - 1]，a[i - 2]，&amp;hellip; ，a[1]比较，直到 a[j] &amp;lt;= a[i]，再将 a[i]插到 a[j]之后 希尔排序 不稳定 基本思想：先取一个正整数 d1 &amp;lt; n，把所有相隔 d1 的记录放一组，组内进行直接插入排序；然后取 d2 &amp;lt; d1，重复上述分组和排序操作；直至 di = 1，即所有记录放进一个组中进行一趟直接插入排序为止 具体做法： 取 d1 = ⌊n / 2⌋ 每一趟 d i = ⌊d i - 1 / 2⌋ 直至 d k = 1结束 void shell_pass(int a[], int step) { for (int i = step + 1; i &amp;lt;= n; i++) { int tmp = a[i]; int j = i - step; while(j &amp;gt;= 1 &amp;amp;&amp;amp; tmp &amp;lt; a[j]) { a[j + step] = a[j]; j = j - step; } a[j + step] = tmp; } } void shell_sort(int a[], int d[]) {	//需t趟完成排序 for (int k = 0; k &amp;lt; t; k++) shell_pass (a, d[k]); } 交换排序 冒泡排序 稳定 沉底法 快速排序 不稳定</description>
      <content:encoded><![CDATA[<p><a href="https://git.acwing.com/ZagY/learn-data-structures/-/blob/main/Sort/README.md">排序</a></p>
<h1 id="插入排序">插入排序</h1>
<h2 id="直接插入排序">直接插入排序</h2>
<ul>
<li><strong>稳定</strong></li>
<li>将 a[i]插入前面已经排好序的 a[1]~a[i - 1]中</li>
<li>在  <code>a[0]</code> 处设置岗哨，使 a[0] == a[i]
<ul>
<li>避免查找插入位置时对下标越界的检查</li>
</ul>
</li>
<li>将 a[i]依次与 a[i - 1]，a[i - 2]，&hellip; ，a[1]比较，直到 a[j] &lt;= a[i]，再将 a[i]插到 a[j]之后</li>
</ul>
<h2 id="希尔排序">希尔排序</h2>
<ul>
<li><strong>不稳定</strong></li>
<li>基本思想：先取一个正整数 d<sub>1</sub> &lt; n，把所有相隔 d<sub>1</sub> 的记录放一组，组内进行直接插入排序；然后取 d<sub>2 </sub> &lt; d<sub>1</sub>，重复上述分组和排序操作；直至 d<sub>i</sub> = 1，即所有记录放进一个组中进行一趟直接插入排序为止</li>
<li>具体做法：
<ul>
<li>取 <strong>d<sub>1</sub> = ⌊n / 2⌋</strong></li>
<li>每一趟 <strong>d <sub> i </sub> = ⌊d <sub> i - 1 </sub> / 2⌋</strong></li>
<li>直至 <strong>d <sub> k </sub> = 1</strong>结束</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">shell_pass</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> step)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> step <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;=</span> n; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> tmp <span style="color:#f92672">=</span> a[i];
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i <span style="color:#f92672">-</span> step;
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">while</span>(j <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> tmp <span style="color:#f92672">&lt;</span> a[j])
</span></span><span style="display:flex;"><span>		{
</span></span><span style="display:flex;"><span>			a[j <span style="color:#f92672">+</span> step] <span style="color:#f92672">=</span> a[j];
</span></span><span style="display:flex;"><span>			j <span style="color:#f92672">=</span> j <span style="color:#f92672">-</span> step;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		a[j <span style="color:#f92672">+</span> step] <span style="color:#f92672">=</span> tmp;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">shell_sort</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> d[])
</span></span><span style="display:flex;"><span>{	
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//需t趟完成排序
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; k <span style="color:#f92672">&lt;</span> t; k<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>		shell_pass (a, d[k]);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="交换排序">交换排序</h1>
<h2 id="冒泡排序">冒泡排序</h2>
<ul>
<li><strong>稳定</strong></li>
<li>沉底法</li>
</ul>
<h2 id="快速排序">快速排序</h2>
<ul>
<li>
<p><strong>不稳定</strong></p>
</li>
<li>
<p>时间性能</p>
<ul>
<li>最坏（基本有序时）：<strong>O ( n <sup> 2 </sup> )</strong></li>
<li>最好（每次划分恰好两个子序列长度相等）：<strong>O (nlogn)</strong></li>
</ul>
</li>
<li>
<p>空间性能</p>
<ul>
<li>递归调用，存储开销</li>
<li>最好：<strong>O (logn)</strong></li>
<li>最坏：<strong>O ( n )</strong></li>
</ul>
</li>
<li>
<p>将  <code>a[0]</code> 设为哨兵，存储每次选中的关键字</p>
</li>
<li>
<p> 基本思想：在待排序列中选一个关键字，按某一规律进行多次比较交换后，它移到某一位置，此元素<strong>将记录分割成独立的两部分</strong>，它左边的关键字都小于或等于它，右边的关键字都大于或等于它。之后对这<strong>两部分分别进行快速排序</strong></p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">partition</span>(SqList L, <span style="color:#66d9ef">int</span> low, <span style="color:#66d9ef">int</span> high)  
</span></span><span style="display:flex;"><span>{  
</span></span><span style="display:flex;"><span>    L.r[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> L.r[low];  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (low <span style="color:#f92672">&lt;</span> high)  
</span></span><span style="display:flex;"><span>    {  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (low <span style="color:#f92672">&lt;</span> high <span style="color:#f92672">&amp;&amp;</span> L.r[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&lt;=</span> L.r[high])  
</span></span><span style="display:flex;"><span>            high<span style="color:#f92672">--</span>;  
</span></span><span style="display:flex;"><span>        L.r[low] <span style="color:#f92672">=</span> L.r[high];  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (low <span style="color:#f92672">&lt;</span> high <span style="color:#f92672">&amp;&amp;</span> L.r[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&gt;=</span> L.r[low])  
</span></span><span style="display:flex;"><span>            low<span style="color:#f92672">++</span>;  
</span></span><span style="display:flex;"><span>        L.r[high] <span style="color:#f92672">=</span> L.r[low];  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>    L.r[low] <span style="color:#f92672">=</span> L.r[<span style="color:#ae81ff">0</span>];  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> low;  
</span></span><span style="display:flex;"><span>}  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">quick_sort</span> (SqList L, <span style="color:#66d9ef">int</span> low, <span style="color:#66d9ef">int</span> high)  
</span></span><span style="display:flex;"><span>{  
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (low <span style="color:#f92672">&lt;</span> high)  
</span></span><span style="display:flex;"><span>    {  
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> pos <span style="color:#f92672">=</span> partition(L, low, high);  
</span></span><span style="display:flex;"><span>        quick_sort(L, low, pos <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);  
</span></span><span style="display:flex;"><span>        quick_sort(L, pos <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, high);  
</span></span><span style="display:flex;"><span>    }  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="选择排序">选择排序</h1>
<h2 id="简单选择排序">简单选择排序</h2>
<ul>
<li><strong>不稳定</strong></li>
<li>第 i 趟排序从待排序记录里选出最小关键字值的记录与第 i 个记录交换（1 &lt;= i &lt;= n - 1）</li>
</ul>
<h2 id="堆排序">堆排序</h2>
<ul>
<li><strong>不稳定</strong></li>
<li>初始建堆：将 <code>n</code> 个元素的序列看成是一个完全二叉树，则最后一个非叶子结点是第 <strong>⌊n / 2⌋</strong> 个元素. 从第 <strong>⌊n / 2⌋</strong> 个元素开始 <code>down</code>，一直 <code>down</code> 到第 <code>1</code> 个元素，就建立了堆</li>
</ul>
<h1 id="二路归并排序">二路归并排序</h1>
<ul>
<li><strong>稳定</strong></li>
<li>时间性能：<strong>O (nlogn)</strong></li>
<li>空间性能：<strong>O (n)</strong></li>
<li>基本思想：设初始序列含有 <code>n</code> 个记录，归并排序把此序列看成是由 <code>n</code> 个只包含<code>一个记录</code>的有序表组成，然后进行<code>两两归并</code>，最后形成包含 n 个记录的有序表</li>
<li>开始时取 <code>L = 1</code>，第一趟归并排序后，<code>L = L * 2</code>，以此类推，直到排序结束</li>
</ul>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
