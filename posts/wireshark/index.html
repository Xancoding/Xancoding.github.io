<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>计算机网络课程大作业 | Xan's Blog</title><meta name=keywords content="Tech,Wireshark,工具,新技能,计算机网络"><meta name=description content="要求 团队合作、合理分工、按组为单位进行 报告文字内容不可拷贝粘贴现有文献，应反映小组所做的工作，有分析，实践性的选题应有具体操作或者配置过程描"><meta name=author content="
作者:&nbsp;Xan"><link rel=canonical href=https://xancoding.cn/posts/wireshark/><link crossorigin=anonymous href=/assets/css/stylesheet.3aa01cbced85ddebdb26eab94916f476145cedd3e7231731a39f34d88d6f410a.css integrity="sha256-OqAcvO2F3evbJuq5SRb0dhRc7dPnIxcxo5802I1vQQo=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://xancoding.cn/img/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://xancoding.cn/img/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://xancoding.cn/img/favicon.ico><link rel=apple-touch-icon href=https://xancoding.cn/img/favicon.ico><link rel=mask-icon href=https://xancoding.cn/img/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["[[","]]"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"})</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style><link rel=stylesheet href=//cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.css><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="计算机网络课程大作业"><meta property="og:description" content="要求 团队合作、合理分工、按组为单位进行 报告文字内容不可拷贝粘贴现有文献，应反映小组所做的工作，有分析，实践性的选题应有具体操作或者配置过程描"><meta property="og:type" content="article"><meta property="og:url" content="https://xancoding.cn/posts/wireshark/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-11-12T11:38:21+08:00"><meta property="article:modified_time" content="2022-11-12T11:38:21+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="计算机网络课程大作业"><meta name=twitter:description content="要求 团队合作、合理分工、按组为单位进行 报告文字内容不可拷贝粘贴现有文献，应反映小组所做的工作，有分析，实践性的选题应有具体操作或者配置过程描"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://xancoding.cn/posts/"},{"@type":"ListItem","position":3,"name":"计算机网络课程大作业","item":"https://xancoding.cn/posts/wireshark/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"计算机网络课程大作业","name":"计算机网络课程大作业","description":"要求 团队合作、合理分工、按组为单位进行 报告文字内容不可拷贝粘贴现有文献，应反映小组所做的工作，有分析，实践性的选题应有具体操作或者配置过程描","keywords":["Tech","Wireshark","工具","新技能","计算机网络"],"articleBody":"要求 团队合作、合理分工、按组为单位进行 报告文字内容不可拷贝粘贴现有文献，应反映小组所做的工作，有分析，实践性的选题应有具体操作或者配置过程描述，辅以截图或实验数据 所交报告中应在最后注明组员分工、参考文献，报告字数3000-6000 不同班级的小组可选择相同的题目，但重复计数（由各班学委协调），不可多于3组，且报告内容不可相同，要求独立完成各组任务 除了个别综述性的选题，其它选题要求在实际平台上实践 选题 基于网络嗅探软件（wireshark）的协议分析实验\nWireshark的深入学习与掌握，如过滤器的使用，归纳方法 通过实验阐述ARP的工作原理 利用实验结果分析ICMP协议的报文结构字段定义 基于实验数据深入分析TCP协议的连接过程原理，报文的分片等功能 从校园网发起向外网中某Web服务器的访问，记录并分析从MAC层协议、IP协议、TCP协议一直到HTTP协议的过程 基于网络嗅探软件Wireshark的协议分析实验 Wireshark 是什么？ Wirkshark 是一个功能十分强大的开源的网络数据包分析器，能够在多种平台上抓取和分析网络包\nWirkshark 可被用于检查安全问题和解决网络问题，也可供开发者调试协议的实现和学习网络协议的原理\nWireshark使用 Npcap or WinPcap 作为接口，直接与网卡进行数据报文交换\nWireshark 下载与安装 官网地址：https://www.wireshark.org/，直接点击下一步下一步安装即可 但是，我在安装过程中报了如下的错误： 排查了好久，没找到合适的解决办法\n最后，下载 WinPcap 来代替 Npcap ，成功运行。\nWireshark 基本用法 简单抓包基础步骤：选择捕获接口 -\u003e 获取网络实时痕迹 -\u003e 获取报文 -\u003e 深入解析\n选择接口（网卡） 网络上传输的数据包需要经过网卡到达计算机，Wireshark可以捕获流经网卡的数据包\n在使用Wireshark捕获数据前，先要选择捕获接口。一台计算机可能会有不止一个网卡，此时需要选择你要捕获数据的接口。\n选择菜单栏上的 捕获-\u003e选项 选择想要捕获数据的接口后，点击开始 界面说明 开始捕获后，Wireshark会把捕获到的报文显示到界面上\n显示过滤器用于设置过滤条件进行数据列表区数据过滤 数据列表区展示的是Wireshark捕获到的所有数据包的列表，每个数据包包含 编号、时间戳、源地址、目标地址、协议、长度以及数据包信息 数据详细区展示的是在数据列表区中选中的数据包的分协议展示 Frame：物理层的数据帧概况 Ethernet II：数据链路层以太网帧头部信息 Internet Protocol Version 4： 互联网层IP包头部信息 Transmission Control Protocol：传输层的数据段头部信息，此处是TCP 数据字节区展示的是选中的数据包的源数据。另外，在数据详细区选中的某层或某字段，对应的数据会在数据字节区中高亮 过滤器设置 根据我们想要抓取的数据包，对过滤器进行设置。过滤掉冗余的数据包，找到我们需要的信息\n捕获过滤器 捕获过滤器表达式作用在Wireshark捕获数据包之前，只捕获符合条件的数据包\n当需要处理大量数据时，使用捕获过滤器可以节省大量资源\n界面说明 选择菜单栏上的 捕获-\u003e捕获过滤器 点击 + 即可添加新的过滤规则\nFilter Name 指代过滤器名称，用来给自己看该过滤器的过滤效果\nFilter Expression 指代过滤器表达式，需要使用 Berkeley Packet Filter 语法书写 语法规则 捕获过滤器使用 BPF 语法，表达式由多个原语组成：\n原语(primitives)：由名称或数字，以及描述它的多个限定词组成。 * 限定词(qualifiers) * Types：设置数字或者名称所指示类型，例如host www.baidu.com，如果没有指定此值，则默认使用“host”关键字 * host、post * net，设定子网， net 192.168.0.0 mask 255.255.255.0等价于net 192.168.0.0/24 * port，设置端口范围，例如port 6000-8000 * Dir：设置网络出入方向，例如dst port 80，如果没有特别指明来源或目的地，则默认使用“src or dst”作为关键字 * src、dst、src or dst、src and dst(src：源端口，dst：目标端口) * Proto：指定协议类型，例如udp，如果没有特别指明是什么协议，则默认使用所有支持的协议 * ether、fddi、tr、wlan、ip、ip6、arp、rarp、decnet、tcp、udp、icmp、igmp、icmp、igrp、pim、ah、esp、vrrp * 其他 * gateway：指明网关IP地址，等价于ether host 'ehost' and not host 'host' * broadcast：广播报文，例如ether broadcast或者ip broadcast * multicast：多播报文，例如ip multicast或者ip6 multicast * less、greater：小于或者大于 * 原语运算符 * 与：\u0026\u0026或者and * 或：||或者or * 非：!或者not 转载自：https://juejin.cn/post/6844904066229747720 应用示例 只抓取源端口或者目的端口范围6000到8000，并且是一个tcp协议或者ipv6的数据包\nsrc or dst port 6000-8000 \u0026\u0026 tcp or ip6 只抓取IP地址为192.168.0.10的数据包\nhost 192.168.0.10 显示过滤器 显示过滤器表达式作用在在Wireshark捕获数据包之后，从已捕获的所有数据包中显示出符合条件的数据包\n显示过滤表达式在工具栏下方的“应用显示过滤器”输入框输入即可生效 基本过滤表达式 一条基本的表达式由过滤项、过滤关系、过滤值三项组成 例如：ip.addr == 192.168.1.1，其中 ip.addr 为过滤项，== 为过滤关系，192.168.1.1 为过滤值。 该表达式的意思是 找出所有ip协议中源或目标ip等于192.168.1.1的数据包 过滤项 Wireshark的过滤项是 协议.协议字段 的模式，Wireshark支持的全部协议及协议字段可查看官方说明。 以端口为例，端口出现于tcp协议中。所以有端口这个过滤项且其写法就是tcp.port Wireshark出于缩减长度的原因，有些字段没有使用协议规定的名称而是使用简写，比如Destination Port在Wireshark中写为dstport Wireshark出于简便使用的原因，增加了一些协议中没有的字段，比如tcp协议只有源端口和目标端口字段，为了简便使用Wireshark增加了tcp.port来同时代表这两个字段 实际使用时我们输入协议.后Wireshark就会有支持的字段提示 过滤关系 过滤关系指的是大于、等于、小于等等式关系，具体可以看官方给出的表 过滤值 过滤值就是设定的过滤项应该满足过滤关系的标准，比如500、5000、50000等等。\n过滤值的写法一般已经被过滤项和过滤关系设定好了，只是填下自己的期望值就可以了。\n复合过滤表达式 所谓复合过滤表达示，就是指由多条基本过滤表达式组合而成的表达示。\n基本过滤表达式的写法还是不变的，复合过滤表达示多出来的东西就只是基本过滤表达示的“连接词”，我们依然直接参照官方给出的表 常见显示过滤需求及其对应表达式 数据链路层 筛选mac地址为04:f9:38:ad:13:26的数据包----eth.src == 04:f9:38:ad:13:26 筛选源mac地址为04:f9:38:ad:13:26的数据包----eth.src == 04:f9:38:ad:13:26 网络层 筛选ip地址为192.168.1.1的数据包----ip.addr == 192.168.1.1 筛选192.168.1.0网段的数据---- ip contains \"192.168.1\" 筛选192.168.1.1和192.168.1.2之间的数据包----ip.addr == 192.168.1.1 \u0026\u0026 ip.addr == 192.168.1.2 筛选从192.168.1.1到192.168.1.2的数据包----ip.src == 192.168.1.1 \u0026\u0026 ip.dst == 192.168.1.2 传输层 筛选tcp协议的数据包----tcp 筛选除tcp协议以外的数据包----!tcp 筛选端口为80的数据包----tcp.port == 80 筛选12345端口和80端口之间的数据包----tcp.port == 12345 \u0026\u0026 tcp.port == 80 筛选从12345端口到80端口的数据包----tcp.srcport == 12345 \u0026\u0026 tcp.dstport == 80 应用层 特别说明----http中http.request表示请求头中的第一行（如GET index.jsp HTTP/1.1），http.response表示响应头中的第一行（如HTTP/1.1 200 OK），其他头部都用http.header_name形式。 筛选url中包含.php的http数据包----http.request.uri contains \".php\" 筛选内容包含username的http数据包----http contains \"username\" 通过实验阐述ARP的工作原理 ARP即地址解析协议（Address Resolution Protocol），是根据IP地址获取MAC地址的一个TCP/IP协议\nARP用于解决同一个局域网上的主机或路由器的IP地址和MAC地址的映射问题\n每一台主机都设有一个 ARP高速缓存，里面存有 本局域网上 各主机和路由器的IP地址到MAC地址的映射表\nARP工作流程 当主机A要向本局域网上的某台主机B发送IP数据报时，就现在其ARP高速缓存中查找有无主机B的IP地址。若有，查出其对应的MAC地址，写入MAC帧；若没有，进行下述步骤 主机A的ARP进程在本局域网上广播一个ARP请求分组，其中有自己的IP地址到MAC地址的映射 本局域网上的所有主机运行的ARP进程都收到此ARP请求分组 主机B的IP地址与ARP请求分组中要查询的IP地址一致，就收下这个ARP请求分组，将主机A的MAC映射写入自己的ARP高速缓存，并向主机A发送ARP响应分组，同时在这个ARP响应分组中写入自己的MAC地址。由于其余所有主机的IP地址都与ARP请求分组中要查询的IP地址不一致，因此不理睬 主机A收到主机B的ARP响应分组后，就在其ARP高速缓存中写入主机B的IP地址到MAC地址的映射 实验步骤及内容 主机A\nIP地址：192.168.31.248\nMAC地址：c0:3c:59:5e:37:47\n主机B\nIP地址：192.168.31.186\nMAC地址：28:7f:cf:12:af:89\nARP命令练习 在cmd中使用ipconfig/all命令，查看自己的IP地址和MAC地址，同时让小组成员连接同一个WIFI执行相同的操作并记录 主机A IP地址和MAC地址 主机B IP地址和MAC地址 主机A使用arp -a查看ARP缓存表 主机A通过ping主机B的IP来添加动态ARP缓存表数据 我在ping主机Bip地址时碰到请求超时的问题。\n经排查，是因为windows防火墙默认设置的是不让别人ping通，通过修改防火墙相关设置解决了该问题。\n步骤：控制面板 → 系统和安全 → Windows防火墙 → 高级设置 → 入站规则 → 文件和打印机共享（回显请求 - ICMPv4-In）设置为启用 主机A使用arp -a查看ARP缓存表，发生新增一条数据 以管理员身份运行cmd，执行arp -d *，删除缓存信息 抓包分析ARP协议 当ARP缓存对应数据为空时 实验步骤 主机A执行arp -d *，删除缓存信息 主机A运行Wireshark，设置显示过滤器表达式为arp.dst.proto_ipv4 == 192.168.31.186 and arp.src.proto_ipv4 == 192.168.31.248 or icmp 主机Aping主机B的ip地址 结果分析 主机A将自己的ip地址 192.168.31.248 \u0026 MAC地址 c0:3c:59:5e:37:47写入请求分组，并将目的ip地址设置为192.168.31.186，目的MAC地址设置为00:00:00:00:00:00，对本局域网内的所有主机进行广播 主机A发出的ARP请求分组 主机B收下这个ARP请求分组，将主机A的MAC映射写入自己的ARP高速缓存，并向主机A发送ARP响应分组，同时在这个ARP响应分组中写入自己的MAC地址，即28:7f:cf:12:af:89 主机A收到主机B的ARP响应分组后，就在其ARP高速缓存中写入主机B的IP地址到MAC地址的映射 主机A收到的来自主机B的ARP响应分组 主机A的ARP高速缓存表 当ARP缓存对应数据不为空时 实验步骤 主机A运行Wireshark，设置显示过滤器表达式为arp.dst.proto_ipv4 == 192.168.31.186 and arp.src.proto_ipv4 == 192.168.31.248 or icmp 主机A ping主机B的ip地址 结果分析 主机A没有发出ARP请求，而主机B接受到了主机A的ICMP报文，说明主机A直接使用了高速缓存区内的对应数据，而没有发出广播\n主机A发出的报文 利用实验结果分析ICMP协议的报文结构字段定义 ICMP即互联网控制报文协议（Internet Control Message Protocol），网络设备（包括路由器）使用它来发送错误消息和指示与另一个IP 地址通信时成功或失败的操作信息\nICMP报文结构 ICMP报文格式 +0------7-------15---------------31 | Type | Code | Checksum | +--------------------------------+ | Message Body | | (Variable length) | +--------------------------------+ ICMP报文格式解释 Type：占一个字节，标识ICMP报文的类型，可以分为差错报告报文和询问报文两大类 Code：占一个字节，用于进一步区分某种类型中的不同情况 Checksum：占两个字节，检验报文在传输过程中是否出现差错 ICMP应用举例 Ping命令 「ping」是用来探测本机与网络中另一主机之间是否可达的命令\n在此次实验中，使用主机A在cmd环境下ping baidu.com，分析回送请求报文和回送回答报文\n回送请求报文 Internet Control Message Protocol Type: 8 (Echo (ping) request) Code: 0 Checksum: 0x4ae9 [correct] [Checksum Status: Good] Identifier (BE): 1 (0x0001) Identifier (LE): 256 (0x0100) Sequence Number (BE): 626 (0x0272) Sequence Number (LE): 29186 (0x7202) [Response frame: 215] Data (32 bytes) Data: 6162636465666768696a6b6c6d6e6f7071727374757677616263646566676869 [Length: 32] Type的值为 8，Code的值为 0，表示回显请求 Checksum的值为 0x4ae9，这里校验和验证正确 Identifier：识别码，用于区分不同进程的应用。由于Window系统与Linux系统发出的ping报文的字节序不一样，所以需要 BE 和 LE 两个值，而这两个值所表示的十六进制值（HEX）是相同的。这里的 BE 指的是大端字节序，在Linux中使用；LE指的是小端字节序，在Windows中使用 Sequence Number：序列号，用于对应请求与响应。这里对于 BE 和 LE 解释同上。 回送回答报文 Internet Control Message Protocol Type: 0 (Echo (ping) reply) Code: 0 Checksum: 0x52e9 [correct] [Checksum Status: Good] Identifier (BE): 1 (0x0001) Identifier (LE): 256 (0x0100) Sequence Number (BE): 626 (0x0272) Sequence Number (LE): 29186 (0x7202) [Request frame: 213] [Response time: 20.855 ms] Data (32 bytes) Data: 6162636465666768696a6b6c6d6e6f7071727374757677616263646566676869 [Length: 32] Type的值为 0，Code的值为 0，表示回送回答 Checksum的值为 0x52e9，这里校验和验证正确 Identifier：识别码，用于区分不同进程的应用 Sequence Number：序列号，用于对应请求与响应。这里的值 626 同上文 回送请求报文 Sequence Number 的值，说明这俩请求和响应是对应的 Tracert命令 「Tracert」是用来显示可能的路由（路径）和测量数据包在 IP 网络中的传输延迟的命令\n在此次实验中，使用主机A在cmd环境下tracert baidu.com，分析报文\n差错报告报文 ICMP的差错报告报文中，会把收到的需要进行差错报告的IP的数据提取出来作为ICMP报文的数据部分\nInternet Protocol Version 4, Src: 192.168.31.248, Dst: 110.242.68.66 0100 .... = Version: 4 .... 0101 = Header Length: 20 bytes (5) Differentiated Services Field: 0x00 (DSCP: CS0, ECN: Not-ECT) 0000 00.. = Differentiated Services Codepoint: Default (0) .... ..00 = Explicit Congestion Notification: Not ECN-Capable Transport (0) Total Length: 92 Identification: 0x1f2e (7982) 000. .... = Flags: 0x0 0... .... = Reserved bit: Not set .0.. .... = Don't fragment: Not set ..0. .... = More fragments: Not set ...0 0000 0000 0000 = Fragment Offset: 0 Time to Live: 1 [Expert Info (Note/Sequence): \"Time To Live\" only 1] [\"Time To Live\" only 1] [Severity level: Note] [Group: Sequence] Protocol: ICMP (1) Header Checksum: 0x0000 [validation disabled] [Header checksum status: Unverified] Source Address: 192.168.31.248 Destination Address: 110.242.68.66 Internet Control Message Protocol Type: 8 (Echo (ping) request) Code: 0 Checksum: 0xf4e4 [correct] [Checksum Status: Good] Identifier (BE): 1 (0x0001) Identifier (LE): 256 (0x0100) Sequence Number (BE): 794 (0x031a) Sequence Number (LE): 6659 (0x1a03) [No response seen] [Expert Info (Warning/Sequence): No response seen to ICMP request] [No response seen to ICMP request] [Severity level: Warning] [Group: Sequence] Data (64 bytes) Data: 000000000000000000000000000000000000000000000000000000000000000000000000… [Length: 64] Internet Control Message Protocol Type: 11 (Time-to-live exceeded) Code: 0 (Time to live exceeded in transit) Checksum: 0xf4ff [correct] [Checksum Status: Good] Unused: 00000000 Internet Protocol Version 4, Src: 192.168.31.248, Dst: 110.242.68.66 0100 .... = Version: 4 .... 0101 = Header Length: 20 bytes (5) Differentiated Services Field: 0x00 (DSCP: CS0, ECN: Not-ECT) 0000 00.. = Differentiated Services Codepoint: Default (0) .... ..00 = Explicit Congestion Notification: Not ECN-Capable Transport (0) Total Length: 92 Identification: 0x1f2e (7982) 000. .... = Flags: 0x0 0... .... = Reserved bit: Not set .0.. .... = Don't fragment: Not set ..0. .... = More fragments: Not set ...0 0000 0000 0000 = Fragment Offset: 0 Time to Live: 1 [Expert Info (Note/Sequence): \"Time To Live\" only 1] [\"Time To Live\" only 1] [Severity level: Note] [Group: Sequence] Protocol: ICMP (1) Header Checksum: 0x069f [validation disabled] [Header checksum status: Unverified] Source Address: 192.168.31.248 Destination Address: 110.242.68.66 Internet Control Message Protocol Type: 8 (Echo (ping) request) Code: 0 Checksum: 0xf4e4 [unverified] [in ICMP error packet] [Checksum Status: Unverified] Identifier (BE): 1 (0x0001) Identifier (LE): 256 (0x0100) Sequence Number (BE): 794 (0x031a) Sequence Number (LE): 6659 (0x1a03) Data (64 bytes) Data: 000000000000000000000000000000000000000000000000000000000000000000000000… [Length: 64] Type的值为 11，Code的值为 0，表示超时报错 图1的回送请求报文出错，图2相对应的差错报告报文，把图1报文的IP数据报的首部和数据字段的前8个字节提取出来，作为ICMP报文的数据字段 基于实验数据深入分析TCP协议功能 TCP即传输控制协议（Transmission Control Protocol），是面向连接的运输层协议\nTCP报文格式 TCP报文格式解释 源端口和目的端口：各占 2 字节，和 IP 头部的 源地址 和 目的地址 一起唯一地标识了每个连接 序列号：占 4 字节，TCP连接中传送的数据流中的每一个字节都按顺序编号，序号字段的值指的是本报文段所发送的数据的第一个字节的序号 确认号：占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号 数据偏移：占 4 位，它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远，实际是指出TCP报文段的首部长度 保留：占 6 位，保留为今后使用，默认置0 紧急 URG(URGent)：当 URG = 1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据) 确认 ACK(ACKnowledegment)：只有当 ACK = 1 时确认号字段有效，当 ACK = 0 时确认号无效 推送 PSH(PuSH)：接收 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程，不再等到整个缓存都填满了后再向上交付 复位 RST(ReSeT)：当 RST = 1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因）必须释放连接，然后再重新建立运输连接。RST置1还用来拒绝一个非法报文或拒绝打开一个连接 同步 SYN(SYNchronization)：在连接建立时用来同步序号。当 SYN = 1 而 ACK = 0 时，表明这是一个连接请求报文段。对方若同意建立连接，则在响应的报文段中使 SYN = 1 和 ACK = 1 终止 FIN(FINish)：用来释放一个连接。FIN = 1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。 窗口：占 2 字节，指的是发送本报文段的一方的接收窗口。用于流量控制，指示接收方愿意接收的字节数量 检验和：占 2 字节，检验和字段检验的范围包括TCP首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部 选项：长度可变，最长可达 40 字节。如 最长报文段长度MSS、窗口扩大选项、时间戳选项等等 填充字段：仅仅是为了使整个TCP首部长度为 4 字节的整数倍 实验步骤 下载 TCP/UDP Socket 调试工具 在cmd中ping zhihu.com，得到ip地址为103.41.167.234 使用TCP调试工具，创建一个连接 打开Wireshark，设置显示过滤器为 ip.addr == 103.41.167.234 在TCP调试工具中，点击 连接 在TCP调试工具中，发送数据 Hello World!!!后，连接自动断开 在Wireshark中捕获到以下数据包 三次握手 三次握手目的是保证双方都有发送和接收的能力\n一开始，客户端和服务端都处于 CLOSE 状态。先是服务端主动监听某个端口，处于 LISTEN 状态 客户端随机初始化 序列号 seq 为 x，同时把 SYN 置1，接着把报文发送给服务端。之后，TCP客户端进入 SYN-SENT 状态 服务器收到连接请求报文段后，若同意连接，将进行下述操作。首先，随机初始化自己的 序列号 seq 为 y，其次把 确认号 ack 置为 x + 1，接着 SYN 和 ACK 均置为1，最后把该报文发给客户端。这时，服务端进入SYN-RCVD 状态 客户端收到服务端报文后，还要向服务端回应最后一个应答报文。首先将应答报文的 ACK 置为1，确认号 ack 置为 y + 1，序列号 seq 置为 x + 1，最后把报文发送给服务端。之后，客户端处于ESTABLISHED 状态，因为它一收一发了 服务端收到客户端的应答报文后，也进入 ESTABLISHED 状态，因为它也一收一发了 四次挥手 客户端打算关闭连接，此时会发送一个 TCP 首部 FIN 标志位被置为 1 的报文并指明自己当前的 序列号 seq 为 u，之后客户端进入 FIN_WAIT_1 状态 服务端收到该报文后，就向客户端发送 ACK 应答报文，指明自己当前的 序列号 seq 为 v， 确认号 ack 为 u + 1，接着服务端进入 CLOSE_WAIT 状态 客户端收到服务端的 ACK 应答报文后，之后进入 FIN_WAIT_2 状态 等待服务端处理完数据后，也向客户端发送 FIN 报文，报文的 ACK 置为 1，序列号 seq 为 w， 确认号 ack 为 u + 1，之后服务端进入 LAST_ACK 状态 客户端收到服务端的 FIN 报文后，回一个 ACK 应答报文，其中 序列号 seq 为 u + 1， 确认号 ack 为 w + 1，之后进入 TIME_WAIT 状态 服务端收到了 ACK 应答报文后，就进入了 CLOSE 状态，至此服务端已经完成连接的关闭 客户端在经过 2MSL 一段时间后，自动进入 CLOSE 状态，至此客户端也完成连接的关闭 访问外网某服务器，分析从MAC层协议、IP协议、TCP协议一直到HTTP协议的过程 网络包的旅途 用户输入网址 浏览器解析网址，生成 HTTP 消息 在发送 HTTP 消息给 Web 服务器之前，浏览器先向 DNS 服务器发送请求，查询与服务器域名相对应的 IP 地址 通过 DNS 获取到 IP 后，浏览器把 HTTP 消息转交给 Socket 库 Socket 库将收到的 HTTP 消息作为数据转交给协议栈 TCP 按照网络包的长度对数据进行拆分，在每个包前面加上 TCP 头部并转交给 IP IP 在 TCP 包前面加上 IP 头部（目的 IP 为 Web 服务器 IP 地址，源 IP 为主机 IP 地址），IP 包生成后参考路由控制表决定接受此 IP 包的路由或主机的 IP 地址。随后，IP 包将被发送给连接这些路由器或主机网络接口的驱动程序 如果尚不知道下一跳接收端的 MAC 地址，可以利用 ARP 查找，加上 MAC 头部，然后将包转交给网卡驱动 网卡驱动收到 IP 模块发来的包，将其转交给网卡并发出发送指令 网卡检查以太网的可发送状态，将数字信息转换为电信号发送出去 服务端的局域网中有防火墙，对进入的包进行检查，判断是否允许通过 Web 服务器前面有如果有缓存服务器，会拦截通过防火墙的包如果用户请求的页面已经缓存在服务器上，则代替服务器向用户返回页面数据 如果请求的页面没有被缓存，缓存服务器会将请求转发给 Web 服务器 Web 服务器收到包后，网卡和网卡驱动会接收这个包并转交给协议栈 协议栈依次检查 IP 头部和 TCP 头部，如果没有问题则取出 HTTP 的数据块并进行组装 HTTP 消息恢复成原始状态，然后通过 Socket 库转交给 Web 服务器 Web 服务器分析 HTTP 消息的内容，并根据请求内容将读取的数据返回给客户端 浏览器接收到响应包后，进行页面的渲染 HTTP请求结束，TCP连接断开 DNS DNS报文结构 DNS查询步骤 浏览器在解析域名时，会经过下列步骤：\n浏览器会先看自身有没有对这个域名的缓存，如果有，就直接返回；如果没有，就去问操作系统 操作系统也会去看自己的缓存，如果有，就直接返回；如果没有，再去 Hosts 文件看 本地的 Hosts 文件，若有域名和 IP 地址的对应关系，直接使用该 IP 地址通信；如果没有，浏览器向本地域名服务器发出一个查询请求 本地域名服务器查看有无缓存记录。若有，直接响应；若没有，本地域名服务器向根域名服务器查询 根域名服务器响应本地域名服务器，给出对应域名的顶级域名服务器IP地址，让本地域名服务器去向其查询 顶级域名服务器响应本地域名服务器，给出对应域名的权威域名服务器（权威 DNS 服务器，它是域名解析结果的原出处）IP地址，让本地域名服务器去向其查询 权威 DNS 服务器查询后将对应的 IP 地址告诉本地 DNS 服务器 本地 DNS 将 IP 地址返回给客户端，客户端和目标建立连接 实验步骤 访问http://www.smartclass.cn/Default.aspx 分析 HTTP 请求报文及 HTTP 响应报文 报文分析 HTTP报文结构 HTTP请求报文 数据链路层 网络层 传输层 应用层 Hypertext Transfer Protocol GET /Default.aspx HTTP/1.1\\r\\n Host: www.smartclass.cn\\r\\n User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36 Edg/107.0.1418.42\\r\\n Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\\r\\n Accept-Encoding: gzip, deflate\\r\\n Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6\\r\\n Upgrade-Insecure-Requests: 1\\r\\n \\r\\n [Full request URI: http://www.smartclass.cn/Default.aspx] [HTTP request 1/14] [Response in frame: 1787] [Next request in frame: 1804] 请求行：由 请求方法字段、URL字段 和 HTTP协议版本字段 组成，如 GET /Default.aspx HTTP/1.1 请求头部：关键字/值对组成，每行一对 Host：请求的主机名 User-Agent：发出请求的浏览器类型 Accept：客户端可识别的内容类型列表 空行：最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头 请求数据 HTTP响应报文 传输层 TCP 协议会分段传输过大的数据段（Segment）保证传输的性能 TCP 协议引入了最大分段大小（Maximum segment size，MSS）这一概念，它是 TCP 数据段能够携带的数据上限。在正常情况下，TCP 连接的 MSS 是 MTU - 40 字节，即 1460 字节 MSS：一个网络包的最大长度，以太网中一般为 1500 字节 MTU：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度 该报文 MSS 值为 1360，数据段分成 8 份从服务端发出，并在客户端经过拼接后被接收 应用层 Hypertext Transfer Protocol HTTP/1.1 200 OK\\r\\n [Expert Info (Chat/Sequence): HTTP/1.1 200 OK\\r\\n] [HTTP/1.1 200 OK\\r\\n] [Severity level: Chat] [Group: Sequence] Response Version: HTTP/1.1 Status Code: 200 [Status Code Description: OK] Response Phrase: OK Date: Sun, 13 Nov 2022 13:06:05 GMT\\r\\n Content-Type: text/html; charset=utf-8\\r\\n Content-Length: 9696\\r\\n [Content length: 9696] Connection: keep-alive\\r\\n Cache-Control: private\\r\\n Content-Encoding: gzip\\r\\n Vary: Accept-Encoding\\r\\n MANUFACTURER: Hanboer\\r\\n X-AspNet-Version: 4.0.30319\\r\\n X-UA-Compatible: IE=edge,chrome=1\\r\\n Access-Control-Allow-Headers: content-type\\r\\n Access-Control-Allow-Methods: GET,POST,PUT,DELETE,OPTIONS\\r\\n Access-Control-Allow-Origin: http://localhost:9527\\r\\n Access-Control-Allow-Credentials: true\\r\\n \\r\\n [HTTP response 1/14] [Time since request: 0.067102000 seconds] [Request in frame: 1776] [Next request in frame: 1804] [Next response in frame: 1806] [Request URI: http://www.smartclass.cn/Webapi/V1/Live/GetPublicLives?csrkToken=0aat6ee1aaks3\u0026IsLiving=true\u0026Sort=StartTime\u0026Order=0\u0026PageSize=8\u0026PageNumber=1\u0026attribute=] Content-encoded entity body (gzip): 9696 bytes -\u003e 40818 bytes File Data: 40818 bytes 状态行：由 HTTP版本 、状态码 和原因短语 组成，如 HTTP/1.1 200 OK 响应头部：关键字/值对组成，每行一对 空行：最后一个响应头之后是一个空行，发送回车符和换行符，通知服务器以下不再有响应头 响应正文 参考 Wireshark系列之4 捕获过滤器 网络——Wireshark工具 WireShark的基本用法 Wireshark使用教程（界面说明、捕获过滤器表达式、显示过滤器表达式） 一文精讲Wireshark的抓包和分析 Wireshark简明教程，新手专用，挑实在的讲，不搞花里胡哨 WireShark网络封包抓包工具各个界面介绍 实验3.利用Wireshark分析ARP协议 如何计算IP或ICMP协议首部里的checksum字段 带你深入熟悉你所不知道的ICMP 使用Wireshark学习网络协议之ICMP 实战！我用 Wireshark 让你“看见“ TCP 4.1 TCP 三次握手与四次挥手面试题 Wireshark抓包TCP三次握手 TCP 中的三次握手和四次挥手 Wireshark配合TCP调试工具理解TCP三次握手和四次挥手过程 老生常谈的TCP三次握手和四次挥手，你会了吗？ HTTP请求报文和HTTP响应报文 为什么 TCP/IP 协议会拆分数据 HTTP的曲折：网络请求到层层封装和终端拆分 浅谈http协议（三）：HTTP 报文及其结构 Wireshark官方文档 ","wordCount":"10293","inLanguage":"en","datePublished":"2022-11-12T11:38:21+08:00","dateModified":"2022-11-12T11:38:21+08:00","author":[{"@type":"Person","name":"Xan"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://xancoding.cn/posts/wireshark/"},"publisher":{"@type":"Organization","name":"Xan's Blog","logo":{"@type":"ImageObject","url":"https://xancoding.cn/img/favicon.ico"}}}</script><script src=https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://xancoding.cn accesskey=h title="Xan's Blog (Alt + H)"><img src=https://xancoding.cn/img/Headshot.jpg alt aria-label=logo height=35>Xan's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://xancoding.cn/ title=Home><span>Home</span></a></li><li><a href=https://xancoding.cn/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://xancoding.cn/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://xancoding.cn/links/ title=Links><span>Links</span></a></li><li><a href=https://xancoding.cn/about/ title=About><span>About</span></a></li><li><a href=https://xancoding.cn/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://xancoding.cn>Home</a>&nbsp;»&nbsp;<a href=https://xancoding.cn/posts/>Posts</a></div><h1 class=post-title>计算机网络课程大作业</h1><div class=post-meta>&nbsp;<span title='2022-11-12 11:38:21 +0800 CST'>2022-11-12</span>&nbsp;|&nbsp;<a href=https://github.com/Xancoding/Blog/tree/main/content/posts/wireshark.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e8%a6%81%e6%b1%82 aria-label=要求>要求</a></li><li><a href=#%e9%80%89%e9%a2%98 aria-label=选题>选题</a></li><li><a href=#%e5%9f%ba%e4%ba%8e%e7%bd%91%e7%bb%9c%e5%97%85%e6%8e%a2%e8%bd%af%e4%bb%b6wireshark%e7%9a%84%e5%8d%8f%e8%ae%ae%e5%88%86%e6%9e%90%e5%ae%9e%e9%aa%8c aria-label=基于网络嗅探软件Wireshark的协议分析实验>基于网络嗅探软件Wireshark的协议分析实验</a><ul><li><a href=#wireshark-%e6%98%af%e4%bb%80%e4%b9%88 aria-label="Wireshark 是什么？">Wireshark 是什么？</a></li><li><a href=#wireshark-%e4%b8%8b%e8%bd%bd%e4%b8%8e%e5%ae%89%e8%a3%85 aria-label="Wireshark 下载与安装">Wireshark 下载与安装</a></li><li><a href=#wireshark-%e5%9f%ba%e6%9c%ac%e7%94%a8%e6%b3%95 aria-label="Wireshark 基本用法">Wireshark 基本用法</a><ul><li><a href=#%e9%80%89%e6%8b%a9%e6%8e%a5%e5%8f%a3%e7%bd%91%e5%8d%a1 aria-label=选择接口（网卡）>选择接口（网卡）</a></li><li><a href=#%e7%95%8c%e9%9d%a2%e8%af%b4%e6%98%8e aria-label=界面说明>界面说明</a></li><li><a href=#%e8%bf%87%e6%bb%a4%e5%99%a8%e8%ae%be%e7%bd%ae aria-label=过滤器设置>过滤器设置</a><ul><li><a href=#%e6%8d%95%e8%8e%b7%e8%bf%87%e6%bb%a4%e5%99%a8 aria-label=捕获过滤器>捕获过滤器</a><ul><li><a href=#%e7%95%8c%e9%9d%a2%e8%af%b4%e6%98%8e-1 aria-label=界面说明>界面说明</a></li><li><a href=#%e8%af%ad%e6%b3%95%e8%a7%84%e5%88%99 aria-label=语法规则>语法规则</a></li><li><a href=#%e5%ba%94%e7%94%a8%e7%a4%ba%e4%be%8b aria-label=应用示例>应用示例</a></li></ul></li><li><a href=#%e6%98%be%e7%a4%ba%e8%bf%87%e6%bb%a4%e5%99%a8 aria-label=显示过滤器>显示过滤器</a><ul><li><a href=#%e5%9f%ba%e6%9c%ac%e8%bf%87%e6%bb%a4%e8%a1%a8%e8%be%be%e5%bc%8f aria-label=基本过滤表达式>基本过滤表达式</a><ul><li><a href=#%e8%bf%87%e6%bb%a4%e9%a1%b9 aria-label=过滤项>过滤项</a></li><li><a href=#%e8%bf%87%e6%bb%a4%e5%85%b3%e7%b3%bb aria-label=过滤关系>过滤关系</a></li><li><a href=#%e8%bf%87%e6%bb%a4%e5%80%bc aria-label=过滤值>过滤值</a></li></ul></li><li><a href=#%e5%a4%8d%e5%90%88%e8%bf%87%e6%bb%a4%e8%a1%a8%e8%be%be%e5%bc%8f aria-label=复合过滤表达式>复合过滤表达式</a></li><li><a href=#%e5%b8%b8%e8%a7%81%e6%98%be%e7%a4%ba%e8%bf%87%e6%bb%a4%e9%9c%80%e6%b1%82%e5%8f%8a%e5%85%b6%e5%af%b9%e5%ba%94%e8%a1%a8%e8%be%be%e5%bc%8f aria-label=常见显示过滤需求及其对应表达式>常见显示过滤需求及其对应表达式</a><ul><li><a href=#%e6%95%b0%e6%8d%ae%e9%93%be%e8%b7%af%e5%b1%82 aria-label=数据链路层>数据链路层</a></li><li><a href=#%e7%bd%91%e7%bb%9c%e5%b1%82 aria-label=网络层>网络层</a></li><li><a href=#%e4%bc%a0%e8%be%93%e5%b1%82 aria-label=传输层>传输层</a></li><li><a href=#%e5%ba%94%e7%94%a8%e5%b1%82 aria-label=应用层>应用层</a></li></ul></li></ul></li></ul></li></ul></li><li><a href=#%e9%80%9a%e8%bf%87%e5%ae%9e%e9%aa%8c%e9%98%90%e8%bf%b0arp%e7%9a%84%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86 aria-label=通过实验阐述ARP的工作原理>通过实验阐述ARP的工作原理</a><ul><li><a href=#arp%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b aria-label=ARP工作流程>ARP工作流程</a></li><li><a href=#%e5%ae%9e%e9%aa%8c%e6%ad%a5%e9%aa%a4%e5%8f%8a%e5%86%85%e5%ae%b9 aria-label=实验步骤及内容>实验步骤及内容</a><ul><li><a href=#arp%e5%91%bd%e4%bb%a4%e7%bb%83%e4%b9%a0 aria-label=ARP命令练习>ARP命令练习</a></li><li><a href=#%e6%8a%93%e5%8c%85%e5%88%86%e6%9e%90arp%e5%8d%8f%e8%ae%ae aria-label=抓包分析ARP协议>抓包分析ARP协议</a><ul><li><a href=#%e5%bd%93arp%e7%bc%93%e5%ad%98%e5%af%b9%e5%ba%94%e6%95%b0%e6%8d%ae%e4%b8%ba%e7%a9%ba%e6%97%b6 aria-label=当ARP缓存对应数据为空时>当ARP缓存对应数据为空时</a><ul><li><a href=#%e5%ae%9e%e9%aa%8c%e6%ad%a5%e9%aa%a4 aria-label=实验步骤>实验步骤</a></li><li><a href=#%e7%bb%93%e6%9e%9c%e5%88%86%e6%9e%90 aria-label=结果分析>结果分析</a></li></ul></li><li><a href=#%e5%bd%93arp%e7%bc%93%e5%ad%98%e5%af%b9%e5%ba%94%e6%95%b0%e6%8d%ae%e4%b8%8d%e4%b8%ba%e7%a9%ba%e6%97%b6 aria-label=当ARP缓存对应数据不为空时>当ARP缓存对应数据不为空时</a><ul><li><a href=#%e5%ae%9e%e9%aa%8c%e6%ad%a5%e9%aa%a4-1 aria-label=实验步骤>实验步骤</a></li><li><a href=#%e7%bb%93%e6%9e%9c%e5%88%86%e6%9e%90-1 aria-label=结果分析>结果分析</a></li></ul></li></ul></li></ul></li></ul></li><li><a href=#%e5%88%a9%e7%94%a8%e5%ae%9e%e9%aa%8c%e7%bb%93%e6%9e%9c%e5%88%86%e6%9e%90icmp%e5%8d%8f%e8%ae%ae%e7%9a%84%e6%8a%a5%e6%96%87%e7%bb%93%e6%9e%84%e5%ad%97%e6%ae%b5%e5%ae%9a%e4%b9%89 aria-label=利用实验结果分析ICMP协议的报文结构字段定义>利用实验结果分析ICMP协议的报文结构字段定义</a><ul><li><a href=#icmp%e6%8a%a5%e6%96%87%e6%a0%bc%e5%bc%8f aria-label=ICMP报文格式>ICMP报文格式</a></li><li><a href=#icmp%e6%8a%a5%e6%96%87%e6%a0%bc%e5%bc%8f%e8%a7%a3%e9%87%8a aria-label=ICMP报文格式解释>ICMP报文格式解释</a></li><li><a href=#icmp%e5%ba%94%e7%94%a8%e4%b8%be%e4%be%8b aria-label=ICMP应用举例>ICMP应用举例</a><ul><li><a href=#ping%e5%91%bd%e4%bb%a4 aria-label=Ping命令>Ping命令</a><ul><li><a href=#%e5%9b%9e%e9%80%81%e8%af%b7%e6%b1%82%e6%8a%a5%e6%96%87 aria-label=回送请求报文>回送请求报文</a></li><li><a href=#%e5%9b%9e%e9%80%81%e5%9b%9e%e7%ad%94%e6%8a%a5%e6%96%87 aria-label=回送回答报文>回送回答报文</a></li></ul></li><li><a href=#tracert%e5%91%bd%e4%bb%a4 aria-label=Tracert命令>Tracert命令</a><ul><li><a href=#%e5%b7%ae%e9%94%99%e6%8a%a5%e5%91%8a%e6%8a%a5%e6%96%87 aria-label=差错报告报文>差错报告报文</a></li></ul></li></ul></li></ul></li><li><a href=#%e5%9f%ba%e4%ba%8e%e5%ae%9e%e9%aa%8c%e6%95%b0%e6%8d%ae%e6%b7%b1%e5%85%a5%e5%88%86%e6%9e%90tcp%e5%8d%8f%e8%ae%ae%e5%8a%9f%e8%83%bd aria-label=基于实验数据深入分析TCP协议功能>基于实验数据深入分析TCP协议功能</a><ul><li><a href=#tcp%e6%8a%a5%e6%96%87%e6%a0%bc%e5%bc%8f aria-label=TCP报文格式>TCP报文格式</a></li><li><a href=#tcp%e6%8a%a5%e6%96%87%e6%a0%bc%e5%bc%8f%e8%a7%a3%e9%87%8a aria-label=TCP报文格式解释>TCP报文格式解释</a></li><li><a href=#%e5%ae%9e%e9%aa%8c%e6%ad%a5%e9%aa%a4-2 aria-label=实验步骤>实验步骤</a></li><li><a href=#%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b aria-label=三次握手>三次握手</a></li><li><a href=#%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b aria-label=四次挥手>四次挥手</a></li></ul></li><li><a href=#%e8%ae%bf%e9%97%ae%e5%a4%96%e7%bd%91%e6%9f%90%e6%9c%8d%e5%8a%a1%e5%99%a8%e5%88%86%e6%9e%90%e4%bb%8emac%e5%b1%82%e5%8d%8f%e8%ae%aeip%e5%8d%8f%e8%ae%aetcp%e5%8d%8f%e8%ae%ae%e4%b8%80%e7%9b%b4%e5%88%b0http%e5%8d%8f%e8%ae%ae%e7%9a%84%e8%bf%87%e7%a8%8b aria-label=访问外网某服务器，分析从MAC层协议、IP协议、TCP协议一直到HTTP协议的过程>访问外网某服务器，分析从MAC层协议、IP协议、TCP协议一直到HTTP协议的过程</a><ul><li><a href=#%e7%bd%91%e7%bb%9c%e5%8c%85%e7%9a%84%e6%97%85%e9%80%94 aria-label=网络包的旅途>网络包的旅途</a></li><li><a href=#dns aria-label=DNS>DNS</a><ul><li><a href=#dns%e6%8a%a5%e6%96%87%e7%bb%93%e6%9e%84 aria-label=DNS报文结构>DNS报文结构</a></li><li><a href=#dns%e6%9f%a5%e8%af%a2%e6%ad%a5%e9%aa%a4 aria-label=DNS查询步骤>DNS查询步骤</a></li></ul></li><li><a href=#%e5%ae%9e%e9%aa%8c%e6%ad%a5%e9%aa%a4-3 aria-label=实验步骤>实验步骤</a></li><li><a href=#%e6%8a%a5%e6%96%87%e5%88%86%e6%9e%90 aria-label=报文分析>报文分析</a><ul><li><a href=#http%e6%8a%a5%e6%96%87%e7%bb%93%e6%9e%84 aria-label=HTTP报文结构>HTTP报文结构</a></li><li><a href=#http%e8%af%b7%e6%b1%82%e6%8a%a5%e6%96%87 aria-label=HTTP请求报文>HTTP请求报文</a><ul><li><a href=#%e6%95%b0%e6%8d%ae%e9%93%be%e8%b7%af%e5%b1%82-1 aria-label=数据链路层>数据链路层</a></li><li><a href=#%e7%bd%91%e7%bb%9c%e5%b1%82-1 aria-label=网络层>网络层</a></li><li><a href=#%e4%bc%a0%e8%be%93%e5%b1%82-1 aria-label=传输层>传输层</a></li><li><a href=#%e5%ba%94%e7%94%a8%e5%b1%82-1 aria-label=应用层>应用层</a></li></ul></li><li><a href=#http%e5%93%8d%e5%ba%94%e6%8a%a5%e6%96%87 aria-label=HTTP响应报文>HTTP响应报文</a><ul><li><a href=#%e4%bc%a0%e8%be%93%e5%b1%82-2 aria-label=传输层>传输层</a></li><li><a href=#%e5%ba%94%e7%94%a8%e5%b1%82-2 aria-label=应用层>应用层</a></li></ul></li></ul></li></ul></li><li><a href=#%e5%8f%82%e8%80%83 aria-label=参考>参考</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=要求>要求<a hidden class=anchor aria-hidden=true href=#要求>#</a></h1><ol><li>团队合作、合理分工、按组为单位进行</li><li>报告文字内容不可拷贝粘贴现有文献，应反映小组所做的工作，有分析，实践性的选题应有具体操作或者配置过程描述，辅以截图或实验数据</li><li>所交报告中应在最后注明组员分工、参考文献，报告字数3000-6000</li><li>不同班级的小组可选择相同的题目，但重复计数（由各班学委协调），不可多于3组，且报告内容不可相同，要求独立完成各组任务</li><li>除了个别综述性的选题，其它选题要求在实际平台上实践</li></ol><h1 id=选题>选题<a hidden class=anchor aria-hidden=true href=#选题>#</a></h1><blockquote><p><strong>基于网络嗅探软件（wireshark）的协议分析实验</strong></p></blockquote><ol><li>Wireshark的深入学习与掌握，如过滤器的使用，归纳方法</li><li>通过实验阐述ARP的工作原理</li><li>利用实验结果分析ICMP协议的报文结构字段定义</li><li>基于实验数据深入分析TCP协议的连接过程原理，报文的分片等功能</li><li>从校园网发起向外网中某Web服务器的访问，记录并分析从MAC层协议、IP协议、TCP协议一直到HTTP协议的过程</li></ol><h1 id=基于网络嗅探软件wireshark的协议分析实验>基于网络嗅探软件Wireshark的协议分析实验<a hidden class=anchor aria-hidden=true href=#基于网络嗅探软件wireshark的协议分析实验>#</a></h1><h2 id=wireshark-是什么>Wireshark 是什么？<a hidden class=anchor aria-hidden=true href=#wireshark-是什么>#</a></h2><blockquote><p><strong>Wirkshark 是一个功能十分强大的开源的网络数据包分析器，能够在多种平台上抓取和分析网络包</strong></p><p><strong>Wirkshark 可被用于检查安全问题和解决网络问题，也可供开发者调试协议的实现和学习网络协议的原理</strong></p><p><strong>Wireshark使用 Npcap or WinPcap 作为接口，直接与网卡进行数据报文交换</strong></p></blockquote><h2 id=wireshark-下载与安装>Wireshark 下载与安装<a hidden class=anchor aria-hidden=true href=#wireshark-下载与安装>#</a></h2><p>官网地址：<a href=https://www.wireshark.org/>https://www.wireshark.org/</a>，直接点击下一步下一步安装即可<div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/12/636eef0324bca.png><img src=https://bu.dusays.com/2022/11/12/636eef0324bca.png alt=1></a></div>但是，我在安装过程中报了如下的错误：<div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/11/636e699429bad.png><img src=https://bu.dusays.com/2022/11/11/636e699429bad.png alt=npcap></a></div>排查了好久，没找到合适的解决办法<br>最后，下载 WinPcap 来代替 Npcap ，成功运行。</p><h2 id=wireshark-基本用法>Wireshark 基本用法<a hidden class=anchor aria-hidden=true href=#wireshark-基本用法>#</a></h2><blockquote><p>简单抓包基础步骤：选择捕获接口 -> 获取网络实时痕迹 -> 获取报文 -> 深入解析</p></blockquote><hr><h3 id=选择接口网卡>选择接口（网卡）<a hidden class=anchor aria-hidden=true href=#选择接口网卡>#</a></h3><blockquote><p><strong>网络上传输的数据包需要经过网卡到达计算机，Wireshark可以捕获流经网卡的数据包</strong></p></blockquote><p>在使用Wireshark捕获数据前，先要选择捕获接口。一台计算机可能会有不止一个网卡，此时需要选择你要捕获数据的接口。</p><p>选择菜单栏上的 捕获->选项<div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/12/636eef03d463f.png><img src=https://bu.dusays.com/2022/11/12/636eef03d463f.png alt=1></a></div>选择想要捕获数据的接口后，点击开始<div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/12/636ef1eb47349.png><img src=https://bu.dusays.com/2022/11/12/636ef1eb47349.png alt=2></a></div></p><h3 id=界面说明>界面说明<a hidden class=anchor aria-hidden=true href=#界面说明>#</a></h3><p>开始捕获后，Wireshark会把捕获到的报文显示到界面上</p><ol><li><strong>显示过滤器</strong>用于设置过滤条件进行数据列表区数据过滤</li><li><strong>数据列表区</strong>展示的是Wireshark捕获到的所有数据包的列表，每个数据包包含 编号、时间戳、源地址、目标地址、协议、长度以及数据包信息</li><li><strong>数据详细区</strong>展示的是在数据列表区中选中的数据包的分协议展示<ol><li><u>Frame</u>：物理层的数据帧概况</li><li><u>Ethernet II</u>：数据链路层以太网帧头部信息</li><li><u>Internet Protocol Version 4</u>： 互联网层IP包头部信息</li><li><u>Transmission Control Protocol</u>：传输层的数据段头部信息，此处是TCP</li></ol></li><li><strong>数据字节区</strong>展示的是选中的数据包的源数据。另外，在数据详细区选中的某层或某字段，对应的数据会在数据字节区中高亮<div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/12/636efb5f7ea6d.png><img src=https://bu.dusays.com/2022/11/12/636efb5f7ea6d.png alt=1></a></div></li></ol><h3 id=过滤器设置>过滤器设置<a hidden class=anchor aria-hidden=true href=#过滤器设置>#</a></h3><blockquote><p><strong>根据我们想要抓取的数据包，对过滤器进行设置。过滤掉冗余的数据包，找到我们需要的信息</strong></p></blockquote><h4 id=捕获过滤器>捕获过滤器<a hidden class=anchor aria-hidden=true href=#捕获过滤器>#</a></h4><blockquote><p><strong>捕获过滤器表达式作用在Wireshark捕获数据包之前，只捕获符合条件的数据包</strong></p><p><strong>当需要处理大量数据时，使用捕获过滤器可以节省大量资源</strong></p></blockquote><h5 id=界面说明-1>界面说明<a hidden class=anchor aria-hidden=true href=#界面说明-1>#</a></h5><p>选择菜单栏上的 捕获->捕获过滤器<div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/12/636efe3d72678.png><img src=https://bu.dusays.com/2022/11/12/636efe3d72678.png alt=1></a></div>点击 <code>+</code> 即可添加新的过滤规则<br><code>Filter Name</code> 指代过滤器名称，用来给自己看该过滤器的过滤效果<br><code>Filter Expression</code> 指代过滤器表达式，需要使用 <code>Berkeley Packet Filter</code> 语法书写<div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/12/636efe3e2ce20.png><img src=https://bu.dusays.com/2022/11/12/636efe3e2ce20.png alt=2></a></div></p><h5 id=语法规则>语法规则<a hidden class=anchor aria-hidden=true href=#语法规则>#</a></h5><p>捕获过滤器使用 <code>BPF</code> 语法，表达式由多个原语组成：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-markdown data-lang=markdown><span style=display:flex><span>原语(primitives)：由名称或数字，以及描述它的多个限定词组成。  
</span></span><span style=display:flex><span>  <span style=color:#fff;font-weight:700>*</span> 限定词(qualifiers)
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>*</span> Types：设置数字或者名称所指示类型，例如host www.baidu.com，如果没有指定此值，则默认使用“host”关键字
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>*</span> host、post
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>*</span> net，设定子网， net 192.168.0.0 mask 255.255.255.0等价于net 192.168.0.0/24
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>*</span> port，设置端口范围，例如port 6000-8000
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>*</span> Dir：设置网络出入方向，例如dst port 80，如果没有特别指明来源或目的地，则默认使用“src or dst”作为关键字
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>*</span> src、dst、src or dst、src and dst(src：源端口，dst：目标端口)
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>*</span> Proto：指定协议类型，例如udp，如果没有特别指明是什么协议，则默认使用所有支持的协议
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>*</span> ether、fddi、tr、wlan、ip、ip6、arp、rarp、decnet、tcp、udp、icmp、igmp、icmp、igrp、pim、ah、esp、vrrp
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>*</span> 其他
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>*</span> gateway：指明网关IP地址，等价于ether host &#39;ehost&#39; and not host &#39;host&#39;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>*</span> broadcast：广播报文，例如ether broadcast或者ip broadcast
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>*</span> multicast：多播报文，例如ip multicast或者ip6 multicast
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>*</span> less、greater：小于或者大于
</span></span><span style=display:flex><span>  <span style=color:#fff;font-weight:700>*</span> 原语运算符
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>*</span> 与：<span style=color:red>&amp;&amp;</span>或者and
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>*</span> 或：||或者or
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>*</span> 非：!或者not
</span></span></code></pre></div><div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px">转载自：https://juejin.cn/post/6844904066229747720</div><h5 id=应用示例>应用示例<a hidden class=anchor aria-hidden=true href=#应用示例>#</a></h5><p>只抓取源端口或者目的端口范围6000到8000，并且是一个tcp协议或者ipv6的数据包</p><pre tabindex=0><code>src or dst port 6000-8000 &amp;&amp; tcp or ip6    
</code></pre><p>只抓取IP地址为192.168.0.10的数据包</p><pre tabindex=0><code>host 192.168.0.10
</code></pre><h4 id=显示过滤器>显示过滤器<a hidden class=anchor aria-hidden=true href=#显示过滤器>#</a></h4><blockquote><p><strong>显示过滤器表达式作用在在Wireshark捕获数据包之后，从已捕获的所有数据包中显示出符合条件的数据包</strong></p></blockquote><p>显示过滤表达式在工具栏下方的“应用显示过滤器”输入框输入即可生效<div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/12/636f11a82564a.png><img src=https://bu.dusays.com/2022/11/12/636f11a82564a.png alt=1></a></div></p><h5 id=基本过滤表达式>基本过滤表达式<a hidden class=anchor aria-hidden=true href=#基本过滤表达式>#</a></h5><ol><li>一条基本的表达式由<strong>过滤项</strong>、<strong>过滤关系</strong>、<strong>过滤值</strong>三项组成</li><li>例如：<code>ip.addr == 192.168.1.1</code>，其中 <code>ip.addr</code> 为过滤项，<code>==</code> 为过滤关系，<code>192.168.1.1</code> 为过滤值。</li><li>该表达式的意思是 <strong>找出所有ip协议中源或目标ip等于192.168.1.1的数据包</strong></li></ol><h6 id=过滤项>过滤项<a hidden class=anchor aria-hidden=true href=#过滤项>#</a></h6><ol><li>Wireshark的过滤项是 <code>协议.协议字段</code> 的模式，Wireshark支持的全部协议及协议字段可查看<a href=https://www.wireshark.org/docs/dfref/>官方说明</a>。</li><li>以端口为例，端口出现于tcp协议中。所以有端口这个过滤项且其写法就是tcp.port</li><li>Wireshark出于缩减长度的原因，有些字段没有使用协议规定的名称而是使用简写，比如Destination Port在Wireshark中写为dstport</li><li>Wireshark出于简便使用的原因，增加了一些协议中没有的字段，比如tcp协议只有源端口和目标端口字段，为了简便使用Wireshark增加了tcp.port来同时代表这两个字段</li><li>实际使用时我们输入<code>协议.</code>后Wireshark就会有支持的字段提示</li></ol><h6 id=过滤关系>过滤关系<a hidden class=anchor aria-hidden=true href=#过滤关系>#</a></h6><p>过滤关系指的是大于、等于、小于等等式关系，具体可以看<a href=https://www.wireshark.org/docs/wsug_html/#DispCompOps>官方给出的表</a><div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/12/636f11ecb35db.png><img src=https://bu.dusays.com/2022/11/12/636f11ecb35db.png alt=1></a></div></p><h6 id=过滤值>过滤值<a hidden class=anchor aria-hidden=true href=#过滤值>#</a></h6><p>过滤值就是设定的过滤项应该满足过滤关系的标准，比如500、5000、50000等等。<br>过滤值的写法一般已经被过滤项和过滤关系设定好了，只是填下自己的期望值就可以了。</p><h5 id=复合过滤表达式>复合过滤表达式<a hidden class=anchor aria-hidden=true href=#复合过滤表达式>#</a></h5><p>所谓复合过滤表达示，就是指由多条基本过滤表达式组合而成的表达示。<br>基本过滤表达式的写法还是不变的，复合过滤表达示多出来的东西就只是基本过滤表达示的“连接词”，我们依然直接参照<a href=https://www.wireshark.org/docs/wsug_html/#FiltLogOps>官方给出的表</a><div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/12/636f11cc4be71.png><img src=https://bu.dusays.com/2022/11/12/636f11cc4be71.png alt=1></a></div></p><h5 id=常见显示过滤需求及其对应表达式>常见显示过滤需求及其对应表达式<a hidden class=anchor aria-hidden=true href=#常见显示过滤需求及其对应表达式>#</a></h5><h6 id=数据链路层>数据链路层<a hidden class=anchor aria-hidden=true href=#数据链路层>#</a></h6><pre tabindex=0><code>筛选mac地址为04:f9:38:ad:13:26的数据包----eth.src == 04:f9:38:ad:13:26

筛选源mac地址为04:f9:38:ad:13:26的数据包----eth.src == 04:f9:38:ad:13:26
</code></pre><h6 id=网络层>网络层<a hidden class=anchor aria-hidden=true href=#网络层>#</a></h6><pre tabindex=0><code>筛选ip地址为192.168.1.1的数据包----ip.addr == 192.168.1.1

筛选192.168.1.0网段的数据---- ip contains &#34;192.168.1&#34;

筛选192.168.1.1和192.168.1.2之间的数据包----ip.addr == 192.168.1.1 &amp;&amp; ip.addr == 192.168.1.2

筛选从192.168.1.1到192.168.1.2的数据包----ip.src == 192.168.1.1 &amp;&amp; ip.dst == 192.168.1.2
</code></pre><h6 id=传输层>传输层<a hidden class=anchor aria-hidden=true href=#传输层>#</a></h6><pre tabindex=0><code>筛选tcp协议的数据包----tcp

筛选除tcp协议以外的数据包----!tcp

筛选端口为80的数据包----tcp.port == 80

筛选12345端口和80端口之间的数据包----tcp.port == 12345 &amp;&amp; tcp.port == 80

筛选从12345端口到80端口的数据包----tcp.srcport == 12345 &amp;&amp; tcp.dstport == 80
</code></pre><h6 id=应用层>应用层<a hidden class=anchor aria-hidden=true href=#应用层>#</a></h6><pre tabindex=0><code>特别说明----http中http.request表示请求头中的第一行（如GET index.jsp HTTP/1.1），http.response表示响应头中的第一行（如HTTP/1.1 200 OK），其他头部都用http.header_name形式。

筛选url中包含.php的http数据包----http.request.uri contains &#34;.php&#34;

筛选内容包含username的http数据包----http contains &#34;username&#34;
</code></pre><h2 id=通过实验阐述arp的工作原理>通过实验阐述ARP的工作原理<a hidden class=anchor aria-hidden=true href=#通过实验阐述arp的工作原理>#</a></h2><blockquote><p><strong>ARP即地址解析协议（Address Resolution Protocol），是根据IP地址获取MAC地址的一个TCP/IP协议</strong></p><p><strong>ARP用于解决同一个局域网上的主机或路由器的IP地址和MAC地址的映射问题</strong></p><p><strong>每一台主机都设有一个 ARP高速缓存，里面存有 本局域网上 各主机和路由器的IP地址到MAC地址的映射表</strong></p></blockquote><h3 id=arp工作流程>ARP工作流程<a hidden class=anchor aria-hidden=true href=#arp工作流程>#</a></h3><ol><li>当主机A要向<strong>本局域网</strong>上的某台主机B发送IP数据报时，就现在其ARP高速缓存中查找有无主机B的IP地址。若有，查出其对应的MAC地址，写入MAC帧；若没有，进行下述步骤</li><li>主机A的ARP进程在本局域网上广播一个ARP请求分组，其中有自己的IP地址到MAC地址的映射</li><li>本局域网上的所有主机运行的ARP进程都收到此ARP请求分组</li><li>主机B的IP地址与ARP请求分组中要查询的IP地址一致，就收下这个ARP请求分组，将主机A的MAC映射写入自己的ARP高速缓存，并向主机A发送ARP响应分组，同时在这个ARP响应分组中写入自己的MAC地址。由于其余所有主机的IP地址都与ARP请求分组中要查询的IP地址不一致，因此不理睬</li><li>主机A收到主机B的ARP响应分组后，就在其ARP高速缓存中写入主机B的IP地址到MAC地址的映射</li></ol><h3 id=实验步骤及内容>实验步骤及内容<a hidden class=anchor aria-hidden=true href=#实验步骤及内容>#</a></h3><blockquote><p><strong>主机A</strong></p><p><strong>IP地址：192.168.31.248</strong></p><p><strong>MAC地址：c0:3c:59:5e:37:47</strong></p><p><strong>主机B</strong></p><p><strong>IP地址：192.168.31.186</strong></p><p><strong>MAC地址：28:7f:cf:12:af:89</strong></p></blockquote><h4 id=arp命令练习>ARP命令练习<a hidden class=anchor aria-hidden=true href=#arp命令练习>#</a></h4><ol><li>在<code>cmd</code>中使用<code>ipconfig/all</code>命令，查看自己的IP地址和MAC地址，同时让小组成员连接同一个<code>WIFI</code>执行相同的操作并记录</li></ol><center><img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=https://bu.dusays.com/2022/11/12/636f62756d2e9.png><br><div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px">主机A IP地址和MAC地址</div></center><center><img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=https://bu.dusays.com/2022/11/12/636f6331a7d39.png><br><div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px">主机B IP地址和MAC地址</div></center><ol start=2><li>主机A使用<code>arp -a</code>查看ARP缓存表<div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/12/636f603bde062.png><img src=https://bu.dusays.com/2022/11/12/636f603bde062.png alt=1></a></div></li><li>主机A通过<code>ping</code>主机B的IP来添加动态ARP缓存表数据<div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/12/636f60cfe4604.png><img src=https://bu.dusays.com/2022/11/12/636f60cfe4604.png alt=2></a></div>我在<code>ping</code>主机B<code>ip</code>地址时碰到<strong>请求超时</strong>的问题。<br>经排查，是因为windows防火墙默认设置的是不让别人ping通，通过修改防火墙相关设置解决了该问题。<br><strong>步骤：控制面板 →  系统和安全 → Windows防火墙 → 高级设置 → 入站规则 → 文件和打印机共享（回显请求 - ICMPv4-In）设置为启用</strong></li><li>主机A使用<code>arp -a</code>查看ARP缓存表，发生新增一条数据<div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/12/636f6169b6f50.png><img src=https://bu.dusays.com/2022/11/12/636f6169b6f50.png alt=3></a></div></li><li>以管理员身份运行<code>cmd</code>，执行<code>arp -d *</code>，删除缓存信息<div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/12/636f62661400d.png><img src=https://bu.dusays.com/2022/11/12/636f62661400d.png alt=4></a></div></li></ol><h4 id=抓包分析arp协议>抓包分析ARP协议<a hidden class=anchor aria-hidden=true href=#抓包分析arp协议>#</a></h4><h5 id=当arp缓存对应数据为空时>当ARP缓存对应数据为空时<a hidden class=anchor aria-hidden=true href=#当arp缓存对应数据为空时>#</a></h5><h6 id=实验步骤>实验步骤<a hidden class=anchor aria-hidden=true href=#实验步骤>#</a></h6><ol><li>主机A执行<code>arp -d *</code>，删除缓存信息</li><li>主机A运行Wireshark，设置显示过滤器表达式为<code>arp.dst.proto_ipv4 == 192.168.31.186 and arp.src.proto_ipv4 == 192.168.31.248 or icmp</code></li><li>主机A<code>ping</code>主机B的<code>ip地址</code></li></ol><h6 id=结果分析>结果分析<a hidden class=anchor aria-hidden=true href=#结果分析>#</a></h6><ol><li>主机A将自己的<code>ip地址 192.168.31.248</code> & <code>MAC地址 c0:3c:59:5e:37:47</code>写入请求分组，并将<code>目的ip地址</code>设置为<code>192.168.31.186</code>，<code>目的MAC地址</code>设置为<code>00:00:00:00:00:00</code>，对本局域网内的所有主机进行广播</li></ol><center><img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=https://bu.dusays.com/2022/11/12/636f8f33f1a20.png><br><div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px">主机A发出的ARP请求分组</div></center><ol start=2><li>主机B收下这个ARP请求分组，将主机A的MAC映射写入自己的ARP高速缓存，并向主机A发送ARP响应分组，同时在这个ARP响应分组中写入自己的MAC地址，即<code>28:7f:cf:12:af:89</code></li><li>主机A收到主机B的ARP响应分组后，就在其ARP高速缓存中写入主机B的IP地址到MAC地址的映射</li></ol><center><img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=https://bu.dusays.com/2022/11/12/636f8e7d3f758.png><br><div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px">主机A收到的来自主机B的ARP响应分组</div></center><center><img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=https://bu.dusays.com/2022/11/12/636f8ea2d8434.png><br><div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px">主机A的ARP高速缓存表</div></center><h5 id=当arp缓存对应数据不为空时>当ARP缓存对应数据不为空时<a hidden class=anchor aria-hidden=true href=#当arp缓存对应数据不为空时>#</a></h5><h6 id=实验步骤-1>实验步骤<a hidden class=anchor aria-hidden=true href=#实验步骤-1>#</a></h6><ol><li>主机A运行Wireshark，设置显示过滤器表达式为<code>arp.dst.proto_ipv4 == 192.168.31.186 and arp.src.proto_ipv4 == 192.168.31.248 or icmp</code></li><li>主机A <code>ping</code>主机B的<code>ip地址</code></li></ol><h6 id=结果分析-1>结果分析<a hidden class=anchor aria-hidden=true href=#结果分析-1>#</a></h6><p>主机A没有发出<code>ARP</code>请求，而主机B接受到了主机A的ICMP报文，说明主机A直接使用了高速缓存区内的对应数据，而没有发出广播</p><center><img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=https://bu.dusays.com/2022/11/12/636f910b7f31d.png><br><div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px">主机A发出的报文</div></center><h2 id=利用实验结果分析icmp协议的报文结构字段定义>利用实验结果分析ICMP协议的报文结构字段定义<a hidden class=anchor aria-hidden=true href=#利用实验结果分析icmp协议的报文结构字段定义>#</a></h2><blockquote><p><strong>ICMP即互联网控制报文协议（Internet Control Message Protocol），网络设备（包括路由器）使用它来发送错误消息和指示与另一个IP 地址通信时成功或失败的操作信息</strong></p></blockquote><center><img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=https://bu.dusays.com/2022/11/12/636fbbc74f13c.png><br><div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px">ICMP报文结构</div></center><h3 id=icmp报文格式>ICMP报文格式<a hidden class=anchor aria-hidden=true href=#icmp报文格式>#</a></h3><pre tabindex=0><code>+0------7-------15---------------31
|  Type | Code  |    Checksum    |
+--------------------------------+
|          Message Body          |
|        (Variable length)       |
+--------------------------------+
</code></pre><h3 id=icmp报文格式解释>ICMP报文格式解释<a hidden class=anchor aria-hidden=true href=#icmp报文格式解释>#</a></h3><ol><li><u>Type</u>：占一个字节，标识ICMP报文的类型，可以分为差错报告报文和询问报文两大类</li><li><u>Code</u>：占一个字节，用于进一步区分某种类型中的不同情况</li><li><u>Checksum</u>：占两个字节，检验报文在传输过程中是否出现差错</li></ol><h3 id=icmp应用举例>ICMP应用举例<a hidden class=anchor aria-hidden=true href=#icmp应用举例>#</a></h3><h4 id=ping命令>Ping命令<a hidden class=anchor aria-hidden=true href=#ping命令>#</a></h4><blockquote><p><strong>「ping」是用来探测本机与网络中另一主机之间是否可达的命令</strong></p></blockquote><p>在此次实验中，使用主机A在<code>cmd</code>环境下<code>ping baidu.com</code>，分析回送请求报文和回送回答报文</p><h5 id=回送请求报文>回送请求报文<a hidden class=anchor aria-hidden=true href=#回送请求报文>#</a></h5><p><div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/13/63702d8239c61.png><img src=https://bu.dusays.com/2022/11/13/63702d8239c61.png alt=1></a></div></p><pre tabindex=0><code>Internet Control Message Protocol
    Type: 8 (Echo (ping) request)
    Code: 0
    Checksum: 0x4ae9 [correct]
    [Checksum Status: Good]
    Identifier (BE): 1 (0x0001)
    Identifier (LE): 256 (0x0100)
    Sequence Number (BE): 626 (0x0272)
    Sequence Number (LE): 29186 (0x7202)
    [Response frame: 215]
    Data (32 bytes)
        Data: 6162636465666768696a6b6c6d6e6f7071727374757677616263646566676869
        [Length: 32]
</code></pre><ol><li>Type的值为 <strong>8</strong>，Code的值为 <strong>0</strong>，表示回显请求</li><li>Checksum的值为 <strong>0x4ae9</strong>，这里校验和验证正确</li><li><u>Identifier</u>：识别码，用于区分不同进程的应用。由于Window系统与Linux系统发出的ping报文的字节序不一样，所以需要 <strong>BE</strong> 和 <strong>LE</strong> 两个值，而这两个值所表示的十六进制值（HEX）是相同的。这里的 <strong>BE</strong> 指的是大端字节序，在Linux中使用；<strong>LE</strong>指的是小端字节序，在Windows中使用</li><li><u>Sequence Number</u>：序列号，用于对应请求与响应。这里对于 <strong>BE</strong> 和 <strong>LE</strong> 解释同上。</li></ol><h5 id=回送回答报文>回送回答报文<a hidden class=anchor aria-hidden=true href=#回送回答报文>#</a></h5><p><div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/13/63702d83032ff.png><img src=https://bu.dusays.com/2022/11/13/63702d83032ff.png alt=2></a></div></p><pre tabindex=0><code>Internet Control Message Protocol
    Type: 0 (Echo (ping) reply)
    Code: 0
    Checksum: 0x52e9 [correct]
    [Checksum Status: Good]
    Identifier (BE): 1 (0x0001)
    Identifier (LE): 256 (0x0100)
    Sequence Number (BE): 626 (0x0272)
    Sequence Number (LE): 29186 (0x7202)
    [Request frame: 213]
    [Response time: 20.855 ms]
    Data (32 bytes)
        Data: 6162636465666768696a6b6c6d6e6f7071727374757677616263646566676869
        [Length: 32]
</code></pre><ol><li>Type的值为 <strong>0</strong>，Code的值为 <strong>0</strong>，表示回送回答</li><li>Checksum的值为 <strong>0x52e9</strong>，这里校验和验证正确</li><li><u>Identifier</u>：识别码，用于区分不同进程的应用</li><li><u>Sequence Number</u>：序列号，用于对应请求与响应。这里的值 <strong>626</strong> 同上文 <strong>回送请求报文</strong> <code>Sequence Number</code> 的值，说明这俩请求和响应是对应的</li></ol><h4 id=tracert命令>Tracert命令<a hidden class=anchor aria-hidden=true href=#tracert命令>#</a></h4><blockquote><p><strong>「Tracert」是用来显示可能的路由（路径）和测量数据包在 IP 网络中的传输延迟的命令</strong></p></blockquote><p>在此次实验中，使用主机A在<code>cmd</code>环境下<code>tracert baidu.com</code>，分析报文</p><p><div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/13/63703bc9a2bf1.png><img src=https://bu.dusays.com/2022/11/13/63703bc9a2bf1.png alt=1></a></div></p><h5 id=差错报告报文>差错报告报文<a hidden class=anchor aria-hidden=true href=#差错报告报文>#</a></h5><p>ICMP的差错报告报文中，会把收到的需要进行差错报告的IP的数据提取出来作为ICMP报文的数据部分</p><p><div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/13/63703c4b4a1e1.png><img src=https://bu.dusays.com/2022/11/13/63703c4b4a1e1.png alt=2></a></div></p><pre tabindex=0><code>Internet Protocol Version 4, Src: 192.168.31.248, Dst: 110.242.68.66
    0100 .... = Version: 4
    .... 0101 = Header Length: 20 bytes (5)
    Differentiated Services Field: 0x00 (DSCP: CS0, ECN: Not-ECT)
        0000 00.. = Differentiated Services Codepoint: Default (0)
        .... ..00 = Explicit Congestion Notification: Not ECN-Capable Transport (0)
    Total Length: 92
    Identification: 0x1f2e (7982)
    000. .... = Flags: 0x0
        0... .... = Reserved bit: Not set
        .0.. .... = Don&#39;t fragment: Not set
        ..0. .... = More fragments: Not set
    ...0 0000 0000 0000 = Fragment Offset: 0
    Time to Live: 1
        [Expert Info (Note/Sequence): &#34;Time To Live&#34; only 1]
            [&#34;Time To Live&#34; only 1]
            [Severity level: Note]
            [Group: Sequence]
    Protocol: ICMP (1)
    Header Checksum: 0x0000 [validation disabled]
    [Header checksum status: Unverified]
    Source Address: 192.168.31.248
    Destination Address: 110.242.68.66

Internet Control Message Protocol
    Type: 8 (Echo (ping) request)
    Code: 0
    Checksum: 0xf4e4 [correct]
    [Checksum Status: Good]
    Identifier (BE): 1 (0x0001)
    Identifier (LE): 256 (0x0100)
    Sequence Number (BE): 794 (0x031a)
    Sequence Number (LE): 6659 (0x1a03)
    [No response seen]
        [Expert Info (Warning/Sequence): No response seen to ICMP request]
            [No response seen to ICMP request]
            [Severity level: Warning]
            [Group: Sequence]
    Data (64 bytes)
        Data: 000000000000000000000000000000000000000000000000000000000000000000000000…
        [Length: 64]
</code></pre><p><div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/13/63703c4c1fe7e.png><img src=https://bu.dusays.com/2022/11/13/63703c4c1fe7e.png alt=3></a></div></p><pre tabindex=0><code>Internet Control Message Protocol
    Type: 11 (Time-to-live exceeded)
    Code: 0 (Time to live exceeded in transit)
    Checksum: 0xf4ff [correct]
    [Checksum Status: Good]
    Unused: 00000000
    Internet Protocol Version 4, Src: 192.168.31.248, Dst: 110.242.68.66
        0100 .... = Version: 4
        .... 0101 = Header Length: 20 bytes (5)
        Differentiated Services Field: 0x00 (DSCP: CS0, ECN: Not-ECT)
            0000 00.. = Differentiated Services Codepoint: Default (0)
            .... ..00 = Explicit Congestion Notification: Not ECN-Capable Transport (0)
        Total Length: 92
        Identification: 0x1f2e (7982)
        000. .... = Flags: 0x0
            0... .... = Reserved bit: Not set
            .0.. .... = Don&#39;t fragment: Not set
            ..0. .... = More fragments: Not set
        ...0 0000 0000 0000 = Fragment Offset: 0
        Time to Live: 1
            [Expert Info (Note/Sequence): &#34;Time To Live&#34; only 1]
                [&#34;Time To Live&#34; only 1]
                [Severity level: Note]
                [Group: Sequence]
        Protocol: ICMP (1)
        Header Checksum: 0x069f [validation disabled]
        [Header checksum status: Unverified]
        Source Address: 192.168.31.248
        Destination Address: 110.242.68.66
    Internet Control Message Protocol
        Type: 8 (Echo (ping) request)
        Code: 0
        Checksum: 0xf4e4 [unverified] [in ICMP error packet]
        [Checksum Status: Unverified]
        Identifier (BE): 1 (0x0001)
        Identifier (LE): 256 (0x0100)
        Sequence Number (BE): 794 (0x031a)
        Sequence Number (LE): 6659 (0x1a03)
        Data (64 bytes)
            Data: 000000000000000000000000000000000000000000000000000000000000000000000000…
            [Length: 64]
</code></pre><ol><li>Type的值为 <strong>11</strong>，Code的值为 <strong>0</strong>，表示超时报错</li><li>图1的<strong>回送请求报文</strong>出错，图2相对应的<strong>差错报告报文</strong>，把图1报文的IP数据报的首部和数据字段的前8个字节提取出来，作为ICMP报文的数据字段</li></ol><h2 id=基于实验数据深入分析tcp协议功能>基于实验数据深入分析TCP协议功能<a hidden class=anchor aria-hidden=true href=#基于实验数据深入分析tcp协议功能>#</a></h2><blockquote><p><strong>TCP即传输控制协议（Transmission Control Protocol），是面向连接的运输层协议</strong></p></blockquote><h3 id=tcp报文格式>TCP报文格式<a hidden class=anchor aria-hidden=true href=#tcp报文格式>#</a></h3><p><div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/13/63704be4d65f3.png><img src=https://bu.dusays.com/2022/11/13/63704be4d65f3.png alt=1></a></div></p><h3 id=tcp报文格式解释>TCP报文格式解释<a hidden class=anchor aria-hidden=true href=#tcp报文格式解释>#</a></h3><ol><li><u>源端口</u>和<u>目的端口</u>：各占 2 字节，和 IP 头部的 <strong>源地址</strong> 和 <strong>目的地址</strong> 一起唯一地标识了每个连接</li><li><u>序列号</u>：占 4 字节，TCP连接中传送的数据流中的<strong>每一个字节都按顺序编号</strong>，序号字段的值指的是<strong>本报文段</strong>所发送的数据的第一个字节的序号</li><li><u>确认号</u>：占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号</li><li><u>数据偏移</u>：占 4 位，它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远，实际是指出TCP报文段的首部长度</li><li><u>保留</u>：占 6 位，保留为今后使用，默认置0</li><li><u>紧急 URG(URGent)</u>：当 URG = 1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)</li><li><u>确认 ACK(ACKnowledegment)</u>：只有当 ACK = 1 时确认号字段有效，当 ACK = 0 时确认号无效</li><li><u>推送 PSH(PuSH)</u>：接收 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程，不再等到整个缓存都填满了后再向上交付</li><li><u>复位 RST(ReSeT)</u>：当 RST = 1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因）必须释放连接，然后再重新建立运输连接。RST置1还用来拒绝一个非法报文或拒绝打开一个连接</li><li><u>同步 SYN(SYNchronization)</u>：在连接建立时用来同步序号。当 SYN = 1 而 ACK = 0 时，表明这是一个连接请求报文段。对方若同意建立连接，则在响应的报文段中使 SYN = 1 和 ACK = 1</li><li><u>终止 FIN(FINish)</u>：用来释放一个连接。FIN = 1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。</li><li><u>窗口</u>：占 2 字节，指的是发送本报文段的一方的<strong>接收窗口</strong>。用于流量控制，指示接收方愿意接收的字节数量</li><li><u>检验和</u>：占 2 字节，检验和字段检验的范围包括TCP首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部</li><li><u>选项</u>：长度可变，最长可达 40 字节。如 <strong>最长报文段长度MSS</strong>、<strong>窗口扩大</strong>选项、<strong>时间戳</strong>选项等等</li><li><u>填充字段</u>：仅仅是为了使整个TCP首部长度为 4 字节的整数倍</li></ol><h3 id=实验步骤-2>实验步骤<a hidden class=anchor aria-hidden=true href=#实验步骤-2>#</a></h3><ol><li>下载 <a href=https://files.cnblogs.com/files/ggll611928/TCP-UDP-Socket%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7-v2.2.rar>TCP/UDP Socket 调试工具</a><div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/13/6370874b20e3e.png><img src=https://bu.dusays.com/2022/11/13/6370874b20e3e.png alt=1></a></div></li><li>在<code>cmd</code>中<code>ping zhihu.com</code>，得到<code>ip地址</code>为<code>103.41.167.234</code><div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/13/637087b2b3a4b.png><img src=https://bu.dusays.com/2022/11/13/637087b2b3a4b.png alt=2></a></div></li><li>使用TCP调试工具，创建一个连接<div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/13/6370887550c8b.png><img src=https://bu.dusays.com/2022/11/13/6370887550c8b.png alt=3></a></div></li><li>打开Wireshark，设置显示过滤器为 <code>ip.addr == 103.41.167.234</code><div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/13/637088cda466f.png><img src=https://bu.dusays.com/2022/11/13/637088cda466f.png alt=4></a></div></li><li>在TCP调试工具中，点击 <strong>连接</strong><div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/13/63708928070a7.png><img src=https://bu.dusays.com/2022/11/13/63708928070a7.png alt=5></a></div></li><li>在TCP调试工具中，发送数据 <code>Hello World!!!</code>后，连接自动断开<div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/13/63708c752ff6b.png><img src=https://bu.dusays.com/2022/11/13/63708c752ff6b.png alt=6></a></div></li><li>在Wireshark中捕获到以下数据包<div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/13/63708cca0d6f9.png><img src=https://bu.dusays.com/2022/11/13/63708cca0d6f9.png alt=7></a></div></li></ol><h3 id=三次握手>三次握手<a hidden class=anchor aria-hidden=true href=#三次握手>#</a></h3><blockquote><p><strong>三次握手目的是保证双方都有发送和接收的能力</strong></p></blockquote><p><div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/13/637052e140268.png><img src=https://bu.dusays.com/2022/11/13/637052e140268.png alt=1></a></div></p><ul><li>一开始，客户端和服务端都处于 <code>CLOSE</code> 状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态</li><li>客户端随机初始化 <strong>序列号 seq</strong> 为 <strong>x</strong>，同时把 <strong>SYN</strong> 置1，接着把报文发送给服务端。之后，TCP客户端进入 <code>SYN-SENT</code> 状态<div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/13/637090318e9b1.png><img src=https://bu.dusays.com/2022/11/13/637090318e9b1.png alt=1></a></div></li><li>服务器收到连接请求报文段后，若同意连接，将进行下述操作。首先，随机初始化自己的 <strong>序列号 seq</strong> 为 <strong>y</strong>，其次把 <strong>确认号 ack</strong> 置为 <strong>x + 1</strong>，接着 <strong>SYN</strong> 和 <strong>ACK</strong> 均置为1，最后把该报文发给客户端。这时，服务端进入<code>SYN-RCVD</code> 状态<div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/13/6370903f2af73.png><img src=https://bu.dusays.com/2022/11/13/6370903f2af73.png alt=2></a></div></li><li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文。首先将应答报文的 <strong>ACK</strong> 置为1，<strong>确认号 ack</strong> 置为 <strong>y + 1</strong>，<strong>序列号 seq</strong> 置为 <strong>x + 1</strong>，最后把报文发送给服务端。之后，客户端处于<code>ESTABLISHED</code> 状态，因为它一收一发了<div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/13/63709042a0303.png><img src=https://bu.dusays.com/2022/11/13/63709042a0303.png alt=3></a></div></li><li>服务端收到客户端的应答报文后，也进入 <code>ESTABLISHED</code> 状态，因为它也一收一发了</li></ul><h3 id=四次挥手>四次挥手<a hidden class=anchor aria-hidden=true href=#四次挥手>#</a></h3><p><div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/13/637055a33c4fe.png><img src=https://bu.dusays.com/2022/11/13/637055a33c4fe.png alt=1></a></div></p><ul><li>客户端打算关闭连接，此时会发送一个 TCP 首部 <code>FIN</code> 标志位被置为 <code>1</code> 的报文并指明自己当前的 <strong>序列号 seq</strong> 为 <strong>u</strong>，之后客户端进入 <code>FIN_WAIT_1</code> 状态<div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/13/637095cced990.png><img src=https://bu.dusays.com/2022/11/13/637095cced990.png alt=1></a></div></li><li>服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，指明自己当前的 <strong>序列号 seq</strong> 为 <strong>v</strong>， <strong>确认号 ack</strong> 为 <strong>u + 1</strong>，接着服务端进入 <code>CLOSE_WAIT</code> 状态<div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/13/637095cf921e9.png><img src=https://bu.dusays.com/2022/11/13/637095cf921e9.png alt=2></a></div></li><li>客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入 <code>FIN_WAIT_2</code> 状态</li><li>等待服务端处理完数据后，也向客户端发送 <code>FIN</code> 报文，报文的 <code>ACK</code> 置为 <code>1</code>，<strong>序列号 seq</strong> 为 <strong>w</strong>， <strong>确认号 ack</strong> 为 <strong>u + 1</strong>，之后服务端进入 <code>LAST_ACK</code> 状态<div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/13/637095d1574be.png><img src=https://bu.dusays.com/2022/11/13/637095d1574be.png alt=3></a></div></li><li>客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，其中 <strong>序列号 seq</strong> 为 <strong>u + 1</strong>， <strong>确认号 ack</strong> 为 <strong>w + 1</strong>，之后进入 <code>TIME_WAIT</code> 状态<div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/13/637095d2df5ff.png><img src=https://bu.dusays.com/2022/11/13/637095d2df5ff.png alt=4></a></div></li><li>服务端收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSE</code> 状态，至此服务端已经完成连接的关闭</li><li>客户端在经过 <code>2MSL</code> 一段时间后，自动进入 <code>CLOSE</code> 状态，至此客户端也完成连接的关闭</li></ul><h2 id=访问外网某服务器分析从mac层协议ip协议tcp协议一直到http协议的过程>访问外网某服务器，分析从MAC层协议、IP协议、TCP协议一直到HTTP协议的过程<a hidden class=anchor aria-hidden=true href=#访问外网某服务器分析从mac层协议ip协议tcp协议一直到http协议的过程>#</a></h2><h3 id=网络包的旅途>网络包的旅途<a hidden class=anchor aria-hidden=true href=#网络包的旅途>#</a></h3><ol><li>用户输入网址</li><li>浏览器解析网址，生成 HTTP 消息</li><li>在发送 HTTP 消息给 Web 服务器之前，浏览器先向 DNS 服务器发送请求，查询与服务器域名相对应的 IP 地址</li><li>通过 DNS 获取到 IP 后，浏览器把 HTTP 消息转交给 Socket 库</li><li>Socket 库将收到的 HTTP 消息作为数据转交给协议栈</li><li>TCP 按照网络包的长度对数据进行拆分，在每个包前面加上 TCP 头部并转交给 IP</li><li>IP 在 TCP 包前面加上 IP 头部（目的 IP 为 Web 服务器 IP 地址，源 IP 为主机 IP 地址），IP 包生成后参考路由控制表决定接受此 IP 包的路由或主机的 IP 地址。随后，IP 包将被发送给连接这些路由器或主机网络接口的驱动程序</li><li>如果尚不知道下一跳接收端的 MAC 地址，可以利用 ARP 查找，加上 MAC 头部，然后将包转交给网卡驱动</li><li>网卡驱动收到 IP 模块发来的包，将其转交给网卡并发出发送指令</li><li>网卡检查以太网的可发送状态，将数字信息转换为电信号发送出去</li><li>服务端的局域网中有防火墙，对进入的包进行检查，判断是否允许通过</li><li>Web 服务器前面有如果有缓存服务器，会拦截通过防火墙的包如果用户请求的页面已经缓存在服务器上，则代替服务器向用户返回页面数据</li><li>如果请求的页面没有被缓存，缓存服务器会将请求转发给 Web 服务器</li><li>Web 服务器收到包后，网卡和网卡驱动会接收这个包并转交给协议栈</li><li>协议栈依次检查 IP 头部和 TCP 头部，如果没有问题则取出 HTTP 的数据块并进行组装</li><li>HTTP 消息恢复成原始状态，然后通过 Socket 库转交给 Web 服务器</li><li>Web 服务器分析 HTTP 消息的内容，并根据请求内容将读取的数据返回给客户端</li><li>浏览器接收到响应包后，进行页面的渲染</li><li>HTTP请求结束，TCP连接断开<div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/15/6372e99613b66.jpg><img src=https://bu.dusays.com/2022/11/15/6372e99613b66.jpg alt=1></a></div></li></ol><h3 id=dns>DNS<a hidden class=anchor aria-hidden=true href=#dns>#</a></h3><h4 id=dns报文结构>DNS报文结构<a hidden class=anchor aria-hidden=true href=#dns报文结构>#</a></h4><p><div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/13/6370b7a2baa6b.png><img src=https://bu.dusays.com/2022/11/13/6370b7a2baa6b.png alt=1></a></div></p><h4 id=dns查询步骤>DNS查询步骤<a hidden class=anchor aria-hidden=true href=#dns查询步骤>#</a></h4><p>浏览器在解析域名时，会经过下列步骤：</p><ol><li>浏览器会先看自身有没有对这个域名的缓存，如果有，就直接返回；如果没有，就去问操作系统</li><li>操作系统也会去看自己的缓存，如果有，就直接返回；如果没有，再去 Hosts 文件看</li><li>本地的 Hosts 文件，若有域名和 IP 地址的对应关系，直接使用该 IP 地址通信；如果没有，浏览器向本地域名服务器发出一个查询请求</li><li>本地域名服务器查看有无缓存记录。若有，直接响应；若没有，本地域名服务器向根域名服务器查询</li><li>根域名服务器响应本地域名服务器，给出对应域名的顶级域名服务器IP地址，让本地域名服务器去向其查询</li><li>顶级域名服务器响应本地域名服务器，给出对应域名的权威域名服务器（权威 DNS 服务器，它是域名解析结果的原出处）IP地址，让本地域名服务器去向其查询</li><li>权威 DNS 服务器查询后将对应的 IP 地址告诉本地 DNS 服务器</li><li>本地 DNS 将 IP 地址返回给客户端，客户端和目标建立连接</li></ol><h3 id=实验步骤-3>实验步骤<a hidden class=anchor aria-hidden=true href=#实验步骤-3>#</a></h3><ol><li>访问<code>http://www.smartclass.cn/Default.aspx</code></li><li>分析 <code>HTTP</code> 请求报文及 <code>HTTP</code> 响应报文</li></ol><h3 id=报文分析>报文分析<a hidden class=anchor aria-hidden=true href=#报文分析>#</a></h3><p><div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/13/6370f2e0d407f.png><img src=https://bu.dusays.com/2022/11/13/6370f2e0d407f.png alt=1></a></div></p><h4 id=http报文结构>HTTP报文结构<a hidden class=anchor aria-hidden=true href=#http报文结构>#</a></h4><p><div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/13/6370f173089a1.png><img src=https://bu.dusays.com/2022/11/13/6370f173089a1.png alt=1></a></div></p><h4 id=http请求报文>HTTP请求报文<a hidden class=anchor aria-hidden=true href=#http请求报文>#</a></h4><h5 id=数据链路层-1>数据链路层<a hidden class=anchor aria-hidden=true href=#数据链路层-1>#</a></h5><p><div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/13/6370f44ce10f8.png><img src=https://bu.dusays.com/2022/11/13/6370f44ce10f8.png alt=1></a></div></p><h5 id=网络层-1>网络层<a hidden class=anchor aria-hidden=true href=#网络层-1>#</a></h5><p><div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/13/6370f585c0330.png><img src=https://bu.dusays.com/2022/11/13/6370f585c0330.png alt=2></a></div></p><h5 id=传输层-1>传输层<a hidden class=anchor aria-hidden=true href=#传输层-1>#</a></h5><p><div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/13/6370f5871b2b2.png><img src=https://bu.dusays.com/2022/11/13/6370f5871b2b2.png alt=3></a></div></p><h5 id=应用层-1>应用层<a hidden class=anchor aria-hidden=true href=#应用层-1>#</a></h5><p><div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/13/6370f670b78f0.png><img src=https://bu.dusays.com/2022/11/13/6370f670b78f0.png alt=4></a></div></p><pre tabindex=0><code>Hypertext Transfer Protocol
    GET /Default.aspx HTTP/1.1\r\n
    Host: www.smartclass.cn\r\n
    User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36 Edg/107.0.1418.42\r\n
    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\r\n
    Accept-Encoding: gzip, deflate\r\n
    Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6\r\n
    Upgrade-Insecure-Requests: 1\r\n
    \r\n
    [Full request URI: http://www.smartclass.cn/Default.aspx]
    [HTTP request 1/14]
    [Response in frame: 1787]
    [Next request in frame: 1804]
</code></pre><ol><li><u>请求行</u>：由 <code>请求方法字段</code>、<code>URL字段</code> 和 <code>HTTP协议版本字段</code> 组成，如 <strong>GET /Default.aspx HTTP/1.1</strong></li><li><u>请求头部</u>：关键字/值对组成，每行一对<ol><li><u>Host</u>：请求的主机名</li><li><u>User-Agent</u>：发出请求的浏览器类型</li><li><u>Accept</u>：客户端可识别的内容类型列表</li></ol></li><li><u>空行</u>：最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头</li><li><u>请求数据</u></li></ol><h4 id=http响应报文>HTTP响应报文<a hidden class=anchor aria-hidden=true href=#http响应报文>#</a></h4><h5 id=传输层-2>传输层<a hidden class=anchor aria-hidden=true href=#传输层-2>#</a></h5><ul><li>TCP 协议会分段传输过大的数据段（Segment）保证传输的性能</li><li>TCP 协议引入了最大分段大小（Maximum segment size，MSS）这一概念，它是 TCP 数据段能够携带的数据上限。在正常情况下，TCP 连接的 MSS 是 MTU - 40 字节，即 1460 字节<ul><li>MSS：一个网络包的最大长度，以太网中一般为 <code>1500</code> 字节</li><li>MTU：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度</li></ul></li><li>该报文 MSS 值为 1360，数据段分成 8 份从服务端发出，并在客户端经过拼接后被接收<div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/13/6370fb4c09aa8.png><img src=https://bu.dusays.com/2022/11/13/6370fb4c09aa8.png alt=1></a></div></li></ul><h5 id=应用层-2>应用层<a hidden class=anchor aria-hidden=true href=#应用层-2>#</a></h5><p><div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/13/6370fdbf7eb46.png><img src=https://bu.dusays.com/2022/11/13/6370fdbf7eb46.png alt=1></a></div></p><pre tabindex=0><code>Hypertext Transfer Protocol
    HTTP/1.1 200 OK\r\n
        [Expert Info (Chat/Sequence): HTTP/1.1 200 OK\r\n]
            [HTTP/1.1 200 OK\r\n]
            [Severity level: Chat]
            [Group: Sequence]
        Response Version: HTTP/1.1
        Status Code: 200
        [Status Code Description: OK]
        Response Phrase: OK
    Date: Sun, 13 Nov 2022 13:06:05 GMT\r\n
    Content-Type: text/html; charset=utf-8\r\n
    Content-Length: 9696\r\n
        [Content length: 9696]
    Connection: keep-alive\r\n
    Cache-Control: private\r\n
    Content-Encoding: gzip\r\n
    Vary: Accept-Encoding\r\n
    MANUFACTURER: Hanboer\r\n
    X-AspNet-Version: 4.0.30319\r\n
    X-UA-Compatible: IE=edge,chrome=1\r\n
    Access-Control-Allow-Headers: content-type\r\n
    Access-Control-Allow-Methods: GET,POST,PUT,DELETE,OPTIONS\r\n
    Access-Control-Allow-Origin: http://localhost:9527\r\n
    Access-Control-Allow-Credentials: true\r\n
    \r\n
    [HTTP response 1/14]
    [Time since request: 0.067102000 seconds]
    [Request in frame: 1776]
    [Next request in frame: 1804]
    [Next response in frame: 1806]
    [Request URI: http://www.smartclass.cn/Webapi/V1/Live/GetPublicLives?csrkToken=0aat6ee1aaks3&amp;IsLiving=true&amp;Sort=StartTime&amp;Order=0&amp;PageSize=8&amp;PageNumber=1&amp;attribute=]
    Content-encoded entity body (gzip): 9696 bytes -&gt; 40818 bytes
    File Data: 40818 bytes
</code></pre><ol><li><u>状态行</u>：由 <code>HTTP版本</code> 、<code>状态码</code> 和<code>原因短语</code> 组成，如 <strong>HTTP/1.1 200 OK</strong></li><li><u>响应头部</u>：关键字/值对组成，每行一对</li><li><u>空行</u>：最后一个响应头之后是一个空行，发送回车符和换行符，通知服务器以下不再有响应头</li><li><u>响应正文</u></li></ol><h2 id=参考>参考<a hidden class=anchor aria-hidden=true href=#参考>#</a></h2><ol><li><a href=https://blog.51cto.com/yttitan/1734425>Wireshark系列之4 捕获过滤器</a></li><li><a href="https://blog.51cto.com/u_13579643/3647795?articleABtest=0">网络——Wireshark工具</a></li><li><a href=https://juejin.cn/post/6844904066229747720>WireShark的基本用法</a></li><li><a href=https://www.cnblogs.com/lsdb/p/9254544.html>Wireshark使用教程（界面说明、捕获过滤器表达式、显示过滤器表达式）</a></li><li><a href=https://www.freebuf.com/sectool/256745.html>一文精讲Wireshark的抓包和分析</a></li><li><a href=https://bbs.huaweicloud.com/blogs/285673>Wireshark简明教程，新手专用，挑实在的讲，不搞花里胡哨</a></li><li><a href=https://blog.51cto.com/u_15688254/5694733>WireShark网络封包抓包工具各个界面介绍</a></li><li><a href=https://codeantenna.com/a/2zI6hbfTIM>实验3.利用Wireshark分析ARP协议</a></li><li><a href=https://zhuanlan.zhihu.com/p/364195316>如何计算IP或ICMP协议首部里的checksum字段</a></li><li><a href=https://blog.51cto.com/ccieh3c/2654283>带你深入熟悉你所不知道的ICMP</a></li><li><a href=https://zhaoqqi.github.io/2016/10/05/network-wireshark-arp/>使用Wireshark学习网络协议之ICMP</a></li><li><a href=https://www.cnblogs.com/xiaolincoding/p/12922927.html>实战！我用 Wireshark 让你“看见“ TCP</a></li><li><a href=https://xiaolincoding.com/network/3_tcp/tcp_interview.html>4.1 TCP 三次握手与四次挥手面试题</a></li><li><a href=https://blog.51cto.com/u_15103025/2643297>Wireshark抓包TCP三次握手</a></li><li><a href=https://rgb-24bit.github.io/blog/2019/tcp-connect-manage.html>TCP 中的三次握手和四次挥手</a></li><li><a href=https://blog.csdn.net/u014117943/article/details/118520498>Wireshark配合TCP调试工具理解TCP三次握手和四次挥手过程</a></li><li><a href=https://juejin.cn/post/7034547558664011783>老生常谈的TCP三次握手和四次挥手，你会了吗？</a></li><li><a href=https://www.cnblogs.com/biyeymyhjob/archive/2012/07/28/2612910.html>HTTP请求报文和HTTP响应报文</a></li><li><a href=https://draveness.me/whys-the-design-tcp-segment-ip-packet/>为什么 TCP/IP 协议会拆分数据</a></li><li><a href=https://www.pianshen.com/article/86011166321/>HTTP的曲折：网络请求到层层封装和终端拆分</a></li><li><a href=https://segmentfault.com/a/1190000019788537>浅谈http协议（三）：HTTP 报文及其结构</a></li><li><a href=https://www.wireshark.org/docs/wsug_html_chunked/ChapterWork.html>Wireshark官方文档</a></li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://xancoding.cn/tags/tech/>Tech</a></li><li><a href=https://xancoding.cn/tags/wireshark/>Wireshark</a></li><li><a href=https://xancoding.cn/tags/%E5%B7%A5%E5%85%B7/>工具</a></li><li><a href=https://xancoding.cn/tags/%E6%96%B0%E6%8A%80%E8%83%BD/>新技能</a></li><li><a href=https://xancoding.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/>计算机网络</a></li></ul><nav class=paginav><a class=prev href=https://xancoding.cn/posts/self-study/><span class=title>« Prev</span><br><span>一些关于自学的感悟</span></a>
<a class=next href=https://xancoding.cn/posts/vimium/><span class=title>Next »</span><br><span>Vimium学习记</span></a></nav></footer><div><div class=pagination__title><span class=pagination__title-h style=font-size:20px>💬评论</span><hr></div><div id=tcomment></div><script src=https://cdn.staticfile.org/twikoo/1.6.7/twikoo.all.min.js></script>
<script>twikoo.init({envId:"https://twikoo.xancoding.cn/",el:"#tcomment",lang:"zh-CN",region:"ap-beijing",path:window.TWIKOO_MAGIC_PATH||window.location.pathname})</script></div></article></main><footer class=footer><span>&copy; 2022 <a href=https://xancoding.cn>Xan's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>