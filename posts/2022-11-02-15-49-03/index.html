<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>AcWing Web 应用课 | Xan's Blog</title><meta name=keywords content="Tech,AcWing,Web,新技能"><meta name=description content='
AcWing Web 应用课 | Colopen&rsquo;s blog
AcWing Web 应用课

HTML 基础标签
CSS
JavaScript
React
Vue3


MDN官方文档

Web 入门
HTML —— 构建 Web
CSS —— 设计Web
JavaScript —— 用户端动态脚本
React 入门
Vue 入门
Canvas 教程





怪异英文生成器 生成比较好看的英文字体，支持复制粘贴
Color Hunt 设计师和艺术家的调色板
Game-icons 游戏图标在线存储库



VSCode 自动生成缺省的 HTML 代码框架

<!DOCTYPE html>

<html lang="en">

<head>

  <meta charset="UTF-8">

  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Document</title>

</head>

<body>

</body>

</html>

输入！，接着输入 tab 键，自动生成缺省的 HTML 代码框架
再按三下 tab 键，光标会移动到 <body> 与 </body> 之间的空行


KOF

KOF
AcWing Web 应用课 | 中期项目——拳皇（上） | Vedio
AcWing Web 应用课 | 中期项目——拳皇（下） | Vedio


基础操作
操作如下：
角色一: w 跳 a 左移 d 右移 j 拳击 
角色二: ↑ 跳 ← 左移 → 右移 1 拳击
文件结构
|-- README.md
|-- static
|   |-- css
|   |   `-- base.css
|   |-- images
|   |   |-- background
|   |   |   `-- 0.gif
|   |   `-- player
|   |       `-- kyo
|   |           |-- 0.gif
|   |           |-- 1.gif
|   |           |-- 2.gif
|   |           |-- 3.gif
|   |           |-- 4.gif
|   |           |-- 5.gif
|   |           `-- 6.gif
|   `-- js
|       |-- ac_game_object
|       |   `-- base.js
|       |-- base.js
|       |-- controller
|       |   `-- base.js
|       |-- game_map
|       |   `-- base.js
|       |-- player
|       |   |-- base.js
|       |   `-- kyo.js
|       `-- utils
|           `-- gif.js
`-- templates
    `-- index.html
整体架构







'><meta name=author content="
作者:&nbsp;Xan"><link rel=canonical href=https://xancoding.cn/posts/2022-11-02-15-49-03/><link crossorigin=anonymous href=/assets/css/stylesheet.f6cc63240f58abf8158866addd7cf098e9520f3ceded37e115b54aab2f685e8d.css integrity="sha256-9sxjJA9Yq/gViGat3XzwmOlSDzzt7TfhFbVKqy9oXo0=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://xancoding.cn/img/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://xancoding.cn/img/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://xancoding.cn/img/favicon.ico><link rel=apple-touch-icon href=https://xancoding.cn/img/favicon.ico><link rel=mask-icon href=https://xancoding.cn/img/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://xancoding.cn/posts/2022-11-02-15-49-03/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["[[","]]"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"})</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style><html><head><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-tc-webfont@1.0.0/style.css><link rel=stylesheet href=https://cdn.staticfile.org/lxgw-wenkai-screen-webfont/1.6.0/style.css><style>body{font-family:lxgw wenkai,sans-serif;font-family:lxgw wenkai lite,sans-serif;font-family:lxgw wenkai tc,sans-serif;font-family:lxgw wenkai screen,sans-serif}</style></head><body></body></html><meta property="og:title" content="AcWing Web 应用课"><meta property="og:description" content='
AcWing Web 应用课 | Colopen&rsquo;s blog
AcWing Web 应用课

HTML 基础标签
CSS
JavaScript
React
Vue3


MDN官方文档

Web 入门
HTML —— 构建 Web
CSS —— 设计Web
JavaScript —— 用户端动态脚本
React 入门
Vue 入门
Canvas 教程





怪异英文生成器 生成比较好看的英文字体，支持复制粘贴
Color Hunt 设计师和艺术家的调色板
Game-icons 游戏图标在线存储库



VSCode 自动生成缺省的 HTML 代码框架

<!DOCTYPE html>

<html lang="en">

<head>

  <meta charset="UTF-8">

  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Document</title>

</head>

<body>

</body>

</html>

输入！，接着输入 tab 键，自动生成缺省的 HTML 代码框架
再按三下 tab 键，光标会移动到 <body> 与 </body> 之间的空行


KOF

KOF
AcWing Web 应用课 | 中期项目——拳皇（上） | Vedio
AcWing Web 应用课 | 中期项目——拳皇（下） | Vedio


基础操作
操作如下：
角色一: w 跳 a 左移 d 右移 j 拳击 
角色二: ↑ 跳 ← 左移 → 右移 1 拳击
文件结构
|-- README.md
|-- static
|   |-- css
|   |   `-- base.css
|   |-- images
|   |   |-- background
|   |   |   `-- 0.gif
|   |   `-- player
|   |       `-- kyo
|   |           |-- 0.gif
|   |           |-- 1.gif
|   |           |-- 2.gif
|   |           |-- 3.gif
|   |           |-- 4.gif
|   |           |-- 5.gif
|   |           `-- 6.gif
|   `-- js
|       |-- ac_game_object
|       |   `-- base.js
|       |-- base.js
|       |-- controller
|       |   `-- base.js
|       |-- game_map
|       |   `-- base.js
|       |-- player
|       |   |-- base.js
|       |   `-- kyo.js
|       `-- utils
|           `-- gif.js
`-- templates
    `-- index.html
整体架构







'><meta property="og:type" content="article"><meta property="og:url" content="https://xancoding.cn/posts/2022-11-02-15-49-03/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-11-02T15:49:03+08:00"><meta property="article:modified_time" content="2022-11-02T15:49:03+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="AcWing Web 应用课"><meta name=twitter:description content='
AcWing Web 应用课 | Colopen&rsquo;s blog
AcWing Web 应用课

HTML 基础标签
CSS
JavaScript
React
Vue3


MDN官方文档

Web 入门
HTML —— 构建 Web
CSS —— 设计Web
JavaScript —— 用户端动态脚本
React 入门
Vue 入门
Canvas 教程





怪异英文生成器 生成比较好看的英文字体，支持复制粘贴
Color Hunt 设计师和艺术家的调色板
Game-icons 游戏图标在线存储库



VSCode 自动生成缺省的 HTML 代码框架

<!DOCTYPE html>

<html lang="en">

<head>

  <meta charset="UTF-8">

  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Document</title>

</head>

<body>

</body>

</html>

输入！，接着输入 tab 键，自动生成缺省的 HTML 代码框架
再按三下 tab 键，光标会移动到 <body> 与 </body> 之间的空行


KOF

KOF
AcWing Web 应用课 | 中期项目——拳皇（上） | Vedio
AcWing Web 应用课 | 中期项目——拳皇（下） | Vedio


基础操作
操作如下：
角色一: w 跳 a 左移 d 右移 j 拳击 
角色二: ↑ 跳 ← 左移 → 右移 1 拳击
文件结构
|-- README.md
|-- static
|   |-- css
|   |   `-- base.css
|   |-- images
|   |   |-- background
|   |   |   `-- 0.gif
|   |   `-- player
|   |       `-- kyo
|   |           |-- 0.gif
|   |           |-- 1.gif
|   |           |-- 2.gif
|   |           |-- 3.gif
|   |           |-- 4.gif
|   |           |-- 5.gif
|   |           `-- 6.gif
|   `-- js
|       |-- ac_game_object
|       |   `-- base.js
|       |-- base.js
|       |-- controller
|       |   `-- base.js
|       |-- game_map
|       |   `-- base.js
|       |-- player
|       |   |-- base.js
|       |   `-- kyo.js
|       `-- utils
|           `-- gif.js
`-- templates
    `-- index.html
整体架构







'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://xancoding.cn/posts/"},{"@type":"ListItem","position":2,"name":"AcWing Web 应用课","item":"https://xancoding.cn/posts/2022-11-02-15-49-03/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"AcWing Web 应用课","name":"AcWing Web 应用课","description":" AcWing Web 应用课 | Colopen\u0026rsquo;s blog AcWing Web 应用课 HTML 基础标签 CSS JavaScript React Vue3 MDN官方文档 Web 入门 HTML —— 构建 Web CSS —— 设计Web JavaScript —— 用户端动态脚本 React 入门 Vue 入门 Canvas 教程 怪异英文生成器 生成比较好看的英文字体，支持复制粘贴 Color Hunt 设计师和艺术家的调色板 Game-icons 游戏图标在线存储库 VSCode 自动生成缺省的 HTML 代码框架 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 输入！，接着输入 tab 键，自动生成缺省的 HTML 代码框架 再按三下 tab 键，光标会移动到 \u0026lt;body\u0026gt; 与 \u0026lt;/body\u0026gt; 之间的空行 KOF KOF AcWing Web 应用课 | 中期项目——拳皇（上） | Vedio AcWing Web 应用课 | 中期项目——拳皇（下） | Vedio 基础操作 操作如下： 角色一: w 跳 a 左移 d 右移 j 拳击 角色二: ↑ 跳 ← 左移 → 右移 1 拳击 文件结构 |-- README.md |-- static | |-- css | | `-- base.css | |-- images | | |-- background | | | `-- 0.gif | | `-- player | | `-- kyo | | |-- 0.gif | | |-- 1.gif | | |-- 2.gif | | |-- 3.gif | | |-- 4.gif | | |-- 5.gif | | `-- 6.gif | `-- js | |-- ac_game_object | | `-- base.js | |-- base.js | |-- controller | | `-- base.js | |-- game_map | | `-- base.js | |-- player | | |-- base.js | | `-- kyo.js | `-- utils | `-- gif.js `-- templates `-- index.html 整体架构 ","keywords":["Tech","AcWing","Web","新技能"],"articleBody":" AcWing Web 应用课 | Colopen’s blog AcWing Web 应用课 HTML 基础标签 CSS JavaScript React Vue3 MDN官方文档 Web 入门 HTML —— 构建 Web CSS —— 设计Web JavaScript —— 用户端动态脚本 React 入门 Vue 入门 Canvas 教程 怪异英文生成器 生成比较好看的英文字体，支持复制粘贴 Color Hunt 设计师和艺术家的调色板 Game-icons 游戏图标在线存储库 VSCode 自动生成缺省的 HTML 代码框架 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c/body\u003e \u003c/html\u003e 输入！，接着输入 tab 键，自动生成缺省的 HTML 代码框架 再按三下 tab 键，光标会移动到 与 之间的空行 KOF KOF AcWing Web 应用课 | 中期项目——拳皇（上） | Vedio AcWing Web 应用课 | 中期项目——拳皇（下） | Vedio 基础操作 操作如下： 角色一: w 跳 a 左移 d 右移 j 拳击 角色二: ↑ 跳 ← 左移 → 右移 1 拳击 文件结构 |-- README.md |-- static | |-- css | | `-- base.css | |-- images | | |-- background | | | `-- 0.gif | | `-- player | | `-- kyo | | |-- 0.gif | | |-- 1.gif | | |-- 2.gif | | |-- 3.gif | | |-- 4.gif | | |-- 5.gif | | `-- 6.gif | `-- js | |-- ac_game_object | | `-- base.js | |-- base.js | |-- controller | | `-- base.js | |-- game_map | | `-- base.js | |-- player | | |-- base.js | | `-- kyo.js | `-- utils | `-- gif.js `-- templates `-- index.html 整体架构 逻辑结构 Retrieved from：https://www.acwing.com/solution/content/139831/ HTML templates/index.html\n\u003c!DOCTYPE html\u003e KOF CSS css/base.css\n#kof { width: 1280px; height: 720px; background-image: url('../images/background/0.gif'); background-size: 200% 100%; background-position: top; position: absolute; } #kof\u003e.kof-head { width: 100%; height: 80px; position: absolute; top: 0; display: flex; align-items: center; } #kof\u003e.kof-head\u003e.kof-head-hp-0 { height: 40px; width: calc(50% - 60px); margin-left: 20px; border: white 5px solid; box-sizing: border-box; border-right: none; } #kof\u003e.kof-head\u003e.kof-head-timer { height: 60px; width: 80px; background-color: orange; border: white 5px solid; box-sizing: border-box; color: white; font-size: 30px; font-weight: 800; text-align: center; line-height: 50px; user-select: none; } #kof\u003e.kof-head\u003e.kof-head-hp-1 { height: 40px; width: calc(50% - 60px); border: white 5px solid; box-sizing: border-box; border-left: none; } #kof\u003e.kof-head\u003e.kof-head-hp-0\u003ediv { background-color: red; height: 100%; width: 100%; float: right; } #kof\u003e.kof-head\u003e.kof-head-hp-1\u003ediv { background-color: red; height: 100%; width: 100%; } #kof\u003e.kof-head\u003e.kof-head-hp-0\u003ediv\u003ediv { background-color: lightgreen; height: 100%; width: 100%; float: right; } #kof\u003e.kof-head\u003e.kof-head-hp-1\u003ediv\u003ediv { background-color: lightgreen; height: 100%; width: 100%; } JavaScript 逻辑结构 KOF js/base.js\nimport { GameMap } from '../js/game_map/base.js' import { Kyo } from '../js/player/kyo.js'; export class KOF { constructor(id) { this.$kof = $('#' + id); this.game_map = new GameMap(this); this.players = [ new Kyo(this, { id: 0, x: 200, y: 0, width: 120, height: 200, color: 'blue' }), new Kyo(this, { id: 1, x: 900, y: 0, width: 120, height: 200, color: 'red' }) ] } } AcGameObject js/ac_game_object/base.js\nlet AC_GAME_OBJECTS = []; export class AcGameObject { constructor() { AC_GAME_OBJECTS.push(this); this.timedelta = 0; this.has_call_start = false; } start() { // 初始化 } update() { // 每一帧执行一次 } destory() { // 删除当前对象 for (let i in AC_GAME_OBJECTS) { if (AC_GAME_OBJECTS[i] === this) { AC_GAME_OBJECTS.splice(i, 1); break; } } } } let last_timestamp; // 上一次执行函数时的时刻 /** * @description 该函数每一帧执行一次 * @param {number} timestamp 当前执行函数时的时刻 */ let AC_GAME_OBJECTS_FRAME = (timestamp) =\u003e { for (let obj of AC_GAME_OBJECTS) { if (!obj.has_call_start) { obj.start(); obj.has_call_start = true; } else { obj.timedelta = timestamp - last_timestamp; obj.update(); } } last_timestamp = timestamp; requestAnimationFrame(AC_GAME_OBJECTS_FRAME); } requestAnimationFrame(AC_GAME_OBJECTS_FRAME); Controller controller 控制器，读取玩家的输入 js/constroller/base.js export class Controller { // 手动实现键盘触发事件——当前按住的按键（效果不同于keydown） constructor($canvas) { this.$canvas = $canvas; this.pressed_keys = new Set(); // Set 对象允许你存储任何类型的唯一值 this.start(); } start() { let outer = this; this.$canvas.keydown(function(e){ // keydown：某个键是否被按住，事件会连续触发 outer.pressed_keys.add(e.key); }); this.$canvas.keyup(function(e){ // keyup：某个按键是否被释放 outer.pressed_keys.delete(e.key); }); } } GameMap js/game_map/base.js\nimport {AcGameObject} from '../ac_game_object/base.js' import { Controller } from '../controller/base.js'; export class GameMap extends AcGameObject { constructor(root) { super(); this.root = root; this.$canvas = $(''); // 构造一个jQuery对象 其中，tabindex=\"0\"使元素可以聚焦 this.ctx = this.$canvas[0].getContext('2d'); // this.$canvas[0]是元素的DOM对象 this.ctx用于画布的渲染 this.root.$kof.append(this.$canvas); this.$canvas.focus(); // 聚焦，使之可以获取输入 this.controller = new Controller(this.$canvas); // 加入血条 this.root.$kof.append($(` `)); // 加入计时表 this.time_left = 60000; //单位：毫秒（因为定义的timedelta单位是ms） this.$timer = this.root.$kof.find('.kof-head-timer'); } start() { } update() { this.update_time(); this.render(); } update_time() { this.time_left -= this.timedelta; if (this.time_left \u003c 0) { // 时间到，游戏结束 this.time_left = 0; let [a, b] = this.root.players; if (a.status !== 6 \u0026\u0026 b.status !== 6) { a.statu = b.status = 6; a.frame_current_cnt = b.frame_current_cnt = 0; a.vx = b.vx = 0; } } this.$timer.text(parseInt(this.time_left / 1000)); } render() { this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height); } } Player js/player/base.js\nimport { AcGameObject } from '../ac_game_object/base.js'; export class Player extends AcGameObject { constructor(root, info) { super(); this.root = root; this.id = info.id; this.x = info.x; this.y = info.y; this.width = info.width; this.height = info.height; this.color = info.color; this.direction = 1; this.vx = 0; this.vy = 0; this.speedx = 400; // 水平速度 this.speedy = -1000; // 跳跃初始速度 this.gravity = 50; this.ctx = this.root.game_map.ctx; this.pressed_keys = this.root.game_map.controller.pressed_keys; this.status = 3; // 0：静止， 1：向前，2：向后，3：跳跃，4：攻击，5：被攻击，6：死亡 随着项目的完善，动作会变的很多，这时用数组存储字符串代替this.status会更方便 this.animations = new Map(); // 存储GIF动画的每一帧 this.frame_current_cnt = 0; // 记录当前的帧数 this.hp = 100; this.$hp = this.root.$kof.find(`.kof-head-hp-${this.id}\u003ediv`); this.$hp_div = this.$hp.find('div'); } start() { } update_control() { let w, a, d, j; if (this.id === 0) { w = this.pressed_keys.has('w'); a = this.pressed_keys.has('a'); d = this.pressed_keys.has('d'); j = this.pressed_keys.has('j'); } else { w = this.pressed_keys.has('ArrowUp'); a = this.pressed_keys.has('ArrowLeft'); d = this.pressed_keys.has('ArrowRight'); j = this.pressed_keys.has('1'); } if (this.status === 0 || this.status === 1) { // 静止状态 || 移动状态 if (j) { // 攻击 this.status = 4; this.vx = 0; this.frame_current_cnt = 0; } else if (w) { // 跳跃 if (d) { // 向右跳 this.vx = this.speedx; } else if (a) { // 向左跳 this.vx = -this.speedx; } else { // 垂直跳 this.vx = 0; } this.vy = this.speedy; this.status = 3; this.frame_current_cnt = 0; // 每次跳跃重新记录帧数，确保跳跃动画正常 } else if (d) { // 向右移动 this.vx = this.speedx; this.status = 1; } else if (a) { // 向左移动 this.vx = - this.speedx; this.status = 1; } else { // 静止 this.vx = 0; } } } update_move() { this.vy += this.gravity; this.x += this.vx * this.timedelta / 1000; this.y += this.vy * this.timedelta / 1000; // 确保两个角色不会重叠 a 是自己、b 是对手 // let [a, b] = this.root.players; // if (a !== this) [a,b] = [b, a]; // let r1 = { // x1: a.x, // y1: a.y, // x2: a.x + a.width, // y2: a.x + a.height, // }; // let r2 = { // x1: b.x, // y1: b.y, // x2: b.x + b.width, // y2: b.x + b.height, // }; // if (this.is_collusion(r1, r2)) { // b.x += this.vx * this.timedelta / 1000 / 2; // b.y += this.vy * this.timedelta / 1000 / 2; // a.x -= this.vx * this.timedelta / 1000 / 2; // a.y -= this.vy * this.timedelta / 1000 / 2; // if (this.status === 3) this.status = 0; // } // 落到平地上后静止 if (this.y \u003e 450) { this.y = 450; this.vy = 0; if (this.status === 3) this.status = 0; // 因为任何时刻都有重力施加，不加这一句会导致状态只有静止状态 } // 不能超出左右边界 if (this.x \u003c 0) { this.x = 0; } else if (this.x + this.width \u003e this.root.game_map.$canvas.width()) { this.x = this.root.game_map.$canvas.width() - this.width; } } update_direction() { // 确保两个角色始终相对 if (this.status === 6) return; let players = this.root.players; if (players[0] \u0026\u0026 players[1]) { let me = this, you = players[1 - this.id]; if (me.x \u003c you.x) me.direction = 1; else me.direction = -1; } } is_collusion(r1, r2) { // 判断两个矩阵是否有交集 if (Math.max(r1.x1, r2.x1) \u003e Math.min(r1.x2, r2.x2)) return false; if (Math.max(r1.y1, r2.y1) \u003e Math.min(r1.y2,r2.y2)) return false; return true; } is_attack() { if (this.status === 6) return; // 已经倒地，无法再被攻击 this.status = 5; this.frame_current_cnt = 0; this.hp = Math.max(this.hp - 10, 0); this.$hp_div.animate({ // 血条减少，渐变 width: this.$hp.parent().width() * this.hp / 100, }, 350); this.$hp.animate({ // 血条减少，渐变 width: this.$hp.parent().width() * this.hp / 100, }, 600); if (this.hp \u003c= 0) { this.status = 6; this.frame_current_cnt = 0; this.vx = 0; } } update_attack() { // 判定是否被攻击到 if (this.status === 4 \u0026\u0026 this.frame_current_cnt === 18) { // 第18帧时动画挥出拳，判断此时是否拳头与对方有碰撞 let me = this, you = this.root.players[1 - this.id]; let r1; // 攻击判定矩形 let r2; // 敌方人物矩形 if (this.direction \u003e 0) { r1 = { x1: me.x + 120, y1: me.y + 40, x2: me.x + 120 + 100, y2: me.y + 40 + 20, } } else { r1 = { x1: me.x + me.width - 120 - 100, y1: me.y + 40, x2: me.x + me.width - 120 - 100 + 100, y2: me.y + 40 + 20, } } r2 = { x1: you.x, y2: you.y, x2: you.x + you.width, y2: you.y + you.height }; if (this.is_collusion(r1, r2)) { you.is_attack(); } } } update() { this.update_attack(); this.update_direction(); this.update_control(); this.update_move(); this.render(); } render() { let status = this.status; if (this.status === 1 \u0026\u0026 this.direction * this.vx \u003c 0) status = 2; // 后退状态 let obj = this.animations.get(status); if (obj \u0026\u0026 obj.loaded) { // GIF 已经加载完成 if (this.direction \u003e 0) { // 正方向 let k = parseInt(this.frame_current_cnt / obj.frame_rate) % obj.frame_cnt; // 通过obj.frame_rate控制渲染动画的速率，方便控制动画，而不只是单纯的每一帧都渲染一次 let image = obj.gif.frames[k].image; this.ctx.drawImage(image, this.x, this.y + obj.offset_y, image.width * obj.scale, image.height * obj.scale); } else { // 反方向 通过调整坐标系来翻转方向 this.ctx.save(); this.ctx.scale(-1, 1); this.ctx.translate(-this.root.game_map.$canvas.width(), 0); let k = parseInt(this.frame_current_cnt / obj.frame_rate) % obj.frame_cnt; let image = obj.gif.frames[k].image; this.ctx.drawImage(image, this.root.game_map.$canvas.width() - this.width - this.x, this.y + obj.offset_y, image.width * obj.scale, image.height * obj.scale); // 不同于正方向时的渲染，因为此时坐标系改变，需要在对称的位置渲染 this.ctx.restore(); } } if (status === 4 || status === 5 || status === 6) { // 确保不会一直循环GIF if (this.frame_current_cnt === obj.frame_rate * (obj.frame_cnt - 1)) { // 确保此时已经播放完一次GIF动画 if (status === 6) { // 死亡倒地不起，这里的 -- 和 下面的 ++ 相抵消，使之在最后一帧不再变化 this.frame_current_cnt--; } else { this.status = 0; } } } this.frame_current_cnt++; } } js/player/kyo.js\nimport { Player } from \"../player/base.js\"; import {GIF} from '../utils/gif.js' export class Kyo extends Player { constructor(root, info) { super(root, info); this.init_animations(); // 初始化动画 } init_animations() { let outer = this; let offsets = [0, -22, -22, -150, 0, 0, 0]; // 偏移量 不同的动画高度不同，因此需要借助竖直方向上的偏移量将他们调整至同一水平面 for (let i = 0; i \u003c 7; ++ i) { // 7个动作 let gif = GIF(); gif.load(`/static/images/player/kyo/${i}.gif`); this.animations.set(i, { // 动画 gif: gif, frame_cnt: 0, // GIF帧数 frame_rate: 5, // 每5帧过渡一次 offset_y: offsets[i], // y方向偏移量 loaded: false, // 是否加载完成 scale: 2, // 放大2倍 }); gif.onload = function() { // 加载完成 let obj = outer.animations.get(i); obj.frame_cnt = gif.frames.length; obj.loaded = true; if (i === 3) { // 调整跳跃时GIF播放速率 obj.frame_rate = 4; } } } } } GIF Loading and playing GIF image to canvas 把玩家的GIF动画渲染在canvas上 js/utils/gif.js\nconst GIF = function () { // **NOT** for commercial use. var timerID; // timer handle for set time out usage var st; // holds the stream object when loading. var interlaceOffsets = [0, 4, 2, 1]; // used in de-interlacing. var interlaceSteps = [8, 8, 4, 2]; var interlacedBufSize; // this holds a buffer to de interlace. Created on the first frame and when size changed var deinterlaceBuf; var pixelBufSize; // this holds a buffer for pixels. Created on the first frame and when size changed var pixelBuf; const GIF_FILE = { // gif file data headers GCExt: 0xF9, COMMENT: 0xFE, APPExt: 0xFF, UNKNOWN: 0x01, // not sure what this is but need to skip it in parser IMAGE: 0x2C, EOF: 59, // This is entered as decimal EXT: 0x21, }; // simple buffered stream used to read from the file var Stream = function (data) { this.data = new Uint8ClampedArray(data); this.pos = 0; var len = this.data.length; this.getString = function (count) { // returns a string from current pos of len count var s = \"\"; while (count--) { s += String.fromCharCode(this.data[this.pos++]) } return s; }; this.readSubBlocks = function () { // reads a set of blocks as a string var size, count, data = \"\"; do { count = size = this.data[this.pos++]; while (count--) { data += String.fromCharCode(this.data[this.pos++]) } } while (size !== 0 \u0026\u0026 this.pos \u003c len); return data; } this.readSubBlocksB = function () { // reads a set of blocks as binary var size, count, data = []; do { count = size = this.data[this.pos++]; while (count--) { data.push(this.data[this.pos++]); } } while (size !== 0 \u0026\u0026 this.pos \u003c len); return data; } }; // LZW decoder uncompressed each frames pixels // this needs to be optimised. // minSize is the min dictionary as powers of two // size and data is the compressed pixels function lzwDecode(minSize, data) { var i, pixelPos, pos, clear, eod, size, done, dic, code, last, d, len; pos = pixelPos = 0; dic = []; clear = 1 \u003c\u003c minSize; eod = clear + 1; size = minSize + 1; done = false; while (!done) { // JavaScript optimisers like a clear exit though I never use 'done' apart from fooling the optimiser last = code; code = 0; for (i = 0; i \u003c size; i++) { if (data[pos \u003e\u003e 3] \u0026 (1 \u003c\u003c (pos \u0026 7))) { code |= 1 \u003c\u003c i } pos++; } if (code === clear) { // clear and reset the dictionary dic = []; size = minSize + 1; for (i = 0; i \u003c clear; i++) { dic[i] = [i] } dic[clear] = []; dic[eod] = null; } else { if (code === eod) { done = true; return } if (code \u003e= dic.length) { dic.push(dic[last].concat(dic[last][0])) } else if (last !== clear) { dic.push(dic[last].concat(dic[code][0])) } d = dic[code]; len = d.length; for (i = 0; i \u003c len; i++) { pixelBuf[pixelPos++] = d[i] } if (dic.length === (1 \u003c\u003c size) \u0026\u0026 size \u003c 12) { size++ } } } }; function parseColourTable(count) { // get a colour table of length count Each entry is 3 bytes, for RGB. var colours = []; for (var i = 0; i \u003c count; i++) { colours.push([st.data[st.pos++], st.data[st.pos++], st.data[st.pos++]]) } return colours; } function parse() { // read the header. This is the starting point of the decode and async calls parseBlock var bitField; st.pos += 6; gif.width = (st.data[st.pos++]) + ((st.data[st.pos++]) \u003c\u003c 8); gif.height = (st.data[st.pos++]) + ((st.data[st.pos++]) \u003c\u003c 8); bitField = st.data[st.pos++]; gif.colorRes = (bitField \u0026 0b1110000) \u003e\u003e 4; gif.globalColourCount = 1 \u003c\u003c ((bitField \u0026 0b111) + 1); gif.bgColourIndex = st.data[st.pos++]; st.pos++; // ignoring pixel aspect ratio. if not 0, aspectRatio = (pixelAspectRatio + 15) / 64 if (bitField \u0026 0b10000000) { gif.globalColourTable = parseColourTable(gif.globalColourCount) } // global colour flag setTimeout(parseBlock, 0); } function parseAppExt() { // get application specific data. Netscape added iterations and terminator. Ignoring that st.pos += 1; if ('NETSCAPE' === st.getString(8)) { st.pos += 8 } // ignoring this data. iterations (word) and terminator (byte) else { st.pos += 3; // 3 bytes of string usually \"2.0\" when identifier is NETSCAPE st.readSubBlocks(); // unknown app extension } }; function parseGCExt() { // get GC data var bitField; st.pos++; bitField = st.data[st.pos++]; gif.disposalMethod = (bitField \u0026 0b11100) \u003e\u003e 2; gif.transparencyGiven = bitField \u0026 0b1 ? true : false; // ignoring bit two that is marked as userInput??? gif.delayTime = (st.data[st.pos++]) + ((st.data[st.pos++]) \u003c\u003c 8); gif.transparencyIndex = st.data[st.pos++]; st.pos++; }; function parseImg() { // decodes image data to create the indexed pixel image var deinterlace, frame, bitField; deinterlace = function (width) { // de interlace pixel data if needed var lines, fromLine, pass, toline; lines = pixelBufSize / width; fromLine = 0; if (interlacedBufSize !== pixelBufSize) { // create the buffer if size changed or undefined. deinterlaceBuf = new Uint8Array(pixelBufSize); interlacedBufSize = pixelBufSize; } for (pass = 0; pass \u003c 4; pass++) { for (toLine = interlaceOffsets[pass]; toLine \u003c lines; toLine += interlaceSteps[pass]) { deinterlaceBuf.set(pixelBuf.subarray(fromLine, fromLine + width), toLine * width); fromLine += width; } } }; frame = {} gif.frames.push(frame); frame.disposalMethod = gif.disposalMethod; frame.time = gif.length; frame.delay = gif.delayTime * 10; gif.length += frame.delay; if (gif.transparencyGiven) { frame.transparencyIndex = gif.transparencyIndex } else { frame.transparencyIndex = undefined } frame.leftPos = (st.data[st.pos++]) + ((st.data[st.pos++]) \u003c\u003c 8); frame.topPos = (st.data[st.pos++]) + ((st.data[st.pos++]) \u003c\u003c 8); frame.width = (st.data[st.pos++]) + ((st.data[st.pos++]) \u003c\u003c 8); frame.height = (st.data[st.pos++]) + ((st.data[st.pos++]) \u003c\u003c 8); bitField = st.data[st.pos++]; frame.localColourTableFlag = bitField \u0026 0b10000000 ? true : false; if (frame.localColourTableFlag) { frame.localColourTable = parseColourTable(1 \u003c\u003c ((bitField \u0026 0b111) + 1)) } if (pixelBufSize !== frame.width * frame.height) { // create a pixel buffer if not yet created or if current frame size is different from previous pixelBuf = new Uint8Array(frame.width * frame.height); pixelBufSize = frame.width * frame.height; } lzwDecode(st.data[st.pos++], st.readSubBlocksB()); // decode the pixels if (bitField \u0026 0b1000000) { // de interlace if needed frame.interlaced = true; deinterlace(frame.width); } else { frame.interlaced = false } processFrame(frame); // convert to canvas image }; function processFrame(frame) { // creates a RGBA canvas image from the indexed pixel data. var ct, cData, dat, pixCount, ind, useT, i, pixel, pDat, col, frame, ti; frame.image = document.createElement('canvas'); frame.image.width = gif.width; frame.image.height = gif.height; frame.image.ctx = frame.image.getContext(\"2d\"); ct = frame.localColourTableFlag ? frame.localColourTable : gif.globalColourTable; if (gif.lastFrame === null) { gif.lastFrame = frame } useT = (gif.lastFrame.disposalMethod === 2 || gif.lastFrame.disposalMethod === 3) ? true : false; if (!useT) { frame.image.ctx.drawImage(gif.lastFrame.image, 0, 0, gif.width, gif.height) } cData = frame.image.ctx.getImageData(frame.leftPos, frame.topPos, frame.width, frame.height); ti = frame.transparencyIndex; dat = cData.data; if (frame.interlaced) { pDat = deinterlaceBuf } else { pDat = pixelBuf } pixCount = pDat.length; ind = 0; for (i = 0; i \u003c pixCount; i++) { pixel = pDat[i]; col = ct[pixel]; if (ti !== pixel) { dat[ind++] = col[0]; dat[ind++] = col[1]; dat[ind++] = col[2]; dat[ind++] = 255; // Opaque. } else if (useT) { dat[ind + 3] = 0; // Transparent. ind += 4; } else { ind += 4 } } frame.image.ctx.putImageData(cData, frame.leftPos, frame.topPos); gif.lastFrame = frame; if (!gif.waitTillDone \u0026\u0026 typeof gif.onload === \"function\") { doOnloadEvent() }// if !waitTillDone the call onload now after first frame is loaded }; // **NOT** for commercial use. function finnished() { // called when the load has completed gif.loading = false; gif.frameCount = gif.frames.length; gif.lastFrame = null; st = undefined; gif.complete = true; gif.disposalMethod = undefined; gif.transparencyGiven = undefined; gif.delayTime = undefined; gif.transparencyIndex = undefined; gif.waitTillDone = undefined; pixelBuf = undefined; // dereference pixel buffer deinterlaceBuf = undefined; // dereference interlace buff (may or may not be used); pixelBufSize = undefined; deinterlaceBuf = undefined; gif.currentFrame = 0; if (gif.frames.length \u003e 0) { gif.image = gif.frames[0].image } doOnloadEvent(); if (typeof gif.onloadall === \"function\") { (gif.onloadall.bind(gif))({ type: 'loadall', path: [gif] }); } if (gif.playOnLoad) { gif.play() } } function canceled() { // called if the load has been cancelled finnished(); if (typeof gif.cancelCallback === \"function\") { (gif.cancelCallback.bind(gif))({ type: 'canceled', path: [gif] }) } } function parseExt() { // parse extended blocks const blockID = st.data[st.pos++]; if (blockID === GIF_FILE.GCExt) { parseGCExt() } else if (blockID === GIF_FILE.COMMENT) { gif.comment += st.readSubBlocks() } else if (blockID === GIF_FILE.APPExt) { parseAppExt() } else { if (blockID === GIF_FILE.UNKNOWN) { st.pos += 13; } // skip unknow block st.readSubBlocks(); } } function parseBlock() { // parsing the blocks if (gif.cancel !== undefined \u0026\u0026 gif.cancel === true) { canceled(); return } const blockId = st.data[st.pos++]; if (blockId === GIF_FILE.IMAGE) { // image block parseImg(); if (gif.firstFrameOnly) { finnished(); return } } else if (blockId === GIF_FILE.EOF) { finnished(); return } else { parseExt() } if (typeof gif.onprogress === \"function\") { gif.onprogress({ bytesRead: st.pos, totalBytes: st.data.length, frame: gif.frames.length }); } setTimeout(parseBlock, 0); // parsing frame async so processes can get some time in. }; function cancelLoad(callback) { // cancels the loading. This will cancel the load before the next frame is decoded if (gif.complete) { return false } gif.cancelCallback = callback; gif.cancel = true; return true; } function error(type) { if (typeof gif.onerror === \"function\") { (gif.onerror.bind(this))({ type: type, path: [this] }) } gif.onload = gif.onerror = undefined; gif.loading = false; } function doOnloadEvent() { // fire onload event if set gif.currentFrame = 0; gif.nextFrameAt = gif.lastFrameAt = new Date().valueOf(); // just sets the time now if (typeof gif.onload === \"function\") { (gif.onload.bind(gif))({ type: 'load', path: [gif] }) } gif.onerror = gif.onload = undefined; } function dataLoaded(data) { // Data loaded create stream and parse st = new Stream(data); parse(); } function loadGif(filename) { // starts the load var ajax = new XMLHttpRequest(); ajax.responseType = \"arraybuffer\"; ajax.onload = function (e) { if (e.target.status === 404) { error(\"File not found\") } else if (e.target.status \u003e= 200 \u0026\u0026 e.target.status \u003c 300) { dataLoaded(ajax.response) } else { error(\"Loading error : \" + e.target.status) } }; ajax.open('GET', filename, true); ajax.send(); ajax.onerror = function (e) { error(\"File error\") }; this.src = filename; this.loading = true; } function play() { // starts play if paused if (!gif.playing) { gif.paused = false; gif.playing = true; playing(); } } function pause() { // stops play gif.paused = true; gif.playing = false; clearTimeout(timerID); } function togglePlay() { if (gif.paused || !gif.playing) { gif.play() } else { gif.pause() } } function seekFrame(frame) { // seeks to frame number. clearTimeout(timerID); gif.currentFrame = frame % gif.frames.length; if (gif.playing) { playing() } else { gif.image = gif.frames[gif.currentFrame].image } } function seek(time) { // time in Seconds // seek to frame that would be displayed at time clearTimeout(timerID); if (time \u003c 0) { time = 0 } time *= 1000; // in ms time %= gif.length; var frame = 0; while (time \u003e gif.frames[frame].time + gif.frames[frame].delay \u0026\u0026 frame \u003c gif.frames.length) { frame += 1 } gif.currentFrame = frame; if (gif.playing) { playing() } else { gif.image = gif.frames[gif.currentFrame].image } } function playing() { var delay; var frame; if (gif.playSpeed === 0) { gif.pause(); return; } else { if (gif.playSpeed \u003c 0) { gif.currentFrame -= 1; if (gif.currentFrame \u003c 0) { gif.currentFrame = gif.frames.length - 1 } frame = gif.currentFrame; frame -= 1; if (frame \u003c 0) { frame = gif.frames.length - 1 } delay = -gif.frames[frame].delay * 1 / gif.playSpeed; } else { gif.currentFrame += 1; gif.currentFrame %= gif.frames.length; delay = gif.frames[gif.currentFrame].delay * 1 / gif.playSpeed; } gif.image = gif.frames[gif.currentFrame].image; timerID = setTimeout(playing, delay); } } var gif = { // the gif image object onload: null, // fire on load. Use waitTillDone = true to have load fire at end or false to fire on first frame onerror: null, // fires on error onprogress: null, // fires a load progress event onloadall: null, // event fires when all frames have loaded and gif is ready paused: false, // true if paused playing: false, // true if playing waitTillDone: true, // If true onload will fire when all frames loaded, if false, onload will fire when first frame has loaded loading: false, // true if still loading firstFrameOnly: false, // if true only load the first frame width: null, // width in pixels height: null, // height in pixels frames: [], // array of frames comment: \"\", // comments if found in file. Note I remember that some gifs have comments per frame if so this will be all comment concatenated length: 0, // gif length in ms (1/1000 second) currentFrame: 0, // current frame. frameCount: 0, // number of frames playSpeed: 1, // play speed 1 normal, 2 twice 0.5 half, -1 reverse etc... lastFrame: null, // temp hold last frame loaded so you can display the gif as it loads image: null, // the current image at the currentFrame playOnLoad: true, // if true starts playback when loaded // functions load: loadGif, // call this to load a file cancel: cancelLoad, // call to stop loading play: play, // call to start play pause: pause, // call to pause seek: seek, // call to seek to time seekFrame: seekFrame, // call to seek to frame togglePlay: togglePlay, // call to toggle play and pause state }; return gif; } export { GIF } 状态机 0：静止 1：移动 3：跳跃 4：攻击 MySpace MySpace AcWing Web 应用课 | Vue3——网站整体布局、用户动态页面 | Vedio AcWing Web 应用课 | Vue3——用户列表、登录、注册页面 | Vedio ","wordCount":"5000","inLanguage":"en","datePublished":"2022-11-02T15:49:03+08:00","dateModified":"2022-11-02T15:49:03+08:00","author":[{"@type":"Person","name":"Xan"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://xancoding.cn/posts/2022-11-02-15-49-03/"},"publisher":{"@type":"Organization","name":"Xan's Blog","logo":{"@type":"ImageObject","url":"https://xancoding.cn/img/favicon.ico"}}}</script><script src=https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://xancoding.cn/ accesskey=h title="Xan's Blog (Alt + H)"><img src=https://xancoding.cn/img/headshot.jpg alt aria-label=logo height=35>Xan's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://xancoding.cn/ title=Home><span>Home</span></a></li><li><a href=https://xancoding.cn/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://xancoding.cn/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://xancoding.cn/links/ title=Links><span>Links</span></a></li><li><a href=https://xancoding.cn/about/ title=About><span>About</span></a></li><li><a href=https://xancoding.cn/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://xancoding.cn/workouts_page/ title=Workouts><span>Workouts</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://xancoding.cn/>Home</a>&nbsp;»&nbsp;<a href=https://xancoding.cn/posts/>Posts</a></div><h1 class=post-title>AcWing Web 应用课</h1><div class=post-meta>2022-11-02&nbsp;|&nbsp;<a href=https://github.com/Xancoding/Blog/tree/main/content/posts/2022-11-02-15-49-03.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#kof aria-label=KOF>KOF</a><ul><li><a href=#%e5%9f%ba%e7%a1%80%e6%93%8d%e4%bd%9c aria-label=基础操作>基础操作</a></li><li><a href=#%e6%96%87%e4%bb%b6%e7%bb%93%e6%9e%84 aria-label=文件结构>文件结构</a></li><li><a href=#%e6%95%b4%e4%bd%93%e6%9e%b6%e6%9e%84 aria-label=整体架构>整体架构</a></li><li><a href=#%e9%80%bb%e8%be%91%e7%bb%93%e6%9e%84 aria-label=逻辑结构>逻辑结构</a></li><li><a href=#html aria-label=HTML>HTML</a></li><li><a href=#css aria-label=CSS>CSS</a></li><li><a href=#javascript aria-label=JavaScript>JavaScript</a><ul><li><a href=#%e9%80%bb%e8%be%91%e7%bb%93%e6%9e%84-1 aria-label=逻辑结构>逻辑结构</a></li><li><a href=#kof-1 aria-label=KOF>KOF</a></li><li><a href=#acgameobject aria-label=AcGameObject>AcGameObject</a></li><li><a href=#controller aria-label=Controller>Controller</a></li><li><a href=#gamemap aria-label=GameMap>GameMap</a></li><li><a href=#player aria-label=Player>Player</a></li><li><a href=#gif aria-label=GIF>GIF</a></li><li><a href=#%e7%8a%b6%e6%80%81%e6%9c%ba aria-label=状态机>状态机</a></li></ul></li></ul></li><li><a href=#myspace aria-label=MySpace>MySpace</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><ul><li><a href=https://www.colopen-blog.com/Engineer/acw_web/>AcWing Web 应用课 | Colopen&rsquo;s blog</a></li><li><a href=https://www.acwing.com/activity/content/punch_the_clock/1150/>AcWing Web 应用课</a><ul><li><a href=https://www.acwing.com/file_system/file/content/whole/index/content/4078555/>HTML 基础标签</a></li><li><a href=https://www.acwing.com/file_system/file/content/whole/index/content/4194723/>CSS</a></li><li><a href=https://www.acwing.com/file_system/file/content/whole/index/content/4719082/>JavaScript</a></li><li><a href=https://www.acwing.com/file_system/file/content/whole/index/content/5501588/>React</a></li><li><a href=https://www.acwing.com/file_system/file/content/whole/index/content/5639568/>Vue3</a></li></ul></li><li><a href=https://developer.mozilla.org/zh-CN/>MDN官方文档</a><ul><li><a href=https://developer.mozilla.org/zh-CN/docs/Learn/Getting_started_with_the_web>Web 入门</a></li><li><a href=https://developer.mozilla.org/zh-CN/docs/Learn/HTML>HTML —— 构建 Web</a></li><li><a href=https://developer.mozilla.org/zh-CN/docs/Learn/CSS>CSS —— 设计Web</a></li><li><a href=https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript>JavaScript —— 用户端动态脚本</a></li><li><a href=https://developer.mozilla.org/zh-CN/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_getting_started>React 入门</a></li><li><a href=https://developer.mozilla.org/zh-CN/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Vue_getting_started>Vue 入门</a></li><li><a href=https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial>Canvas 教程</a></li></ul></li></ul><hr><ol><li><a href=https://www.dute.org/weird-fonts>怪异英文生成器</a> 生成比较好看的英文字体，支持复制粘贴</li><li><a href=https://colorhunt.co/>Color Hunt</a> 设计师和艺术家的调色板</li><li><a href=https://game-icons.net/>Game-icons</a> 游戏图标在线存储库</li></ol><hr><ul><li><code>VSCode</code> 自动生成缺省的 <code>HTML</code> 代码框架</li></ul><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-HTML data-lang=HTML><span style=display:flex><span><span style=color:#0f0;font-weight:700>&lt;!DOCTYPE html&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&lt;<span style=font-weight:700>html</span> <span style=color:#007f7f>lang</span>=<span style=color:#0ff;font-weight:700>&#34;en&#34;</span>&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&lt;<span style=font-weight:700>head</span>&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  &lt;<span style=font-weight:700>meta</span> <span style=color:#007f7f>charset</span>=<span style=color:#0ff;font-weight:700>&#34;UTF-8&#34;</span>&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  &lt;<span style=font-weight:700>meta</span> <span style=color:#007f7f>http-equiv</span>=<span style=color:#0ff;font-weight:700>&#34;X-UA-Compatible&#34;</span> <span style=color:#007f7f>content</span>=<span style=color:#0ff;font-weight:700>&#34;IE=edge&#34;</span>&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  &lt;<span style=font-weight:700>meta</span> <span style=color:#007f7f>name</span>=<span style=color:#0ff;font-weight:700>&#34;viewport&#34;</span> <span style=color:#007f7f>content</span>=<span style=color:#0ff;font-weight:700>&#34;width=device-width, initial-scale=1.0&#34;</span>&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  &lt;<span style=font-weight:700>title</span>&gt;Document&lt;/<span style=font-weight:700>title</span>&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&lt;/<span style=font-weight:700>head</span>&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&lt;<span style=font-weight:700>body</span>&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&lt;/<span style=font-weight:700>body</span>&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&lt;/<span style=font-weight:700>html</span>&gt;
</span></span></code></pre></div><ol><li>输入<code>！</code>，接着输入 <code>tab</code> 键，自动生成缺省的 <code>HTML</code> 代码框架</li><li>再按三下 <code>tab</code> 键，光标会移动到 <code>&lt;body></code> 与 <code>&lt;/body></code> 之间的空行</li></ol><hr><h2 id=kof>KOF<a hidden class=anchor aria-hidden=true href=#kof>#</a></h2><ul><li><a href=https://github.com/Xancoding/Leaning-jQuery>KOF</a></li><li><a href=https://www.acwing.com/video/3830/>AcWing Web 应用课 | 中期项目——拳皇（上） | Vedio</a></li><li><a href=https://www.acwing.com/video/3833/>AcWing Web 应用课 | 中期项目——拳皇（下） | Vedio</a></li></ul><hr><h3 id=基础操作>基础操作<a hidden class=anchor aria-hidden=true href=#基础操作>#</a></h3><pre tabindex=0><code>操作如下：
角色一: w 跳 a 左移 d 右移 j 拳击 
角色二: ↑ 跳 ← 左移 → 右移 1 拳击
</code></pre><h3 id=文件结构>文件结构<a hidden class=anchor aria-hidden=true href=#文件结构>#</a></h3><pre tabindex=0><code>|-- README.md
|-- static
|   |-- css
|   |   `-- base.css
|   |-- images
|   |   |-- background
|   |   |   `-- 0.gif
|   |   `-- player
|   |       `-- kyo
|   |           |-- 0.gif
|   |           |-- 1.gif
|   |           |-- 2.gif
|   |           |-- 3.gif
|   |           |-- 4.gif
|   |           |-- 5.gif
|   |           `-- 6.gif
|   `-- js
|       |-- ac_game_object
|       |   `-- base.js
|       |-- base.js
|       |-- controller
|       |   `-- base.js
|       |-- game_map
|       |   `-- base.js
|       |-- player
|       |   |-- base.js
|       |   `-- kyo.js
|       `-- utils
|           `-- gif.js
`-- templates
    `-- index.html
</code></pre><h3 id=整体架构>整体架构<a hidden class=anchor aria-hidden=true href=#整体架构>#</a></h3><p><div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/02/63627b3105c46.png><img src=https://bu.dusays.com/2022/11/02/63627b3105c46.png alt=KOFStructure></a></div></p><h3 id=逻辑结构>逻辑结构<a hidden class=anchor aria-hidden=true href=#逻辑结构>#</a></h3><center><img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=https://bu.dusays.com/2022/11/02/63627ace5a2f9.png><br><div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px">Retrieved from：https://www.acwing.com/solution/content/139831/</div></center><h3 id=html>HTML<a hidden class=anchor aria-hidden=true href=#html>#</a></h3><p><code>templates/index.html</code></p><pre tabindex=0><code>&lt;!DOCTYPE html&gt;

&lt;html lang=&#34;en&#34;&gt;

&lt;head&gt;

  &lt;meta charset=&#34;UTF-8&#34;&gt;

  &lt;meta http-equiv=&#34;X-UA-Compatible&#34; content=&#34;IE=edge&#34;&gt;

  &lt;meta name=&#34;viewport&#34; content=&#34;width=device-width, initial-scale=1.0&#34;&gt;

  &lt;title&gt;KOF&lt;/title&gt;

  &lt;link rel=&#34;stylesheet&#34; href=&#34;../static/css/base.css&#34;&gt;

  &lt;script src=&#34;https://cdn.acwing.com/static/jquery/js/jquery-3.3.1.min.js&#34;&gt;&lt;/script&gt;

&lt;/head&gt;

&lt;body&gt;

  &lt;div id=&#34;kof&#34;&gt;&lt;/div&gt;

  

  &lt;script type=&#34;module&#34;&gt;

    import {KOF} from &#39;../static/js/base.js&#39;;

  

    let kof = new KOF(&#39;kof&#39;);

  &lt;/script&gt;

&lt;/body&gt;

&lt;/html&gt;
</code></pre><h3 id=css>CSS<a hidden class=anchor aria-hidden=true href=#css>#</a></h3><p><code>css/base.css</code></p><pre tabindex=0><code>#kof {

  width: 1280px;

  height: 720px;

  background-image: url(&#39;../images/background/0.gif&#39;);

  background-size: 200% 100%;

  background-position: top;

  position: absolute;

}

  

#kof&gt;.kof-head {

  width: 100%;

  height: 80px;

  position: absolute;

  top: 0;

  display: flex;

  align-items: center;

}

  

#kof&gt;.kof-head&gt;.kof-head-hp-0 {

  height: 40px;

  width: calc(50% - 60px);

  margin-left: 20px;

  border: white 5px solid;

  box-sizing: border-box;

  border-right: none;

}

  

#kof&gt;.kof-head&gt;.kof-head-timer {

  height: 60px;

  width: 80px;

  background-color: orange;

  border: white 5px solid;

  box-sizing: border-box;

  color: white;

  font-size: 30px;

  font-weight: 800;

  text-align: center;

  line-height: 50px;

  user-select: none;

}

  

#kof&gt;.kof-head&gt;.kof-head-hp-1 {

  height: 40px;

  width: calc(50% - 60px);

  border: white 5px solid;

  box-sizing: border-box;

  border-left: none;

}

  

#kof&gt;.kof-head&gt;.kof-head-hp-0&gt;div {

  background-color: red;

  height: 100%;

  width: 100%;

  float: right;

}

  

#kof&gt;.kof-head&gt;.kof-head-hp-1&gt;div {

  background-color: red;

  height: 100%;

  width: 100%;

}

  

#kof&gt;.kof-head&gt;.kof-head-hp-0&gt;div&gt;div {

  background-color: lightgreen;

  height: 100%;

  width: 100%;

  float: right;

}

  

#kof&gt;.kof-head&gt;.kof-head-hp-1&gt;div&gt;div {

  background-color: lightgreen;

  height: 100%;

  width: 100%;

}
</code></pre><h3 id=javascript>JavaScript<a hidden class=anchor aria-hidden=true href=#javascript>#</a></h3><h4 id=逻辑结构-1>逻辑结构<a hidden class=anchor aria-hidden=true href=#逻辑结构-1>#</a></h4><p><div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/03/63631ec3461ef.png><img src=https://bu.dusays.com/2022/11/03/63631ec3461ef.png alt=逻辑结构></a></div></p><h4 id=kof-1>KOF<a hidden class=anchor aria-hidden=true href=#kof-1>#</a></h4><p><code>js/base.js</code></p><pre tabindex=0><code>import { GameMap } from &#39;../js/game_map/base.js&#39;

import { Kyo } from &#39;../js/player/kyo.js&#39;;

  

export class KOF {

  constructor(id) {

    this.$kof = $(&#39;#&#39; + id);

  

    this.game_map = new GameMap(this);

    this.players = [

      new Kyo(this, {

        id: 0,

        x: 200,

        y: 0,

        width: 120,

        height: 200,

        color: &#39;blue&#39;

      }),

      new Kyo(this, {

        id: 1,

        x: 900,

        y: 0,

        width: 120,

        height: 200,

        color: &#39;red&#39;

      })

    ]

  }

}
</code></pre><h4 id=acgameobject>AcGameObject<a hidden class=anchor aria-hidden=true href=#acgameobject>#</a></h4><p><code>js/ac_game_object/base.js</code></p><pre tabindex=0><code>let AC_GAME_OBJECTS = [];

  

export class AcGameObject {

  constructor() {

    AC_GAME_OBJECTS.push(this);

  

    this.timedelta = 0;

    this.has_call_start = false;

  }

  

  start() {  // 初始化

  
  

  }

  

  update() {  // 每一帧执行一次

  

  }

  

  destory() {  // 删除当前对象

    for (let i in AC_GAME_OBJECTS) {

      if (AC_GAME_OBJECTS[i] === this) {

        AC_GAME_OBJECTS.splice(i, 1);

        break;

      }

    }

  }

}

  

let last_timestamp;   // 上一次执行函数时的时刻

  

/**

 * @description 该函数每一帧执行一次

 * @param {number} timestamp 当前执行函数时的时刻

 */

  

let AC_GAME_OBJECTS_FRAME = (timestamp) =&gt; {

  for (let obj of AC_GAME_OBJECTS) {

    if (!obj.has_call_start) {

      obj.start();

      obj.has_call_start = true;

    } else {

      obj.timedelta = timestamp - last_timestamp;

      obj.update();

    }

  }

  

  last_timestamp = timestamp;

  requestAnimationFrame(AC_GAME_OBJECTS_FRAME);

}

  

requestAnimationFrame(AC_GAME_OBJECTS_FRAME);
</code></pre><h4 id=controller>Controller<a hidden class=anchor aria-hidden=true href=#controller>#</a></h4><ul><li><code>controller</code> 控制器，读取玩家的输入
<code>js/constroller/base.js</code></li></ul><pre tabindex=0><code>export class Controller {   // 手动实现键盘触发事件——当前按住的按键（效果不同于keydown）

  constructor($canvas) {

    this.$canvas = $canvas;

    this.pressed_keys = new Set();    // Set 对象允许你存储任何类型的唯一值

    this.start();

  }

  

  start() {

    let outer = this;

    this.$canvas.keydown(function(e){   // keydown：某个键是否被按住，事件会连续触发

      outer.pressed_keys.add(e.key);

    });

  

    this.$canvas.keyup(function(e){   // keyup：某个按键是否被释放

      outer.pressed_keys.delete(e.key);

    });

  

  }

}
</code></pre><h4 id=gamemap>GameMap<a hidden class=anchor aria-hidden=true href=#gamemap>#</a></h4><p><code>js/game_map/base.js</code></p><pre tabindex=0><code>import {AcGameObject} from &#39;../ac_game_object/base.js&#39;

import { Controller } from &#39;../controller/base.js&#39;;

  

export class GameMap extends AcGameObject {

  constructor(root) {

    super();

  

    this.root = root;

    this.$canvas = $(&#39;&lt;canvas width=&#34;1280&#34; height=&#34;720&#34; tabindex=0&gt;&lt;/canvas&gt;&#39;);   // 构造一个jQuery对象  其中，tabindex=&#34;0&#34;使&lt;canvas&gt;元素可以聚焦

    this.ctx = this.$canvas[0].getContext(&#39;2d&#39;);  // this.$canvas[0]是&lt;canvas&gt;元素的DOM对象   this.ctx用于画布的渲染

    this.root.$kof.append(this.$canvas);

    this.$canvas.focus();   // 聚焦，使之可以获取输入

  

    this.controller = new Controller(this.$canvas);

  

    // 加入血条

    this.root.$kof.append($(`

      &lt;div class=&#34;kof-head&#34;&gt;

        &lt;div class=&#34;kof-head-hp-0&#34;&gt;&lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;

        &lt;div class=&#34;kof-head-timer&#34;&gt;&lt;/div&gt;

        &lt;div class=&#34;kof-head-hp-1&#34;&gt;&lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;

      &lt;/div&gt;

    `));

  

    // 加入计时表

    this.time_left = 60000;  //单位：毫秒（因为定义的timedelta单位是ms）

    this.$timer = this.root.$kof.find(&#39;.kof-head-timer&#39;);

  }

  

  start() {

  

  }

  

  update() {

    this.update_time();

  

    this.render();

  }

  

  update_time() {

    this.time_left -= this.timedelta;

    if (this.time_left &lt; 0) {   // 时间到，游戏结束

      this.time_left = 0;

  

      let [a, b] = this.root.players;

      if (a.status !== 6 &amp;&amp; b.status !== 6) {

        a.statu = b.status = 6;

        a.frame_current_cnt = b.frame_current_cnt = 0;

        a.vx = b.vx = 0;

      }

    }

    this.$timer.text(parseInt(this.time_left / 1000));

  }

  

  render() {

    this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);

  }

}
</code></pre><h4 id=player>Player<a hidden class=anchor aria-hidden=true href=#player>#</a></h4><p><code>js/player/base.js</code></p><pre tabindex=0><code>import { AcGameObject } from &#39;../ac_game_object/base.js&#39;;

  

export class Player extends AcGameObject {

  constructor(root, info) {

    super();

  

    this.root = root;

    this.id = info.id;

    this.x = info.x;

    this.y = info.y;

    this.width = info.width;

    this.height = info.height;

    this.color = info.color;

  

    this.direction = 1;

  

    this.vx = 0;

    this.vy = 0;

  

    this.speedx = 400;  // 水平速度

    this.speedy = -1000;  // 跳跃初始速度

  

    this.gravity = 50;

  

    this.ctx = this.root.game_map.ctx;

    this.pressed_keys = this.root.game_map.controller.pressed_keys;

    this.status = 3;  // 0：静止， 1：向前，2：向后，3：跳跃，4：攻击，5：被攻击，6：死亡   随着项目的完善，动作会变的很多，这时用数组存储字符串代替this.status会更方便

    this.animations = new Map();  // 存储GIF动画的每一帧

    this.frame_current_cnt = 0;  // 记录当前的帧数

  

    this.hp = 100;

    this.$hp = this.root.$kof.find(`.kof-head-hp-${this.id}&gt;div`);

    this.$hp_div = this.$hp.find(&#39;div&#39;);

  }

  start() {

  }

  

  update_control() {

    let w, a, d, j;

    if (this.id === 0) {

      w = this.pressed_keys.has(&#39;w&#39;);

      a = this.pressed_keys.has(&#39;a&#39;);

      d = this.pressed_keys.has(&#39;d&#39;);

      j = this.pressed_keys.has(&#39;j&#39;);

    } else {

      w = this.pressed_keys.has(&#39;ArrowUp&#39;);

      a = this.pressed_keys.has(&#39;ArrowLeft&#39;);

      d = this.pressed_keys.has(&#39;ArrowRight&#39;);

      j = this.pressed_keys.has(&#39;1&#39;);

    }

  

    if (this.status === 0 || this.status === 1) {   // 静止状态 || 移动状态

      if (j) {  // 攻击

        this.status = 4;

        this.vx = 0;

        this.frame_current_cnt = 0;

      } else if (w) {  // 跳跃

        if (d) {  // 向右跳

          this.vx = this.speedx;

        } else if (a) {  // 向左跳

          this.vx = -this.speedx;

        } else {  // 垂直跳

          this.vx = 0;

        }

        this.vy = this.speedy;

        this.status = 3;

        this.frame_current_cnt = 0; // 每次跳跃重新记录帧数，确保跳跃动画正常

  

      } else if (d) {  // 向右移动

        this.vx = this.speedx;

        this.status = 1;

      } else if (a) {  // 向左移动

        this.vx = - this.speedx;

        this.status = 1;

      } else {  // 静止

        this.vx = 0;

      }

    }

  

  }

  update_move() {

    this.vy += this.gravity;

  

    this.x += this.vx * this.timedelta / 1000;

    this.y += this.vy * this.timedelta / 1000;

  

    // 确保两个角色不会重叠   a 是自己、b 是对手

    // let [a, b] = this.root.players;

    // if (a !== this) [a,b] = [b, a];

  

    // let r1 = {

    //   x1: a.x,

    //   y1: a.y,

    //   x2: a.x + a.width,

    //   y2: a.x + a.height,

    // };

    // let r2 = {

    //   x1: b.x,

    //   y1: b.y,

    //   x2: b.x + b.width,

    //   y2: b.x + b.height,

    // };

  

    // if (this.is_collusion(r1, r2)) {

    //   b.x += this.vx * this.timedelta / 1000 / 2;

    //   b.y += this.vy * this.timedelta / 1000 / 2;

    //   a.x -= this.vx * this.timedelta / 1000 / 2;

    //   a.y -= this.vy * this.timedelta / 1000 / 2;

  

    //   if (this.status === 3) this.status = 0;

    // }

  

    // 落到平地上后静止

    if (this.y &gt; 450) {

      this.y = 450;

      this.vy = 0;

      if (this.status === 3) this.status = 0;   // 因为任何时刻都有重力施加，不加这一句会导致状态只有静止状态

    }

  

    // 不能超出左右边界

    if (this.x &lt; 0) {

      this.x = 0;

    } else if (this.x + this.width &gt; this.root.game_map.$canvas.width()) {

      this.x = this.root.game_map.$canvas.width() - this.width;

    }

  

  }

  

  update_direction() {  // 确保两个角色始终相对

    if (this.status === 6) return;

  

    let players = this.root.players;

    if (players[0] &amp;&amp; players[1]) {

      let me = this, you = players[1 - this.id];

      if (me.x &lt; you.x) me.direction = 1;

      else me.direction = -1;

    }

  }

  

  is_collusion(r1, r2) {  // 判断两个矩阵是否有交集

    if (Math.max(r1.x1, r2.x1) &gt; Math.min(r1.x2, r2.x2))

      return false;

    if (Math.max(r1.y1, r2.y1) &gt; Math.min(r1.y2,r2.y2))

      return false;

    return true;

  }

  

  is_attack() {

    if (this.status === 6) return;  // 已经倒地，无法再被攻击

  

    this.status = 5;

    this.frame_current_cnt = 0;

  

    this.hp = Math.max(this.hp - 10, 0);

  

    this.$hp_div.animate({  // 血条减少，渐变

      width: this.$hp.parent().width() * this.hp / 100,

    }, 350);

  

    this.$hp.animate({  // 血条减少，渐变

      width: this.$hp.parent().width() * this.hp / 100,

    }, 600);

  

    if (this.hp &lt;= 0) {

      this.status = 6;

      this.frame_current_cnt = 0;

      this.vx = 0;

    }

  }

  

  update_attack() {   // 判定是否被攻击到

    if (this.status === 4 &amp;&amp; this.frame_current_cnt === 18) {   // 第18帧时动画挥出拳，判断此时是否拳头与对方有碰撞

      let me = this, you = this.root.players[1 - this.id];

      let r1;  // 攻击判定矩形

      let r2;  // 敌方人物矩形

      if (this.direction &gt; 0) {

        r1 = {

          x1: me.x + 120,

          y1: me.y + 40,

          x2: me.x + 120 + 100,

          y2: me.y + 40 + 20,

        }

      } else {

        r1 = {

          x1: me.x + me.width - 120 - 100,

          y1: me.y + 40,

          x2: me.x + me.width - 120 - 100 + 100,

          y2: me.y + 40 + 20,

        }

      }

  

      r2 = {

        x1: you.x,

        y2: you.y,

        x2: you.x + you.width,

        y2: you.y + you.height

      };

  

      if (this.is_collusion(r1, r2)) {

        you.is_attack();

      }

    }

  }

  

  update() {

    this.update_attack();

    this.update_direction();

    this.update_control();

    this.update_move();

    this.render();

  }

  

  render() {

  

    let status = this.status;

  

    if (this.status === 1 &amp;&amp; this.direction * this.vx &lt; 0) status = 2;    // 后退状态

  

    let obj = this.animations.get(status);

    if (obj &amp;&amp; obj.loaded) {    // GIF 已经加载完成

      if (this.direction &gt; 0) {  // 正方向

        let k = parseInt(this.frame_current_cnt / obj.frame_rate) % obj.frame_cnt;  // 通过obj.frame_rate控制渲染动画的速率，方便控制动画，而不只是单纯的每一帧都渲染一次

        let image = obj.gif.frames[k].image;

        this.ctx.drawImage(image, this.x, this.y + obj.offset_y, image.width * obj.scale, image.height * obj.scale);

      } else {  // 反方向   通过调整坐标系来翻转方向

        this.ctx.save();

        this.ctx.scale(-1, 1);

        this.ctx.translate(-this.root.game_map.$canvas.width(), 0);

  

        let k = parseInt(this.frame_current_cnt / obj.frame_rate) % obj.frame_cnt;

        let image = obj.gif.frames[k].image;

        this.ctx.drawImage(image, this.root.game_map.$canvas.width() - this.width - this.x, this.y + obj.offset_y, image.width * obj.scale, image.height * obj.scale);  // 不同于正方向时的渲染，因为此时坐标系改变，需要在对称的位置渲染

  

        this.ctx.restore();

      }

    }

  

    if (status === 4 || status === 5 || status === 6) {  // 确保不会一直循环GIF

      if (this.frame_current_cnt === obj.frame_rate * (obj.frame_cnt - 1)) {  // 确保此时已经播放完一次GIF动画

        if (status === 6) {   // 死亡倒地不起，这里的 -- 和 下面的 ++ 相抵消，使之在最后一帧不再变化

          this.frame_current_cnt--;

        } else {

          this.status = 0;

        }

      }

    }

  

    this.frame_current_cnt++;

  }

}
</code></pre><p><code>js/player/kyo.js</code></p><pre tabindex=0><code>import { Player } from &#34;../player/base.js&#34;;

import {GIF} from &#39;../utils/gif.js&#39;

  

export class Kyo extends Player {

  constructor(root, info) {

    super(root, info);

  

    this.init_animations();   // 初始化动画

  }

  

  init_animations() {

    let outer = this;

    let offsets = [0, -22, -22, -150, 0, 0, 0];   // 偏移量 不同的动画高度不同，因此需要借助竖直方向上的偏移量将他们调整至同一水平面

    for (let i = 0; i &lt; 7; ++ i) {  // 7个动作

      let gif = GIF();

      gif.load(`/static/images/player/kyo/${i}.gif`);

      this.animations.set(i, {  // 动画

        gif: gif,

        frame_cnt: 0,  // GIF帧数

        frame_rate: 5,  // 每5帧过渡一次

        offset_y: offsets[i],  // y方向偏移量

        loaded: false,  // 是否加载完成

        scale: 2,  // 放大2倍

      });

  

      gif.onload = function() {   // 加载完成

        let obj = outer.animations.get(i);

        obj.frame_cnt = gif.frames.length;

        obj.loaded = true;

  

        if (i === 3) {  // 调整跳跃时GIF播放速率

          obj.frame_rate = 4;

        }

      }

    }

  }

}
</code></pre><h4 id=gif>GIF<a hidden class=anchor aria-hidden=true href=#gif>#</a></h4><ul><li><a href=https://stackoverflow.com/questions/48234696/how-to-put-a-gif-with-canvas/48348567#48348567>Loading and playing GIF image to canvas</a> 把玩家的<code>GIF</code>动画渲染在<code>canvas</code>上</li></ul><hr><p><code>js/utils/gif.js</code></p><pre tabindex=0><code>const GIF = function () {

  // **NOT** for commercial use.

  var timerID;                          // timer handle for set time out usage

  var st;                               // holds the stream object when loading.

  var interlaceOffsets = [0, 4, 2, 1]; // used in de-interlacing.

  var interlaceSteps = [8, 8, 4, 2];

  var interlacedBufSize;  // this holds a buffer to de interlace. Created on the first frame and when size changed

  var deinterlaceBuf;

  var pixelBufSize;    // this holds a buffer for pixels. Created on the first frame and when size changed

  var pixelBuf;

  const GIF_FILE = { // gif file data headers

    GCExt: 0xF9,

    COMMENT: 0xFE,

    APPExt: 0xFF,

    UNKNOWN: 0x01, // not sure what this is but need to skip it in parser

    IMAGE: 0x2C,

    EOF: 59,   // This is entered as decimal

    EXT: 0x21,

  };

  // simple buffered stream used to read from the file

  var Stream = function (data) {

      this.data = new Uint8ClampedArray(data);

      this.pos = 0;

      var len = this.data.length;

      this.getString = function (count) { // returns a string from current pos of len count

          var s = &#34;&#34;;

          while (count--) { s += String.fromCharCode(this.data[this.pos++]) }

          return s;

      };

      this.readSubBlocks = function () { // reads a set of blocks as a string

          var size, count, data = &#34;&#34;;

          do {

              count = size = this.data[this.pos++];

              while (count--) { data += String.fromCharCode(this.data[this.pos++]) }

          } while (size !== 0 &amp;&amp; this.pos &lt; len);

          return data;

      }

      this.readSubBlocksB = function () { // reads a set of blocks as binary

          var size, count, data = [];

          do {

              count = size = this.data[this.pos++];

              while (count--) { data.push(this.data[this.pos++]); }

          } while (size !== 0 &amp;&amp; this.pos &lt; len);

          return data;

      }

  };

  // LZW decoder uncompressed each frames pixels

  // this needs to be optimised.

  // minSize is the min dictionary as powers of two

  // size and data is the compressed pixels

  function lzwDecode(minSize, data) {

      var i, pixelPos, pos, clear, eod, size, done, dic, code, last, d, len;

      pos = pixelPos = 0;

      dic = [];

      clear = 1 &lt;&lt; minSize;

      eod = clear + 1;

      size = minSize + 1;

      done = false;

      while (!done) { // JavaScript optimisers like a clear exit though I never use &#39;done&#39; apart from fooling the optimiser

          last = code;

          code = 0;

          for (i = 0; i &lt; size; i++) {

              if (data[pos &gt;&gt; 3] &amp; (1 &lt;&lt; (pos &amp; 7))) { code |= 1 &lt;&lt; i }

              pos++;

          }

          if (code === clear) { // clear and reset the dictionary

              dic = [];

              size = minSize + 1;

              for (i = 0; i &lt; clear; i++) { dic[i] = [i] }

              dic[clear] = [];

              dic[eod] = null;

          } else {

              if (code === eod) { done = true; return }

              if (code &gt;= dic.length) { dic.push(dic[last].concat(dic[last][0])) }

              else if (last !== clear) { dic.push(dic[last].concat(dic[code][0])) }

              d = dic[code];

              len = d.length;

              for (i = 0; i &lt; len; i++) { pixelBuf[pixelPos++] = d[i] }

              if (dic.length === (1 &lt;&lt; size) &amp;&amp; size &lt; 12) { size++ }

          }

      }

  };

  function parseColourTable(count) { // get a colour table of length count  Each entry is 3 bytes, for RGB.

      var colours = [];

      for (var i = 0; i &lt; count; i++) { colours.push([st.data[st.pos++], st.data[st.pos++], st.data[st.pos++]]) }

      return colours;

  }

  function parse() {        // read the header. This is the starting point of the decode and async calls parseBlock

      var bitField;

      st.pos += 6;

      gif.width = (st.data[st.pos++]) + ((st.data[st.pos++]) &lt;&lt; 8);

      gif.height = (st.data[st.pos++]) + ((st.data[st.pos++]) &lt;&lt; 8);

      bitField = st.data[st.pos++];

      gif.colorRes = (bitField &amp; 0b1110000) &gt;&gt; 4;

      gif.globalColourCount = 1 &lt;&lt; ((bitField &amp; 0b111) + 1);

      gif.bgColourIndex = st.data[st.pos++];

      st.pos++;                    // ignoring pixel aspect ratio. if not 0, aspectRatio = (pixelAspectRatio + 15) / 64

      if (bitField &amp; 0b10000000) { gif.globalColourTable = parseColourTable(gif.globalColourCount) } // global colour flag

      setTimeout(parseBlock, 0);

  }

  function parseAppExt() { // get application specific data. Netscape added iterations and terminator. Ignoring that

      st.pos += 1;

      if (&#39;NETSCAPE&#39; === st.getString(8)) { st.pos += 8 }  // ignoring this data. iterations (word) and terminator (byte)

      else {

          st.pos += 3;            // 3 bytes of string usually &#34;2.0&#34; when identifier is NETSCAPE

          st.readSubBlocks();     // unknown app extension

      }

  };

  function parseGCExt() { // get GC data

      var bitField;

      st.pos++;

      bitField = st.data[st.pos++];

      gif.disposalMethod = (bitField &amp; 0b11100) &gt;&gt; 2;

      gif.transparencyGiven = bitField &amp; 0b1 ? true : false; // ignoring bit two that is marked as  userInput???

      gif.delayTime = (st.data[st.pos++]) + ((st.data[st.pos++]) &lt;&lt; 8);

      gif.transparencyIndex = st.data[st.pos++];

      st.pos++;

  };

  function parseImg() {                           // decodes image data to create the indexed pixel image

      var deinterlace, frame, bitField;

      deinterlace = function (width) {                   // de interlace pixel data if needed

          var lines, fromLine, pass, toline;

          lines = pixelBufSize / width;

          fromLine = 0;

          if (interlacedBufSize !== pixelBufSize) {      // create the buffer if size changed or undefined.

              deinterlaceBuf = new Uint8Array(pixelBufSize);

              interlacedBufSize = pixelBufSize;

          }

          for (pass = 0; pass &lt; 4; pass++) {

              for (toLine = interlaceOffsets[pass]; toLine &lt; lines; toLine += interlaceSteps[pass]) {

                  deinterlaceBuf.set(pixelBuf.subarray(fromLine, fromLine + width), toLine * width);

                  fromLine += width;

              }

          }

      };

      frame = {}

      gif.frames.push(frame);

      frame.disposalMethod = gif.disposalMethod;

      frame.time = gif.length;

      frame.delay = gif.delayTime * 10;

      gif.length += frame.delay;

      if (gif.transparencyGiven) { frame.transparencyIndex = gif.transparencyIndex }

      else { frame.transparencyIndex = undefined }

      frame.leftPos = (st.data[st.pos++]) + ((st.data[st.pos++]) &lt;&lt; 8);

      frame.topPos = (st.data[st.pos++]) + ((st.data[st.pos++]) &lt;&lt; 8);

      frame.width = (st.data[st.pos++]) + ((st.data[st.pos++]) &lt;&lt; 8);

      frame.height = (st.data[st.pos++]) + ((st.data[st.pos++]) &lt;&lt; 8);

      bitField = st.data[st.pos++];

      frame.localColourTableFlag = bitField &amp; 0b10000000 ? true : false;

      if (frame.localColourTableFlag) { frame.localColourTable = parseColourTable(1 &lt;&lt; ((bitField &amp; 0b111) + 1)) }

      if (pixelBufSize !== frame.width * frame.height) { // create a pixel buffer if not yet created or if current frame size is different from previous

          pixelBuf = new Uint8Array(frame.width * frame.height);

          pixelBufSize = frame.width * frame.height;

      }

      lzwDecode(st.data[st.pos++], st.readSubBlocksB()); // decode the pixels

      if (bitField &amp; 0b1000000) {                        // de interlace if needed

          frame.interlaced = true;

          deinterlace(frame.width);

      } else { frame.interlaced = false }

      processFrame(frame);                               // convert to canvas image

  };

  function processFrame(frame) { // creates a RGBA canvas image from the indexed pixel data.

      var ct, cData, dat, pixCount, ind, useT, i, pixel, pDat, col, frame, ti;

      frame.image = document.createElement(&#39;canvas&#39;);

      frame.image.width = gif.width;

      frame.image.height = gif.height;

      frame.image.ctx = frame.image.getContext(&#34;2d&#34;);

      ct = frame.localColourTableFlag ? frame.localColourTable : gif.globalColourTable;

      if (gif.lastFrame === null) { gif.lastFrame = frame }

      useT = (gif.lastFrame.disposalMethod === 2 || gif.lastFrame.disposalMethod === 3) ? true : false;

      if (!useT) { frame.image.ctx.drawImage(gif.lastFrame.image, 0, 0, gif.width, gif.height) }

      cData = frame.image.ctx.getImageData(frame.leftPos, frame.topPos, frame.width, frame.height);

      ti = frame.transparencyIndex;

      dat = cData.data;

      if (frame.interlaced) { pDat = deinterlaceBuf }

      else { pDat = pixelBuf }

      pixCount = pDat.length;

      ind = 0;

      for (i = 0; i &lt; pixCount; i++) {

          pixel = pDat[i];

          col = ct[pixel];

          if (ti !== pixel) {

              dat[ind++] = col[0];

              dat[ind++] = col[1];

              dat[ind++] = col[2];

              dat[ind++] = 255;      // Opaque.

          } else

              if (useT) {

                  dat[ind + 3] = 0; // Transparent.

                  ind += 4;

              } else { ind += 4 }

      }

      frame.image.ctx.putImageData(cData, frame.leftPos, frame.topPos);

      gif.lastFrame = frame;

      if (!gif.waitTillDone &amp;&amp; typeof gif.onload === &#34;function&#34;) { doOnloadEvent() }// if !waitTillDone the call onload now after first frame is loaded

  };

  // **NOT** for commercial use.

  function finnished() { // called when the load has completed

      gif.loading = false;

      gif.frameCount = gif.frames.length;

      gif.lastFrame = null;

      st = undefined;

      gif.complete = true;

      gif.disposalMethod = undefined;

      gif.transparencyGiven = undefined;

      gif.delayTime = undefined;

      gif.transparencyIndex = undefined;

      gif.waitTillDone = undefined;

      pixelBuf = undefined; // dereference pixel buffer

      deinterlaceBuf = undefined; // dereference interlace buff (may or may not be used);

      pixelBufSize = undefined;

      deinterlaceBuf = undefined;

      gif.currentFrame = 0;

      if (gif.frames.length &gt; 0) { gif.image = gif.frames[0].image }

      doOnloadEvent();

      if (typeof gif.onloadall === &#34;function&#34;) {

          (gif.onloadall.bind(gif))({ type: &#39;loadall&#39;, path: [gif] });

      }

      if (gif.playOnLoad) { gif.play() }

  }

  function canceled() { // called if the load has been cancelled

      finnished();

      if (typeof gif.cancelCallback === &#34;function&#34;) { (gif.cancelCallback.bind(gif))({ type: &#39;canceled&#39;, path: [gif] }) }

  }

  function parseExt() {              // parse extended blocks

      const blockID = st.data[st.pos++];

      if (blockID === GIF_FILE.GCExt) { parseGCExt() }

      else if (blockID === GIF_FILE.COMMENT) { gif.comment += st.readSubBlocks() }

      else if (blockID === GIF_FILE.APPExt) { parseAppExt() }

      else {

          if (blockID === GIF_FILE.UNKNOWN) { st.pos += 13; } // skip unknow block

          st.readSubBlocks();

      }

  

  }

  function parseBlock() { // parsing the blocks

      if (gif.cancel !== undefined &amp;&amp; gif.cancel === true) { canceled(); return }

  

      const blockId = st.data[st.pos++];

      if (blockId === GIF_FILE.IMAGE) { // image block

          parseImg();

          if (gif.firstFrameOnly) { finnished(); return }

      } else if (blockId === GIF_FILE.EOF) { finnished(); return }

      else { parseExt() }

      if (typeof gif.onprogress === &#34;function&#34;) {

          gif.onprogress({ bytesRead: st.pos, totalBytes: st.data.length, frame: gif.frames.length });

      }

      setTimeout(parseBlock, 0); // parsing frame async so processes can get some time in.

  };

  function cancelLoad(callback) { // cancels the loading. This will cancel the load before the next frame is decoded

      if (gif.complete) { return false }

      gif.cancelCallback = callback;

      gif.cancel = true;

      return true;

  }

  function error(type) {

      if (typeof gif.onerror === &#34;function&#34;) { (gif.onerror.bind(this))({ type: type, path: [this] }) }

      gif.onload = gif.onerror = undefined;

      gif.loading = false;

  }

  function doOnloadEvent() { // fire onload event if set

      gif.currentFrame = 0;

      gif.nextFrameAt = gif.lastFrameAt = new Date().valueOf(); // just sets the time now

      if (typeof gif.onload === &#34;function&#34;) { (gif.onload.bind(gif))({ type: &#39;load&#39;, path: [gif] }) }

      gif.onerror = gif.onload = undefined;

  }

  function dataLoaded(data) { // Data loaded create stream and parse

      st = new Stream(data);

      parse();

  }

  function loadGif(filename) { // starts the load

      var ajax = new XMLHttpRequest();

      ajax.responseType = &#34;arraybuffer&#34;;

      ajax.onload = function (e) {

          if (e.target.status === 404) { error(&#34;File not found&#34;) }

          else if (e.target.status &gt;= 200 &amp;&amp; e.target.status &lt; 300) { dataLoaded(ajax.response) }

          else { error(&#34;Loading error : &#34; + e.target.status) }

      };

      ajax.open(&#39;GET&#39;, filename, true);

      ajax.send();

      ajax.onerror = function (e) { error(&#34;File error&#34;) };

      this.src = filename;

      this.loading = true;

  }

  function play() { // starts play if paused

      if (!gif.playing) {

          gif.paused = false;

          gif.playing = true;

          playing();

      }

  }

  function pause() { // stops play

      gif.paused = true;

      gif.playing = false;

      clearTimeout(timerID);

  }

  function togglePlay() {

      if (gif.paused || !gif.playing) { gif.play() }

      else { gif.pause() }

  }

  function seekFrame(frame) { // seeks to frame number.

      clearTimeout(timerID);

      gif.currentFrame = frame % gif.frames.length;

      if (gif.playing) { playing() }

      else { gif.image = gif.frames[gif.currentFrame].image }

  }

  function seek(time) { // time in Seconds  // seek to frame that would be displayed at time

      clearTimeout(timerID);

      if (time &lt; 0) { time = 0 }

      time *= 1000; // in ms

      time %= gif.length;

      var frame = 0;

      while (time &gt; gif.frames[frame].time + gif.frames[frame].delay &amp;&amp; frame &lt; gif.frames.length) { frame += 1 }

      gif.currentFrame = frame;

      if (gif.playing) { playing() }

      else { gif.image = gif.frames[gif.currentFrame].image }

  }

  function playing() {

      var delay;

      var frame;

      if (gif.playSpeed === 0) {

          gif.pause();

          return;

      } else {

          if (gif.playSpeed &lt; 0) {

              gif.currentFrame -= 1;

              if (gif.currentFrame &lt; 0) { gif.currentFrame = gif.frames.length - 1 }

              frame = gif.currentFrame;

              frame -= 1;

              if (frame &lt; 0) { frame = gif.frames.length - 1 }

              delay = -gif.frames[frame].delay * 1 / gif.playSpeed;

          } else {

              gif.currentFrame += 1;

              gif.currentFrame %= gif.frames.length;

              delay = gif.frames[gif.currentFrame].delay * 1 / gif.playSpeed;

          }

          gif.image = gif.frames[gif.currentFrame].image;

          timerID = setTimeout(playing, delay);

      }

  }

  var gif = {                      // the gif image object

      onload: null,       // fire on load. Use waitTillDone = true to have load fire at end or false to fire on first frame

      onerror: null,       // fires on error

      onprogress: null,       // fires a load progress event

      onloadall: null,       // event fires when all frames have loaded and gif is ready

      paused: false,      // true if paused

      playing: false,      // true if playing

      waitTillDone: true,       // If true onload will fire when all frames loaded, if false, onload will fire when first frame has loaded

      loading: false,      // true if still loading

      firstFrameOnly: false,      // if true only load the first frame

      width: null,       // width in pixels

      height: null,       // height in pixels

      frames: [],         // array of frames

      comment: &#34;&#34;,         // comments if found in file. Note I remember that some gifs have comments per frame if so this will be all comment concatenated

      length: 0,          // gif length in ms (1/1000 second)

      currentFrame: 0,          // current frame.

      frameCount: 0,          // number of frames

      playSpeed: 1,          // play speed 1 normal, 2 twice 0.5 half, -1 reverse etc...

      lastFrame: null,       // temp hold last frame loaded so you can display the gif as it loads

      image: null,       // the current image at the currentFrame

      playOnLoad: true,       // if true starts playback when loaded

      // functions

      load: loadGif,    // call this to load a file

      cancel: cancelLoad, // call to stop loading

      play: play,       // call to start play

      pause: pause,      // call to pause

      seek: seek,       // call to seek to time

      seekFrame: seekFrame,  // call to seek to frame

      togglePlay: togglePlay, // call to toggle play and pause state

  };

  return gif;

}

  

export {

  GIF

}
</code></pre><h4 id=状态机>状态机<a hidden class=anchor aria-hidden=true href=#状态机>#</a></h4><center><img style="border-radius:.3125em;box-shadow:0 2px 4px rgba(34,36,38,.12),0 2px 10px rgba(34,36,38,8%)" src=https://bu.dusays.com/2022/11/03/6363d89220c15.png><br><div style="color:orange;border-bottom:1px solid #d9d9d9;display:inline-block;color:#999;padding:2px">0：静止 1：移动 3：跳跃 4：攻击</div></center><h2 id=myspace>MySpace<a hidden class=anchor aria-hidden=true href=#myspace>#</a></h2><ul><li><a href=https://github.com/Xancoding/Learning-Vue>MySpace</a></li><li><a href=https://www.acwing.com/video/3867/>AcWing Web 应用课 | Vue3——网站整体布局、用户动态页面 | Vedio</a></li><li><a href=https://www.acwing.com/video/3875/>AcWing Web 应用课 | Vue3——用户列表、登录、注册页面 | Vedio</a></li></ul><hr></div><footer class=post-footer><ul class=post-tags><li><a href=https://xancoding.cn/tags/tech/>Tech</a></li><li><a href=https://xancoding.cn/tags/acwing/>AcWing</a></li><li><a href=https://xancoding.cn/tags/web/>Web</a></li><li><a href=https://xancoding.cn/tags/%E6%96%B0%E6%8A%80%E8%83%BD/>新技能</a></li></ul><nav class=paginav><a class=prev href=https://xancoding.cn/posts/2022-11-14-15-56-45/><span class=title>« Prev</span><br><span>Self-study</span>
</a><a class=next href=https://xancoding.cn/posts/2022-10-30-15-28-22/><span class=title>Next »</span><br><span>Output message</span></a></nav></footer><div><div class=pagination__title><span class=pagination__title-h style=font-size:20px>💬评论</span><hr></div><div id=tcomment></div><script src=https://cdn.staticfile.org/twikoo/1.6.7/twikoo.all.min.js></script><script>twikoo.init({envId:"https://twikoo.xancoding.cn/",el:"#tcomment",lang:"zh-CN",region:"ap-beijing",path:window.TWIKOO_MAGIC_PATH||window.location.pathname})</script></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://xancoding.cn/>Xan's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>