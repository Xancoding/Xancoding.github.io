<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Learning C++ | Xan's Blog</title><meta name=keywords content="Tech,C++,新技能"><meta name=description content="C++ 基础：函数和文件 函数返回值 C++标准只定义了3种状态码的含义：0、EXIT_SUCCESS、EXIT_FAILURE。 0 和 EXIT_SUCCESS 都表示程序执行"><meta name=author content="
作者:&nbsp;Xan"><link rel=canonical href=https://xancoding.cn/posts/2022-11-15-12-54-07/><link crossorigin=anonymous href=/assets/css/stylesheet.3aa01cbced85ddebdb26eab94916f476145cedd3e7231731a39f34d88d6f410a.css integrity="sha256-OqAcvO2F3evbJuq5SRb0dhRc7dPnIxcxo5802I1vQQo=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://xancoding.cn/img/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://xancoding.cn/img/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://xancoding.cn/img/favicon.ico><link rel=apple-touch-icon href=https://xancoding.cn/img/favicon.ico><link rel=mask-icon href=https://xancoding.cn/img/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["[[","]]"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"})</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style><link rel=stylesheet href=//cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.css><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Learning C++"><meta property="og:description" content="C++ 基础：函数和文件 函数返回值 C++标准只定义了3种状态码的含义：0、EXIT_SUCCESS、EXIT_FAILURE。 0 和 EXIT_SUCCESS 都表示程序执行"><meta property="og:type" content="article"><meta property="og:url" content="https://xancoding.cn/posts/2022-11-15-12-54-07/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-11-15T12:54:07+08:00"><meta property="article:modified_time" content="2022-11-15T12:54:07+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Learning C++"><meta name=twitter:description content="C++ 基础：函数和文件 函数返回值 C++标准只定义了3种状态码的含义：0、EXIT_SUCCESS、EXIT_FAILURE。 0 和 EXIT_SUCCESS 都表示程序执行"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://xancoding.cn/posts/"},{"@type":"ListItem","position":3,"name":"Learning C++","item":"https://xancoding.cn/posts/2022-11-15-12-54-07/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Learning C++","name":"Learning C\u002b\u002b","description":"C++ 基础：函数和文件 函数返回值 C++标准只定义了3种状态码的含义：0、EXIT_SUCCESS、EXIT_FAILURE。 0 和 EXIT_SUCCESS 都表示程序执行","keywords":["Tech","C++","新技能"],"articleBody":"C++ 基础：函数和文件 函数返回值 C++标准只定义了3种状态码的含义：0、EXIT_SUCCESS、EXIT_FAILURE。 0 和 EXIT_SUCCESS 都表示程序执行成功。 EXIT_FAILURE 表示程序没有成功执行\nEXIT_SUCCESS 和 EXIT_FAILURE 是 标头中定义的预处理器宏：\n#include // for EXIT_SUCCESS and EXIT_FAILURE int main() { return EXIT_SUCCESS; } 如果你想最大限度地提高可移植性，你应该只使用 0 或 EXIT_SUCCESS 来指示成功终止，或者使用 EXIT_FAILURE 来指示不成功终止\ninclude 头文件顺序 在 C++ 中，头文件的顺序通常应该遵循以下顺序：\nC 标准库头文件（如 ） C++ 标准库头文件（如 ） 第三方库头文件（如 Boost） 项目特定的头文件（如自定义的头文件） 这样的顺序可以避免头文件之间的依赖关系问题，同时也可以更快地查找问题。\nThe headers for each grouping should be sorted alphabetically（按字母顺序排序）.\n这个顺序并不是强制的，主要取决于项目的需要和编程风格。\nHeader file best practices 始终 include header guards 不要在头文件中定义变量和函数（全局常量是一个例外） 为头文件指定与其关联的源文件相同的名称（例如，grades.h 与 grades.cpp 配对） 每个头文件应该有一个特定的工作，并且尽可能独立。例如，您可以将与功能 A 相关的所有声明放在 A.h 中，将与功能 B 相关的所有声明放在 B.h 中。这样如果你以后只关心 A，你可以只 include A.h 而不会得到任何与 B 相关的东西 请注意您需要为代码文件中使用的功能显式包含哪些 header 您编写的每个 header 都应该自行编译（它应该#include 它需要的每个依赖项） 仅 #include 您需要的内容（不要仅仅因为可以就包含所有内容） 不要#include .cpp 文件 预处理器 在编译之前，代码文件会经历一个称为翻译的阶段。翻译阶段会发生很多事情，让您的代码准备好进行编译（如果您好奇，可以在此处找到翻译阶段列表）。应用了翻译的代码文件称为翻译单元\n最值得注意的翻译阶段涉及预处理器。预处理器最好被认为是一个单独的程序，它可以处理每个代码文件中的文本\n当预处理器运行时，它会扫描代码文件（从上到下），寻找预处理器指令。预处理程序指令（通常简称为 指令（Directives））是以# 符号开头并以换行符（不是分号）结尾的指令。这些指令告诉预处理器执行某些文本操作任务。请注意，预处理器不理解 C++ 语法——相反，指令有自己的语法（在某些情况下类似于 C++ 语法，而在其他情况下，则不太相似）\n请注意，预处理器不会以任何方式修改原始代码文件——相反，预处理器所做的所有文本更改都会在每次编译代码文件时临时发生在内存中或使用临时文件\nIncludes 当您 #include 一个文件时，预处理器会用 include 文件的内容替换 #include 指令。然后对 include 的内容进行预处理（连同文件的其余部分），然后进行编译\nMacro defines #define 指令可用于创建 宏\n有两种基本类型的宏：类对象宏和类函数宏\n类函数宏的行为类似于函数，并且具有相似的目的。它们的使用通常被认为是危险的，它们几乎可以做的任何事情都可以通过一个正常的函数来完成\n类对象宏可以通过以下两种方式之一定义：\n#define identifier #define identifier substitution_text 替换文本的类对象宏被用作（在 C 中）将名称分配给文字的一种方式。这不再是必需的，因为 C++ 中提供了更好的方法（Const 变量和符号常量）。带有替换文本的类对象宏现在通常只能在遗留代码中看到\n没有替换文本的类对象宏：标识符的任何进一步出现都将被删除并被替换为任何东西！\n与带有替换文本的类对象宏不同，这种形式的宏通常被认为可以使用。\nConditional compilation 条件编译预处理器指令允许您指定在什么条件下编译或不编译。有很多不同的条件编译指令，但我们在这里只介绍目前使用最多的三个：#ifdef、#ifndef 和 #endif\n#ifdef 预处理器指令允许预处理器检查标识符是否先前已被#defined。如果是，编译 #ifdef 和匹配的 #endif 之间的代码。如果不是，代码将被忽略\n考虑以下程序：\n#include #define PRINT_JOE int main() { #ifdef PRINT_JOE std::cout \u003c\u003c \"Joe\\n\"; // will be compiled since PRINT_JOE is defined #endif #ifdef PRINT_BOB std::cout \u003c\u003c \"Bob\\n\"; // will be ignored since PRINT_BOB is not defined #endif return 0; } 因为 PRINT_JOE 已被 #defined，std::cout \u003c\u003c \"Joe\\n\" 行将被编译。因为 PRINT_BOB 尚未被 #defined，std::cout \u003c\u003c \"Bob\\n\" 行将被忽略\n#ifndef 与 #ifdef 相反，因为它允许您检查标识符是否尚未 #defined\n#include int main() { #ifndef PRINT_BOB std::cout \u003c\u003c \"Bob\\n\"; #endif return 0; } 该程序打印 “Bob”，因为 PRINT_BOB 从未被 #defined\n条件编译的一个更常见的用途是使用 #if 0 将代码块排除在编译之外（就像它在注释块中一样）：\n#include int main() { std::cout \u003c\u003c \"Joe\\n\"; #if 0 // Don't compile anything starting here std::cout \u003c\u003c \"Bob\\n\"; std::cout \u003c\u003c \"Steve\\n\"; #endif // until this point return 0; } 这也提供了一种方便的方法来**“注释掉”包含多行注释的代码**（由于多行注释是不可嵌套的，因此不能使用另一个多行注释来注释掉）：\n#include int main() { std::cout \u003c\u003c \"Joe\\n\"; #if 0 // Don't compile anything starting here std::cout \u003c\u003c \"Bob\\n\"; /* Some * multi-line * comment here */ std::cout \u003c\u003c \"Steve\\n\"; #endif // until this point return 0; } 类对象宏不影响其他预处理器指令，宏只会导致普通代码的文本替换。其他预处理器命令将被忽略\n#define FOO 9 // Here's a macro substitution #ifdef FOO // This FOO does not get replaced because it’s part of another preprocessor directive std::cout \u003c\u003c FOO; // This FOO gets replaced with 9 because it's part of the normal code #endif 指令在编译前解析，逐个文件地从上到下解析\n#include void foo() { #define MY_NAME \"Alex\" } int main() { std::cout \u003c\u003c \"My name is: \" \u003c\u003c MY_NAME; return 0; } 即使看起来 #define MY_NAME “Alex” 是在函数 foo 中定义的，预处理器也不会注意到，因为它不理解像函数这样的 C++ 概念。因此，该程序的行为与 #define MY_NAME “Alex” 在函数 foo 之前或之后立即定义的程序相同。为了一般的可读性，您通常希望在函数之外 #define 标识符\n预处理器完成后，该文件中所有定义的标识符都将被丢弃。这意味着指令仅从定义点到定义它们的文件末尾有效。一个代码文件中定义的指令不会影响同一项目中的其他代码文件\n考虑以下示例：\nfunction.cpp:\n#include void doSomething() { #ifdef PRINT std::cout \u003c\u003c \"Printing!\"; #endif #ifndef PRINT std::cout \u003c\u003c \"Not printing!\"; #endif } main.cpp:\nvoid doSomething(); // forward declaration for function doSomething() #define PRINT int main() { doSomething(); return 0; } 上面的程序会打印：\nNot printing! 尽管 PRINT 是在 main.cpp 中定义的，但这对 function.cpp 中的任何代码都没有任何影响（PRINT 只是从定义点到 main.cpp 末尾的 #defined）\n如何完成你的第一个程序 Design（设计） 定义目标。将此表示为面向用户的结果通常很有用，例如： 允许用户组织姓名和相关电话号码的列表 模拟球从塔上掉落到地面需要多长时间 定义需求。既指您的解决方案需要遵守的约束（例如预算、时间线、空间、内存等），也指程序为满足用户需求而必须展示的能力。请注意，您的要求同样应该关注“什么”，而不是“如何”。例如： 应保存电话号码，以便日后调用 用户应该能够输入塔的高度 定义您的工具、目标和备份计划 定义您的程序将运行的目标架构 和/或 操作系统 确定您将使用的工具集 确定您是单独编写程序还是作为团队的一部分编写程序’ 定义您的测试/反馈/发布策略 确定您将如何备份您的代码 将困难问题分解为简单问题。如果发现其中一个项目（功能）太难实现，只需将该项目拆分为多个子项目/子功能。最终，您应该达到程序中的每个功能都可以轻松实现的地步 弄清楚事件的顺序 Implementation（实现） 概述您的主要功能。 int main() { // Get first number from user // getUserInput(); // Get mathematical operation from user // getMathematicalOperation(); // Get second number from user // getUserInput(); // Calculate result // calculateResult(); // Print result // printResult(); return 0; } 实现各个功能。对于每个函数，您将做三件事： 定义函数原型（输入和输出） 编写函数 测试功能 最终测试。一旦你的程序“完成”，最后一步就是测试整个程序并确保它按预期工作。如果它不起作用，请修复它 Words of advice when writing programs（忠告） Keep your programs simple to start.让你的第一个目标尽可能简单，一些你绝对可以实现的目标 Add features over time.一旦您的简单程序运行良好并且运行良好，您就可以向其添加功能 Focus on one area at a time.不要试图一次编写所有代码，也不要将注意力分散到多个任务上。一次专注于一项任务 Test each piece of code as you go.编写一段代码，然后立即编译并测试它。如果它不起作用，您将确切地知道问题出在哪里，并且很容易修复。确定代码有效后，移至下一段并重复。完成代码的编写可能需要更长的时间，但是当您完成后，整个事情应该可以正常工作，并且您不必花费两倍的时间来弄清楚为什么它不起作用 Don’t invest in perfecting early code.让你的功能最低限度地工作，然后继续。不要以完美为目标——重要的程序从来都不是完美的，而且总有更多的事情可以做来改进它们。达到“足够好”并继续前进 调试 C++ 程序 调试过程 找到问题的根本原因（通常是不起作用的代码行） 确保您了解问题发生的原因 确定您将如何解决问题 修复问题 重新测试以确保问题已解决并且没有出现新问题 调试策略 观察程序运行时的行为，并尝试从中诊断问题\n弄清楚如何重现问题 运行程序并收集信息以缩小问题所在的范围 重复前面的步骤，直到找到问题 调试策略 1：注释掉你的代码 如果您的程序表现出错误行为，减少必须搜索的代码量的一种方法是注释掉一些代码并查看问题是否仍然存在。如果问题仍然存在，则注释掉的代码不负责任\n调试策略 2：验证代码流 另一个在更复杂的程序中常见的问题是程序调用一个函数的次数太多或太少（包括根本不调用）\n在这种情况下，将语句放在函数的顶部以打印函数的名称会很有帮助。这样，当程序运行时，您可以看到调用了哪些函数\n当出于调试目的打印信息时，使用 std::cerr 而不是 std::cout。这样做的一个原因是 std::cout 可能被缓冲，这意味着在您要求 std::cout 输出信息和它实际输出信息之间可能会有一个暂停。如果您使用 std::cout 进行输出，然后您的程序随后立即崩溃，则 std::cout 可能已经或可能还没有实际输出。这可能会误导您了解问题出在哪里。另一方面，std::cerr 是无缓冲1的，这意味着您发送给它的任何内容都会立即输出。这有助于确保所有调试输出尽快出现（以一些性能为代价，我们在调试时通常不关心）\n使用 std::cerr 还有助于明确输出的信息是针对错误情况而不是正常情况\n添加临时调试语句时，不缩进它们会很有帮助。这使它们更容易在以后找到并移除\n#include int getValue() { std::cerr \u003c\u003c \"getValue() called\\n\"; return 4; } int main() { std::cerr \u003c\u003c \"main() called\\n\"; std::cout \u003c\u003c getValue; return 0; } 调试策略 3：打印值 对于某些类型的错误，程序可能会计算或传递错误的值。\n我们还可以输出变量（包括参数）或表达式的值，以确保它们是正确的。\nFor example:\n#include int add(int x, int y) { std::cerr \u003c\u003c \"add() called (x=\" \u003c\u003c x \u003c\u003c\", y=\" \u003c\u003c y \u003c\u003c \")\\n\"; return x + y; } void printResult(int z) { std::cout \u003c\u003c \"The answer is: \" \u003c\u003c z \u003c\u003c '\\n'; } int getUserInput() { std::cout \u003c\u003c \"Enter a number: \"; int x{}; std::cin \u003e\u003e x; return x; } int main() { int x{ getUserInput() }; std::cerr \u003c\u003c \"main::x = \" \u003c\u003c x \u003c\u003c '\\n'; int y{ getUserInput() }; std::cerr \u003c\u003c \"main::y = \" \u003c\u003c y \u003c\u003c '\\n'; std::cout \u003c\u003c x \u003c\u003c \" + \" \u003c\u003c y \u003c\u003c '\\n'; int z{ add(x, 5) }; std::cerr \u003c\u003c \"main::z = \" \u003c\u003c z \u003c\u003c '\\n'; printResult(z); return 0; } 现在我们将得到输出：\nEnter a number: 4 main::x = 4 Enter a number: 3 main::y = 3 add() called (x=4, y=5) main::z = 9 The answer is: 9 虽然为诊断目的向程序添加调试语句是一种常见的基本技术，也是一种功能性技术（尤其是当调试器由于某种原因不可用时），但由于多种原因它并不是很好：\n调试语句使您的代码混乱。 调试语句使程序的输出混乱。 调试语句必须在完成后删除，这使得它们不可重用。 调试语句需要修改您的代码以添加和删除，这可能会引入新的错误。 条件化调试代码 一种更容易在整个程序中禁用和启用调试的方法是使用预处理器指令使调试语句有条件：\n#include #define ENABLE_DEBUG // comment out to disable debugging int getUserInput() { #ifdef ENABLE_DEBUG std::cerr \u003c\u003c \"getUserInput() called\\n\"; #endif std::cout \u003c\u003c \"Enter a number: \"; int x{}; std::cin \u003e\u003e x; return x; } int main() { #ifdef ENABLE_DEBUG std::cerr \u003c\u003c \"main() called\\n\"; #endif int x{ getUserInput() }; std::cout \u003c\u003c \"You entered: \" \u003c\u003c x; return 0; } 现在我们可以通过注释/取消注释#define ENABLE_DEBUG 来启用调试。这使我们能够重用以前添加的调试语句，然后在用完它们后将它们禁用，而不必从代码中实际删除它们\n这解决了必须删除调试语句的问题以及这样做的风险，但代价是代码更加混乱。这种方法的另一个缺点是，如果您输入错误（例如拼错“DEBUG”）或忘记将标头包含到代码文件中，则可能无法启用该文件的部分或全部调试\n使用日志 通过预处理器进行条件化调试的另一种方法是将调试信息发送到日志文件。日志文件是记录软件中发生的事件的文件（通常存储在磁盘上）。将信息写入日志文件的过程称为日志记录。大多数应用程序和操作系统都会写入可用于帮助诊断发生的问题的日志文件\n日志文件有几个优点。因为写入日志文件的信息与程序的输出是分开的，所以可以避免将正常输出和调试输出混合在一起造成的混乱。日志文件也可以很容易地发送给其他人进行诊断——所以如果有人使用你的软件有问题，你可以让他们把日志文件发给你，这可能会帮助你找到问题所在的线索\n虽然您可以编写自己的代码来创建日志文件并将输出发送给它们，但最好还是使用许多现有的第三方日志记录工具之一\nUsing the plog logger：\n#include #include // Step 1: include the logger headers #include int getUserInput() { PLOGD \u003c\u003c \"getUserInput() called\"; // PLOGD is defined by the plog library std::cout \u003c\u003c \"Enter a number: \"; int x{}; std::cin \u003e\u003e x; return x; } int main() { plog::init(plog::debug, \"Logfile.txt\"); // Step 2: initialize the logger PLOGD \u003c\u003c \"main() called\"; // Step 3: Output to the log as if you were writing to the console int x{ getUserInput() }; std::cout \u003c\u003c \"You entered: \" \u003c\u003c x; return 0; } 这是上述记录器的输出（在 Logfile.txt 文件中）：\n2018-12-26 20:03:33.295 DEBUG [4752] [main@14] main() called 2018-12-26 20:03:33.296 DEBUG [4752] [getUserInput@4] getUserInput() called 您如何包含、初始化和使用记录器将根据您选择的特定记录器而有所不同\n请注意，使用此方法也不需要条件编译指令，因为大多数记录器都有减少/消除将输出写入日志的方法。这使得代码更容易阅读，因为条件编译行增加了很多混乱。使用 plog，可以通过将 init 语句更改为以下内容来暂时禁用日志记录：\nplog::init(plog::none , \"Logfile.txt\"); // plog::none eliminates writing of most messages, essentially turning logging off 使用集成调试器：Stepping（步进） 当您运行您的程序时，执行从 main 函数的顶部开始，然后逐个语句按顺序执行，直到程序结束。在你的程序运行的任何时间点，程序都在跟踪很多事情：你正在使用的变量的值，调用了哪些函数（这样当这些函数返回时，程序就会知道在哪里返回），以及程序中的当前执行点（因此它知道接下来要执行哪个语句）。所有这些跟踪信息都称为您的程序状态（或简称为状态）\nStepping 是一组相关调试器功能的名称，这些功能让我们逐条语句地执行（单步执行）我们的代码\n箭头标记表示接下来将执行所指向的行\nStep into 步入 命令执行程序正常执行路径中的下一条语句，然后暂停程序的执行，以便我们可以使用调试器检查程序的状态。如果正在执行的语句包含一个函数调用，step into 会使程序跳转到被调用函数的顶部，并在那里暂停\nStep over 同步入命令一样，步过命令执行程序正常执行路径中的下一条语句。然而，step into 将输入函数调用并逐行执行它们，step over 将不间断地执行整个函数，并在函数执行后将控制权返回给您\nstep over 命令提供了一种方便的方法来跳过函数，当您确定它们已经工作或现在对调试它们不感兴趣时\nStep out 与其他两个步进命令不同，步出 命令不只是执行下一行代码。相反，它执行当前正在执行的函数中的所有剩余代码，然后在函数返回时将控制权返回给您\n当你不小心进入了一个你不想调试的函数时，这个命令最有用\n使用集成调试器：Running and breakpoints（运行和断点） Run to cursor 第一个有用的命令通常称为运行到光标。此运行到光标命令执行程序，直到执行到达光标选择的语句。然后它将控制权返回给您，以便您可以从那时开始进行调试\nBreakpoints 断点 是一个特殊的标记，它告诉调试器在调试模式下运行时在断点处停止执行程序\n使用集成调试器：调用堆栈 调用堆栈是为到达当前执行点而调用的所有活动函数的列表。调用堆栈包括每个调用的函数的条目，以及函数返回时将返回到哪一行代码。每当调用一个新函数时，该函数就会被添加到调用堆栈的顶部。当前函数返回给调用者时，它会从调用栈的顶部移除，控制权会返回到它下面的函数\n调用堆栈窗口是一个显示当前调用堆栈的调试器窗口\n函数名称后的行号显示了每个函数中要执行的下一行\n由于调用堆栈的顶部条目代表当前正在执行的函数，因此此处的行号显示了执行恢复时将执行的下一行。调用堆栈中的其余条目表示将在某个时间点返回的函数，因此这些条目的行号表示函数返回后将执行的下一条语句\n在问题成为问题之前发现问题 重构你的代码 当您向程序添加新功能（“行为更改”）时，您会发现某些功能的长度会增加。随着函数越来越长，它们变得越来越复杂，也越来越难以理解\n解决此问题的一种方法是将单个长函数分解为多个较短的函数。这种在不改变代码行为的情况下对代码进行结构更改的过程（通常是为了使您的程序更有组织性、模块化或性能）称为重构\n一个函数占据一个垂直屏幕的代码通常被认为太长了——如果你必须滚动才能阅读整个函数，函数的可理解性会显着下降。但越短越好 – 少于十行的功能是好的。少于五行的函数就更好了\n更改代码时，进行行为更改或结构更改，然后重新测试正确性。同时进行行为和结构更改往往会导致更多错误以及更难发现的错误\n约束 基于约束的技术涉及添加一些额外的代码（如果需要，可以在非调试构建中编译出来）以检查是否违反了某些假设或期望集\n例如，如果我们正在编写一个函数来计算一个数字的阶乘，它需要一个非负参数，该函数可以检查以确保调用者在继续之前传递了一个非负数。如果调用者传入一个负数，那么该函数可能会立即出错，而不是产生一些不确定的结果，从而有助于确保立即发现问题\n一种常见的方法是通过 assert 和 static_assert\n基本数据类型 数据类型大小 数据类型的大小取决于编译器和计算机体系结构！\nC++ 仅保证每个基本数据类型都具有最小大小 为了获得最大的兼容性，您不应假设变量大于指定的最小大小\n#include int main() { std::cout \u003c\u003c \"bool:\\t\\t\" \u003c\u003c sizeof(bool) \u003c\u003c \" bytes\\n\"; std::cout \u003c\u003c \"char:\\t\\t\" \u003c\u003c sizeof(char) \u003c\u003c \" bytes\\n\"; std::cout \u003c\u003c \"wchar_t:\\t\" \u003c\u003c sizeof(wchar_t) \u003c\u003c \" bytes\\n\"; std::cout \u003c\u003c \"char16_t:\\t\" \u003c\u003c sizeof(char16_t) \u003c\u003c \" bytes\\n\"; std::cout \u003c\u003c \"char32_t:\\t\" \u003c\u003c sizeof(char32_t) \u003c\u003c \" bytes\\n\"; std::cout \u003c\u003c \"short:\\t\\t\" \u003c\u003c sizeof(short) \u003c\u003c \" bytes\\n\"; std::cout \u003c\u003c \"int:\\t\\t\" \u003c\u003c sizeof(int) \u003c\u003c \" bytes\\n\"; std::cout \u003c\u003c \"long:\\t\\t\" \u003c\u003c sizeof(long) \u003c\u003c \" bytes\\n\"; std::cout \u003c\u003c \"long long:\\t\" \u003c\u003c sizeof(long long) \u003c\u003c \" bytes\\n\"; std::cout \u003c\u003c \"float:\\t\\t\" \u003c\u003c sizeof(float) \u003c\u003c \" bytes\\n\"; std::cout \u003c\u003c \"double:\\t\\t\" \u003c\u003c sizeof(double) \u003c\u003c \" bytes\\n\"; std::cout \u003c\u003c \"long double:\\t\" \u003c\u003c sizeof(long double) \u003c\u003c \" bytes\\n\"; return 0; } 下面是我的 x64 机器的输出，使用 Clion：\nbool: 1 bytes char: 1 bytes wchar_t: 2 bytes char16_t: 2 bytes char32_t: 4 bytes short: 2 bytes int: 4 bytes long: 4 bytes long long: 8 bytes float: 4 bytes double: 8 bytes long double: 16 bytes 如果您使用不同类型的机器或不同的编译器，您的结果可能会有所不同。请注意，您不能对 void 类型使用 sizeof 运算符，因为它没有大小（这样做会导致编译错误）\n无符号整数和有符号整数 有符号整数范围： 无符号整数范围： 如果无符号整数超出范围，则将其除以大于该类型的最大数，只保留余数\n在 C++ 的数学运算中（例如算术或比较），如果使用一个有符号整数和一个无符号整数，则有符号整数将转换为无符号整数。并且无符号整数不能存储负数，这会导致数据丢失\n在保存整数（甚至应该是非负的整数）和数学运算时，有符号数优于无符号数。避免混合有符号和无符号数字\n在 C++ 中仍然有一些情况必须使用无符号数：\n首先，在处理位操作时首选无符号数。当需要明确定义的环绕行为时，它们也很有用（在某些算法中很有用，例如加密和随机数生成）\n其次，无符号数的使用在某些情况下仍然是不可避免的，主要是那些与数组索引有关的情况。。在这些情况下，无符号值可以转换为有符号值\n固定宽度整数和 size_t Fixed-width 整数 为什么整数变量的大小不固定？\n这可以追溯到 C，当时计算机速度很慢，性能是最受关注的问题。 C 选择有意保留整数的大小，以便编译器实现者可以选择在目标计算机体系结构上表现最佳的 int 大小\nC99 定义了一组固定宽度的整数（在 stdint.h 头文件中），保证在任何体系结构上都具有相同的大小\nC++ 正式采用这些固定宽度整数作为 C++11 的一部分。可以通过包含 头文件来访问它们，它们在 std 命名空间内定义\nFast and least 整数 The fast 类型（std::int_fast#_t 和 std::uint_fast#_t）提供最快的有符号/无符号整数类型，宽度至少为 # 位（其中 # = 8、16、32 或 64）。例如，std::int_fast32_t 将为您提供最快的至少 32 位的有符号整数类型\nThe least 类型（std::int_least#_t 和 std::uint_least#_t）提供宽度至少为 # 位（其中 # = 8、16、32 或 64）的最小有符号/无符号整数类型。例如，std::uint_least32_t 将为您提供至少 32 位的最小无符号整数类型\n示例：\n#include // for fixed-width integers #include int main() { std::cout \u003c\u003c \"least 8: \" \u003c\u003c sizeof(std::int_least8_t) * 8 \u003c\u003c \" bits\\n\"; std::cout \u003c\u003c \"least 16: \" \u003c\u003c sizeof(std::int_least16_t) * 8 \u003c\u003c \" bits\\n\"; std::cout \u003c\u003c \"least 32: \" \u003c\u003c sizeof(std::int_least32_t) * 8 \u003c\u003c \" bits\\n\"; std::cout \u003c\u003c '\\n'; std::cout \u003c\u003c \"fast 8: \" \u003c\u003c sizeof(std::int_fast8_t) * 8 \u003c\u003c \" bits\\n\"; std::cout \u003c\u003c \"fast 16: \" \u003c\u003c sizeof(std::int_fast16_t) * 8 \u003c\u003c \" bits\\n\"; std::cout \u003c\u003c \"fast 32: \" \u003c\u003c sizeof(std::int_fast32_t) * 8 \u003c\u003c \" bits\\n\"; return 0; } Result：\nleast 8: 8 bits least 16: 16 bits least 32: 32 bits fast 8: 8 bits fast 16: 16 bits fast 32: 32 bits 然而，这些快速且最小的整数有其自身的缺点：首先，真正使用它们的程序员并不多，不熟悉会导致错误。其次，快速类型会导致与我们在 4 字节整数中看到的相同类型的内存浪费。最严重的是，由于快速/最小整数的大小可能会有所不同，因此您的程序可能会在解析为不同大小的架构上表现出不同的行为\nstd::int8_t 和 std::uint8_t 可能表现得像字符而不是整数 由于 C++ 规范中的疏忽，大多数编译器分别将 std::int8_t 和 std::uint8_t（以及相应的快速和最小固定宽度类型）定义为 signed char 和 unsigned char 类型，并将其视为相同的类型。这意味着这些 8 位类型的行为可能（或可能不）与其他固定宽度类型不同，这可能会导致错误。此行为是系统相关的，因此在一种体系结构上正确运行的程序可能无法编译或在另一种体系结构上正确运行\n为了保持一致性，最好完全避免使用 std::int8_t 和 std::uint8_t（以及相关的快速和最少类型）（改用 std::int16_t 或 std::uint16_t）\n8 位固定宽度整数类型通常被视为字符而不是整数值（这可能因系统而异）。大多数情况下首选 16 位固定整数类型\nBest practice 我们的立场是正确比快速更好，在编译时失败比运行时更好——因此，我们建议避免使用快速/最少的类型，而使用固定宽度的类型。如果您后来发现需要支持无法编译固定宽度类型的平台，那么您可以在此时决定如何迁移您的程序（并彻底测试）\n当整数的大小无关紧要时，首选 int（例如，数字将始终适合 2 字节有符号整数的范围）。例如，如果您要求用户输入他们的年龄，或者从 1 数到 10，则 int 是 16 位还是 32 位都没有关系（数字将适合任何一种方式）。这将涵盖您可能遇到的绝大多数情况 存储需要保证范围的数量时，首选 std::int#_t 在进行位操作或需要明确定义的环绕行为时，首选 std::uint#_t 尽可能避免以下情况： 存储数量的无符号类型 8 位固定宽度整数类型 Fast and least 整数类型 任何特定于编译器的固定宽度整数——例如，Visual Studio 定义了 __int8、__int16 …… size_t sizeof（以及许多返回大小或长度值的函数）返回一个 std::size_t 类型的值。 std::size_t 被定义为无符号整数类型，通常用于表示对象的大小或长度\n有趣的是，我们可以使用 sizeof 运算符（返回 std::size_t 类型的值）来询问 std::size_t 本身的大小：\n#include // std::size_t #include int main() { std::cout \u003c\u003c sizeof(std::size_t) \u003c\u003c '\\n'; return 0; } 就像整数的大小会因系统而异一样，std::size_t 的大小也会有所不同。 std::size_t 保证为无符号且至少为 16 位，但在大多数系统上将等同于应用程序的地址宽度。也就是说，对于 32 位应用程序，std::size_t 通常是 32 位无符号整数，而对于 64 位应用程序，size_t 通常是 64 位无符号整数。 size_t 被定义为足够大以容纳系统上可创建的最大对象的大小（以字节为单位）。例如，如果 std::size_t 为 4 字节宽，则系统上可创建的最大对象不能大于 4,294,967,295 字节，因为 4,294,967,295 是 4 字节无符号整数可以存储的最大数字。这只是对象大小的上限，实际大小限制可能会更低，具体取决于您使用的编译器\n根据定义，任何大小（以字节为单位）大于 size_t 可以容纳的最大整数值的对象都被视为格式错误（并将导致编译错误），因为 sizeof 运算符将无法在不环绕的情况下返回大小\n浮点数（IEEE 754） 浮点范围和浮点精度 使用浮点文字时，始终至少包含一位小数（即使小数为 0）。这有助于编译器理解该数字是浮点数而不是整数\nint x{5}; // 5 means integer double y{5.0}; // 5.0 is a floating point literal (no suffix means double type by default) float z{5.0f}; // 5.0 is a floating point literal, f suffix means float type 始终确保字面量的类型与分配给它们或用于初始化的变量的类型相匹配。否则会导致不必要的转换，可能会导致精度损失\n确保在应该使用浮点文字的地方不使用整数文字。这包括初始化浮点对象或为浮点对象赋值、进行浮点运算以及调用需要浮点值的函数\n输出浮点数时，std::cout 的默认精度为 6——也就是说，它假定所有浮点变量仅对 6 位有效（浮点数的最小精度），因此它将截断之后的任何内容\n浮点变量的精度位数取决于大小（浮点数的精度低于双精度数）和存储的特定值（某些值的精度高于其他值）。浮点值的精度在 6 到 9 位之间，大多数浮点值至少有 7 位有效数字。双精度值的精度在 15 到 18 位之间，大多数双精度值至少有 16 位有效数字。 Long double 的最小精度为 15、18 或 33 位有效数字，具体取决于它占用的字节数\n舍入误差 我们可以使用名为 std::setprecision() 的输出操纵器函数覆盖 std::cout 显示的默认精度。输出操纵器改变数据的输出方式，并在 iomanip 标头中定义\n#include #include // for output manipulator std::setprecision() int main() { std::cout \u003c\u003c std::setprecision(16); // show 16 digits of precision std::cout \u003c\u003c 3.33333333333333333333333333333333333333f \u003c\u003c'\\n'; // f suffix means float std::cout \u003c\u003c 3.33333333333333333333333333333333333333 \u003c\u003c '\\n'; // no suffix means double return 0; } 在使用需要比变量所能容纳的精度更高的浮点数时，必须小心\n除非空间非常宝贵，否则最好使用 double over float，因为 float 缺乏精度通常会导致不准确\n值 123456789.0 具有 10 位有效数字，但浮点值通常具有 7 位精度（而 123456792 的结果仅精确到 7 位有效数字）。我们失去了一些精度！当由于无法精确存储数字而导致精度丢失时，这称为舍入误差\n数学运算（例如加法和乘法）往往会使舍入误差增大。所以即使0.1在第17位有效位有舍入误差，但是当我们加上0.1十次时，舍入误差已经爬到第16位有效位了。继续操作会导致此错误变得越来越严重\nNaN 和 Inf 有两种特殊类别的浮点数。第一个是 Inf，代表无穷大。 Inf 可以是正数或负数。第二个是 NaN，代表“不是数字”。有几种不同类型的 NaN（我们不会在这里讨论）。 NaN 和 Inf 仅在编译器对浮点数使用特定格式 (IEEE 754) 时可用\nConclusion 总而言之，关于浮点数你应该记住两件事：\n浮点数对于存储非常大或非常小的数字很有用，包括带有小数部分的数字\n浮点数通常有小的舍入误差，即使数字的有效数字少于精度也是如此。很多时候这些都没有引起注意，因为它们太小了，而且因为输出的数字被截断了。但是，浮点数的比较可能不会给出预期的结果。对这些值执行数学运算将导致舍入误差变大\n布尔值 如果您希望 std::cout 打印“true”或“false”而不是 0 或 1，您可以使用 std::boolalpha。这是一个例子：\n#include int main() { std::cout \u003c\u003c true \u003c\u003c '\\n'; std::cout \u003c\u003c false \u003c\u003c '\\n'; std::cout \u003c\u003c std::boolalpha; // print bools as true or false std::cout \u003c\u003c true \u003c\u003c '\\n'; std::cout \u003c\u003c false \u003c\u003c '\\n'; return 0; } 您可以使用 std::noboolalpha 将其关闭\n您不能使用除 0 1 外的整数初始化布尔值：\n#include int main() { bool b{ 4 }; // error: narrowing conversions disallowed std::cout \u003c\u003c b; return 0; } 但是，在任何可以将整数转换为布尔值的上下文中，整数 0 将转换为 false，而任何其他整数将转换为 true\n事实证明，std::cin 只接受布尔变量的两个输入：0 和 1（不是 true 或 false）。任何其他输入都会导致 std::cin 无声地失败。在这种情况下，因为我们输入了 true，所以 std::cin 默默地失败了。失败的输入也会将变量清零，因此 b 也被赋值 false。因此，当 std::cout 打印 b 的值时，它打印 0\n要允许 std::cin 接受“false”和“true”作为输入，必须启用 std::boolalpha 选项：\n#include int main() { bool b{}; std::cout \u003c\u003c \"Enter a boolean value: \"; // Allow the user to enter 'true' or 'false' for boolean values // This is case-sensitive, so True or TRUE will not work std::cin \u003e\u003e std::boolalpha; std::cin \u003e\u003e b; std::cout \u003c\u003c \"You entered: \" \u003c\u003c b \u003c\u003c '\\n'; return 0; } 但是，当启用 std::boolalpha 时，“0”和“1”将不再被视为布尔值\nChars char 数据类型旨在保存单个字符。字符可以是单个字母、数字、符号或空格\nchar 数据类型是整数类型，这意味着基础值存储为整数。类似于布尔值 0 被解释为 false 而非零被解释为 true 的方式，char 变量存储的整数被解释为 ASCII 字符\nChar 由 C++ 定义为大小始终为 1 个字节。默认情况下，char 可以是有符号的或无符号的（尽管它通常是有符号的）。如果您使用 chars 来保存 ASCII 字符，则不需要指定符号（因为有符号和无符号字符都可以保存 0 到 127 之间的值）\n如果您使用 char 来保存小整数（除非您明确优化空间，否则您不应该这样做），您应该始终指定它是有符号的还是无符号的。 signed char 可以保存 -128 到 127 之间的数字。unsigned char 可以保存 0 到 255 之间的数字\n将单个字符放在单引号中（ e.g. 't' or '\\n', not \"t\" or \"\\n\"）这有助于编译器更有效地进行优化\n出于向后兼容性的原因，许多 C++ 编译器支持多字符文字，即包含多个字符（例如“56”）的字符文字。如果支持，它们具有实现定义的值（意味着它因编译器而异）。因为它们不是 C++ 标准的一部分，而且它们的值也没有严格定义，所以应该避免使用多字符文字\nASCII 之外最著名的映射是 Unicode 标准，它将超过 144,000 个整数映射到许多不同语言的字符。由于 Unicode 包含如此多的代码点，因此单个 Unicode 代码点需要 32 位来表示一个字符（称为 UTF-32）。但是，Unicode 字符也可以使用多个 16 位或 8 位字符（分别称为 UTF-16 和 UTF-8）进行编码\nchar16_t 和 char32_t 添加到 C++11 以提供对 16 位和 32 位 Unicode 字符的明确支持。 C++20 中添加了 char8_t\n您不需要使用 char8_t、char16_t 或 char32_t，除非您计划让您的程序与 Unicode 兼容\n同时，在处理字符（和字符串）时，您应该只使用 ASCII 字符。使用来自其他字符集的字符可能会导致您的字符显示不正确\n常量和符号常量 const variables Const 变量必须在定义它们时进行初始化，然后不能通过赋值更改该值\nConst 变量可以从其他变量（包括非常量变量）初始化\n命名时以 “k” 开头, 大小写混合,例如：\nconst int kDaysInAWeek = 7; 符号常量 符号常量指的是被赋予常量值的名称。const variables 是一种符号常量，因为变量有一个名称（它的标识符）和一个常量值\n#include #define MAX_STUDENTS_PER_CLASS 30 int main() { std::cout \u003c\u003c \"The class has \" \u003c\u003c MAX_STUDENTS_PER_CLASS \u003c\u003c \" students.\\n\"; return 0; } 编译此程序时，预处理器会将 MAX_STUDENTS_PER_CLASS 替换为字面值 30，然后编译器会将其编译为您的可执行文件\n因为类对象宏有一个名字，并且替换文本是一个常量值，所以带有替换文本的类对象宏也是符号常量\n对于符号常量，更喜欢常量变量而不是类对象宏 首先，因为宏是由预处理器解析的，所有出现的宏都在编译之前被定义的值替换。如果您正在调试代码，您将看不到实际值（例如 30）——您只会看到符号常量的名称（例如 MAX_STUDENTS_PER_CLASS）。因为这些#defined 值不是变量，所以您无法在调试器中添加监视来查看它们的值。如果您想知道 MAX_STUDENTS_PER_CLASS 解析为什么值，您必须找到 MAX_STUDENTS_PER_CLASS 的定义（可能在不同的文件中）。这会使您的程序更难调试\n其次，宏可能与普通代码有命名冲突\n第三，宏不遵循正常的作用域规则，这意味着在极少数情况下，在程序的一部分中定义的宏可能会与在程序的另一部分中编写的代码发生冲突，而它不应该与之交互\n编译时常量、常量表达式和 constexpr Constant expressions 常量表达式是可以在编译时由编译器求值的表达式。要成为常量表达式，表达式中的所有值必须在编译时已知（并且所有调用的运算符和函数必须支持编译时求值）\n在编译时对常量表达式求值会使我们的编译时间变长（因为编译器必须做更多的工作），但这样的表达式只需要求值一次（而不是每次程序运行时）。生成的可执行文件速度更快，使用的内存更少\nCompile-time constants 编译时常量是其值在编译时已知的常量。文字（例如“1”、“2.3”和“Hello, world!”）是一种编译时常量\nConst 变量可能是也可能不是编译时常量\nCompile-time const 如果 const 变量的初始值设定项是常量表达式，则它是编译时常量\n#include int main() { const int x { 3 }; // x is a compile-time const const int y { 4 }; // y is a compile-time const const int z { x + y }; // x + y is a compile-time expression std::cout \u003c\u003c z \u003c\u003c '\\n'; return 0; } 因为 x 和 y 的初始化值是常量表达式，所以 x 和 y 是编译时常量。这意味着 x + y 也是常量表达式。所以当编译器编译这个程序时，它可以计算 x + y 的值，并将常量表达式替换为结果文字 7\nRuntime const 任何使用非常量表达式初始化的 const 变量都是运行时常量。运行时常量是其初始化值直到运行时才知道的常量\n#include int getNumber() { std::cout \u003c\u003c \"Enter a number: \"; int y{}; std::cin \u003e\u003e y; return y; } int main() { const int x{ 3 }; // x is a compile time constant const int y{ getNumber() }; // y is a runtime constant const int z{ x + y }; // x + y is a runtime expression std::cout \u003c\u003c z \u003c\u003c '\\n'; // this is also a runtime expression return 0; } 即使 y 是常量，初始化值（getNumber() 的返回值）直到运行时才知道。因此，y 是运行时常量，而不是编译时常量。因此，表达式 x + y 是一个运行时表达式\nconstexpr 关键字 当你声明一个 const 变量时，编译器会隐式地跟踪它是运行时常量还是编译时常量。在大多数情况下，除了优化目的之外，这无关紧要，但有一些奇怪的情况，C++ 需要编译时常量而不是运行时常量\n因为编译时常量通常允许更好的优化（并且几乎没有缺点），所以我们通常希望尽可能使用编译时常量\n我们可以寻求编译器的帮助，以确保我们得到一个我们期望的编译时常量。为此，我们在变量声明中使用 constexpr 关键字而不是 const。 constexpr（“常量表达式”的缩写）变量只能是编译时常量。如果 constexpr 变量的初始化值不是常量表达式，编译器会出错\n#include int five() { return 5; } int main() { constexpr double gravity { 9.8 }; // ok: 9.8 is a constant expression constexpr int sum { 4 + 5 }; // ok: 4 + 5 is a constant expression constexpr int something { sum }; // ok: sum is a constant expression std::cout \u003c\u003c \"Enter your age: \"; int age{}; std::cin \u003e\u003e age; constexpr int myAge { age }; // compile error: age is not a constant expression constexpr int f { five() }; // compile error: return value of five() is not a constant expression return 0; } 任何在初始化后不应修改且其初始值设定项在编译时已知的变量都应声明为 constexpr\n任何在初始化后不应修改且其初始值设定项在编译时未知的变量都应声明为 const\nLiterals 文字是直接插入代码中的未命名值。例如：\nreturn 5; // 5 is an integer literal bool myNameIsAlex { true }; // true is a boolean literal std::cout \u003c\u003c 3.4; // 3.4 is a double literal 如对象有类型一样，所有文字都有类型。文字的类型是从文字的值推导出来的\n十进制、二进制、十六进制和八进制 二进制文字和数字分隔符 在 C++14 之前，不支持二进制文字。然而，十六进制文字为我们提供了一个有用的解决方法（您可能仍会在现有代码库中看到）：\n#include int main() { int bin{}; // assume 16-bit ints bin = 0x0001; // assign binary 0000 0000 0000 0001 to the variable bin = 0x0002; // assign binary 0000 0000 0000 0010 to the variable bin = 0x0004; // assign binary 0000 0000 0000 0100 to the variable bin = 0x0008; // assign binary 0000 0000 0000 1000 to the variable bin = 0x0010; // assign binary 0000 0000 0001 0000 to the variable bin = 0x0020; // assign binary 0000 0000 0010 0000 to the variable bin = 0x0040; // assign binary 0000 0000 0100 0000 to the variable bin = 0x0080; // assign binary 0000 0000 1000 0000 to the variable bin = 0x00FF; // assign binary 0000 0000 1111 1111 to the variable bin = 0x00B3; // assign binary 0000 0000 1011 0011 to the variable bin = 0xF770; // assign binary 1111 0111 0111 0000 to the variable return 0; } 在 C++14 中，我们可以通过使用 0b 前缀来使用二进制文字：\n#include int main() { int bin{}; // assume 16-bit ints bin = 0b1; // assign binary 0000 0000 0000 0001 to the variable bin = 0b11; // assign binary 0000 0000 0000 0011 to the variable bin = 0b1010; // assign binary 0000 0000 0000 1010 to the variable bin = 0b11110000; // assign binary 0000 0000 1111 0000 to the variable return 0; } 由于长文本可能难以阅读，C++14 还添加了使用引号 (‘) 作为数字分隔符的功能（分隔符不能出现在值的第一位数字之前）（数字分隔符纯粹是视觉上的，不会以任何方式影响字面值）\n#include int main() { int bin { 0b1011'0010 }; // assign binary 1011 0010 to the variable long value { 2'132'673'462 }; // much easier to read than 2132673462 return 0; } 以十进制、八进制或十六进制输出值 默认情况下，C++ 以十进制形式输出值。但是，您可以通过使用 std::dec、std::oct 和 std::hex I/O 操纵器更改输出格式：\n#include int main() { int x { 12 }; std::cout \u003c\u003c x \u003c\u003c '\\n'; // decimal (by default) std::cout \u003c\u003c std::hex \u003c\u003c x \u003c\u003c '\\n'; // hexadecimal std::cout \u003c\u003c x \u003c\u003c '\\n'; // now hexadecimal std::cout \u003c\u003c std::oct \u003c\u003c x \u003c\u003c '\\n'; // octal std::cout \u003c\u003c std::dec \u003c\u003c x \u003c\u003c '\\n'; // return to decimal std::cout \u003c\u003c x \u003c\u003c '\\n'; // decimal return 0; } 以二进制输出值 以二进制形式输出值有点困难，因为 std::cout 没有内置此功能。幸运的是，C++ 标准库包含一个名为 std::bitset 的类型，它将为我们完成此操作（在 标头中）。要使用 std::bitset，我们可以定义一个 std::bitset 变量并告诉 std::bitset 我们要存储多少位。位数必须是编译时常量。 std::bitset 可以用无符号整数值（任何格式，包括十进制、八进制、十六进制或二进制）初始化\n#include // for std::bitset #include int main() { // std::bitset\u003c8\u003e means we want to store 8 bits std::bitset\u003c8\u003e bin1{ 0b1100'0101 }; // binary literal for binary 1100 0101 std::bitset\u003c8\u003e bin2{ 0xC5 }; // hexadecimal literal for binary 1100 0101 std::cout \u003c\u003c bin1 \u003c\u003c '\\n' \u003c\u003c bin2 \u003c\u003c '\\n'; std::cout \u003c\u003c std::bitset\u003c4\u003e{ 0b1010 } \u003c\u003c '\\n'; // create a temporary std::bitset and print it return 0; } std::string 使用 std::getline() 输入文本 事实证明，当使用 operator» 从 std::cin 中提取字符串时，operator» 只返回它遇到的第一个空格之前的字符。任何其他字符都留在 std::cin 中，等待下一次提取\n要将整行输入读入字符串，最好改用 std::getline() 函数。 std::getline() 需要两个参数：第一个是 std::cin，第二个是您的字符串变量\n#include // For std::string and std::getline #include int main() { std::cout \u003c\u003c \"Enter your full name: \"; std::string name{}; std::getline(std::cin \u003e\u003e std::ws, name); // read a full line of text into name std::cout \u003c\u003c \"Enter your age: \"; std::string age{}; std::getline(std::cin \u003e\u003e std::ws, age); // read a full line of text into age std::cout \u003c\u003c \"Your name is \" \u003c\u003c name \u003c\u003c \" and your age is \" \u003c\u003c age \u003c\u003c '\\n'; return 0; } std::ws 输入操纵器告诉 std::cin 在提取之前忽略任何前导空格。前导空白是出现在字符串开头的任何空白字符（空格、制表符、换行符）\n如果使用 std::getline() 读取字符串，请使用 std::cin \u003e\u003e std::ws 输入操纵器忽略前导空格\n将提取运算符 (») 与 std::cin 一起使用会忽略前导空格\nstd::getline() 不会忽略前导空格，除非您使用输入操纵器 std::ws\n字符串长度 如果我们想知道 std::string 中有多少个字符，我们可以向 std::string 对象询问它的长度。注意 std::string::length() 返回一个无符号整数值（很可能是 size_t 类型）。如果你想将长度分配给一个 int 变量，你应该对其进行 static_cast 以避免编译器关于有符号/无符号转换的警告：\nint length { static_cast\u003cint\u003e(name.length()) }; std::string 的初始化和复制开销很大 每当初始化 std::string 时，都会生成用于初始化它的字符串的副本。每当 std::string 按值传递给 std::string 参数时，都会生成另一个副本。不要按值传递 std::string，因为生成 std::string 的副本开销很大。更喜欢 std::string_view 参数\nLiterals for std::string \u0026 std::string_view 双引号字符串文字（比如“Hello, world!”）默认是 C 风格的字符串\n我们可以通过在双引号字符串文字后使用 s 后缀来创建类型为 std::string 的字符串文字\n#include #include // for std::string #include // for std::string_view int main() { using namespace std::literals; // easiest way to access the s and sv suffixes std::cout \u003c\u003c \"foo\\n\"; // no suffix is a C-style string literal std::cout \u003c\u003c \"goo\\n\"s; // s suffix is a std::string literal std::cout \u003c\u003c \"moo\\n\"sv; // sv suffix is a std::string_view literal return 0; } “s”后缀位于命名空间 std::literals::string_literals 中。“sv”后缀位于命名空间 std::literals::string_view_literals 中。访问文字后缀的最简单方法是通过使用指令使用命名空间 std::literals。这是可以使用整个命名空间的例外情况之一，因为其中定义的后缀不太可能与您的任何代码冲突\n你可能不需要经常使用 std::string 文字（因为用 C 风格的字符串文字初始化 std::string 对象很好），但我们会在以后的课程中看到一些使用 std 的情况::string literals 而不是 C 风格的 string literals 使事情变得更容易\nConstexpr 字符串 如果您尝试定义一个 constexpr std::string，您的编译器可能会产生一个错误\n#include #include using namespace std::literals; int main() { constexpr std::string name{ \"Alex\"s }; // compile error std::cout \u003c\u003c \"My name is: \" \u003c\u003c name; return 0; } 发生这种情况是因为 constexpr std::string 在 C++17 或更早版本中不受支持，并且在 C++20 中仅提供最低限度的支持。如果您需要 constexpr 字符串，请改用 std::string_view\nstd::string_view std::string_view C++17 为了解决 std::string 初始化（或复制）成本高昂的问题，C++17 引入了 std::string_view（位于 标头中）。 std::string_view 提供对现有字符串（C 风格字符串文字、std::string 或 char 数组）的只读访问，而无需制作副本\n#include #include void printSV(std::string_view str) // now a std::string_view { std::cout \u003c\u003c str \u003c\u003c '\\n'; } int main() { std::string_view s{ \"Hello, world!\" }; // now a std::string_view printSV(s); return 0; } 当我们用 C 风格的字符串文字“Hello, world!”初始化 std::string_view s 时，s 提供对“Hello, world!”的只读访问。无需复制字符串。当我们将 s 传递给 printSV() 时，参数 str 从 s 初始化。这使我们能够通过 str 访问“Hello, world!”，不用再次复制字符串\n当您需要只读字符串时，尤其是对于函数参数，优先使用 std::string_view 而不是 std::string\nconstexpr std::string_view std::string_view 完全支持 constexpr：\n#include #include int main() { constexpr std::string_view s{ \"Hello, world!\" }; std::cout \u003c\u003c s \u003c\u003c '\\n'; // s will be replaced with \"Hello, world!\" at compile-time return 0; } std::string \u0026 std::string_view 可以使用 std::string 初始值设定项创建 std::string_view，并且 std::string 将隐式转换为 std::string_view：\n#include #include #include void printSV(std::string_view str) { std::cout \u003c\u003c str \u003c\u003c '\\n'; } int main() { std::string s{ \"Hello, world\" }; std::string_view sv{ s }; // Initialize a std::string_view from a std::string std::cout \u003c\u003c sv \u003c\u003c '\\n'; printSV(s); // implicitly convert a std::string to std::string_view return 0; } 因为 std::string 复制了它的初始化器（这开销很大），C++ 不允许将 std::string_view 隐式转换为 std::string。但是，我们可以使用 std::string_view 初始值设定项显式创建 std::string，或者我们可以使用 static_cast 将现有的 std::string_view 转换为 std::string\n#include #include #include void printString(std::string str) { std::cout \u003c\u003c str \u003c\u003c '\\n'; } int main() { std::string_view sv{ \"balloon\" }; std::string str{ sv }; // okay, we can create std::string using std::string_view initializer // printString(sv); // compile error: won't implicitly convert std::string_view to a std::string printString(static_cast(sv)); // okay, we can explicitly cast a std::string_view to a std::string return 0; } Operators（操作符） , \u0026 ? : 运算符 C++ 没有定义函数参数或运算符操作数的计算顺序\n不要在给定语句中多次使用具有副作用的变量。如果这样做，结果可能是未定义的\n逗号在所有运算符中的优先级最低，甚至低于赋值\n请注意， ? : 运算符的优先级非常低。如果除了将结果分配给变量之外做任何事情，整个 ? : 运算符也需要用括号括起来\nstd::cout \u003c\u003c ((x \u003e y) ? x : y) \u003c\u003c '\\n'; 如果在上述情况下我们不将整个条件运算符括起来会发生什么。因为 « 运算符的优先级高于 ?: 运算符，所以语句：\nstd::cout \u003c\u003c (x \u003e y) ? x : y \u003c\u003c '\\n'; 将评估为：\n(std::cout \u003c\u003c (x \u003e y)) ? x : y \u003c\u003c '\\n'; 比较浮点数大小 进行浮点相等的最常见方法涉及使用一个函数来查看两个数字是否几乎相同。如果它们“足够接近”，那么我们称它们相等。用于表示“足够接近”的值传统上称为 epsilon。 Epsilon 通常被定义为一个小的正数（例如 0.00000001，有时写作 1e-8）\n#include // for std::abs() // epsilon is an absolute value bool approximatelyEqualAbs(double a, double b, double absEpsilon) { // if the distance between a and b is less than absEpsilon, then a and b are \"close enough\" return std::abs(a - b) \u003c= absEpsilon; } 虽然这个功能可以工作，但不是很好。 0.00001 的 epsilon 适用于 1.0 左右的输入，对于 0.0000001 左右的输入太大，对于 10,000 这样的输入太小\n著名计算机科学家唐纳德·高德纳 (Donald Knuth) 在他的著作“计算机编程的艺术，第二卷：半数值算法 (Addison-Wesley, 1969)”一书中提出了以下方法：\n#include // std::max #include // std::abs // return true if the difference between a and b is within epsilon percent of the larger of a and b bool approximatelyEqualRel(double a, double b, double relEpsilon) { return (std::abs(a - b) \u003c= (std::max(std::abs(a), std::abs(b)) * relEpsilon)); } 在这种情况下，epsilon 不是绝对数字，而是相对于 a 或 b 的大小。在 \u003c= 运算符的左侧，std::abs(a - b) 告诉我们 a 和 b 之间的距离为正数。在 \u003c= 运算符的右侧，我们需要计算我们愿意接受的“足够接近”的最大值。为此，该算法选择 a 和 b 中较大的一个（作为数字总体大小的粗略指标），然后将其乘以 relEpsilon。在此函数中，relEpsilon 表示百分比。例如，如果我们想说“足够接近”意味着 a 和 b 在 a 和 b 中较大者的 1% 以内，我们传入 0.01 (1% = 1/100 = 0.01) 的 relEpsilon。 relEpsilon 的值可以根据情况调整为最合适的值（例如，0.002 的 epsilon 表示在 0.2% 以内）\n要执行不等式 (!=) 而不是相等，只需调用此函数并使用逻辑 NOT 运算符 (!) 翻转结果：\nif (!approximatelyEqualRel(a, b, 0.001)) std::cout \u003c\u003c a \u003c\u003c \" is not equal to \" \u003c\u003c b \u003c\u003c '\\n'; 虽然 approximatelyEqualRel() 函数适用于大多数情况，但它并不完美，尤其是当数字接近零时：\n#include #include #include // return true if the difference between a and b is within epsilon percent of the larger of a and b bool approximatelyEqualRel(double a, double b, double relEpsilon) { return (std::abs(a - b) \u003c= (std::max(std::abs(a), std::abs(b)) * relEpsilon)); } int main() { // a is really close to 1.0, but has rounding errors, so it's slightly smaller than 1.0 double a{ 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 }; // First, let's compare a (almost 1.0) to 1.0. std::cout \u003c\u003c approximatelyEqualRel(a, 1.0, 1e-8) \u003c\u003c '\\n'; // Second, let's compare a-1.0 (almost 0.0) to 0.0 std::cout \u003c\u003c approximatelyEqualRel(a-1.0, 0.0, 1e-8) \u003c\u003c '\\n'; } 这会返回：\n1 0 避免这种情况的一种方法是同时使用绝对 epsilon（如我们在第一种方法中所做的）和相对 epsilon（如我们在 Knuth 的方法中所做的）：\n// return true if the difference between a and b is less than absEpsilon, or within relEpsilon percent of the larger of a and b bool approximatelyEqualAbsRel(double a, double b, double absEpsilon, double relEpsilon) { // Check if the numbers are really close -- needed when comparing numbers near zero. double diff{ std::abs(a - b) }; if (diff \u003c= absEpsilon) return true; // Otherwise fall back to Knuth's algorithm return (diff \u003c= (std::max(std::abs(a), std::abs(b)) * relEpsilon)); } 在这个算法中，我们首先检查 a 和 b 在绝对值上是否接近，这处理了 a 和 b 都接近于零的情况。 absEpsilon 参数应设置为非常小的值（例如 1e-12）。如果失败，则我们使用相对 epsilon 回退到 Knuth 的算法\n浮点数的比较是一个困难的话题，并且没有适用于所有情况的“一刀切”算法。但是，absEpsilon 为 1e-12 和 relEpsilon 为 1e-8 的 approximatesEqualAbsRel() 应该足以处理您将遇到的大多数情况\n逻辑 XOR 运算符 C++ 不提供逻辑 XOR 运算符。与逻辑或或逻辑与不同，逻辑异或不能进行短路评估。因此，从逻辑 OR 和逻辑 AND 运算符中创建逻辑 XOR 运算符具有挑战性。但是，您可以使用不等运算符 (!=) 轻松模拟逻辑 XOR：\nif (a != b) ... // a XOR b, assuming a and b are Booleans 这可以扩展到多个操作数，如下所示：\nif (a != b != c != d) ... // a XOR b XOR c XOR d, assuming a, b, c, and d are Booleans 请注意，上述 XOR 模式仅在操作数为布尔值（而非整数）时才有效。如果您需要一种适用于非布尔操作数的逻辑 XOR 形式，您可以将它们静态转换为布尔值：\nif (static_cast\u003cbool\u003e(a) != static_cast\u003cbool\u003e(b) != static_cast\u003cbool\u003e(c) != static_cast\u003cbool\u003e(d)) ... // a XOR b XOR c XOR d, for any type that can be converted to bool 位操作 位标志 and 位操作 via std::bitset 要定义一组位标志，我们通常会使用适当大小的无符号整数（8 位、16 位、32 位等……取决于我们有多少标志），或 std::bitset\n#include // for std::bitset std::bitset\u003c8\u003e mybitset {}; // 8 bits in size means room for 8 flags 位操作是您应该明确使用无符号整数（或 std::bitset）的少数情况之一\nstd::bitset 提供了 4 个可用于位操作的关键函数：\ntest() 允许我们查询某个位是 0 还是 1 set() 允许我们打开一个位（如果位已经打开，这将不执行任何操作） reset() 允许我们关闭一个位（如果该位已经关闭，这将不执行任何操作） flip() 允许我们将位值从 0 翻转为 1，反之亦然 这些函数中的每一个都将我们要操作的位的位置作为它们唯一的参数\n#include #include int main() { std::bitset\u003c8\u003e bits{ 0b0000'0101 }; // we need 8 bits, start with bit pattern 0000 0101 bits.set(3); // set bit position 3 to 1 (now we have 0000 1101) bits.flip(4); // flip bit 4 (now we have 0001 1101) bits.reset(4); // set bit 4 back to 0 (now we have 0000 1101) std::cout \u003c\u003c \"All the bits: \" \u003c\u003c bits \u003c\u003c '\\n'; std::cout \u003c\u003c \"Bit 3 has value: \" \u003c\u003c bits.test(3) \u003c\u003c '\\n'; std::cout \u003c\u003c \"Bit 4 has value: \" \u003c\u003c bits.test(4) \u003c\u003c '\\n'; return 0; } 按位运算符 为避免意外，请使用无符号操作数或 std::bitset 的按位运算符\n在计算按位 XOR 时，如果一列中有奇数个 1 位，则该列的结果为 1\n位掩码 位掩码是一组预定义的位，用于选择哪些特定位将被后续操作修改。位掩码阻止按位运算符接触我们不想修改的位，并允许访问我们确实想要修改的位\n最简单的一组位掩码是为每个位位置定义一个位掩码。我们用 0 来屏蔽我们不关心的位，用 1 来表示我们想要修改的位\n尽管位掩码可以是文字，但它们通常被定义为符号常量，因此可以为它们指定一个有意义的名称并易于重用\n在 C++14 中定义位掩码 因为 C++14 支持二进制文字，所以定义这些位掩码很容易：\n#include constexpr std::uint8_t mask0{ 0b0000'0001 }; // represents bit 0 constexpr std::uint8_t mask1{ 0b0000'0010 }; // represents bit 1 constexpr std::uint8_t mask2{ 0b0000'0100 }; // represents bit 2 constexpr std::uint8_t mask3{ 0b0000'1000 }; // represents bit 3 constexpr std::uint8_t mask4{ 0b0001'0000 }; // represents bit 4 constexpr std::uint8_t mask5{ 0b0010'0000 }; // represents bit 5 constexpr std::uint8_t mask6{ 0b0100'0000 }; // represents bit 6 constexpr std::uint8_t mask7{ 0b1000'0000 }; // represents bit 7 在 C++11 或更早版本中定义位掩码 由于 C++11 不支持二进制文字，我们必须使用其他方法来设置符号常量\n第一种方法是使用十六进制文字：\nconstexpr std::uint8_t mask0{ 0x01 }; // hex for 0000 0001 constexpr std::uint8_t mask1{ 0x02 }; // hex for 0000 0010 constexpr std::uint8_t mask2{ 0x04 }; // hex for 0000 0100 constexpr std::uint8_t mask3{ 0x08 }; // hex for 0000 1000 constexpr std::uint8_t mask4{ 0x10 }; // hex for 0001 0000 constexpr std::uint8_t mask5{ 0x20 }; // hex for 0010 0000 constexpr std::uint8_t mask6{ 0x40 }; // hex for 0100 0000 constexpr std::uint8_t mask7{ 0x80 }; // hex for 1000 0000 另一种更简单的方法是使用左移运算符将一位移动到正确的位置：\nconstexpr std::uint8_t mask0{ 1 \u003c\u003c 0 }; // 0000 0001 constexpr std::uint8_t mask1{ 1 \u003c\u003c 1 }; // 0000 0010 constexpr std::uint8_t mask2{ 1 \u003c\u003c 2 }; // 0000 0100 constexpr std::uint8_t mask3{ 1 \u003c\u003c 3 }; // 0000 1000 constexpr std::uint8_t mask4{ 1 \u003c\u003c 4 }; // 0001 0000 constexpr std::uint8_t mask5{ 1 \u003c\u003c 5 }; // 0010 0000 constexpr std::uint8_t mask6{ 1 \u003c\u003c 6 }; // 0100 0000 constexpr std::uint8_t mask7{ 1 \u003c\u003c 7 }; // 1000 0000 Testing a bit 要确定某个位是开还是关，我们使用 \u0026 结合相应位的位掩码：\n#include #include int main() { constexpr std::uint8_t mask0{ 0b0000'0001 }; // represents bit 0 constexpr std::uint8_t mask1{ 0b0000'0010 }; // represents bit 1 constexpr std::uint8_t mask2{ 0b0000'0100 }; // represents bit 2 constexpr std::uint8_t mask3{ 0b0000'1000 }; // represents bit 3 constexpr std::uint8_t mask4{ 0b0001'0000 }; // represents bit 4 constexpr std::uint8_t mask5{ 0b0010'0000 }; // represents bit 5 constexpr std::uint8_t mask6{ 0b0100'0000 }; // represents bit 6 constexpr std::uint8_t mask7{ 0b1000'0000 }; // represents bit 7 std::uint8_t flags{ 0b0000'0101 }; // 8 bits in size means room for 8 flags std::cout \u003c\u003c \"bit 0 is \" \u003c\u003c ((flags \u0026 mask0) ? \"on\\n\" : \"off\\n\"); std::cout \u003c\u003c \"bit 1 is \" \u003c\u003c ((flags \u0026 mask1) ? \"on\\n\" : \"off\\n\"); return 0; } Setting a bit 要设置（打开）位，我们将按位或等于（运算符 |=）与相应位的位掩码结合使用：\n#include #include int main() { constexpr std::uint8_t mask0{ 0b0000'0001 }; // represents bit 0 constexpr std::uint8_t mask1{ 0b0000'0010 }; // represents bit 1 constexpr std::uint8_t mask2{ 0b0000'0100 }; // represents bit 2 constexpr std::uint8_t mask3{ 0b0000'1000 }; // represents bit 3 constexpr std::uint8_t mask4{ 0b0001'0000 }; // represents bit 4 constexpr std::uint8_t mask5{ 0b0010'0000 }; // represents bit 5 constexpr std::uint8_t mask6{ 0b0100'0000 }; // represents bit 6 constexpr std::uint8_t mask7{ 0b1000'0000 }; // represents bit 7 std::uint8_t flags{ 0b0000'0101 }; // 8 bits in size means room for 8 flags std::cout \u003c\u003c \"bit 1 is \" \u003c\u003c ((flags \u0026 mask1) ? \"on\\n\" : \"off\\n\"); flags |= mask1; // turn on bit 1 std::cout \u003c\u003c \"bit 1 is \" \u003c\u003c ((flags \u0026 mask1) ? \"on\\n\" : \"off\\n\"); return 0; } 我们还可以使用按位或同时打开多个位：\nflags |= (mask4 | mask5); // turn bits 4 and 5 on at the same time Resetting a bit 要清除位（关闭），我们同时使用 \u0026= 和 ~ ：\n#include #include int main() { constexpr std::uint8_t mask0{ 0b0000'0001 }; // represents bit 0 constexpr std::uint8_t mask1{ 0b0000'0010 }; // represents bit 1 constexpr std::uint8_t mask2{ 0b0000'0100 }; // represents bit 2 constexpr std::uint8_t mask3{ 0b0000'1000 }; // represents bit 3 constexpr std::uint8_t mask4{ 0b0001'0000 }; // represents bit 4 constexpr std::uint8_t mask5{ 0b0010'0000 }; // represents bit 5 constexpr std::uint8_t mask6{ 0b0100'0000 }; // represents bit 6 constexpr std::uint8_t mask7{ 0b1000'0000 }; // represents bit 7 std::uint8_t flags{ 0b0000'0101 }; // 8 bits in size means room for 8 flags std::cout \u003c\u003c \"bit 2 is \" \u003c\u003c ((flags \u0026 mask2) ? \"on\\n\" : \"off\\n\"); flags \u0026= ~mask2; // turn off bit 2 std::cout \u003c\u003c \"bit 2 is \" \u003c\u003c ((flags \u0026 mask2) ? \"on\\n\" : \"off\\n\"); return 0; } 我们可以同时关闭多个位：\nflags \u0026= ~(mask4 | mask5); // turn bits 4 and 5 off at the same time Flipping a bit 要切换位状态，我们使用 ^=：\n#include #include int main() { constexpr std::uint8_t mask0{ 0b0000'0001 }; // represents bit 0 constexpr std::uint8_t mask1{ 0b0000'0010 }; // represents bit 1 constexpr std::uint8_t mask2{ 0b0000'0100 }; // represents bit 2 constexpr std::uint8_t mask3{ 0b0000'1000 }; // represents bit 3 constexpr std::uint8_t mask4{ 0b0001'0000 }; // represents bit 4 constexpr std::uint8_t mask5{ 0b0010'0000 }; // represents bit 5 constexpr std::uint8_t mask6{ 0b0100'0000 }; // represents bit 6 constexpr std::uint8_t mask7{ 0b1000'0000 }; // represents bit 7 std::uint8_t flags{ 0b0000'0101 }; // 8 bits in size means room for 8 flags std::cout \u003c\u003c \"bit 2 is \" \u003c\u003c ((flags \u0026 mask2) ? \"on\\n\" : \"off\\n\"); flags ^= mask2; // flip bit 2 std::cout \u003c\u003c \"bit 2 is \" \u003c\u003c ((flags \u0026 mask2) ? \"on\\n\" : \"off\\n\"); flags ^= mask2; // flip bit 2 std::cout \u003c\u003c \"bit 2 is \" \u003c\u003c ((flags \u0026 mask2) ? \"on\\n\" : \"off\\n\"); return 0; } 我们可以同时翻转多个位：\nflags ^= (mask4 | mask5); // flip bits 4 and 5 at the same time 位掩码和 std::bitset std::bitset 支持全套位运算符。因此，尽管使用函数（测试、设置、重置和翻转）修改单个位更容易，但如果需要，您可以使用按位运算符和位掩码\n函数只允许您一次修改单个位。按位运算符允许您一次修改多个位\n#include #include #include int main() { constexpr std::bitset\u003c8\u003e mask0{ 0b0000'0001 }; // represents bit 0 constexpr std::bitset\u003c8\u003e mask1{ 0b0000'0010 }; // represents bit 1 constexpr std::bitset\u003c8\u003e mask2{ 0b0000'0100 }; // represents bit 2 constexpr std::bitset\u003c8\u003e mask3{ 0b0000'1000 }; // represents bit 3 constexpr std::bitset\u003c8\u003e mask4{ 0b0001'0000 }; // represents bit 4 constexpr std::bitset\u003c8\u003e mask5{ 0b0010'0000 }; // represents bit 5 constexpr std::bitset\u003c8\u003e mask6{ 0b0100'0000 }; // represents bit 6 constexpr std::bitset\u003c8\u003e mask7{ 0b1000'0000 }; // represents bit 7 std::bitset\u003c8\u003e flags{ 0b0000'0101 }; // 8 bits in size means room for 8 flags std::cout \u003c\u003c \"bit 1 is \" \u003c\u003c (flags.test(1) ? \"on\\n\" : \"off\\n\"); std::cout \u003c\u003c \"bit 2 is \" \u003c\u003c (flags.test(2) ? \"on\\n\" : \"off\\n\"); flags ^= (mask1 | mask2); // flip bits 1 and 2 std::cout \u003c\u003c \"bit 1 is \" \u003c\u003c (flags.test(1) ? \"on\\n\" : \"off\\n\"); std::cout \u003c\u003c \"bit 2 is \" \u003c\u003c (flags.test(2) ? \"on\\n\" : \"off\\n\"); flags |= (mask1 | mask2); // turn bits 1 and 2 on std::cout \u003c\u003c \"bit 1 is \" \u003c\u003c (flags.test(1) ? \"on\\n\" : \"off\\n\"); std::cout \u003c\u003c \"bit 2 is \" \u003c\u003c (flags.test(2) ? \"on\\n\" : \"off\\n\"); flags \u0026= ~(mask1 | mask2); // turn bits 1 and 2 off std::cout \u003c\u003c \"bit 1 is \" \u003c\u003c (flags.test(1) ? \"on\\n\" : \"off\\n\"); std::cout \u003c\u003c \"bit 2 is \" \u003c\u003c (flags.test(2) ? \"on\\n\" : \"off\\n\"); return 0; } Summary query bit states if (flags \u0026 option4) ... // if option4 is set, do something set bits (turn on) flags |= option4; // turn option 4 on. flags |= (option4 | option5); // turn options 4 and 5 on. clear bits (turn off) flags \u0026= ~option4; // turn option 4 off flags \u0026= ~(option4 | option5); // turn options 4 and 5 off flip bit states flags ^= option4; // flip option4 from on to off, or vice versa flags ^= (option4 | option5); // flip options 4 and 5 运算符重载 何时使用普通函数、友元函数或成员函数重载运算符 在处理不修改左操作数的二元运算符（例如 operator+）时，通常首选普通或友元函数版本，因为它适用于所有参数类型（即使左操作数不是类对象，或者是一个不可修改的类）。普通或友元函数版本具有“对称”的额外好处，因为所有操作数都成为显式参数（而不是左操作数成为 *this 而右操作数成为显式参数） 在处理确实修改左操作数的二元运算符时（例如 operator+=），通常首选成员函数版本。在这些情况下，最左边的操作数将始终是类类型，并且让被修改的对象成为 *this 指向的对象是很自然的。因为最右边的操作数成为一个显式参数，所以不会混淆谁正在修改和谁正在评估 一元运算符通常也作为成员函数重载，因为成员函数版本没有参数 以下经验法则可以帮助您确定哪种形式最适合给定情况： 如果要重载赋值 (=)、下标 ([])、函数调用 (()) 或成员选择 (-\u003e)，请将其作为成员函数进行重载 如果要重载一元运算符，请将其作为成员函数 如果要重载不修改其左操作数的二元运算符（例如 operator+），请将其作为普通函数（首选）或友元函数 如果您正在重载修改其左操作数的二元运算符，但您不能将成员添加到左操作数的类定义中（例如，operator«，它有一个 ostream 类型的左操作数），请像往常一样这样做函数（首选）或友元函数 如果您正在重载修改其左操作数的二元运算符（例如 operator+=），并且您可以修改左操作数的定义，请将其作为成员函数进行 最小化比较冗余 也就是说我们只需要实现operator==和operator\u003c的逻辑，其他四个比较运算符就可以根据这两个来定义了！这是一个更新的 Cents 示例，说明了这一点：\n#include class Cents { private: int m_cents; public: Cents(int cents) : m_cents{ cents } {} friend bool operator== (const Cents\u0026 c1, const Cents\u0026 c2) { return c1.m_cents == c2.m_cents; }; friend bool operator!= (const Cents\u0026 c1, const Cents\u0026 c2) { return !(operator==(c1, c2)); }; friend bool operator\u003c (const Cents\u0026 c1, const Cents\u0026 c2) { return c1.m_cents \u003c c2.m_cents; }; friend bool operator\u003e (const Cents\u0026 c1, const Cents\u0026 c2) { return operator\u003c(c2, c1); }; friend bool operator\u003c= (const Cents\u0026 c1, const Cents\u0026 c2) { return !(operator\u003e(c1, c2)); }; friend bool operator\u003e= (const Cents\u0026 c1, const Cents\u0026 c2) { return !(operator\u003c(c1, c2)); }; }; int main() { Cents dime{ 10 }; Cents nickel{ 5 }; if (nickel \u003e dime) std::cout \u003c\u003c \"a nickel is greater than a dime.\\n\"; if (nickel \u003e= dime) std::cout \u003c\u003c \"a nickel is greater than or equal to a dime.\\n\"; if (nickel \u003c dime) std::cout \u003c\u003c \"a dime is greater than a nickel.\\n\"; if (nickel \u003c= dime) std::cout \u003c\u003c \"a dime is greater than or equal to a nickel.\\n\"; if (nickel == dime) std::cout \u003c\u003c \"a dime is equal to a nickel.\\n\"; if (nickel != dime) std::cout \u003c\u003c \"a dime is not equal to a nickel.\\n\"; return 0; } 这样，如果我们需要更改某些内容，我们只需要更新 operator== 和 operator\u003c 而不是所有六个比较运算符！\n浅拷贝与深拷贝 编译器提供的默认复制构造函数和默认赋值运算符如下所示：\n#include #include class Fraction { private: int m_numerator { 0 }; int m_denominator { 1 }; public: // Default constructor Fraction(int numerator = 0, int denominator = 1) : m_numerator{ numerator } , m_denominator{ denominator } { assert(denominator != 0); } // Possible implementation of implicit copy constructor Fraction(const Fraction\u0026 f) : m_numerator{ f.m_numerator } , m_denominator{ f.m_denominator } { } // Possible implementation of implicit assignment operator Fraction\u0026 operator= (const Fraction\u0026 fraction) { // self-assignment guard if (this == \u0026fraction) return *this; // do the copy m_numerator = fraction.m_numerator; m_denominator = fraction.m_denominator; // return the existing object so we can chain this operator return *this; } friend std::ostream\u0026 operator\u003c\u003c(std::ostream\u0026 out, const Fraction\u0026 f1) { out \u003c\u003c f1.m_numerator \u003c\u003c '/' \u003c\u003c f1.m_denominator; return out; } }; 请注意，因为这些默认版本可以很好地复制此类，所以在这种情况下真的没有理由编写我们自己的这些函数版本\n然而，在设计处理动态分配内存的类时，成员（浅）复制会给我们带来很多麻烦！这是因为指针的浅拷贝只是复制指针的地址——它不分配任何内存或复制指向的内容！\n深拷贝为副本分配内存，然后复制实际值，以便副本位于与源不同的内存中。这样，副本和来源是截然不同的，不会以任何方式相互影响。进行深度复制需要我们编写自己的复制构造函数和重载赋值运算符。\n默认复制构造函数和默认赋值运算符执行浅拷贝，这适用于不包含动态分配变量的类。\n具有动态分配变量的类需要有一个复制构造函数和赋值运算符来执行深复制。\n喜欢使用标准库中的类而不是自己进行内存管理。\n深拷贝为副本分配内存，然后复制实际值，以便副本位于与源不同的内存中。这样，副本和来源是截然不同的，不会以任何方式相互影响。进行深度复制需要我们编写自己的复制构造函数和重载赋值运算符。\n// assumes m_data is initialized void MyString::deepCopy(const MyString\u0026 source) { // first we need to deallocate any value that this string is holding! delete[] m_data; // because m_length is not a pointer, we can shallow copy it m_length = source.m_length; // m_data is a pointer, so we need to deep copy it if it is non-null if (source.m_data) { // allocate memory for our copy m_data = new char[m_length]; // do the copy for (int i{ 0 }; i \u003c m_length; ++i) m_data[i] = source.m_data[i]; } else m_data = nullptr; } // Copy constructor MyString::MyString(const MyString\u0026 source) { deepCopy(source); } 这比简单的浅拷贝要复杂得多！\n现在让我们做重载的赋值运算符。重载的赋值运算符有点棘手：\n// Assignment operator MyString\u0026 MyString::operator=(const MyString\u0026 source) { // check for self-assignment if (this != \u0026source) { // now do the deep copy deepCopy(source); } return *this; } 输出不是直接写入的，它存储在缓冲区中，直到缓冲区被刷新。输出到文件或终端历来很慢（终端或控制台仍然很慢），逐个字符地写入是低效率的，写入一大块字节要有效得多。若 cerr 被缓冲，那么如果程序以非正常方式崩溃，您可能会将有用的调试信息卡在缓冲区中，而不是打印到 stderr。stdout 是行缓冲的，即在您编写换行符或显式刷新缓冲区之前，输出不会发送到操作系统。通常，std::endl 函数通过插入换行符并刷新流来工作。读取 stdcin 会刷新 stdcout ↩︎\n","wordCount":"20672","inLanguage":"en","datePublished":"2022-11-15T12:54:07+08:00","dateModified":"2022-11-15T12:54:07+08:00","author":[{"@type":"Person","name":"Xan"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://xancoding.cn/posts/2022-11-15-12-54-07/"},"publisher":{"@type":"Organization","name":"Xan's Blog","logo":{"@type":"ImageObject","url":"https://xancoding.cn/img/favicon.ico"}}}</script><script src=https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://xancoding.cn accesskey=h title="Xan's Blog (Alt + H)"><img src=https://xancoding.cn/img/Headshot.jpg alt aria-label=logo height=35>Xan's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://xancoding.cn/ title=Home><span>Home</span></a></li><li><a href=https://xancoding.cn/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://xancoding.cn/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://xancoding.cn/links/ title=Links><span>Links</span></a></li><li><a href=https://xancoding.cn/about/ title=About><span>About</span></a></li><li><a href=https://xancoding.cn/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://xancoding.cn>Home</a>&nbsp;»&nbsp;<a href=https://xancoding.cn/posts/>Posts</a></div><h1 class=post-title>Learning C++</h1><div class=post-meta>&nbsp;<span title='2022-11-15 12:54:07 +0800 +0800'>2022-11-15</span>&nbsp;|&nbsp;<a href=https://github.com/Xancoding/Blog/tree/main/content/posts/2022-11-15-12-54-07.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#c-%e5%9f%ba%e7%a1%80%e5%87%bd%e6%95%b0%e5%92%8c%e6%96%87%e4%bb%b6 aria-label="C++ 基础：函数和文件">C++ 基础：函数和文件</a><ul><li><a href=#%e5%87%bd%e6%95%b0%e8%bf%94%e5%9b%9e%e5%80%bc aria-label=函数返回值>函数返回值</a></li><li><a href=#include-%e5%a4%b4%e6%96%87%e4%bb%b6%e9%a1%ba%e5%ba%8f aria-label="include 头文件顺序">include 头文件顺序</a></li><li><a href=#header-file-best-practices aria-label="Header file best practices">Header file best practices</a></li><li><a href=#%e9%a2%84%e5%a4%84%e7%90%86%e5%99%a8 aria-label=预处理器>预处理器</a><ul><li><a href=#includes aria-label=Includes>Includes</a></li><li><a href=#macro-defines aria-label="Macro defines">Macro defines</a></li><li><a href=#conditional-compilation aria-label="Conditional compilation">Conditional compilation</a></li></ul></li><li><a href=#%e5%a6%82%e4%bd%95%e5%ae%8c%e6%88%90%e4%bd%a0%e7%9a%84%e7%ac%ac%e4%b8%80%e4%b8%aa%e7%a8%8b%e5%ba%8f aria-label=如何完成你的第一个程序>如何完成你的第一个程序</a></li></ul></li><li><a href=#%e8%b0%83%e8%af%95-c-%e7%a8%8b%e5%ba%8f aria-label="调试 C++ 程序">调试 C++ 程序</a><ul><li><a href=#%e8%b0%83%e8%af%95%e8%bf%87%e7%a8%8b aria-label=调试过程>调试过程</a></li><li><a href=#%e8%b0%83%e8%af%95%e7%ad%96%e7%95%a5 aria-label=调试策略>调试策略</a><ul><li><a href=#%e8%b0%83%e8%af%95%e7%ad%96%e7%95%a5-1%e6%b3%a8%e9%87%8a%e6%8e%89%e4%bd%a0%e7%9a%84%e4%bb%a3%e7%a0%81 aria-label="调试策略 1：注释掉你的代码">调试策略 1：注释掉你的代码</a></li><li><a href=#%e8%b0%83%e8%af%95%e7%ad%96%e7%95%a5-2%e9%aa%8c%e8%af%81%e4%bb%a3%e7%a0%81%e6%b5%81 aria-label="调试策略 2：验证代码流">调试策略 2：验证代码流</a></li><li><a href=#%e8%b0%83%e8%af%95%e7%ad%96%e7%95%a5-3%e6%89%93%e5%8d%b0%e5%80%bc aria-label="调试策略 3：打印值">调试策略 3：打印值</a></li><li><a href=#%e6%9d%a1%e4%bb%b6%e5%8c%96%e8%b0%83%e8%af%95%e4%bb%a3%e7%a0%81 aria-label=条件化调试代码>条件化调试代码</a></li><li><a href=#%e4%bd%bf%e7%94%a8%e6%97%a5%e5%bf%97 aria-label=使用日志>使用日志</a></li></ul></li><li><a href=#%e4%bd%bf%e7%94%a8%e9%9b%86%e6%88%90%e8%b0%83%e8%af%95%e5%99%a8stepping%e6%ad%a5%e8%bf%9b aria-label=使用集成调试器：Stepping（步进）>使用集成调试器：Stepping（步进）</a><ul><li><a href=#step-into aria-label="Step into">Step into</a></li><li><a href=#step-over aria-label="Step over">Step over</a></li><li><a href=#step-out aria-label="Step out">Step out</a></li></ul></li><li><a href=#%e4%bd%bf%e7%94%a8%e9%9b%86%e6%88%90%e8%b0%83%e8%af%95%e5%99%a8running-and-breakpoints%e8%bf%90%e8%a1%8c%e5%92%8c%e6%96%ad%e7%82%b9 aria-label="使用集成调试器：Running and breakpoints（运行和断点）">使用集成调试器：Running and breakpoints（运行和断点）</a><ul><li><a href=#run-to-cursor aria-label="Run to cursor">Run to cursor</a></li><li><a href=#breakpoints aria-label=Breakpoints>Breakpoints</a></li></ul></li><li><a href=#%e4%bd%bf%e7%94%a8%e9%9b%86%e6%88%90%e8%b0%83%e8%af%95%e5%99%a8%e8%b0%83%e7%94%a8%e5%a0%86%e6%a0%88 aria-label=使用集成调试器：调用堆栈>使用集成调试器：调用堆栈</a></li><li><a href=#%e5%9c%a8%e9%97%ae%e9%a2%98%e6%88%90%e4%b8%ba%e9%97%ae%e9%a2%98%e4%b9%8b%e5%89%8d%e5%8f%91%e7%8e%b0%e9%97%ae%e9%a2%98 aria-label=在问题成为问题之前发现问题>在问题成为问题之前发现问题</a><ul><li><a href=#%e9%87%8d%e6%9e%84%e4%bd%a0%e7%9a%84%e4%bb%a3%e7%a0%81 aria-label=重构你的代码>重构你的代码</a></li><li><a href=#%e7%ba%a6%e6%9d%9f aria-label=约束>约束</a></li></ul></li></ul></li><li><a href=#%e5%9f%ba%e6%9c%ac%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b aria-label=基本数据类型>基本数据类型</a><ul><li><a href=#%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e5%a4%a7%e5%b0%8f aria-label=数据类型大小>数据类型大小</a></li><li><a href=#%e6%97%a0%e7%ac%a6%e5%8f%b7%e6%95%b4%e6%95%b0%e5%92%8c%e6%9c%89%e7%ac%a6%e5%8f%b7%e6%95%b4%e6%95%b0 aria-label=无符号整数和有符号整数>无符号整数和有符号整数</a></li><li><a href=#%e5%9b%ba%e5%ae%9a%e5%ae%bd%e5%ba%a6%e6%95%b4%e6%95%b0%e5%92%8c-size_t aria-label="固定宽度整数和 size_t">固定宽度整数和 size_t</a><ul><li><a href=#fixed-width-%e6%95%b4%e6%95%b0 aria-label="Fixed-width 整数">Fixed-width 整数</a></li><li><a href=#fast-and-least-%e6%95%b4%e6%95%b0 aria-label="Fast and least 整数">Fast and least 整数</a></li><li><a href=#stdint8_t-%e5%92%8c-stduint8_t-%e5%8f%af%e8%83%bd%e8%a1%a8%e7%8e%b0%e5%be%97%e5%83%8f%e5%ad%97%e7%ac%a6%e8%80%8c%e4%b8%8d%e6%98%af%e6%95%b4%e6%95%b0 aria-label="std::int8_t 和 std::uint8_t 可能表现得像字符而不是整数">std::int8_t 和 std::uint8_t 可能表现得像字符而不是整数</a></li><li><a href=#best-practice aria-label="Best practice">Best practice</a></li><li><a href=#size_t aria-label=size_t>size_t</a></li></ul></li><li><a href=#%e6%b5%ae%e7%82%b9%e6%95%b0ieee-754 aria-label="浮点数（IEEE 754）">浮点数（IEEE 754）</a><ul><li><a href=#%e6%b5%ae%e7%82%b9%e8%8c%83%e5%9b%b4%e5%92%8c%e6%b5%ae%e7%82%b9%e7%b2%be%e5%ba%a6 aria-label=浮点范围和浮点精度>浮点范围和浮点精度</a></li><li><a href=#%e8%88%8d%e5%85%a5%e8%af%af%e5%b7%ae aria-label=舍入误差>舍入误差</a></li><li><a href=#nan-%e5%92%8c-inf aria-label="NaN 和 Inf">NaN 和 Inf</a></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></li><li><a href=#%e5%b8%83%e5%b0%94%e5%80%bc aria-label=布尔值>布尔值</a></li><li><a href=#chars aria-label=Chars>Chars</a></li><li><a href=#%e5%b8%b8%e9%87%8f%e5%92%8c%e7%ac%a6%e5%8f%b7%e5%b8%b8%e9%87%8f aria-label=常量和符号常量>常量和符号常量</a><ul><li><a href=#const-variables aria-label="const variables">const variables</a></li><li><a href=#%e7%ac%a6%e5%8f%b7%e5%b8%b8%e9%87%8f aria-label=符号常量>符号常量</a></li><li><a href=#%e5%af%b9%e4%ba%8e%e7%ac%a6%e5%8f%b7%e5%b8%b8%e9%87%8f%e6%9b%b4%e5%96%9c%e6%ac%a2%e5%b8%b8%e9%87%8f%e5%8f%98%e9%87%8f%e8%80%8c%e4%b8%8d%e6%98%af%e7%b1%bb%e5%af%b9%e8%b1%a1%e5%ae%8f aria-label=对于符号常量，更喜欢常量变量而不是类对象宏>对于符号常量，更喜欢常量变量而不是类对象宏</a></li></ul></li><li><a href=#%e7%bc%96%e8%af%91%e6%97%b6%e5%b8%b8%e9%87%8f%e5%b8%b8%e9%87%8f%e8%a1%a8%e8%be%be%e5%bc%8f%e5%92%8c-constexpr aria-label="编译时常量、常量表达式和 constexpr">编译时常量、常量表达式和 constexpr</a><ul><li><a href=#constant-expressions aria-label="Constant expressions">Constant expressions</a></li><li><a href=#compile-time-constants aria-label="Compile-time constants">Compile-time constants</a></li><li><a href=#compile-time-const aria-label="Compile-time const">Compile-time const</a></li><li><a href=#runtime-const aria-label="Runtime const">Runtime const</a></li><li><a href=#constexpr-%e5%85%b3%e9%94%ae%e5%ad%97 aria-label="constexpr 关键字">constexpr 关键字</a></li></ul></li><li><a href=#literals aria-label=Literals>Literals</a></li><li><a href=#%e5%8d%81%e8%bf%9b%e5%88%b6%e4%ba%8c%e8%bf%9b%e5%88%b6%e5%8d%81%e5%85%ad%e8%bf%9b%e5%88%b6%e5%92%8c%e5%85%ab%e8%bf%9b%e5%88%b6 aria-label=十进制、二进制、十六进制和八进制>十进制、二进制、十六进制和八进制</a><ul><li><a href=#%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%96%87%e5%ad%97%e5%92%8c%e6%95%b0%e5%ad%97%e5%88%86%e9%9a%94%e7%ac%a6 aria-label=二进制文字和数字分隔符>二进制文字和数字分隔符</a></li><li><a href=#%e4%bb%a5%e5%8d%81%e8%bf%9b%e5%88%b6%e5%85%ab%e8%bf%9b%e5%88%b6%e6%88%96%e5%8d%81%e5%85%ad%e8%bf%9b%e5%88%b6%e8%be%93%e5%87%ba%e5%80%bc aria-label=以十进制、八进制或十六进制输出值>以十进制、八进制或十六进制输出值</a></li><li><a href=#%e4%bb%a5%e4%ba%8c%e8%bf%9b%e5%88%b6%e8%be%93%e5%87%ba%e5%80%bc aria-label=以二进制输出值>以二进制输出值</a></li></ul></li><li><a href=#stdstring aria-label=std::string>std::string</a><ul><li><a href=#%e4%bd%bf%e7%94%a8-stdgetline-%e8%be%93%e5%85%a5%e6%96%87%e6%9c%ac aria-label="使用 std::getline() 输入文本">使用 std::getline() 输入文本</a></li><li><a href=#%e5%ad%97%e7%ac%a6%e4%b8%b2%e9%95%bf%e5%ba%a6 aria-label=字符串长度>字符串长度</a></li><li><a href=#stdstring-%e7%9a%84%e5%88%9d%e5%a7%8b%e5%8c%96%e5%92%8c%e5%a4%8d%e5%88%b6%e5%bc%80%e9%94%80%e5%be%88%e5%a4%a7 aria-label="std::string 的初始化和复制开销很大">std::string 的初始化和复制开销很大</a></li><li><a href=#literals-forstdstring--stdstring_view aria-label="Literals for std::string &amp;amp; std::string_view">Literals for <code>std::string</code> & <code>std::string_view</code></a></li><li><a href=#constexpr-%e5%ad%97%e7%ac%a6%e4%b8%b2 aria-label="Constexpr 字符串">Constexpr 字符串</a></li></ul></li><li><a href=#stdstring_view aria-label=std::string_view>std::string_view</a><ul><li><a href=#stdstring_view-c17 aria-label="std::string_view C++17">std::string_view C++17</a></li><li><a href=#constexpr-stdstring_view aria-label="constexpr std::string_view">constexpr std::string_view</a></li><li><a href=#stdstring--stdstring_view aria-label="std::string &amp;amp; std::string_view">std::string & std::string_view</a></li></ul></li></ul></li><li><a href=#operators%e6%93%8d%e4%bd%9c%e7%ac%a6 aria-label=Operators（操作符）>Operators（操作符）</a><ul><li><a href=#----%e8%bf%90%e7%ae%97%e7%ac%a6 aria-label=", &amp;amp; ? : 运算符"><code>,</code> & <code>? :</code> 运算符</a></li><li><a href=#%e6%af%94%e8%be%83%e6%b5%ae%e7%82%b9%e6%95%b0%e5%a4%a7%e5%b0%8f aria-label=比较浮点数大小>比较浮点数大小</a></li><li><a href=#%e9%80%bb%e8%be%91-xor-%e8%bf%90%e7%ae%97%e7%ac%a6 aria-label="逻辑 XOR 运算符">逻辑 XOR 运算符</a></li></ul></li><li><a href=#%e4%bd%8d%e6%93%8d%e4%bd%9c aria-label=位操作>位操作</a><ul><li><a href=#%e4%bd%8d%e6%a0%87%e5%bf%97-and-%e4%bd%8d%e6%93%8d%e4%bd%9c-via-stdbitset aria-label="位标志 and 位操作 via std::bitset">位标志 and 位操作 via std::bitset</a></li><li><a href=#%e6%8c%89%e4%bd%8d%e8%bf%90%e7%ae%97%e7%ac%a6 aria-label=按位运算符>按位运算符</a></li><li><a href=#%e4%bd%8d%e6%8e%a9%e7%a0%81 aria-label=位掩码>位掩码</a><ul><li><a href=#%e5%9c%a8-c14-%e4%b8%ad%e5%ae%9a%e4%b9%89%e4%bd%8d%e6%8e%a9%e7%a0%81 aria-label="在 C++14 中定义位掩码">在 C++14 中定义位掩码</a></li><li><a href=#%e5%9c%a8-c11-%e6%88%96%e6%9b%b4%e6%97%a9%e7%89%88%e6%9c%ac%e4%b8%ad%e5%ae%9a%e4%b9%89%e4%bd%8d%e6%8e%a9%e7%a0%81 aria-label="在 C++11 或更早版本中定义位掩码">在 C++11 或更早版本中定义位掩码</a></li><li><a href=#testing-a-bit aria-label="Testing a bit">Testing a bit</a></li><li><a href=#setting-a-bit aria-label="Setting a bit">Setting a bit</a></li><li><a href=#resetting-a-bit aria-label="Resetting a bit">Resetting a bit</a></li><li><a href=#flipping-a-bit aria-label="Flipping a bit">Flipping a bit</a></li></ul></li><li><a href=#%e4%bd%8d%e6%8e%a9%e7%a0%81%e5%92%8c-stdbitset aria-label="位掩码和 std::bitset">位掩码和 std::bitset</a></li><li><a href=#summary aria-label=Summary>Summary</a></li></ul></li><li><a href=#%e8%bf%90%e7%ae%97%e7%ac%a6%e9%87%8d%e8%bd%bd aria-label=运算符重载>运算符重载</a><ul><li><a href=#%e4%bd%95%e6%97%b6%e4%bd%bf%e7%94%a8%e6%99%ae%e9%80%9a%e5%87%bd%e6%95%b0%e5%8f%8b%e5%85%83%e5%87%bd%e6%95%b0%e6%88%96%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0%e9%87%8d%e8%bd%bd%e8%bf%90%e7%ae%97%e7%ac%a6 aria-label=何时使用普通函数、友元函数或成员函数重载运算符>何时使用普通函数、友元函数或成员函数重载运算符</a></li><li><a href=#%e6%9c%80%e5%b0%8f%e5%8c%96%e6%af%94%e8%be%83%e5%86%97%e4%bd%99 aria-label=最小化比较冗余>最小化比较冗余</a></li></ul></li><li><a href=#%e6%b5%85%e6%8b%b7%e8%b4%9d%e4%b8%8e%e6%b7%b1%e6%8b%b7%e8%b4%9d aria-label=浅拷贝与深拷贝>浅拷贝与深拷贝</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h1 id=c-基础函数和文件>C++ 基础：函数和文件<a hidden class=anchor aria-hidden=true href=#c-基础函数和文件>#</a></h1><h2 id=函数返回值>函数返回值<a hidden class=anchor aria-hidden=true href=#函数返回值>#</a></h2><p>C++标准只定义了3种状态码的含义：0、EXIT_SUCCESS、EXIT_FAILURE。 0 和 EXIT_SUCCESS 都表示程序执行成功。 EXIT_FAILURE 表示程序没有成功执行</p><p>EXIT_SUCCESS 和 EXIT_FAILURE 是 <code>&lt;cstdlib></code> 标头中定义的预处理器宏：</p><pre tabindex=0><code>#include &lt;cstdlib&gt; // for EXIT_SUCCESS and EXIT_FAILURE

int main()
{
    return EXIT_SUCCESS;
}
</code></pre><p>如果你想最大限度地提高可移植性，你应该只使用 0 或 EXIT_SUCCESS 来指示成功终止，或者使用 EXIT_FAILURE 来指示不成功终止</p><h2 id=include-头文件顺序>include 头文件顺序<a hidden class=anchor aria-hidden=true href=#include-头文件顺序>#</a></h2><p>在 C++ 中，头文件的顺序通常应该遵循以下顺序：</p><ol><li>C 标准库头文件（如 <code>&lt;stdio.h></code>）</li><li>C++ 标准库头文件（如 <code>&lt;iostream></code>）</li><li>第三方库头文件（如 <code>Boost</code>）</li><li>项目特定的头文件（如自定义的头文件）</li></ol><p>这样的顺序可以避免头文件之间的依赖关系问题，同时也可以更快地查找问题。</p><p>The headers for each grouping should be sorted alphabetically（按字母顺序排序）.</p><p>这个顺序并不是强制的，主要取决于项目的需要和编程风格。</p><h2 id=header-file-best-practices>Header file best practices<a hidden class=anchor aria-hidden=true href=#header-file-best-practices>#</a></h2><ol><li>始终 include header guards</li><li>不要在头文件中定义变量和函数（全局常量是一个例外）</li><li>为头文件指定与其关联的源文件相同的名称（例如，grades.h 与 grades.cpp 配对）</li><li>每个头文件应该有一个特定的工作，并且尽可能独立。例如，您可以将与功能 A 相关的所有声明放在 A.h 中，将与功能 B 相关的所有声明放在 B.h 中。这样如果你以后只关心 A，你可以只 include A.h 而不会得到任何与 B 相关的东西</li><li>请注意您需要为代码文件中使用的功能显式包含哪些 header</li><li>您编写的每个 header 都应该自行编译（它应该<code>#include</code> 它需要的每个依赖项）</li><li>仅 <code>#include</code> 您需要的内容（不要仅仅因为可以就包含所有内容）</li><li>不要<code>#include</code> .cpp 文件</li></ol><h2 id=预处理器>预处理器<a hidden class=anchor aria-hidden=true href=#预处理器>#</a></h2><p>在编译之前，代码文件会经历一个称为翻译的阶段。翻译阶段会发生很多事情，让您的代码准备好进行编译（如果您好奇，可以在此处找到翻译阶段列表）。应用了翻译的代码文件称为翻译单元</p><p>最值得注意的翻译阶段涉及预处理器。预处理器最好被认为是一个单独的程序，它可以处理每个代码文件中的文本</p><p>当预处理器运行时，它会扫描代码文件（从上到下），寻找预处理器指令。预处理程序指令（通常简称为 <strong>指令（Directives）</strong>）是以# 符号开头并以换行符（不是分号）结尾的指令。这些指令告诉预处理器执行某些文本操作任务。请注意，预处理器不理解 C++ 语法——相反，指令有自己的语法（在某些情况下类似于 C++ 语法，而在其他情况下，则不太相似）</p><p>请注意，预处理器不会以任何方式修改原始代码文件——相反，预处理器所做的所有文本更改都会在每次编译代码文件时临时发生在内存中或使用临时文件</p><h3 id=includes>Includes<a hidden class=anchor aria-hidden=true href=#includes>#</a></h3><p>当您 <code>#include</code> 一个文件时，预处理器会用 include 文件的内容替换 <code>#include</code> 指令。然后对 include 的内容进行预处理（连同文件的其余部分），然后进行编译</p><h3 id=macro-defines>Macro defines<a hidden class=anchor aria-hidden=true href=#macro-defines>#</a></h3><p><code>#define</code> 指令可用于创建 <strong>宏</strong></p><p>有两种基本类型的宏：<strong>类对象宏</strong>和<strong>类函数宏</strong></p><p><strong>类函数宏</strong>的行为类似于函数，并且具有相似的目的。它们的使用通常被认为是危险的，它们几乎可以做的任何事情都可以通过一个正常的函数来完成</p><p><strong>类对象宏</strong>可以通过以下两种方式之一定义：</p><pre tabindex=0><code>#define identifier
#define identifier substitution_text
</code></pre><p><strong>替换文本</strong>的类对象宏被用作（在 C 中）将名称分配给文字的一种方式。这不再是必需的，因为 C++ 中提供了更好的方法（Const 变量和符号常量）。带有替换文本的类对象宏现在通常只能在遗留代码中看到</p><p><strong>没有替换文本</strong>的类对象宏：标识符的任何进一步出现都将被删除并被替换为任何东西！</p><p>与带有替换文本的类对象宏不同，这种形式的宏通常被认为可以使用。</p><h3 id=conditional-compilation>Conditional compilation<a hidden class=anchor aria-hidden=true href=#conditional-compilation>#</a></h3><p><strong>条件编译预处理器指令</strong>允许您指定在什么条件下编译或不编译。有很多不同的条件编译指令，但我们在这里只介绍目前使用最多的三个：<code>#ifdef</code>、<code>#ifndef</code> 和 <code>#endif</code></p><p><code>#ifdef</code> 预处理器指令允许预处理器检查标识符是否先前已被<code>#defined</code>。如果是，编译 <code>#ifdef</code> 和匹配的 <code>#endif</code> 之间的代码。如果不是，代码将被忽略</p><p>考虑以下程序：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#define PRINT_JOE
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#ifdef PRINT_JOE
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;Joe</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>; <span style=color:#007f7f>// will be compiled since PRINT_JOE is defined
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#0f0;font-weight:700>#endif
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#ifdef PRINT_BOB
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;Bob</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>; <span style=color:#007f7f>// will be ignored since PRINT_BOB is not defined
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#0f0;font-weight:700>#endif
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>因为 <code>PRINT_JOE</code> 已被 <code>#defined</code>，<code>std::cout &lt;&lt; "Joe\n"</code> 行将被编译。因为 <code>PRINT_BOB</code> 尚未被 <code>#defined</code>，<code>std::cout &lt;&lt; "Bob\n" </code>行将被忽略</p><p><code>#ifndef</code> 与 <code>#ifdef</code> 相反，因为它允许您检查标识符是否尚未 <code>#defined</code></p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#ifndef PRINT_BOB
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;Bob</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#endif
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>该程序打印 <code>“Bob”</code>，因为 <code>PRINT_BOB</code> 从未被 <code>#defined</code></p><p>条件编译的一个更常见的用途是使用 <code>#if 0</code> 将代码块排除在编译之外（就像它在注释块中一样）：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;Joe</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#if 0</span><span style=color:#007f7f> // Don&#39;t compile anything starting here
</span></span></span><span style=display:flex><span><span style=color:#007f7f>    std::cout &lt;&lt; &#34;Bob\n&#34;;
</span></span></span><span style=display:flex><span><span style=color:#007f7f>    std::cout &lt;&lt; &#34;Steve\n&#34;;
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#0f0;font-weight:700>#endif // until this point
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这也提供了一种方便的方法来**“注释掉”包含多行注释的代码**（由于多行注释是不可嵌套的，因此不能使用另一个多行注释来注释掉）：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;Joe</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#if 0</span><span style=color:#007f7f> // Don&#39;t compile anything starting here
</span></span></span><span style=display:flex><span><span style=color:#007f7f>    std::cout &lt;&lt; &#34;Bob\n&#34;;
</span></span></span><span style=display:flex><span><span style=color:#007f7f>    /* Some
</span></span></span><span style=display:flex><span><span style=color:#007f7f>     * multi-line
</span></span></span><span style=display:flex><span><span style=color:#007f7f>     * comment here
</span></span></span><span style=display:flex><span><span style=color:#007f7f>     */
</span></span></span><span style=display:flex><span><span style=color:#007f7f>    std::cout &lt;&lt; &#34;Steve\n&#34;;
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#0f0;font-weight:700>#endif // until this point
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>类对象宏不影响其他预处理器指令，宏只会导致普通代码的文本替换。其他预处理器命令将被忽略</strong></p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#define FOO 9 </span><span style=color:#007f7f>// Here&#39;s a macro substitution
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#ifdef FOO </span><span style=color:#007f7f>// This FOO does not get replaced because it’s part of another preprocessor directive
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    std::cout &lt;&lt; FOO; <span style=color:#007f7f>// This FOO gets replaced with 9 because it&#39;s part of the normal code
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#0f0;font-weight:700>#endif
</span></span></span></code></pre></div><p>指令在编译前解析，逐个文件地从上到下解析</p><pre tabindex=0><code>#include &lt;iostream&gt;

void foo()
{
#define MY_NAME &#34;Alex&#34;
}

int main()
{
	std::cout &lt;&lt; &#34;My name is: &#34; &lt;&lt; MY_NAME;

	return 0;
}
</code></pre><p>即使看起来 <code>#define MY_NAME “Alex”</code> 是在函数 <code>foo</code> 中定义的，预处理器也不会注意到，因为它不理解像函数这样的 C++ 概念。因此，该程序的行为与 <code>#define MY_NAME “Alex”</code> 在函数 <code>foo</code> 之前或之后立即定义的程序相同。为了一般的可读性，您通常希望在函数之外 <code>#define</code> 标识符</p><p>预处理器完成后，该文件中所有定义的标识符都将被丢弃。这意味着指令<strong>仅从定义点到定义它们的文件末尾有效</strong>。<strong>一个代码文件中定义的指令不会影响同一项目中的其他代码文件</strong></p><p>考虑以下示例：</p><p>function.cpp:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>void</span> doSomething()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#ifdef PRINT
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;Printing!&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#endif
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#ifndef PRINT
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;Not printing!&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#endif
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>}
</span></span></code></pre></div><p>main.cpp:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#fff;font-weight:700>void</span> doSomething(); <span style=color:#007f7f>// forward declaration for function doSomething()
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#define PRINT
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    doSomething();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面的程序会打印：</p><pre tabindex=0><code>Not printing!
</code></pre><p>尽管 <code>PRINT</code> 是在 <code>main.cpp</code> 中定义的，但这对 <code>function.cpp</code> 中的任何代码都没有任何影响（<code>PRINT</code> 只是从定义点到 <code>main.cpp</code> 末尾的 <code>#defined</code>）</p><h2 id=如何完成你的第一个程序>如何完成你的第一个程序<a hidden class=anchor aria-hidden=true href=#如何完成你的第一个程序>#</a></h2><ol><li>Design（设计）<ol><li>定义目标。将此表示为面向用户的结果通常很有用，例如：<ul><li>允许用户组织姓名和相关电话号码的列表</li><li>模拟球从塔上掉落到地面需要多长时间</li></ul></li><li>定义需求。既指您的解决方案需要遵守的约束（例如预算、时间线、空间、内存等），也指程序为满足用户需求而必须展示的能力。请注意，您的要求同样应该关注“什么”，而不是“如何”。例如：<ul><li>应保存电话号码，以便日后调用</li><li>用户应该能够输入塔的高度</li></ul></li><li>定义您的工具、目标和备份计划<ol><li>定义您的程序将运行的目标架构 和/或 操作系统</li><li>确定您将使用的工具集</li><li>确定您是单独编写程序还是作为团队的一部分编写程序’</li><li>定义您的测试/反馈/发布策略</li><li>确定您将如何备份您的代码</li></ol></li><li>将困难问题分解为简单问题。如果发现其中一个项目（功能）太难实现，只需将该项目拆分为多个子项目/子功能。最终，您应该达到程序中的每个功能都可以轻松实现的地步</li><li>弄清楚事件的顺序</li></ol></li><li>Implementation（实现）<ol><li>概述您的主要功能。</li></ol><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#007f7f>// Get first number from user
</span></span></span><span style=display:flex><span><span style=color:#007f7f>//    getUserInput();
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    <span style=color:#007f7f>// Get mathematical operation from user
</span></span></span><span style=display:flex><span><span style=color:#007f7f>//    getMathematicalOperation();
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    <span style=color:#007f7f>// Get second number from user
</span></span></span><span style=display:flex><span><span style=color:#007f7f>//    getUserInput();
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    <span style=color:#007f7f>// Calculate result
</span></span></span><span style=display:flex><span><span style=color:#007f7f>//    calculateResult();
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    <span style=color:#007f7f>// Print result
</span></span></span><span style=display:flex><span><span style=color:#007f7f>//    printResult();
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=2><li>实现各个功能。对于每个函数，您将做三件事：<ol><li>定义函数原型（输入和输出）</li><li>编写函数</li><li>测试功能</li></ol></li><li>最终测试。一旦你的程序“完成”，最后一步就是测试整个程序并确保它按预期工作。如果它不起作用，请修复它</li></ol></li><li>Words of advice when writing programs（忠告）<ol><li><strong>Keep your programs simple to start</strong>.让你的第一个目标尽可能简单，一些你绝对可以实现的目标</li><li><strong>Add features over time</strong>.一旦您的简单程序运行良好并且运行良好，您就可以向其添加功能</li><li><strong>Focus on one area at a time</strong>.不要试图一次编写所有代码，也不要将注意力分散到多个任务上。一次专注于一项任务</li><li><strong>Test each piece of code as you go</strong>.编写一段代码，然后立即编译并测试它。如果它不起作用，您将确切地知道问题出在哪里，并且很容易修复。确定代码有效后，移至下一段并重复。完成代码的编写可能需要更长的时间，但是当您完成后，整个事情应该可以正常工作，并且您不必花费两倍的时间来弄清楚为什么它不起作用</li><li><strong>Don’t invest in perfecting early code</strong>.让你的功能最低限度地工作，然后继续。不要以完美为目标——重要的程序从来都不是完美的，而且总有更多的事情可以做来改进它们。达到“足够好”并继续前进</li></ol></li></ol><h1 id=调试-c-程序>调试 C++ 程序<a hidden class=anchor aria-hidden=true href=#调试-c-程序>#</a></h1><h2 id=调试过程>调试过程<a hidden class=anchor aria-hidden=true href=#调试过程>#</a></h2><ol><li>找到问题的根本原因（通常是不起作用的代码行）</li><li>确保您了解问题发生的原因</li><li>确定您将如何解决问题</li><li>修复问题</li><li>重新测试以确保问题已解决并且没有出现新问题</li></ol><h2 id=调试策略>调试策略<a hidden class=anchor aria-hidden=true href=#调试策略>#</a></h2><p>观察程序运行时的行为，并尝试从中诊断问题</p><ol><li>弄清楚如何<strong>重现问题</strong></li><li>运行程序并收集信息以<strong>缩小问题所在的范围</strong></li><li>重复前面的步骤，<strong>直到找到问题</strong></li></ol><h3 id=调试策略-1注释掉你的代码>调试策略 1：注释掉你的代码<a hidden class=anchor aria-hidden=true href=#调试策略-1注释掉你的代码>#</a></h3><p>如果您的程序表现出错误行为，减少必须搜索的代码量的一种方法是注释掉一些代码并查看问题是否仍然存在。如果问题仍然存在，则注释掉的代码不负责任</p><h3 id=调试策略-2验证代码流>调试策略 2：验证代码流<a hidden class=anchor aria-hidden=true href=#调试策略-2验证代码流>#</a></h3><p>另一个在更复杂的程序中常见的问题是程序调用一个函数的次数太多或太少（包括根本不调用）</p><p>在这种情况下，将语句放在函数的顶部以打印函数的名称会很有帮助。这样，当程序运行时，您可以看到调用了哪些函数</p><p>当<strong>出于调试目的打印信息时</strong>，使用 <code>std::cerr</code> 而不是 <code>std::cout</code>。这样做的一个原因是 std::cout 可能被缓冲，这意味着在您要求 std::cout 输出信息和它实际输出信息之间可能会有一个暂停。如果您使用 std::cout 进行输出，然后您的程序随后立即崩溃，则 std::cout 可能已经或可能还没有实际输出。这可能会误导您了解问题出在哪里。另一方面，std::cerr 是无缓冲<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>的，这意味着您发送给它的任何内容都会立即输出。这有助于确保所有调试输出尽快出现（以一些性能为代价，我们在调试时通常不关心）</p><p>使用 std::cerr 还有助于明确输出的信息是针对错误情况而不是正常情况</p><p>添加临时调试语句时，不缩进它们会很有帮助。这使它们更容易在以后找到并移除</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> getValue()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>std::cerr &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;getValue() called</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>4</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>std::cerr &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;main() called</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>    std::cout &lt;&lt; getValue;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=调试策略-3打印值>调试策略 3：打印值<a hidden class=anchor aria-hidden=true href=#调试策略-3打印值>#</a></h3><p>对于某些类型的错误，程序可能会计算或传递错误的值。</p><p>我们还可以输出变量（包括参数）或表达式的值，以确保它们是正确的。</p><p>For example:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> add(<span style=color:#fff;font-weight:700>int</span> x, <span style=color:#fff;font-weight:700>int</span> y)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>std::cerr &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;add() called (x=&#34;</span> &lt;&lt; x &lt;&lt;<span style=color:#0ff;font-weight:700>&#34;, y=&#34;</span> &lt;&lt; y &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;)</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> x + y;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>void</span> printResult(<span style=color:#fff;font-weight:700>int</span> z)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;The answer is: &#34;</span> &lt;&lt; z &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> getUserInput()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;Enter a number: &#34;</span>;
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>int</span> x{};
</span></span><span style=display:flex><span>	std::cin &gt;&gt; x;
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> x;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>int</span> x{ getUserInput() };
</span></span><span style=display:flex><span>std::cerr &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;main::x = &#34;</span> &lt;&lt; x &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>int</span> y{ getUserInput() };
</span></span><span style=display:flex><span>std::cerr &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;main::y = &#34;</span> &lt;&lt; y &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	std::cout &lt;&lt; x &lt;&lt; <span style=color:#0ff;font-weight:700>&#34; + &#34;</span> &lt;&lt; y &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>int</span> z{ add(x, <span style=color:#ff0;font-weight:700>5</span>) };
</span></span><span style=display:flex><span>std::cerr &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;main::z = &#34;</span> &lt;&lt; z &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>	printResult(z);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>现在我们将得到输出：</p><pre tabindex=0><code>Enter a number: 4
main::x = 4
Enter a number: 3
main::y = 3
add() called (x=4, y=5)
main::z = 9
The answer is: 9
</code></pre><p>虽然为诊断目的向程序添加调试语句是一种常见的基本技术，也是一种功能性技术（尤其是当调试器由于某种原因不可用时），但由于多种原因它并不是很好：</p><ol><li>调试语句使您的代码混乱。</li><li>调试语句使程序的输出混乱。</li><li>调试语句必须在完成后删除，这使得它们不可重用。</li><li>调试语句需要修改您的代码以添加和删除，这可能会引入新的错误。</li></ol><h3 id=条件化调试代码>条件化调试代码<a hidden class=anchor aria-hidden=true href=#条件化调试代码>#</a></h3><p>一种更容易在整个程序中禁用和启用调试的方法是使用预处理器指令使调试语句有条件：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#define ENABLE_DEBUG </span><span style=color:#007f7f>// comment out to disable debugging
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> getUserInput()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#ifdef ENABLE_DEBUG
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>std::cerr &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;getUserInput() called</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#endif
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;Enter a number: &#34;</span>;
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>int</span> x{};
</span></span><span style=display:flex><span>	std::cin &gt;&gt; x;
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> x;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#ifdef ENABLE_DEBUG
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>std::cerr &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;main() called</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#endif
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>    <span style=color:#fff;font-weight:700>int</span> x{ getUserInput() };
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;You entered: &#34;</span> &lt;&lt; x;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>现在我们可以通过注释/取消注释#define ENABLE_DEBUG 来启用调试。这使我们能够重用以前添加的调试语句，然后在用完它们后将它们禁用，而不必从代码中实际删除它们</p><p>这解决了必须删除调试语句的问题以及这样做的风险，但代价是代码更加混乱。这种方法的另一个缺点是，如果您输入错误（例如拼错“DEBUG”）或忘记将标头包含到代码文件中，则可能无法启用该文件的部分或全部调试</p><h3 id=使用日志>使用日志<a hidden class=anchor aria-hidden=true href=#使用日志>#</a></h3><p>通过预处理器进行条件化调试的另一种方法是将调试信息发送到日志文件。日志文件是记录软件中发生的事件的文件（通常存储在磁盘上）。将信息写入日志文件的过程称为日志记录。大多数应用程序和操作系统都会写入可用于帮助诊断发生的问题的日志文件</p><p>日志文件有几个优点。因为写入日志文件的信息与程序的输出是分开的，所以可以避免将正常输出和调试输出混合在一起造成的混乱。日志文件也可以很容易地发送给其他人进行诊断——所以如果有人使用你的软件有问题，你可以让他们把日志文件发给你，这可能会帮助你找到问题所在的线索</p><p>虽然您可以编写自己的代码来创建日志文件并将输出发送给它们，但最好还是使用许多现有的第三方日志记录工具之一</p><p>Using the <a href=https://github.com/SergiusTheBest/plog>plog</a> logger：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;plog/Log.h&gt; // Step 1: include the logger headers</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;plog/Initializers/RollingFileInitializer.h&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> getUserInput()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	PLOGD &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;getUserInput() called&#34;</span>; <span style=color:#007f7f>// PLOGD is defined by the plog library
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;Enter a number: &#34;</span>;
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>int</span> x{};
</span></span><span style=display:flex><span>	std::cin &gt;&gt; x;
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> x;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	plog::init(plog::debug, <span style=color:#0ff;font-weight:700>&#34;Logfile.txt&#34;</span>); <span style=color:#007f7f>// Step 2: initialize the logger
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>	PLOGD &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;main() called&#34;</span>; <span style=color:#007f7f>// Step 3: Output to the log as if you were writing to the console
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>int</span> x{ getUserInput() };
</span></span><span style=display:flex><span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;You entered: &#34;</span> &lt;&lt; x;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这是上述记录器的输出（在 <code>Logfile.txt</code> 文件中）：</p><pre tabindex=0><code>2018-12-26 20:03:33.295 DEBUG [4752] [main@14] main() called
2018-12-26 20:03:33.296 DEBUG [4752] [getUserInput@4] getUserInput() called
</code></pre><p>您如何包含、初始化和使用记录器将根据您选择的特定记录器而有所不同</p><p>请注意，使用此方法也不需要条件编译指令，因为大多数记录器都有减少/消除将输出写入日志的方法。这使得代码更容易阅读，因为条件编译行增加了很多混乱。使用 plog，可以通过将 init 语句更改为以下内容来暂时禁用日志记录：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>plog::init(plog::none , <span style=color:#0ff;font-weight:700>&#34;Logfile.txt&#34;</span>); <span style=color:#007f7f>// plog::none eliminates writing of most messages, essentially turning logging off
</span></span></span></code></pre></div><h2 id=使用集成调试器stepping步进>使用集成调试器：Stepping（步进）<a hidden class=anchor aria-hidden=true href=#使用集成调试器stepping步进>#</a></h2><p>当您运行您的程序时，执行从 main 函数的顶部开始，然后逐个语句按顺序执行，直到程序结束。在你的程序运行的任何时间点，程序都在跟踪很多事情：你正在使用的变量的值，调用了哪些函数（这样当这些函数返回时，程序就会知道在哪里返回），以及程序中的当前执行点（因此它知道接下来要执行哪个语句）。所有这些跟踪信息都称为您的程序状态（或简称为状态）</p><p><strong>Stepping</strong> 是一组相关调试器功能的名称，这些功能让我们逐条语句地执行（单步执行）我们的代码</p><p>箭头标记表示接下来将执行所指向的行</p><h3 id=step-into>Step into<a hidden class=anchor aria-hidden=true href=#step-into>#</a></h3><p><strong>步入</strong> 命令执行程序正常执行路径中的下一条语句，然后暂停程序的执行，以便我们可以使用调试器检查程序的状态。如果正在执行的语句包含一个函数调用，step into 会使程序跳转到被调用函数的顶部，并在那里暂停</p><h3 id=step-over>Step over<a hidden class=anchor aria-hidden=true href=#step-over>#</a></h3><p>同<strong>步入</strong>命令一样，<strong>步过</strong>命令执行程序正常执行路径中的下一条语句。然而，step into 将输入函数调用并逐行执行它们，step over 将不间断地执行整个函数，并在函数执行后将控制权返回给您</p><p>step over 命令提供了一种方便的方法来跳过函数，当您确定它们已经工作或现在对调试它们不感兴趣时</p><h3 id=step-out>Step out<a hidden class=anchor aria-hidden=true href=#step-out>#</a></h3><p>与其他两个步进命令不同，<strong>步出</strong> 命令不只是执行下一行代码。相反，它<strong>执行当前正在执行的函数中的所有剩余代码</strong>，然后在函数返回时将控制权返回给您</p><p>当你不小心进入了一个你不想调试的函数时，这个命令最有用</p><h2 id=使用集成调试器running-and-breakpoints运行和断点>使用集成调试器：Running and breakpoints（运行和断点）<a hidden class=anchor aria-hidden=true href=#使用集成调试器running-and-breakpoints运行和断点>#</a></h2><h3 id=run-to-cursor>Run to cursor<a hidden class=anchor aria-hidden=true href=#run-to-cursor>#</a></h3><p>第一个有用的命令通常称为<strong>运行到光标</strong>。此运行到光标命令执行程序，直到执行到达光标选择的语句。然后它将控制权返回给您，以便您可以从那时开始进行调试</p><h3 id=breakpoints>Breakpoints<a hidden class=anchor aria-hidden=true href=#breakpoints>#</a></h3><p><strong>断点</strong> 是一个特殊的标记，它告诉调试器在调试模式下运行时在断点处停止执行程序</p><h2 id=使用集成调试器调用堆栈>使用集成调试器：调用堆栈<a hidden class=anchor aria-hidden=true href=#使用集成调试器调用堆栈>#</a></h2><p>调用堆栈是为到达当前执行点而调用的所有活动函数的列表。调用堆栈包括每个调用的函数的条目，以及函数返回时将返回到哪一行代码。每当调用一个新函数时，该函数就会被添加到调用堆栈的顶部。当前函数返回给调用者时，它会从调用栈的顶部移除，控制权会返回到它下面的函数</p><p>调用堆栈窗口是一个显示当前调用堆栈的调试器窗口</p><p>函数名称后的行号显示了每个函数中要执行的下一行</p><p>由于调用堆栈的顶部条目代表当前正在执行的函数，因此此处的行号显示了执行恢复时将执行的下一行。调用堆栈中的其余条目表示将在某个时间点返回的函数，因此这些条目的行号表示函数返回后将执行的下一条语句</p><h2 id=在问题成为问题之前发现问题>在问题成为问题之前发现问题<a hidden class=anchor aria-hidden=true href=#在问题成为问题之前发现问题>#</a></h2><h3 id=重构你的代码>重构你的代码<a hidden class=anchor aria-hidden=true href=#重构你的代码>#</a></h3><p>当您向程序添加新功能（“行为更改”）时，您会发现某些功能的长度会增加。随着函数越来越长，它们变得越来越复杂，也越来越难以理解</p><p>解决此问题的一种方法是将单个长函数分解为多个较短的函数。这种在不改变代码行为的情况下对代码进行结构更改的过程（通常是为了使您的程序更有组织性、模块化或性能）称为<strong>重构</strong></p><p>一个函数占据一个垂直屏幕的代码通常被认为太长了——如果你必须滚动才能阅读整个函数，函数的可理解性会显着下降。但越短越好 &ndash; 少于十行的功能是好的。少于五行的函数就更好了</p><p>更改代码时，<strong>进行行为更改或结构更改</strong>，然后重新测试正确性。同时进行行为和结构更改往往会导致更多错误以及更难发现的错误</p><h3 id=约束>约束<a hidden class=anchor aria-hidden=true href=#约束>#</a></h3><p>基于约束的技术涉及添加一些额外的代码（如果需要，可以在非调试构建中编译出来）以检查是否违反了某些假设或期望集</p><p>例如，如果我们正在编写一个函数来计算一个数字的阶乘，它需要一个非负参数，该函数可以检查以确保调用者在继续之前传递了一个非负数。如果调用者传入一个负数，那么该函数可能会立即出错，而不是产生一些不确定的结果，从而有助于确保立即发现问题</p><p>一种常见的方法是通过 assert 和 static_assert</p><h1 id=基本数据类型>基本数据类型<a hidden class=anchor aria-hidden=true href=#基本数据类型>#</a></h1><h2 id=数据类型大小>数据类型大小<a hidden class=anchor aria-hidden=true href=#数据类型大小>#</a></h2><p>数据类型的大小取决于编译器和计算机体系结构！</p><p>C++ 仅保证每个基本数据类型都具有最小大小<div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/26/6381d2545c3fa.png><img src=https://bu.dusays.com/2022/11/26/6381d2545c3fa.png alt=1></a></div></p><p>为了获得最大的兼容性，您不应假设变量大于指定的最小大小</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;bool:</span><span style=color:#0ff;font-weight:700>\t\t</span><span style=color:#0ff;font-weight:700>&#34;</span> &lt;&lt; <span style=color:#fff;font-weight:700>sizeof</span>(<span style=color:#fff;font-weight:700>bool</span>) &lt;&lt; <span style=color:#0ff;font-weight:700>&#34; bytes</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;char:</span><span style=color:#0ff;font-weight:700>\t\t</span><span style=color:#0ff;font-weight:700>&#34;</span> &lt;&lt; <span style=color:#fff;font-weight:700>sizeof</span>(<span style=color:#fff;font-weight:700>char</span>) &lt;&lt; <span style=color:#0ff;font-weight:700>&#34; bytes</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;wchar_t:</span><span style=color:#0ff;font-weight:700>\t</span><span style=color:#0ff;font-weight:700>&#34;</span> &lt;&lt; <span style=color:#fff;font-weight:700>sizeof</span>(<span style=color:#fff;font-weight:700>wchar_t</span>) &lt;&lt; <span style=color:#0ff;font-weight:700>&#34; bytes</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;char16_t:</span><span style=color:#0ff;font-weight:700>\t</span><span style=color:#0ff;font-weight:700>&#34;</span> &lt;&lt; <span style=color:#fff;font-weight:700>sizeof</span>(<span style=color:#fff;font-weight:700>char16_t</span>) &lt;&lt; <span style=color:#0ff;font-weight:700>&#34; bytes</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;char32_t:</span><span style=color:#0ff;font-weight:700>\t</span><span style=color:#0ff;font-weight:700>&#34;</span> &lt;&lt; <span style=color:#fff;font-weight:700>sizeof</span>(<span style=color:#fff;font-weight:700>char32_t</span>) &lt;&lt; <span style=color:#0ff;font-weight:700>&#34; bytes</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;short:</span><span style=color:#0ff;font-weight:700>\t\t</span><span style=color:#0ff;font-weight:700>&#34;</span> &lt;&lt; <span style=color:#fff;font-weight:700>sizeof</span>(<span style=color:#fff;font-weight:700>short</span>) &lt;&lt; <span style=color:#0ff;font-weight:700>&#34; bytes</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;int:</span><span style=color:#0ff;font-weight:700>\t\t</span><span style=color:#0ff;font-weight:700>&#34;</span> &lt;&lt; <span style=color:#fff;font-weight:700>sizeof</span>(<span style=color:#fff;font-weight:700>int</span>) &lt;&lt; <span style=color:#0ff;font-weight:700>&#34; bytes</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;long:</span><span style=color:#0ff;font-weight:700>\t\t</span><span style=color:#0ff;font-weight:700>&#34;</span> &lt;&lt; <span style=color:#fff;font-weight:700>sizeof</span>(<span style=color:#fff;font-weight:700>long</span>) &lt;&lt; <span style=color:#0ff;font-weight:700>&#34; bytes</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;long long:</span><span style=color:#0ff;font-weight:700>\t</span><span style=color:#0ff;font-weight:700>&#34;</span> &lt;&lt; <span style=color:#fff;font-weight:700>sizeof</span>(<span style=color:#fff;font-weight:700>long</span> <span style=color:#fff;font-weight:700>long</span>) &lt;&lt; <span style=color:#0ff;font-weight:700>&#34; bytes</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;float:</span><span style=color:#0ff;font-weight:700>\t\t</span><span style=color:#0ff;font-weight:700>&#34;</span> &lt;&lt; <span style=color:#fff;font-weight:700>sizeof</span>(<span style=color:#fff;font-weight:700>float</span>) &lt;&lt; <span style=color:#0ff;font-weight:700>&#34; bytes</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;double:</span><span style=color:#0ff;font-weight:700>\t\t</span><span style=color:#0ff;font-weight:700>&#34;</span> &lt;&lt; <span style=color:#fff;font-weight:700>sizeof</span>(<span style=color:#fff;font-weight:700>double</span>) &lt;&lt; <span style=color:#0ff;font-weight:700>&#34; bytes</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;long double:</span><span style=color:#0ff;font-weight:700>\t</span><span style=color:#0ff;font-weight:700>&#34;</span> &lt;&lt; <span style=color:#fff;font-weight:700>sizeof</span>(<span style=color:#fff;font-weight:700>long</span> <span style=color:#fff;font-weight:700>double</span>) &lt;&lt; <span style=color:#0ff;font-weight:700>&#34; bytes</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>下面是我的 x64 机器的输出，使用 Clion：</p><pre tabindex=0><code>bool:           1 bytes
char:           1 bytes
wchar_t:        2 bytes
char16_t:       2 bytes
char32_t:       4 bytes
short:          2 bytes
int:            4 bytes
long:           4 bytes
long long:      8 bytes
float:          4 bytes
double:         8 bytes
long double:    16 bytes
</code></pre><p>如果您使用不同类型的机器或不同的编译器，您的结果可能会有所不同。请注意，您不能对 void 类型使用 sizeof 运算符，因为它没有大小（这样做会导致编译错误）</p><h2 id=无符号整数和有符号整数>无符号整数和有符号整数<a hidden class=anchor aria-hidden=true href=#无符号整数和有符号整数>#</a></h2><p>有符号整数范围：<div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/26/6381d81f385fa.png><img src=https://bu.dusays.com/2022/11/26/6381d81f385fa.png alt=1></a></div></p><p>无符号整数范围：<div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/26/6381d91f961eb.png><img src=https://bu.dusays.com/2022/11/26/6381d91f961eb.png alt=1></a></div></p><p>如果无符号整数超出范围，则将其除以大于该类型的最大数，只保留余数</p><p>在 C++ 的数学运算中（例如算术或比较），如果使用一个有符号整数和一个无符号整数，则<strong>有符号整数将转换为无符号整数</strong>。并且无符号整数不能存储负数，这会导致数据丢失</p><p>在保存整数（甚至应该是非负的整数）和数学运算时，有符号数优于无符号数。避免混合有符号和无符号数字</p><p>在 C++ 中仍然有一些情况必须使用无符号数：</p><p>首先，在处理位操作时首选无符号数。当需要明确定义的环绕行为时，它们也很有用（在某些算法中很有用，例如加密和随机数生成）</p><p>其次，无符号数的使用在某些情况下仍然是不可避免的，主要是那些与数组索引有关的情况。。在这些情况下，无符号值可以转换为有符号值</p><h2 id=固定宽度整数和-size_t>固定宽度整数和 size_t<a hidden class=anchor aria-hidden=true href=#固定宽度整数和-size_t>#</a></h2><h3 id=fixed-width-整数>Fixed-width 整数<a hidden class=anchor aria-hidden=true href=#fixed-width-整数>#</a></h3><p>为什么整数变量的大小不固定？</p><p>这可以追溯到 C，当时计算机速度很慢，性能是最受关注的问题。 C 选择有意保留整数的大小，以便编译器实现者可以选择在目标计算机体系结构上表现最佳的 int 大小</p><p>C99 定义了一组固定宽度的整数（在 stdint.h 头文件中），保证在任何体系结构上都具有相同的大小</p><p>C++ 正式采用这些固定宽度整数作为 C++11 的一部分。可以通过包含 <code>&lt;cstdint></code> 头文件来访问它们，它们在 std 命名空间内定义</p><p><div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/26/6381dcb67d0e0.png><img src=https://bu.dusays.com/2022/11/26/6381dcb67d0e0.png alt=1></a></div></p><h3 id=fast-and-least-整数>Fast and least 整数<a hidden class=anchor aria-hidden=true href=#fast-and-least-整数>#</a></h3><p>The fast 类型（<code>std::int_fast#_t</code> 和 <code>std::uint_fast#_t</code>）提供最快的有符号/无符号整数类型，宽度至少为 # 位（其中 # = 8、16、32 或 64）。例如，<code>std::int_fast32_t</code> 将为您提供最快的至少 32 位的有符号整数类型</p><p>The least 类型（<code>std::int_least#_t</code> 和 <code>std::uint_least#_t</code>）提供宽度至少为 # 位（其中 # = 8、16、32 或 64）的最小有符号/无符号整数类型。例如，<code>std::uint_least32_t</code> 将为您提供至少 32 位的最小无符号整数类型</p><p>示例：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;cstdint&gt; // for fixed-width integers</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;least 8:  &#34;</span> &lt;&lt; <span style=color:#fff;font-weight:700>sizeof</span>(std::<span style=color:#fff;font-weight:700>int_least8_t</span>) * <span style=color:#ff0;font-weight:700>8</span> &lt;&lt; <span style=color:#0ff;font-weight:700>&#34; bits</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;least 16: &#34;</span> &lt;&lt; <span style=color:#fff;font-weight:700>sizeof</span>(std::<span style=color:#fff;font-weight:700>int_least16_t</span>) * <span style=color:#ff0;font-weight:700>8</span> &lt;&lt; <span style=color:#0ff;font-weight:700>&#34; bits</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;least 32: &#34;</span> &lt;&lt; <span style=color:#fff;font-weight:700>sizeof</span>(std::<span style=color:#fff;font-weight:700>int_least32_t</span>) * <span style=color:#ff0;font-weight:700>8</span> &lt;&lt; <span style=color:#0ff;font-weight:700>&#34; bits</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;fast 8:  &#34;</span> &lt;&lt; <span style=color:#fff;font-weight:700>sizeof</span>(std::<span style=color:#fff;font-weight:700>int_fast8_t</span>) * <span style=color:#ff0;font-weight:700>8</span> &lt;&lt; <span style=color:#0ff;font-weight:700>&#34; bits</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;fast 16: &#34;</span> &lt;&lt; <span style=color:#fff;font-weight:700>sizeof</span>(std::<span style=color:#fff;font-weight:700>int_fast16_t</span>) * <span style=color:#ff0;font-weight:700>8</span> &lt;&lt; <span style=color:#0ff;font-weight:700>&#34; bits</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;fast 32: &#34;</span> &lt;&lt; <span style=color:#fff;font-weight:700>sizeof</span>(std::<span style=color:#fff;font-weight:700>int_fast32_t</span>) * <span style=color:#ff0;font-weight:700>8</span> &lt;&lt; <span style=color:#0ff;font-weight:700>&#34; bits</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Result：</p><pre tabindex=0><code>least 8:  8 bits
least 16: 16 bits
least 32: 32 bits

fast 8:  8 bits
fast 16: 16 bits
fast 32: 32 bits
</code></pre><p>然而，这些快速且最小的整数有其自身的缺点：首先，真正使用它们的程序员并不多，不熟悉会导致错误。其次，快速类型会导致与我们在 4 字节整数中看到的相同类型的内存浪费。最严重的是，由于快速/最小整数的大小可能会有所不同，因此您的程序可能会在解析为不同大小的架构上表现出不同的行为</p><h3 id=stdint8_t-和-stduint8_t-可能表现得像字符而不是整数>std::int8_t 和 std::uint8_t 可能表现得像字符而不是整数<a hidden class=anchor aria-hidden=true href=#stdint8_t-和-stduint8_t-可能表现得像字符而不是整数>#</a></h3><p>由于 C++ 规范中的疏忽，大多数编译器分别将 std::int8_t 和 std::uint8_t（以及相应的快速和最小固定宽度类型）定义为 signed char 和 unsigned char 类型，并将其视为相同的类型。这意味着这些 8 位类型的行为可能（或可能不）与其他固定宽度类型不同，这可能会导致错误。此行为是系统相关的，因此在一种体系结构上正确运行的程序可能无法编译或在另一种体系结构上正确运行</p><p>为了保持一致性，最好完全避免使用 std::int8_t 和 std::uint8_t（以及相关的快速和最少类型）（改用 std::int16_t 或 std::uint16_t）</p><p>8 位固定宽度整数类型通常被视为字符而不是整数值（这可能因系统而异）。大多数情况下首选 16 位固定整数类型</p><h3 id=best-practice>Best practice<a hidden class=anchor aria-hidden=true href=#best-practice>#</a></h3><p>我们的立场是正确比快速更好，在编译时失败比运行时更好——因此，我们建议避免使用快速/最少的类型，而使用固定宽度的类型。如果您后来发现需要支持无法编译固定宽度类型的平台，那么您可以在此时决定如何迁移您的程序（并彻底测试）</p><ol><li>当整数的大小无关紧要时，首选 int（例如，数字将始终适合 2 字节有符号整数的范围）。例如，如果您要求用户输入他们的年龄，或者从 1 数到 10，则 int 是 16 位还是 32 位都没有关系（数字将适合任何一种方式）。这将涵盖您可能遇到的绝大多数情况</li><li>存储需要保证范围的数量时，首选 <code>std::int#_t</code></li><li>在进行位操作或需要明确定义的环绕行为时，首选 <code>std::uint#_t</code></li><li>尽可能避免以下情况：<ol><li>存储数量的无符号类型</li><li>8 位固定宽度整数类型</li><li>Fast and least 整数类型</li><li>任何特定于编译器的固定宽度整数——例如，Visual Studio 定义了 <code>__int8</code>、<code>__int16</code> ……</li></ol></li></ol><h3 id=size_t>size_t<a hidden class=anchor aria-hidden=true href=#size_t>#</a></h3><p>sizeof（以及许多返回大小或长度值的函数）返回一个 std::size_t 类型的值。 std::size_t 被定义为无符号整数类型，通常用于表示对象的大小或长度</p><p>有趣的是，我们可以使用 sizeof 运算符（返回 std::size_t 类型的值）来询问 std::size_t 本身的大小：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;cstddef&gt; // std::size_t</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	std::cout &lt;&lt; <span style=color:#fff;font-weight:700>sizeof</span>(std::size_t) &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>就像整数的大小会因系统而异一样，std::size_t 的大小也会有所不同。 std::size_t 保证为无符号且至少为 16 位，但在大多数系统上将等同于应用程序的地址宽度。也就是说，对于 32 位应用程序，std::size_t 通常是 32 位无符号整数，而对于 64 位应用程序，size_t 通常是 64 位无符号整数。 size_t 被定义为足够大以容纳系统上可创建的最大对象的大小（以字节为单位）。例如，如果 std::size_t 为 4 字节宽，则系统上可创建的最大对象不能大于 4,294,967,295 字节，因为 4,294,967,295 是 4 字节无符号整数可以存储的最大数字。这只是对象大小的上限，实际大小限制可能会更低，具体取决于您使用的编译器</p><p>根据定义，任何大小（以字节为单位）大于 size_t 可以容纳的最大整数值的对象都被视为格式错误（并将导致编译错误），因为 sizeof 运算符将无法在不环绕的情况下返回大小</p><h2 id=浮点数ieee-754>浮点数（IEEE 754）<a hidden class=anchor aria-hidden=true href=#浮点数ieee-754>#</a></h2><h3 id=浮点范围和浮点精度>浮点范围和浮点精度<a hidden class=anchor aria-hidden=true href=#浮点范围和浮点精度>#</a></h3><p><div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/26/63820f12cc479.png><img src=https://bu.dusays.com/2022/11/26/63820f12cc479.png alt=1></a></div></p><p>使用浮点文字时，始终至少包含一位小数（即使小数为 0）。这有助于编译器理解该数字是浮点数而不是整数</p><pre tabindex=0><code>int x{5}; // 5 means integer
double y{5.0}; // 5.0 is a floating point literal (no suffix means double type by default)
float z{5.0f}; // 5.0 is a floating point literal, f suffix means float type
</code></pre><p>始终确保字面量的类型与分配给它们或用于初始化的变量的类型相匹配。否则会导致不必要的转换，可能会导致精度损失</p><p>确保在应该使用浮点文字的地方不使用整数文字。这包括初始化浮点对象或为浮点对象赋值、进行浮点运算以及调用需要浮点值的函数</p><p><div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/26/6382110b7d067.png><img src=https://bu.dusays.com/2022/11/26/6382110b7d067.png alt></a></div></p><p>输出浮点数时，std::cout 的默认精度为 6——也就是说，它假定所有浮点变量仅对 6 位有效（浮点数的最小精度），因此它将截断之后的任何内容</p><p>浮点变量的精度位数取决于大小（浮点数的精度低于双精度数）和存储的特定值（某些值的精度高于其他值）。浮点值的精度在 6 到 9 位之间，大多数浮点值至少有 7 位有效数字。双精度值的精度在 15 到 18 位之间，大多数双精度值至少有 16 位有效数字。 Long double 的最小精度为 15、18 或 33 位有效数字，具体取决于它占用的字节数</p><h3 id=舍入误差>舍入误差<a hidden class=anchor aria-hidden=true href=#舍入误差>#</a></h3><p>我们可以使用名为 std::setprecision() 的输出操纵器函数覆盖 std::cout 显示的默认精度。输出操纵器改变数据的输出方式，并在 iomanip 标头中定义</p><pre tabindex=0><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt; // for output manipulator std::setprecision()

int main()
{
    std::cout &lt;&lt; std::setprecision(16); // show 16 digits of precision
    std::cout &lt;&lt; 3.33333333333333333333333333333333333333f &lt;&lt;&#39;\n&#39;; // f suffix means float
    std::cout &lt;&lt; 3.33333333333333333333333333333333333333 &lt;&lt; &#39;\n&#39;; // no suffix means double

    return 0;
}
</code></pre><p>在使用需要比变量所能容纳的精度更高的浮点数时，必须小心</p><p><strong>除非空间非常宝贵，否则最好使用 double over float，因为 float 缺乏精度通常会导致不准确</strong></p><p>值 123456789.0 具有 10 位有效数字，但浮点值通常具有 7 位精度（而 123456792 的结果仅精确到 7 位有效数字）。我们失去了一些精度！当由于无法精确存储数字而导致精度丢失时，这称为<strong>舍入误差</strong></p><p>数学运算（例如加法和乘法）往往会使舍入误差增大。所以即使0.1在第17位有效位有舍入误差，但是当我们加上0.1十次时，舍入误差已经爬到第16位有效位了。继续操作会导致此错误变得越来越严重</p><h3 id=nan-和-inf>NaN 和 Inf<a hidden class=anchor aria-hidden=true href=#nan-和-inf>#</a></h3><p>有两种特殊类别的浮点数。第一个是 <code>Inf</code>，代表无穷大。 Inf 可以是正数或负数。第二个是 <code>NaN</code>，代表“不是数字”。有几种不同类型的 NaN（我们不会在这里讨论）。 NaN 和 Inf 仅在编译器对浮点数使用特定格式 (IEEE 754) 时可用</p><h3 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h3><p>总而言之，关于浮点数你应该记住两件事：</p><p>浮点数对于存储非常大或非常小的数字很有用，包括带有小数部分的数字</p><p>浮点数通常有小的舍入误差，即使数字的有效数字少于精度也是如此。很多时候这些都没有引起注意，因为它们太小了，而且因为输出的数字被截断了。但是，浮点数的比较可能不会给出预期的结果。对这些值执行数学运算将导致舍入误差变大</p><h2 id=布尔值>布尔值<a hidden class=anchor aria-hidden=true href=#布尔值>#</a></h2><p>如果您希望 std::cout 打印“true”或“false”而不是 0 或 1，您可以使用 std::boolalpha。这是一个例子：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#fff;font-weight:700>true</span> &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#fff;font-weight:700>false</span> &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    std::cout &lt;&lt; std::boolalpha; <span style=color:#007f7f>// print bools as true or false
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#fff;font-weight:700>true</span> &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#fff;font-weight:700>false</span> &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>您可以使用 std::noboolalpha 将其关闭</p><p>您不能使用除 0 1 外的整数初始化布尔值：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>bool</span> b{ <span style=color:#ff0;font-weight:700>4</span> }; <span style=color:#007f7f>// error: narrowing conversions disallowed
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	std::cout &lt;&lt; b;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>但是，在任何可以将整数转换为布尔值的上下文中，整数 0 将转换为 false，而任何其他整数将转换为 true</p><p>事实证明，std::cin 只接受布尔变量的两个输入：0 和 1（不是 true 或 false）。任何其他输入都会导致 std::cin 无声地失败。在这种情况下，因为我们输入了 true，所以 std::cin 默默地失败了。失败的输入也会将变量清零，因此 b 也被赋值 false。因此，当 std::cout 打印 b 的值时，它打印 0</p><p>要允许 std::cin 接受“false”和“true”作为输入，必须启用 std::boolalpha 选项：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>bool</span> b{};
</span></span><span style=display:flex><span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;Enter a boolean value: &#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#007f7f>// Allow the user to enter &#39;true&#39; or &#39;false&#39; for boolean values
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	<span style=color:#007f7f>// This is case-sensitive, so True or TRUE will not work
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	std::cin &gt;&gt; std::boolalpha;
</span></span><span style=display:flex><span>	std::cin &gt;&gt; b;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;You entered: &#34;</span> &lt;&lt; b &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>但是，当启用 std::boolalpha 时，“0”和“1”将不再被视为布尔值</p><h2 id=chars>Chars<a hidden class=anchor aria-hidden=true href=#chars>#</a></h2><p>char 数据类型旨在保存单个字符。字符可以是单个字母、数字、符号或空格</p><p>char 数据类型是整数类型，这意味着基础值存储为整数。类似于布尔值 0 被解释为 false 而非零被解释为 true 的方式，char 变量存储的整数被解释为 ASCII 字符</p><p>Char 由 C++ 定义为大小始终为 1 个字节。默认情况下，char 可以是有符号的或无符号的（尽管它通常是有符号的）。如果您使用 chars 来保存 ASCII 字符，则不需要指定符号（因为有符号和无符号字符都可以保存 0 到 127 之间的值）</p><p>如果您使用 char 来保存小整数（除非您明确优化空间，否则您不应该这样做），您应该始终指定它是有符号的还是无符号的。 signed char 可以保存 -128 到 127 之间的数字。unsigned char 可以保存 0 到 255 之间的数字</p><p><strong>将单个字符放在单引号中（ e.g. <code>'t'</code> or <code>'\n'</code>, not <code>"t"</code> or <code>"\n"</code>）这有助于编译器更有效地进行优化</strong></p><p>出于向后兼容性的原因，许多 C++ 编译器支持多字符文字，即包含多个字符（例如“56”）的字符文字。如果支持，它们具有实现定义的值（意味着它因编译器而异）。因为它们不是 C++ 标准的一部分，而且它们的值也没有严格定义，所以应该避免使用多字符文字</p><p>ASCII 之外最著名的映射是 Unicode 标准，它将超过 144,000 个整数映射到许多不同语言的字符。由于 Unicode 包含如此多的代码点，因此单个 Unicode 代码点需要 32 位来表示一个字符（称为 UTF-32）。但是，Unicode 字符也可以使用多个 16 位或 8 位字符（分别称为 UTF-16 和 UTF-8）进行编码</p><p>char16_t 和 char32_t 添加到 C++11 以提供对 16 位和 32 位 Unicode 字符的明确支持。 C++20 中添加了 char8_t</p><p>您不需要使用 char8_t、char16_t 或 char32_t，除非您计划让您的程序与 Unicode 兼容</p><p>同时，在处理字符（和字符串）时，您应该只使用 ASCII 字符。使用来自其他字符集的字符可能会导致您的字符显示不正确</p><h2 id=常量和符号常量>常量和符号常量<a hidden class=anchor aria-hidden=true href=#常量和符号常量>#</a></h2><h3 id=const-variables>const variables<a hidden class=anchor aria-hidden=true href=#const-variables>#</a></h3><p>Const 变量必须在定义它们时进行初始化，然后不能通过赋值更改该值</p><p>Const 变量可以从其他变量（包括非常量变量）初始化</p><p>命名时以 “k” 开头, 大小写混合,例如：</p><pre tabindex=0><code>const int kDaysInAWeek = 7;
</code></pre><h3 id=符号常量>符号常量<a hidden class=anchor aria-hidden=true href=#符号常量>#</a></h3><p>符号常量指的是<strong>被赋予常量值的名称</strong>。<code>const variables</code> 是一种符号常量，因为变量有一个名称（它的标识符）和一个常量值</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#define MAX_STUDENTS_PER_CLASS 30
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;The class has &#34;</span> &lt;&lt; MAX_STUDENTS_PER_CLASS &lt;&lt; <span style=color:#0ff;font-weight:700>&#34; students.</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>编译此程序时，预处理器会将 MAX_STUDENTS_PER_CLASS 替换为字面值 30，然后编译器会将其编译为您的可执行文件</p><p>因为类对象宏有一个名字，并且替换文本是一个常量值，所以带有替换文本的类对象宏也是符号常量</p><h3 id=对于符号常量更喜欢常量变量而不是类对象宏>对于符号常量，更喜欢常量变量而不是类对象宏<a hidden class=anchor aria-hidden=true href=#对于符号常量更喜欢常量变量而不是类对象宏>#</a></h3><p>首先，因为宏是由预处理器解析的，所有出现的宏都在编译之前被定义的值替换。如果您正在调试代码，您将看不到实际值（例如 30）——您只会看到符号常量的名称（例如 MAX_STUDENTS_PER_CLASS）。因为这些#defined 值不是变量，所以您无法在调试器中添加监视来查看它们的值。如果您想知道 MAX_STUDENTS_PER_CLASS 解析为什么值，您必须找到 MAX_STUDENTS_PER_CLASS 的定义（可能在不同的文件中）。这会使您的程序更难调试</p><p>其次，宏可能与普通代码有命名冲突</p><p>第三，宏不遵循正常的作用域规则，这意味着在极少数情况下，在程序的一部分中定义的宏可能会与在程序的另一部分中编写的代码发生冲突，而它不应该与之交互</p><h2 id=编译时常量常量表达式和-constexpr>编译时常量、常量表达式和 constexpr<a hidden class=anchor aria-hidden=true href=#编译时常量常量表达式和-constexpr>#</a></h2><h3 id=constant-expressions>Constant expressions<a hidden class=anchor aria-hidden=true href=#constant-expressions>#</a></h3><p>常量表达式是可以在编译时由编译器求值的表达式。要成为常量表达式，表达式中的所有值必须在编译时已知（并且所有调用的运算符和函数必须支持编译时求值）</p><p>在编译时对常量表达式求值会使我们的编译时间变长（因为编译器必须做更多的工作），但这样的表达式只需要求值一次（而不是每次程序运行时）。生成的可执行文件速度更快，使用的内存更少</p><h3 id=compile-time-constants>Compile-time constants<a hidden class=anchor aria-hidden=true href=#compile-time-constants>#</a></h3><p>编译时常量是其值在编译时已知的常量。文字（例如“1”、“2.3”和“Hello, world!”）是一种编译时常量</p><p>Const 变量可能是也可能不是编译时常量</p><h3 id=compile-time-const>Compile-time const<a hidden class=anchor aria-hidden=true href=#compile-time-const>#</a></h3><p>如果 const 变量的初始值设定项是常量表达式，则它是编译时常量</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>const</span> <span style=color:#fff;font-weight:700>int</span> x { <span style=color:#ff0;font-weight:700>3</span> };  <span style=color:#007f7f>// x is a compile-time const
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	<span style=color:#fff;font-weight:700>const</span> <span style=color:#fff;font-weight:700>int</span> y { <span style=color:#ff0;font-weight:700>4</span> };  <span style=color:#007f7f>// y is a compile-time const
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>const</span> <span style=color:#fff;font-weight:700>int</span> z { x + y }; <span style=color:#007f7f>// x + y is a compile-time expression
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>	std::cout &lt;&lt; z &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>因为 x 和 y 的初始化值是常量表达式，所以 x 和 y 是编译时常量。这意味着 x + y 也是常量表达式。所以当编译器编译这个程序时，它可以计算 x + y 的值，并将常量表达式替换为结果文字 7</p><h3 id=runtime-const>Runtime const<a hidden class=anchor aria-hidden=true href=#runtime-const>#</a></h3><p>任何使用非常量表达式初始化的 const 变量都是运行时常量。运行时常量是其初始化值直到运行时才知道的常量</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> getNumber()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;Enter a number: &#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>int</span> y{};
</span></span><span style=display:flex><span>    std::cin &gt;&gt; y;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> y;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>const</span> <span style=color:#fff;font-weight:700>int</span> x{ <span style=color:#ff0;font-weight:700>3</span> };           <span style=color:#007f7f>// x is a compile time constant
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>const</span> <span style=color:#fff;font-weight:700>int</span> y{ getNumber() }; <span style=color:#007f7f>// y is a runtime constant
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>const</span> <span style=color:#fff;font-weight:700>int</span> z{ x + y };       <span style=color:#007f7f>// x + y is a runtime expression
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    std::cout &lt;&lt; z &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;     <span style=color:#007f7f>// this is also a runtime expression
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>即使 y 是常量，初始化值（getNumber() 的返回值）直到运行时才知道。因此，y 是运行时常量，而不是编译时常量。因此，表达式 x + y 是一个运行时表达式</p><h3 id=constexpr-关键字>constexpr 关键字<a hidden class=anchor aria-hidden=true href=#constexpr-关键字>#</a></h3><p>当你声明一个 const 变量时，编译器会隐式地跟踪它是运行时常量还是编译时常量。在大多数情况下，除了优化目的之外，这无关紧要，但有一些奇怪的情况，C++ 需要编译时常量而不是运行时常量</p><p>因为编译时常量通常允许更好的优化（并且几乎没有缺点），所以我们通常希望尽可能使用编译时常量</p><p>我们可以寻求编译器的帮助，以确保我们得到一个我们期望的编译时常量。为此，我们在变量声明中使用 constexpr 关键字而不是 const。 constexpr（“常量表达式”的缩写）变量只能是编译时常量。如果 constexpr 变量的初始化值不是常量表达式，编译器会出错</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> five()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>5</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>constexpr</span> <span style=color:#fff;font-weight:700>double</span> gravity { <span style=color:#ff0;font-weight:700>9.8</span> }; <span style=color:#007f7f>// ok: 9.8 is a constant expression
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> <span style=color:#fff;font-weight:700>int</span> sum { <span style=color:#ff0;font-weight:700>4</span> + <span style=color:#ff0;font-weight:700>5</span> };      <span style=color:#007f7f>// ok: 4 + 5 is a constant expression
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> <span style=color:#fff;font-weight:700>int</span> something { sum };  <span style=color:#007f7f>// ok: sum is a constant expression
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;Enter your age: &#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>int</span> age{};
</span></span><span style=display:flex><span>    std::cin &gt;&gt; age;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>constexpr</span> <span style=color:#fff;font-weight:700>int</span> myAge { age };      <span style=color:#007f7f>// compile error: age is not a constant expression
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> <span style=color:#fff;font-weight:700>int</span> f { five() };       <span style=color:#007f7f>// compile error: return value of five() is not a constant expression
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>任何在初始化后不应修改且其初始值设定项在编译时已知的变量都应声明为 <code>constexpr</code></p><p>任何在初始化后不应修改且其初始值设定项在编译时未知的变量都应声明为 <code>const</code></p><h2 id=literals>Literals<a hidden class=anchor aria-hidden=true href=#literals>#</a></h2><p>文字是直接插入代码中的未命名值。例如：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>5</span>;                   <span style=color:#007f7f>// 5 is an integer literal
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>bool</span> myNameIsAlex { <span style=color:#fff;font-weight:700>true</span> }; <span style=color:#007f7f>// true is a boolean literal
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>std::cout &lt;&lt; <span style=color:#ff0;font-weight:700>3.4</span>;           <span style=color:#007f7f>// 3.4 is a double literal
</span></span></span></code></pre></div><p>如对象有类型一样，所有文字都有类型。文字的类型是从文字的值推导出来的</p><h2 id=十进制二进制十六进制和八进制>十进制、二进制、十六进制和八进制<a hidden class=anchor aria-hidden=true href=#十进制二进制十六进制和八进制>#</a></h2><h3 id=二进制文字和数字分隔符>二进制文字和数字分隔符<a hidden class=anchor aria-hidden=true href=#二进制文字和数字分隔符>#</a></h3><p>在 C++14 之前，不支持二进制文字。然而，十六进制文字为我们提供了一个有用的解决方法（您可能仍会在现有代码库中看到）：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>int</span> bin{};    <span style=color:#007f7f>// assume 16-bit ints
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    bin = <span style=color:#ff0;font-weight:700>0x0001</span>; <span style=color:#007f7f>// assign binary 0000 0000 0000 0001 to the variable
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    bin = <span style=color:#ff0;font-weight:700>0x0002</span>; <span style=color:#007f7f>// assign binary 0000 0000 0000 0010 to the variable
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    bin = <span style=color:#ff0;font-weight:700>0x0004</span>; <span style=color:#007f7f>// assign binary 0000 0000 0000 0100 to the variable
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    bin = <span style=color:#ff0;font-weight:700>0x0008</span>; <span style=color:#007f7f>// assign binary 0000 0000 0000 1000 to the variable
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    bin = <span style=color:#ff0;font-weight:700>0x0010</span>; <span style=color:#007f7f>// assign binary 0000 0000 0001 0000 to the variable
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    bin = <span style=color:#ff0;font-weight:700>0x0020</span>; <span style=color:#007f7f>// assign binary 0000 0000 0010 0000 to the variable
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    bin = <span style=color:#ff0;font-weight:700>0x0040</span>; <span style=color:#007f7f>// assign binary 0000 0000 0100 0000 to the variable
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    bin = <span style=color:#ff0;font-weight:700>0x0080</span>; <span style=color:#007f7f>// assign binary 0000 0000 1000 0000 to the variable
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    bin = <span style=color:#ff0;font-weight:700>0x00FF</span>; <span style=color:#007f7f>// assign binary 0000 0000 1111 1111 to the variable
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    bin = <span style=color:#ff0;font-weight:700>0x00B3</span>; <span style=color:#007f7f>// assign binary 0000 0000 1011 0011 to the variable
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    bin = <span style=color:#ff0;font-weight:700>0xF770</span>; <span style=color:#007f7f>// assign binary 1111 0111 0111 0000 to the variable
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在 C++14 中，我们可以通过使用 0b 前缀来使用二进制文字：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>int</span> bin{};        <span style=color:#007f7f>// assume 16-bit ints
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    bin = <span style=color:#ff0;font-weight:700>0b1</span>;        <span style=color:#007f7f>// assign binary 0000 0000 0000 0001 to the variable
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    bin = <span style=color:#ff0;font-weight:700>0b11</span>;       <span style=color:#007f7f>// assign binary 0000 0000 0000 0011 to the variable
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    bin = <span style=color:#ff0;font-weight:700>0b1010</span>;     <span style=color:#007f7f>// assign binary 0000 0000 0000 1010 to the variable
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    bin = <span style=color:#ff0;font-weight:700>0b11110000</span>; <span style=color:#007f7f>// assign binary 0000 0000 1111 0000 to the variable
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>由于长文本可能难以阅读，C++14 还添加了使用引号 (‘) 作为数字分隔符的功能（分隔符不能出现在值的第一位数字之前）（数字分隔符纯粹是视觉上的，不会以任何方式影响字面值）</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>int</span> bin { <span style=color:#ff0;font-weight:700>0b1011&#39;0010</span> };  <span style=color:#007f7f>// assign binary 1011 0010 to the variable
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>long</span> value { <span style=color:#ff0;font-weight:700>2&#39;132&#39;673&#39;462</span> }; <span style=color:#007f7f>// much easier to read than 2132673462
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=以十进制八进制或十六进制输出值>以十进制、八进制或十六进制输出值<a hidden class=anchor aria-hidden=true href=#以十进制八进制或十六进制输出值>#</a></h3><p>默认情况下，C++ 以十进制形式输出值。但是，您可以通过使用 std::dec、std::oct 和 std::hex I/O 操纵器更改输出格式：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>int</span> x { <span style=color:#ff0;font-weight:700>12</span> };
</span></span><span style=display:flex><span>    std::cout &lt;&lt; x &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>; <span style=color:#007f7f>// decimal (by default)
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    std::cout &lt;&lt; std::hex &lt;&lt; x &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>; <span style=color:#007f7f>// hexadecimal
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    std::cout &lt;&lt; x &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>; <span style=color:#007f7f>// now hexadecimal
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    std::cout &lt;&lt; std::oct &lt;&lt; x &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>; <span style=color:#007f7f>// octal
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    std::cout &lt;&lt; std::dec &lt;&lt; x &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>; <span style=color:#007f7f>// return to decimal
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    std::cout &lt;&lt; x &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>; <span style=color:#007f7f>// decimal
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=以二进制输出值>以二进制输出值<a hidden class=anchor aria-hidden=true href=#以二进制输出值>#</a></h3><p>以二进制形式输出值有点困难，因为 std::cout 没有内置此功能。幸运的是，C++ 标准库包含一个名为 std::bitset 的类型，它将为我们完成此操作（在 <code>&lt;bitset></code> 标头中）。要使用 std::bitset，我们可以定义一个 std::bitset 变量并告诉 std::bitset 我们要存储多少位。位数必须是编译时常量。 std::bitset 可以用无符号整数值（任何格式，包括十进制、八进制、十六进制或二进制）初始化</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;bitset&gt; // for std::bitset</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#007f7f>// std::bitset&lt;8&gt; means we want to store 8 bits
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	std::bitset&lt;<span style=color:#ff0;font-weight:700>8</span>&gt; bin1{ <span style=color:#ff0;font-weight:700>0b1100&#39;0101</span> }; <span style=color:#007f7f>// binary literal for binary 1100 0101
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	std::bitset&lt;<span style=color:#ff0;font-weight:700>8</span>&gt; bin2{ <span style=color:#ff0;font-weight:700>0xC5</span> }; <span style=color:#007f7f>// hexadecimal literal for binary 1100 0101
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>	std::cout &lt;&lt; bin1 &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span> &lt;&lt; bin2 &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>	std::cout &lt;&lt; std::bitset&lt;<span style=color:#ff0;font-weight:700>4</span>&gt;{ <span style=color:#ff0;font-weight:700>0b1010</span> } &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>; <span style=color:#007f7f>// create a temporary std::bitset and print it
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=stdstring>std::string<a hidden class=anchor aria-hidden=true href=#stdstring>#</a></h2><h3 id=使用-stdgetline-输入文本>使用 std::getline() 输入文本<a hidden class=anchor aria-hidden=true href=#使用-stdgetline-输入文本>#</a></h3><p>事实证明，当使用 operator&#187; 从 std::cin 中提取字符串时，operator&#187; 只返回它遇到的第一个空格之前的字符。任何其他字符都留在 std::cin 中，等待下一次提取</p><p>要将整行输入读入字符串，最好改用 <code>std::getline()</code> 函数。 std::getline() 需要两个参数：第一个是 std::cin，第二个是您的字符串变量</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;string&gt; // For std::string and std::getline</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;Enter your full name: &#34;</span>;
</span></span><span style=display:flex><span>    std::string name{};
</span></span><span style=display:flex><span>    std::getline(std::cin &gt;&gt; std::ws, name); <span style=color:#007f7f>// read a full line of text into name
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;Enter your age: &#34;</span>;
</span></span><span style=display:flex><span>    std::string age{};
</span></span><span style=display:flex><span>    std::getline(std::cin &gt;&gt; std::ws, age); <span style=color:#007f7f>// read a full line of text into age
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;Your name is &#34;</span> &lt;&lt; name &lt;&lt; <span style=color:#0ff;font-weight:700>&#34; and your age is &#34;</span> &lt;&lt; age &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>std::ws</code> 输入操纵器告诉 std::cin 在提取之前<strong>忽略任何前导空格</strong>。前导空白是出现在字符串开头的任何空白字符（空格、制表符、换行符）</p><p>如果使用 <code>std::getline()</code> 读取字符串，请使用 <code>std::cin >> std::ws</code> 输入操纵器忽略前导空格</p><p>将提取运算符 (&#187;) 与 std::cin 一起使用会忽略前导空格</p><p>std::getline() 不会忽略前导空格，除非您使用输入操纵器 std::ws</p><h3 id=字符串长度>字符串长度<a hidden class=anchor aria-hidden=true href=#字符串长度>#</a></h3><p>如果我们想知道 std::string 中有多少个字符，我们可以向 std::string 对象询问它的长度。注意 std::string::length() 返回一个无符号整数值（很可能是 size_t 类型）。如果你想将长度分配给一个 int 变量，你应该对其进行 static_cast 以避免编译器关于有符号/无符号转换的警告：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> length { <span style=color:#fff;font-weight:700>static_cast</span>&lt;<span style=color:#fff;font-weight:700>int</span>&gt;(name.length()) };
</span></span></code></pre></div><h3 id=stdstring-的初始化和复制开销很大>std::string 的初始化和复制开销很大<a hidden class=anchor aria-hidden=true href=#stdstring-的初始化和复制开销很大>#</a></h3><p>每当初始化 std::string 时，都会生成用于初始化它的字符串的副本。每当 std::string 按值传递给 std::string 参数时，都会生成另一个副本。不要按值传递 std::string，因为生成 std::string 的副本开销很大。更喜欢 std::string_view 参数</p><h3 id=literals-forstdstring--stdstring_view>Literals for <code>std::string</code> & <code>std::string_view</code><a hidden class=anchor aria-hidden=true href=#literals-forstdstring--stdstring_view>#</a></h3><p>双引号字符串文字（比如“Hello, world!”）默认是 C 风格的字符串</p><p>我们可以通过在双引号字符串文字后使用 s 后缀来创建类型为 std::string 的字符串文字</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;string&gt;      // for std::string</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;string_view&gt; // for std::string_view</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>using</span> <span style=color:#fff;font-weight:700>namespace</span> std::literals; <span style=color:#007f7f>// easiest way to access the s and sv suffixes
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;foo</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>;   <span style=color:#007f7f>// no suffix is a C-style string literal
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;goo</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>s;  <span style=color:#007f7f>// s suffix is a std::string literal
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;moo</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>sv; <span style=color:#007f7f>// sv suffix is a std::string_view literal
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>“s”后缀位于命名空间 std::literals::string_literals 中。“sv”后缀位于命名空间 std::literals::string_view_literals 中。访问文字后缀的最简单方法是通过使用指令使用命名空间 std::literals。这是可以使用整个命名空间的例外情况之一，因为其中定义的后缀不太可能与您的任何代码冲突</p><p>你可能不需要经常使用 std::string 文字（因为用 C 风格的字符串文字初始化 std::string 对象很好），但我们会在以后的课程中看到一些使用 std 的情况::string literals 而不是 C 风格的 string literals 使事情变得更容易</p><h3 id=constexpr-字符串>Constexpr 字符串<a hidden class=anchor aria-hidden=true href=#constexpr-字符串>#</a></h3><p>如果您尝试定义一个 constexpr std::string，您的编译器可能会产生一个错误</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;string&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>using</span> <span style=color:#fff;font-weight:700>namespace</span> std::literals;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>constexpr</span> std::string name{ <span style=color:#0ff;font-weight:700>&#34;Alex&#34;</span>s }; <span style=color:#007f7f>// compile error
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;My name is: &#34;</span> &lt;&lt; name;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>发生这种情况是因为 constexpr std::string 在 C++17 或更早版本中不受支持，并且在 C++20 中仅提供最低限度的支持。如果您需要 constexpr 字符串，请改用 std::string_view</p><h2 id=stdstring_view>std::string_view<a hidden class=anchor aria-hidden=true href=#stdstring_view>#</a></h2><h3 id=stdstring_view-c17>std::string_view C++17<a hidden class=anchor aria-hidden=true href=#stdstring_view-c17>#</a></h3><p>为了解决 std::string 初始化（或复制）成本高昂的问题，C++17 引入了 std::string_view（位于 &lt;string_view> 标头中）。 std::string_view 提供对现有字符串（C 风格字符串文字、std::string 或 char 数组）的只读访问，而无需制作副本</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;string_view&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>void</span> printSV(std::string_view str) <span style=color:#007f7f>// now a std::string_view
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>{
</span></span><span style=display:flex><span>    std::cout &lt;&lt; str &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    std::string_view s{ <span style=color:#0ff;font-weight:700>&#34;Hello, world!&#34;</span> }; <span style=color:#007f7f>// now a std::string_view
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    printSV(s);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>当我们用 C 风格的字符串文字“Hello, world!”初始化 std::string_view s 时，s 提供对“Hello, world!”的只读访问。无需复制字符串。当我们将 s 传递给 printSV() 时，参数 str 从 s 初始化。这使我们能够通过 str 访问“Hello, world!”，不用再次复制字符串</p><p>当您需要只读字符串时，尤其是对于函数参数，优先使用 std::string_view 而不是 std::string</p><h3 id=constexpr-stdstring_view>constexpr std::string_view<a hidden class=anchor aria-hidden=true href=#constexpr-stdstring_view>#</a></h3><p>std::string_view 完全支持 constexpr：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;string_view&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>constexpr</span> std::string_view s{ <span style=color:#0ff;font-weight:700>&#34;Hello, world!&#34;</span> };
</span></span><span style=display:flex><span>    std::cout &lt;&lt; s &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>; <span style=color:#007f7f>// s will be replaced with &#34;Hello, world!&#34; at compile-time
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=stdstring--stdstring_view>std::string & std::string_view<a hidden class=anchor aria-hidden=true href=#stdstring--stdstring_view>#</a></h3><p>可以使用 std::string 初始值设定项创建 std::string_view，并且 std::string 将隐式转换为 std::string_view：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;string&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;string_view&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>void</span> printSV(std::string_view str)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    std::cout &lt;&lt; str &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    std::string s{ <span style=color:#0ff;font-weight:700>&#34;Hello, world&#34;</span> };
</span></span><span style=display:flex><span>    std::string_view sv{ s }; <span style=color:#007f7f>// Initialize a std::string_view from a std::string
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    std::cout &lt;&lt; sv &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    printSV(s); <span style=color:#007f7f>// implicitly convert a std::string to std::string_view
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>因为 std::string 复制了它的初始化器（这开销很大），C++ 不允许将 std::string_view 隐式转换为 std::string。但是，我们可以使用 std::string_view 初始值设定项显式创建 std::string，或者我们可以使用 static_cast 将现有的 std::string_view 转换为 std::string</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;string&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;string_view&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>void</span> printString(std::string str)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    std::cout &lt;&lt; str &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  std::string_view sv{ <span style=color:#0ff;font-weight:700>&#34;balloon&#34;</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  std::string str{ sv }; <span style=color:#007f7f>// okay, we can create std::string using std::string_view initializer
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>  <span style=color:#007f7f>// printString(sv);   // compile error: won&#39;t implicitly convert std::string_view to a std::string
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>  printString(<span style=color:#fff;font-weight:700>static_cast</span>&lt;std::string&gt;(sv)); <span style=color:#007f7f>// okay, we can explicitly cast a std::string_view to a std::string
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>  <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=operators操作符>Operators（操作符）<a hidden class=anchor aria-hidden=true href=#operators操作符>#</a></h1><h2 id=----运算符><code>,</code> & <code>? :</code> 运算符<a hidden class=anchor aria-hidden=true href=#----运算符>#</a></h2><p>C++ 没有定义函数参数或运算符操作数的计算顺序</p><p>不要在给定语句中多次使用具有副作用的变量。如果这样做，结果可能是未定义的</p><p>逗号在所有运算符中的优先级最低，甚至低于赋值</p><p>请注意， <code>? :</code> 运算符的优先级非常低。如果除了将结果分配给变量之外做任何事情，整个 <code>? :</code> 运算符也需要用括号括起来</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std::cout &lt;&lt; ((x &gt; y) ? x : y) &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span></code></pre></div><p>如果在上述情况下我们不将整个条件运算符括起来会发生什么。因为 &#171; 运算符的优先级高于 ?: 运算符，所以语句：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std::cout &lt;&lt; (x &gt; y) ? x : y &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span></code></pre></div><p>将评估为：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>(std::cout &lt;&lt; (x &gt; y)) ? x : y &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span></code></pre></div><h2 id=比较浮点数大小>比较浮点数大小<a hidden class=anchor aria-hidden=true href=#比较浮点数大小>#</a></h2><p>进行浮点相等的最常见方法涉及使用一个函数来查看两个数字是否几乎相同。如果它们“足够接近”，那么我们称它们相等。用于表示“足够接近”的值传统上称为 epsilon。 Epsilon 通常被定义为一个小的正数（例如 0.00000001，有时写作 1e-8）</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;cmath&gt; // for std::abs()</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#007f7f>// epsilon is an absolute value
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>bool</span> approximatelyEqualAbs(<span style=color:#fff;font-weight:700>double</span> a, <span style=color:#fff;font-weight:700>double</span> b, <span style=color:#fff;font-weight:700>double</span> absEpsilon)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#007f7f>// if the distance between a and b is less than absEpsilon, then a and b are &#34;close enough&#34;
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>return</span> std::abs(a - b) &lt;= absEpsilon;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>虽然这个功能可以工作，但不是很好。 0.00001 的 epsilon 适用于 1.0 左右的输入，对于 0.0000001 左右的输入太大，对于 10,000 这样的输入太小</p><p>著名计算机科学家唐纳德·高德纳 (Donald Knuth) 在他的著作“计算机编程的艺术，第二卷：半数值算法 (Addison-Wesley, 1969)”一书中提出了以下方法：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;algorithm&gt; // std::max</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;cmath&gt; // std::abs</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#007f7f>// return true if the difference between a and b is within epsilon percent of the larger of a and b
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>bool</span> approximatelyEqualRel(<span style=color:#fff;font-weight:700>double</span> a, <span style=color:#fff;font-weight:700>double</span> b, <span style=color:#fff;font-weight:700>double</span> relEpsilon)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> (std::abs(a - b) &lt;= (std::max(std::abs(a), std::abs(b)) * relEpsilon));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在这种情况下，epsilon 不是绝对数字，而是相对于 a 或 b 的大小。在 &lt;= 运算符的左侧，std::abs(a - b) 告诉我们 a 和 b 之间的距离为正数。在 &lt;= 运算符的右侧，我们需要计算我们愿意接受的“足够接近”的最大值。为此，该算法选择 a 和 b 中较大的一个（作为数字总体大小的粗略指标），然后将其乘以 relEpsilon。在此函数中，relEpsilon 表示百分比。例如，如果我们想说“足够接近”意味着 a 和 b 在 a 和 b 中较大者的 1% 以内，我们传入 0.01 (1% = 1/100 = 0.01) 的 relEpsilon。 relEpsilon 的值可以根据情况调整为最合适的值（例如，0.002 的 epsilon 表示在 0.2% 以内）</p><p>要执行不等式 (!=) 而不是相等，只需调用此函数并使用逻辑 NOT 运算符 (!) 翻转结果：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#fff;font-weight:700>if</span> (!approximatelyEqualRel(a, b, <span style=color:#ff0;font-weight:700>0.001</span>))
</span></span><span style=display:flex><span>    std::cout &lt;&lt; a &lt;&lt; <span style=color:#0ff;font-weight:700>&#34; is not equal to &#34;</span> &lt;&lt; b &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span></code></pre></div><p>虽然 approximatelyEqualRel() 函数适用于大多数情况，但它并不完美，尤其是当数字接近零时：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;algorithm&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;cmath&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#007f7f>// return true if the difference between a and b is within epsilon percent of the larger of a and b
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>bool</span> approximatelyEqualRel(<span style=color:#fff;font-weight:700>double</span> a, <span style=color:#fff;font-weight:700>double</span> b, <span style=color:#fff;font-weight:700>double</span> relEpsilon)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> (std::abs(a - b) &lt;= (std::max(std::abs(a), std::abs(b)) * relEpsilon));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#007f7f>// a is really close to 1.0, but has rounding errors, so it&#39;s slightly smaller than 1.0
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	<span style=color:#fff;font-weight:700>double</span> a{ <span style=color:#ff0;font-weight:700>0.1</span> + <span style=color:#ff0;font-weight:700>0.1</span> + <span style=color:#ff0;font-weight:700>0.1</span> + <span style=color:#ff0;font-weight:700>0.1</span> + <span style=color:#ff0;font-weight:700>0.1</span> + <span style=color:#ff0;font-weight:700>0.1</span> + <span style=color:#ff0;font-weight:700>0.1</span> + <span style=color:#ff0;font-weight:700>0.1</span> + <span style=color:#ff0;font-weight:700>0.1</span> + <span style=color:#ff0;font-weight:700>0.1</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#007f7f>// First, let&#39;s compare a (almost 1.0) to 1.0.
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	std::cout &lt;&lt; approximatelyEqualRel(a, <span style=color:#ff0;font-weight:700>1.0</span>, <span style=color:#ff0;font-weight:700>1e-8</span>) &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#007f7f>// Second, let&#39;s compare a-1.0 (almost 0.0) to 0.0
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	std::cout &lt;&lt; approximatelyEqualRel(a-<span style=color:#ff0;font-weight:700>1.0</span>, <span style=color:#ff0;font-weight:700>0.0</span>, <span style=color:#ff0;font-weight:700>1e-8</span>) &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这会返回：</p><pre tabindex=0><code>1
0
</code></pre><p>避免这种情况的一种方法是同时使用绝对 epsilon（如我们在第一种方法中所做的）和相对 epsilon（如我们在 Knuth 的方法中所做的）：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007f7f>// return true if the difference between a and b is less than absEpsilon, or within relEpsilon percent of the larger of a and b
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>bool</span> approximatelyEqualAbsRel(<span style=color:#fff;font-weight:700>double</span> a, <span style=color:#fff;font-weight:700>double</span> b, <span style=color:#fff;font-weight:700>double</span> absEpsilon, <span style=color:#fff;font-weight:700>double</span> relEpsilon)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#007f7f>// Check if the numbers are really close -- needed when comparing numbers near zero.
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>double</span> diff{ std::abs(a - b) };
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>if</span> (diff &lt;= absEpsilon)
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>return</span> <span style=color:#fff;font-weight:700>true</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#007f7f>// Otherwise fall back to Knuth&#39;s algorithm
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>return</span> (diff &lt;= (std::max(std::abs(a), std::abs(b)) * relEpsilon));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在这个算法中，我们首先检查 a 和 b 在绝对值上是否接近，这处理了 a 和 b 都接近于零的情况。 absEpsilon 参数应设置为非常小的值（例如 1e-12）。如果失败，则我们使用相对 epsilon 回退到 Knuth 的算法</p><p>浮点数的比较是一个困难的话题，并且没有适用于所有情况的“一刀切”算法。但是，absEpsilon 为 1e-12 和 relEpsilon 为 1e-8 的 approximatesEqualAbsRel() 应该足以处理您将遇到的大多数情况</p><h2 id=逻辑-xor-运算符>逻辑 XOR 运算符<a hidden class=anchor aria-hidden=true href=#逻辑-xor-运算符>#</a></h2><p>C++ 不提供逻辑 XOR 运算符。与逻辑或或逻辑与不同，逻辑异或不能进行短路评估。因此，从逻辑 OR 和逻辑 AND 运算符中创建逻辑 XOR 运算符具有挑战性。但是，您可以使用不等运算符 (!=) 轻松模拟逻辑 XOR：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#fff;font-weight:700>if</span> (a != b) ... <span style=color:#007f7f>// a XOR b, assuming a and b are Booleans
</span></span></span></code></pre></div><p>这可以扩展到多个操作数，如下所示：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#fff;font-weight:700>if</span> (a != b != c != d) ... <span style=color:#007f7f>// a XOR b XOR c XOR d, assuming a, b, c, and d are Booleans
</span></span></span></code></pre></div><p>请注意，上述 XOR 模式仅在操作数为布尔值（而非整数）时才有效。如果您需要一种适用于非布尔操作数的逻辑 XOR 形式，您可以将它们静态转换为布尔值：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#fff;font-weight:700>if</span> (<span style=color:#fff;font-weight:700>static_cast</span>&lt;<span style=color:#fff;font-weight:700>bool</span>&gt;(a) != <span style=color:#fff;font-weight:700>static_cast</span>&lt;<span style=color:#fff;font-weight:700>bool</span>&gt;(b) != <span style=color:#fff;font-weight:700>static_cast</span>&lt;<span style=color:#fff;font-weight:700>bool</span>&gt;(c) != <span style=color:#fff;font-weight:700>static_cast</span>&lt;<span style=color:#fff;font-weight:700>bool</span>&gt;(d)) ... <span style=color:#007f7f>// a XOR b XOR c XOR d, for any type that can be converted to bool
</span></span></span></code></pre></div><h1 id=位操作>位操作<a hidden class=anchor aria-hidden=true href=#位操作>#</a></h1><h2 id=位标志-and-位操作-via-stdbitset>位标志 and 位操作 via std::bitset<a hidden class=anchor aria-hidden=true href=#位标志-and-位操作-via-stdbitset>#</a></h2><p>要定义一组位标志，我们通常会使用适当大小的无符号整数（8 位、16 位、32 位等……取决于我们有多少标志），或 std::bitset</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;bitset&gt; // for std::bitset</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span>std::bitset&lt;<span style=color:#ff0;font-weight:700>8</span>&gt; mybitset {}; <span style=color:#007f7f>// 8 bits in size means room for 8 flags
</span></span></span></code></pre></div><p>位操作是您应该明确使用无符号整数（或 std::bitset）的少数情况之一</p><p>std::bitset 提供了 4 个可用于位操作的关键函数：</p><ul><li>test() 允许我们查询某个位是 0 还是 1</li><li>set() 允许我们打开一个位（如果位已经打开，这将不执行任何操作）</li><li>reset() 允许我们关闭一个位（如果该位已经关闭，这将不执行任何操作）</li><li>flip() 允许我们将位值从 0 翻转为 1，反之亦然</li></ul><p>这些函数中的每一个都将我们要操作的位的位置作为它们唯一的参数</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;bitset&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    std::bitset&lt;<span style=color:#ff0;font-weight:700>8</span>&gt; bits{ <span style=color:#ff0;font-weight:700>0b0000&#39;0101</span> }; <span style=color:#007f7f>// we need 8 bits, start with bit pattern 0000 0101
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    bits.set(<span style=color:#ff0;font-weight:700>3</span>); <span style=color:#007f7f>// set bit position 3 to 1 (now we have 0000 1101)
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    bits.flip(<span style=color:#ff0;font-weight:700>4</span>); <span style=color:#007f7f>// flip bit 4 (now we have 0001 1101)
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    bits.reset(<span style=color:#ff0;font-weight:700>4</span>); <span style=color:#007f7f>// set bit 4 back to 0 (now we have 0000 1101)
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;All the bits: &#34;</span> &lt;&lt; bits &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;Bit 3 has value: &#34;</span> &lt;&lt; bits.test(<span style=color:#ff0;font-weight:700>3</span>) &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;Bit 4 has value: &#34;</span> &lt;&lt; bits.test(<span style=color:#ff0;font-weight:700>4</span>) &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;\n&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=按位运算符>按位运算符<a hidden class=anchor aria-hidden=true href=#按位运算符>#</a></h2><p><div class=post-img-view><a data-fancybox=gallery href=https://bu.dusays.com/2022/11/27/638344de90243.png><img src=https://bu.dusays.com/2022/11/27/638344de90243.png alt></a></div>为避免意外，请使用无符号操作数或 std::bitset 的按位运算符</p><p>在计算按位 XOR 时，如果一列中有奇数个 1 位，则该列的结果为 1</p><h2 id=位掩码>位掩码<a hidden class=anchor aria-hidden=true href=#位掩码>#</a></h2><p>位掩码是一组预定义的位，用于选择哪些特定位将被后续操作修改。位掩码阻止按位运算符接触我们不想修改的位，并允许访问我们确实想要修改的位</p><p>最简单的一组位掩码是为每个位位置定义一个位掩码。我们用 0 来屏蔽我们不关心的位，用 1 来表示我们想要修改的位</p><p>尽管位掩码可以是文字，但它们通常被定义为符号常量，因此可以为它们指定一个有意义的名称并易于重用</p><h3 id=在-c14-中定义位掩码>在 C++14 中定义位掩码<a hidden class=anchor aria-hidden=true href=#在-c14-中定义位掩码>#</a></h3><p>因为 C++14 支持二进制文字，所以定义这些位掩码很容易：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;cstdint&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask0{ <span style=color:#ff0;font-weight:700>0b0000&#39;0001</span> }; <span style=color:#007f7f>// represents bit 0
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask1{ <span style=color:#ff0;font-weight:700>0b0000&#39;0010</span> }; <span style=color:#007f7f>// represents bit 1
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask2{ <span style=color:#ff0;font-weight:700>0b0000&#39;0100</span> }; <span style=color:#007f7f>// represents bit 2
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask3{ <span style=color:#ff0;font-weight:700>0b0000&#39;1000</span> }; <span style=color:#007f7f>// represents bit 3
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask4{ <span style=color:#ff0;font-weight:700>0b0001&#39;0000</span> }; <span style=color:#007f7f>// represents bit 4
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask5{ <span style=color:#ff0;font-weight:700>0b0010&#39;0000</span> }; <span style=color:#007f7f>// represents bit 5
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask6{ <span style=color:#ff0;font-weight:700>0b0100&#39;0000</span> }; <span style=color:#007f7f>// represents bit 6
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask7{ <span style=color:#ff0;font-weight:700>0b1000&#39;0000</span> }; <span style=color:#007f7f>// represents bit 7
</span></span></span></code></pre></div><h3 id=在-c11-或更早版本中定义位掩码>在 C++11 或更早版本中定义位掩码<a hidden class=anchor aria-hidden=true href=#在-c11-或更早版本中定义位掩码>#</a></h3><p>由于 C++11 不支持二进制文字，我们必须使用其他方法来设置符号常量</p><p>第一种方法是使用十六进制文字：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask0{ <span style=color:#ff0;font-weight:700>0x01</span> }; <span style=color:#007f7f>// hex for 0000 0001
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask1{ <span style=color:#ff0;font-weight:700>0x02</span> }; <span style=color:#007f7f>// hex for 0000 0010
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask2{ <span style=color:#ff0;font-weight:700>0x04</span> }; <span style=color:#007f7f>// hex for 0000 0100
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask3{ <span style=color:#ff0;font-weight:700>0x08</span> }; <span style=color:#007f7f>// hex for 0000 1000
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask4{ <span style=color:#ff0;font-weight:700>0x10</span> }; <span style=color:#007f7f>// hex for 0001 0000
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask5{ <span style=color:#ff0;font-weight:700>0x20</span> }; <span style=color:#007f7f>// hex for 0010 0000
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask6{ <span style=color:#ff0;font-weight:700>0x40</span> }; <span style=color:#007f7f>// hex for 0100 0000
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask7{ <span style=color:#ff0;font-weight:700>0x80</span> }; <span style=color:#007f7f>// hex for 1000 0000
</span></span></span></code></pre></div><p>另一种更简单的方法是使用左移运算符将一位移动到正确的位置：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask0{ <span style=color:#ff0;font-weight:700>1</span> &lt;&lt; <span style=color:#ff0;font-weight:700>0</span> }; <span style=color:#007f7f>// 0000 0001
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask1{ <span style=color:#ff0;font-weight:700>1</span> &lt;&lt; <span style=color:#ff0;font-weight:700>1</span> }; <span style=color:#007f7f>// 0000 0010
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask2{ <span style=color:#ff0;font-weight:700>1</span> &lt;&lt; <span style=color:#ff0;font-weight:700>2</span> }; <span style=color:#007f7f>// 0000 0100
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask3{ <span style=color:#ff0;font-weight:700>1</span> &lt;&lt; <span style=color:#ff0;font-weight:700>3</span> }; <span style=color:#007f7f>// 0000 1000
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask4{ <span style=color:#ff0;font-weight:700>1</span> &lt;&lt; <span style=color:#ff0;font-weight:700>4</span> }; <span style=color:#007f7f>// 0001 0000
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask5{ <span style=color:#ff0;font-weight:700>1</span> &lt;&lt; <span style=color:#ff0;font-weight:700>5</span> }; <span style=color:#007f7f>// 0010 0000
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask6{ <span style=color:#ff0;font-weight:700>1</span> &lt;&lt; <span style=color:#ff0;font-weight:700>6</span> }; <span style=color:#007f7f>// 0100 0000
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask7{ <span style=color:#ff0;font-weight:700>1</span> &lt;&lt; <span style=color:#ff0;font-weight:700>7</span> }; <span style=color:#007f7f>// 1000 0000
</span></span></span></code></pre></div><h3 id=testing-a-bit>Testing a bit<a hidden class=anchor aria-hidden=true href=#testing-a-bit>#</a></h3><p>要确定某个位是开还是关，我们使用 <code>&</code> 结合相应位的位掩码：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;cstdint&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask0{ <span style=color:#ff0;font-weight:700>0b0000&#39;0001</span> }; <span style=color:#007f7f>// represents bit 0
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	<span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask1{ <span style=color:#ff0;font-weight:700>0b0000&#39;0010</span> }; <span style=color:#007f7f>// represents bit 1
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	<span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask2{ <span style=color:#ff0;font-weight:700>0b0000&#39;0100</span> }; <span style=color:#007f7f>// represents bit 2
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	<span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask3{ <span style=color:#ff0;font-weight:700>0b0000&#39;1000</span> }; <span style=color:#007f7f>// represents bit 3
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	<span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask4{ <span style=color:#ff0;font-weight:700>0b0001&#39;0000</span> }; <span style=color:#007f7f>// represents bit 4
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	<span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask5{ <span style=color:#ff0;font-weight:700>0b0010&#39;0000</span> }; <span style=color:#007f7f>// represents bit 5
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	<span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask6{ <span style=color:#ff0;font-weight:700>0b0100&#39;0000</span> }; <span style=color:#007f7f>// represents bit 6
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	<span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask7{ <span style=color:#ff0;font-weight:700>0b1000&#39;0000</span> }; <span style=color:#007f7f>// represents bit 7
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>	std::<span style=color:#fff;font-weight:700>uint8_t</span> flags{ <span style=color:#ff0;font-weight:700>0b0000&#39;0101</span> }; <span style=color:#007f7f>// 8 bits in size means room for 8 flags
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;bit 0 is &#34;</span> &lt;&lt; ((flags &amp; mask0) ? <span style=color:#0ff;font-weight:700>&#34;on</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span> : <span style=color:#0ff;font-weight:700>&#34;off</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>);
</span></span><span style=display:flex><span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;bit 1 is &#34;</span> &lt;&lt; ((flags &amp; mask1) ? <span style=color:#0ff;font-weight:700>&#34;on</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span> : <span style=color:#0ff;font-weight:700>&#34;off</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=setting-a-bit>Setting a bit<a hidden class=anchor aria-hidden=true href=#setting-a-bit>#</a></h3><p>要设置（打开）位，我们将按位或等于（运算符 <code>|=</code>）与相应位的位掩码结合使用：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;cstdint&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask0{ <span style=color:#ff0;font-weight:700>0b0000&#39;0001</span> }; <span style=color:#007f7f>// represents bit 0
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask1{ <span style=color:#ff0;font-weight:700>0b0000&#39;0010</span> }; <span style=color:#007f7f>// represents bit 1
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask2{ <span style=color:#ff0;font-weight:700>0b0000&#39;0100</span> }; <span style=color:#007f7f>// represents bit 2
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask3{ <span style=color:#ff0;font-weight:700>0b0000&#39;1000</span> }; <span style=color:#007f7f>// represents bit 3
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask4{ <span style=color:#ff0;font-weight:700>0b0001&#39;0000</span> }; <span style=color:#007f7f>// represents bit 4
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask5{ <span style=color:#ff0;font-weight:700>0b0010&#39;0000</span> }; <span style=color:#007f7f>// represents bit 5
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask6{ <span style=color:#ff0;font-weight:700>0b0100&#39;0000</span> }; <span style=color:#007f7f>// represents bit 6
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask7{ <span style=color:#ff0;font-weight:700>0b1000&#39;0000</span> }; <span style=color:#007f7f>// represents bit 7
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    std::<span style=color:#fff;font-weight:700>uint8_t</span> flags{ <span style=color:#ff0;font-weight:700>0b0000&#39;0101</span> }; <span style=color:#007f7f>// 8 bits in size means room for 8 flags
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;bit 1 is &#34;</span> &lt;&lt; ((flags &amp; mask1) ? <span style=color:#0ff;font-weight:700>&#34;on</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span> : <span style=color:#0ff;font-weight:700>&#34;off</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    flags |= mask1; <span style=color:#007f7f>// turn on bit 1
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;bit 1 is &#34;</span> &lt;&lt; ((flags &amp; mask1) ? <span style=color:#0ff;font-weight:700>&#34;on</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span> : <span style=color:#0ff;font-weight:700>&#34;off</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们还可以使用按位或同时打开多个位：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>flags |= (mask4 | mask5); <span style=color:#007f7f>// turn bits 4 and 5 on at the same time
</span></span></span></code></pre></div><h3 id=resetting-a-bit>Resetting a bit<a hidden class=anchor aria-hidden=true href=#resetting-a-bit>#</a></h3><p>要清除位（关闭），我们同时使用 <code>&=</code> 和 <code>~</code> ：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;cstdint&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask0{ <span style=color:#ff0;font-weight:700>0b0000&#39;0001</span> }; <span style=color:#007f7f>// represents bit 0
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask1{ <span style=color:#ff0;font-weight:700>0b0000&#39;0010</span> }; <span style=color:#007f7f>// represents bit 1
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask2{ <span style=color:#ff0;font-weight:700>0b0000&#39;0100</span> }; <span style=color:#007f7f>// represents bit 2
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask3{ <span style=color:#ff0;font-weight:700>0b0000&#39;1000</span> }; <span style=color:#007f7f>// represents bit 3
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask4{ <span style=color:#ff0;font-weight:700>0b0001&#39;0000</span> }; <span style=color:#007f7f>// represents bit 4
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask5{ <span style=color:#ff0;font-weight:700>0b0010&#39;0000</span> }; <span style=color:#007f7f>// represents bit 5
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask6{ <span style=color:#ff0;font-weight:700>0b0100&#39;0000</span> }; <span style=color:#007f7f>// represents bit 6
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask7{ <span style=color:#ff0;font-weight:700>0b1000&#39;0000</span> }; <span style=color:#007f7f>// represents bit 7
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    std::<span style=color:#fff;font-weight:700>uint8_t</span> flags{ <span style=color:#ff0;font-weight:700>0b0000&#39;0101</span> }; <span style=color:#007f7f>// 8 bits in size means room for 8 flags
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;bit 2 is &#34;</span> &lt;&lt; ((flags &amp; mask2) ? <span style=color:#0ff;font-weight:700>&#34;on</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span> : <span style=color:#0ff;font-weight:700>&#34;off</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    flags &amp;= ~mask2; <span style=color:#007f7f>// turn off bit 2
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;bit 2 is &#34;</span> &lt;&lt; ((flags &amp; mask2) ? <span style=color:#0ff;font-weight:700>&#34;on</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span> : <span style=color:#0ff;font-weight:700>&#34;off</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们可以同时关闭多个位：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>flags &amp;= ~(mask4 | mask5); <span style=color:#007f7f>// turn bits 4 and 5 off at the same time
</span></span></span></code></pre></div><h3 id=flipping-a-bit>Flipping a bit<a hidden class=anchor aria-hidden=true href=#flipping-a-bit>#</a></h3><p>要切换位状态，我们使用 <code>^=</code>：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;cstdint&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask0{ <span style=color:#ff0;font-weight:700>0b0000&#39;0001</span> }; <span style=color:#007f7f>// represents bit 0
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask1{ <span style=color:#ff0;font-weight:700>0b0000&#39;0010</span> }; <span style=color:#007f7f>// represents bit 1
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask2{ <span style=color:#ff0;font-weight:700>0b0000&#39;0100</span> }; <span style=color:#007f7f>// represents bit 2
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask3{ <span style=color:#ff0;font-weight:700>0b0000&#39;1000</span> }; <span style=color:#007f7f>// represents bit 3
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask4{ <span style=color:#ff0;font-weight:700>0b0001&#39;0000</span> }; <span style=color:#007f7f>// represents bit 4
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask5{ <span style=color:#ff0;font-weight:700>0b0010&#39;0000</span> }; <span style=color:#007f7f>// represents bit 5
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask6{ <span style=color:#ff0;font-weight:700>0b0100&#39;0000</span> }; <span style=color:#007f7f>// represents bit 6
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>constexpr</span> std::<span style=color:#fff;font-weight:700>uint8_t</span> mask7{ <span style=color:#ff0;font-weight:700>0b1000&#39;0000</span> }; <span style=color:#007f7f>// represents bit 7
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    std::<span style=color:#fff;font-weight:700>uint8_t</span> flags{ <span style=color:#ff0;font-weight:700>0b0000&#39;0101</span> }; <span style=color:#007f7f>// 8 bits in size means room for 8 flags
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;bit 2 is &#34;</span> &lt;&lt; ((flags &amp; mask2) ? <span style=color:#0ff;font-weight:700>&#34;on</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span> : <span style=color:#0ff;font-weight:700>&#34;off</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>);
</span></span><span style=display:flex><span>    flags ^= mask2; <span style=color:#007f7f>// flip bit 2
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;bit 2 is &#34;</span> &lt;&lt; ((flags &amp; mask2) ? <span style=color:#0ff;font-weight:700>&#34;on</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span> : <span style=color:#0ff;font-weight:700>&#34;off</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>);
</span></span><span style=display:flex><span>    flags ^= mask2; <span style=color:#007f7f>// flip bit 2
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;bit 2 is &#34;</span> &lt;&lt; ((flags &amp; mask2) ? <span style=color:#0ff;font-weight:700>&#34;on</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span> : <span style=color:#0ff;font-weight:700>&#34;off</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们可以同时翻转多个位：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>flags ^= (mask4 | mask5); <span style=color:#007f7f>// flip bits 4 and 5 at the same time
</span></span></span></code></pre></div><h2 id=位掩码和-stdbitset>位掩码和 std::bitset<a hidden class=anchor aria-hidden=true href=#位掩码和-stdbitset>#</a></h2><p>std::bitset 支持全套位运算符。因此，尽管使用函数（测试、设置、重置和翻转）修改单个位更容易，但如果需要，您可以使用按位运算符和位掩码</p><p>函数只允许您一次修改单个位。按位运算符允许您一次修改多个位</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;cstdint&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;bitset&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>int</span> main()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>constexpr</span> std::bitset&lt;<span style=color:#ff0;font-weight:700>8</span>&gt; mask0{ <span style=color:#ff0;font-weight:700>0b0000&#39;0001</span> }; <span style=color:#007f7f>// represents bit 0
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	<span style=color:#fff;font-weight:700>constexpr</span> std::bitset&lt;<span style=color:#ff0;font-weight:700>8</span>&gt; mask1{ <span style=color:#ff0;font-weight:700>0b0000&#39;0010</span> }; <span style=color:#007f7f>// represents bit 1
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	<span style=color:#fff;font-weight:700>constexpr</span> std::bitset&lt;<span style=color:#ff0;font-weight:700>8</span>&gt; mask2{ <span style=color:#ff0;font-weight:700>0b0000&#39;0100</span> }; <span style=color:#007f7f>// represents bit 2
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	<span style=color:#fff;font-weight:700>constexpr</span> std::bitset&lt;<span style=color:#ff0;font-weight:700>8</span>&gt; mask3{ <span style=color:#ff0;font-weight:700>0b0000&#39;1000</span> }; <span style=color:#007f7f>// represents bit 3
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	<span style=color:#fff;font-weight:700>constexpr</span> std::bitset&lt;<span style=color:#ff0;font-weight:700>8</span>&gt; mask4{ <span style=color:#ff0;font-weight:700>0b0001&#39;0000</span> }; <span style=color:#007f7f>// represents bit 4
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	<span style=color:#fff;font-weight:700>constexpr</span> std::bitset&lt;<span style=color:#ff0;font-weight:700>8</span>&gt; mask5{ <span style=color:#ff0;font-weight:700>0b0010&#39;0000</span> }; <span style=color:#007f7f>// represents bit 5
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	<span style=color:#fff;font-weight:700>constexpr</span> std::bitset&lt;<span style=color:#ff0;font-weight:700>8</span>&gt; mask6{ <span style=color:#ff0;font-weight:700>0b0100&#39;0000</span> }; <span style=color:#007f7f>// represents bit 6
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	<span style=color:#fff;font-weight:700>constexpr</span> std::bitset&lt;<span style=color:#ff0;font-weight:700>8</span>&gt; mask7{ <span style=color:#ff0;font-weight:700>0b1000&#39;0000</span> }; <span style=color:#007f7f>// represents bit 7
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>	std::bitset&lt;<span style=color:#ff0;font-weight:700>8</span>&gt; flags{ <span style=color:#ff0;font-weight:700>0b0000&#39;0101</span> }; <span style=color:#007f7f>// 8 bits in size means room for 8 flags
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;bit 1 is &#34;</span> &lt;&lt; (flags.test(<span style=color:#ff0;font-weight:700>1</span>) ? <span style=color:#0ff;font-weight:700>&#34;on</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span> : <span style=color:#0ff;font-weight:700>&#34;off</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>);
</span></span><span style=display:flex><span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;bit 2 is &#34;</span> &lt;&lt; (flags.test(<span style=color:#ff0;font-weight:700>2</span>) ? <span style=color:#0ff;font-weight:700>&#34;on</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span> : <span style=color:#0ff;font-weight:700>&#34;off</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	flags ^= (mask1 | mask2); <span style=color:#007f7f>// flip bits 1 and 2
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;bit 1 is &#34;</span> &lt;&lt; (flags.test(<span style=color:#ff0;font-weight:700>1</span>) ? <span style=color:#0ff;font-weight:700>&#34;on</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span> : <span style=color:#0ff;font-weight:700>&#34;off</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>);
</span></span><span style=display:flex><span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;bit 2 is &#34;</span> &lt;&lt; (flags.test(<span style=color:#ff0;font-weight:700>2</span>) ? <span style=color:#0ff;font-weight:700>&#34;on</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span> : <span style=color:#0ff;font-weight:700>&#34;off</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	flags |= (mask1 | mask2); <span style=color:#007f7f>// turn bits 1 and 2 on
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;bit 1 is &#34;</span> &lt;&lt; (flags.test(<span style=color:#ff0;font-weight:700>1</span>) ? <span style=color:#0ff;font-weight:700>&#34;on</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span> : <span style=color:#0ff;font-weight:700>&#34;off</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>);
</span></span><span style=display:flex><span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;bit 2 is &#34;</span> &lt;&lt; (flags.test(<span style=color:#ff0;font-weight:700>2</span>) ? <span style=color:#0ff;font-weight:700>&#34;on</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span> : <span style=color:#0ff;font-weight:700>&#34;off</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	flags &amp;= ~(mask1 | mask2); <span style=color:#007f7f>// turn bits 1 and 2 off
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;bit 1 is &#34;</span> &lt;&lt; (flags.test(<span style=color:#ff0;font-weight:700>1</span>) ? <span style=color:#0ff;font-weight:700>&#34;on</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span> : <span style=color:#0ff;font-weight:700>&#34;off</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>);
</span></span><span style=display:flex><span>	std::cout &lt;&lt; <span style=color:#0ff;font-weight:700>&#34;bit 2 is &#34;</span> &lt;&lt; (flags.test(<span style=color:#ff0;font-weight:700>2</span>) ? <span style=color:#0ff;font-weight:700>&#34;on</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span> : <span style=color:#0ff;font-weight:700>&#34;off</span><span style=color:#0ff;font-weight:700>\n</span><span style=color:#0ff;font-weight:700>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><ol><li>query bit states</li></ol><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#fff;font-weight:700>if</span> (flags &amp; option4) ... <span style=color:#007f7f>// if option4 is set, do something
</span></span></span></code></pre></div><ol start=2><li>set bits (turn on)</li></ol><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>flags |= option4; <span style=color:#007f7f>// turn option 4 on.
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>flags |= (option4 | option5); <span style=color:#007f7f>// turn options 4 and 5 on.
</span></span></span></code></pre></div><ol start=3><li>clear bits (turn off)</li></ol><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>flags &amp;= ~option4; <span style=color:#007f7f>// turn option 4 off
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>flags &amp;= ~(option4 | option5); <span style=color:#007f7f>// turn options 4 and 5 off
</span></span></span></code></pre></div><ol start=4><li>flip bit states</li></ol><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>flags ^= option4; <span style=color:#007f7f>// flip option4 from on to off, or vice versa
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>flags ^= (option4 | option5); <span style=color:#007f7f>// flip options 4 and 5
</span></span></span></code></pre></div><h1 id=运算符重载>运算符重载<a hidden class=anchor aria-hidden=true href=#运算符重载>#</a></h1><h2 id=何时使用普通函数友元函数或成员函数重载运算符>何时使用普通函数、友元函数或成员函数重载运算符<a hidden class=anchor aria-hidden=true href=#何时使用普通函数友元函数或成员函数重载运算符>#</a></h2><ol><li>在处理不修改左操作数的二元运算符（例如 operator+）时，通常首选普通或友元函数版本，因为它适用于所有参数类型（即使左操作数不是类对象，或者是一个不可修改的类）。普通或友元函数版本具有“对称”的额外好处，因为所有操作数都成为显式参数（而不是左操作数成为 <code>*this</code> 而右操作数成为显式参数）</li><li>在处理确实修改左操作数的二元运算符时（例如 operator+=），通常首选成员函数版本。在这些情况下，最左边的操作数将始终是类类型，并且让被修改的对象成为 <code>*this</code> 指向的对象是很自然的。因为最右边的操作数成为一个显式参数，所以不会混淆谁正在修改和谁正在评估</li><li>一元运算符通常也作为成员函数重载，因为成员函数版本没有参数</li><li>以下经验法则可以帮助您确定哪种形式最适合给定情况：<ol><li>如果要重载赋值 (=)、下标 ([])、函数调用 (()) 或成员选择 (->)，请将其作为成员函数进行重载</li><li>如果要重载一元运算符，请将其作为成员函数</li><li>如果要重载不修改其左操作数的二元运算符（例如 operator+），请将其作为普通函数（首选）或友元函数</li><li>如果您正在重载修改其左操作数的二元运算符，但您不能将成员添加到左操作数的类定义中（例如，operator&#171;，它有一个 ostream 类型的左操作数），请像往常一样这样做函数（首选）或友元函数</li><li>如果您正在重载修改其左操作数的二元运算符（例如 operator+=），并且您可以修改左操作数的定义，请将其作为成员函数进行</li></ol></li></ol><h2 id=最小化比较冗余>最小化比较冗余<a hidden class=anchor aria-hidden=true href=#最小化比较冗余>#</a></h2><p>也就是说我们只需要实现<code>operator==</code>和<code>operator&lt;</code>的逻辑，其他四个比较运算符就可以根据这两个来定义了！这是一个更新的 <code>Cents</code> 示例，说明了这一点：</p><pre tabindex=0><code>#include &lt;iostream&gt;

class Cents
{
private:
    int m_cents;

public:
    Cents(int cents)
        : m_cents{ cents }
    {}

    friend bool operator== (const Cents&amp; c1, const Cents&amp; c2) { return c1.m_cents == c2.m_cents; };
    friend bool operator!= (const Cents&amp; c1, const Cents&amp; c2) { return !(operator==(c1, c2)); };

    friend bool operator&lt; (const Cents&amp; c1, const Cents&amp; c2) { return c1.m_cents &lt; c2.m_cents; };
    friend bool operator&gt; (const Cents&amp; c1, const Cents&amp; c2) { return operator&lt;(c2, c1); };

    friend bool operator&lt;= (const Cents&amp; c1, const Cents&amp; c2) { return !(operator&gt;(c1, c2)); };
    friend bool operator&gt;= (const Cents&amp; c1, const Cents&amp; c2) { return !(operator&lt;(c1, c2)); };

};

int main()
{
    Cents dime{ 10 };
    Cents nickel{ 5 };

    if (nickel &gt; dime)
        std::cout &lt;&lt; &#34;a nickel is greater than a dime.\n&#34;;
    if (nickel &gt;= dime)
        std::cout &lt;&lt; &#34;a nickel is greater than or equal to a dime.\n&#34;;
    if (nickel &lt; dime)
        std::cout &lt;&lt; &#34;a dime is greater than a nickel.\n&#34;;
    if (nickel &lt;= dime)
        std::cout &lt;&lt; &#34;a dime is greater than or equal to a nickel.\n&#34;;
    if (nickel == dime)
        std::cout &lt;&lt; &#34;a dime is equal to a nickel.\n&#34;;
    if (nickel != dime)
        std::cout &lt;&lt; &#34;a dime is not equal to a nickel.\n&#34;;

    return 0;
}
</code></pre><p>这样，如果我们需要更改某些内容，我们只需要更新 operator== 和 operator&lt; 而不是所有六个比较运算符！</p><h1 id=浅拷贝与深拷贝>浅拷贝与深拷贝<a hidden class=anchor aria-hidden=true href=#浅拷贝与深拷贝>#</a></h1><p>编译器提供的默认复制构造函数和默认赋值运算符如下所示：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;cassert&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700>#include</span> <span style=color:#0f0;font-weight:700>&lt;iostream&gt;</span><span style=color:#0f0;font-weight:700>
</span></span></span><span style=display:flex><span><span style=color:#0f0;font-weight:700></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>class</span> Fraction
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>private</span>:
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>int</span> m_numerator { <span style=color:#ff0;font-weight:700>0</span> };
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>int</span> m_denominator { <span style=color:#ff0;font-weight:700>1</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>public</span>:
</span></span><span style=display:flex><span>    <span style=color:#007f7f>// Default constructor
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    Fraction(<span style=color:#fff;font-weight:700>int</span> numerator = <span style=color:#ff0;font-weight:700>0</span>, <span style=color:#fff;font-weight:700>int</span> denominator = <span style=color:#ff0;font-weight:700>1</span>)
</span></span><span style=display:flex><span>        : m_numerator{ numerator }
</span></span><span style=display:flex><span>        , m_denominator{ denominator }
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        assert(denominator != <span style=color:#ff0;font-weight:700>0</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#007f7f>// Possible implementation of implicit copy constructor
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    Fraction(<span style=color:#fff;font-weight:700>const</span> Fraction&amp; f)
</span></span><span style=display:flex><span>        : m_numerator{ f.m_numerator }
</span></span><span style=display:flex><span>        , m_denominator{ f.m_denominator }
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#007f7f>// Possible implementation of implicit assignment operator
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    Fraction&amp; <span style=color:#fff;font-weight:700>operator</span>= (<span style=color:#fff;font-weight:700>const</span> Fraction&amp; fraction)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#007f7f>// self-assignment guard
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>        <span style=color:#fff;font-weight:700>if</span> (<span style=color:#fff;font-weight:700>this</span> == &amp;fraction)
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>return</span> *<span style=color:#fff;font-weight:700>this</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#007f7f>// do the copy
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>        m_numerator = fraction.m_numerator;
</span></span><span style=display:flex><span>        m_denominator = fraction.m_denominator;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#007f7f>// return the existing object so we can chain this operator
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>        <span style=color:#fff;font-weight:700>return</span> *<span style=color:#fff;font-weight:700>this</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>friend</span> std::ostream&amp; <span style=color:#fff;font-weight:700>operator</span>&lt;&lt;(std::ostream&amp; out, <span style=color:#fff;font-weight:700>const</span> Fraction&amp; f1)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>	out &lt;&lt; f1.m_numerator &lt;&lt; <span style=color:#0ff;font-weight:700>&#39;/&#39;</span> &lt;&lt; f1.m_denominator;
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> out;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>请注意，因为这些默认版本可以很好地复制此类，所以在这种情况下真的没有理由编写我们自己的这些函数版本</p><p>然而，在设计处理动态分配内存的类时，成员（浅）复制会给我们带来很多麻烦！这是因为指针的浅拷贝只是复制指针的地址——它不分配任何内存或复制指向的内容！</p><p>深拷贝为副本分配内存，然后复制实际值，以便副本位于与源不同的内存中。这样，副本和来源是截然不同的，不会以任何方式相互影响。进行深度复制需要我们编写自己的复制构造函数和重载赋值运算符。</p><p>默认复制构造函数和默认赋值运算符执行浅拷贝，这适用于不包含动态分配变量的类。<br>具有动态分配变量的类需要有一个复制构造函数和赋值运算符来执行深复制。<br>喜欢使用标准库中的类而不是自己进行内存管理。</p><p><strong>深拷贝</strong>为副本分配内存，然后复制实际值，以便副本位于与源不同的内存中。这样，副本和来源是截然不同的，不会以任何方式相互影响。进行深度复制需要我们编写自己的复制构造函数和重载赋值运算符。</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007f7f>// assumes m_data is initialized
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>void</span> MyString::deepCopy(<span style=color:#fff;font-weight:700>const</span> MyString&amp; source)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#007f7f>// first we need to deallocate any value that this string is holding!
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>delete</span>[] m_data;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#007f7f>// because m_length is not a pointer, we can shallow copy it
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    m_length = source.m_length;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#007f7f>// m_data is a pointer, so we need to deep copy it if it is non-null
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>if</span> (source.m_data)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#007f7f>// allocate memory for our copy
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>        m_data = <span style=color:#fff;font-weight:700>new</span> <span style=color:#fff;font-weight:700>char</span>[m_length];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#007f7f>// do the copy
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>        <span style=color:#fff;font-weight:700>for</span> (<span style=color:#fff;font-weight:700>int</span> i{ <span style=color:#ff0;font-weight:700>0</span> }; i &lt; m_length; ++i)
</span></span><span style=display:flex><span>            m_data[i] = source.m_data[i];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>else</span>
</span></span><span style=display:flex><span>        m_data = <span style=color:#fff;font-weight:700>nullptr</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007f7f>// Copy constructor
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>MyString::MyString(<span style=color:#fff;font-weight:700>const</span> MyString&amp; source)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    deepCopy(source);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这比简单的浅拷贝要复杂得多！</p><p>现在让我们做重载的赋值运算符。重载的赋值运算符有点棘手：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#007f7f>// Assignment operator
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>MyString&amp; MyString::<span style=color:#fff;font-weight:700>operator</span>=(<span style=color:#fff;font-weight:700>const</span> MyString&amp; source)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#007f7f>// check for self-assignment
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>if</span> (<span style=color:#fff;font-weight:700>this</span> != &amp;source)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#007f7f>// now do the deep copy
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>        deepCopy(source);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> *<span style=color:#fff;font-weight:700>this</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>输出不是直接写入的，它存储在缓冲区中，直到缓冲区被刷新。输出到文件或终端历来很慢（终端或控制台仍然很慢），逐个字符地写入是低效率的，写入一大块字节要有效得多。若 cerr 被缓冲，那么如果程序以非正常方式崩溃，您可能会将有用的调试信息卡在缓冲区中，而不是打印到 stderr。stdout 是行缓冲的，即在您编写换行符或显式刷新缓冲区之前，输出不会发送到操作系统。通常，std::endl 函数通过插入换行符并刷新流来工作。读取 stdcin 会刷新 stdcout&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://xancoding.cn/tags/tech/>Tech</a></li><li><a href=https://xancoding.cn/tags/c++/>C++</a></li><li><a href=https://xancoding.cn/tags/%E6%96%B0%E6%8A%80%E8%83%BD/>新技能</a></li></ul><nav class=paginav><a class=prev href=https://xancoding.cn/posts/2022-11-15-21-37-17/><span class=title>« Prev</span><br><span>计算机系统基础</span></a>
<a class=next href=https://xancoding.cn/posts/2022-11-14-15-56-45/><span class=title>Next »</span><br><span>Self-study</span></a></nav></footer><div><div class=pagination__title><span class=pagination__title-h style=font-size:20px>💬评论</span><hr></div><div id=tcomment></div><script src=https://cdn.staticfile.org/twikoo/1.6.7/twikoo.all.min.js></script>
<script>twikoo.init({envId:"https://twikoo.xancoding.cn/",el:"#tcomment",lang:"zh-CN",region:"ap-beijing",path:window.TWIKOO_MAGIC_PATH||window.location.pathname})</script></div></article></main><footer class=footer><span>&copy; 2023 <a href=https://xancoding.cn>Xan's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>