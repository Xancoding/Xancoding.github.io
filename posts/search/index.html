<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Search | Xan's Blog</title><meta name=keywords content="数据结构"><meta name=description content="图
邻接矩阵 typedef struct { char vexs[MAX][NUM];; //顶点信息 int arcs[MAX][MAX]; //边或弧上的权值 int vex; //顶点数 int arc; //弧数 }graph, *graphlink; 邻接表 #define MAX 20 //最大顶点数 #define NUM 20 //最大字符串长度 //边结点 typedef struct arcnode { int adjvex; //弧所指向顶点下标 struct arcnode *next; //指向下一条弧 int weight; //边结点类型（权重） }arcnode; //表头结点 typedef struct vexnode { char vertex[NUM]; //存放结点值 arcnode *head; //存放边链表头指针 }vexnode; //邻接表 typedef struct graph{ vexnode adjlist[MAX]; int vex; //顶点数 int arc; //边数 }graph, *graphlink; 最小生成树 Prim 稠密图 设 G = (V, {E}) 是连通图，最小生成树 T 的顶点集合为 U，边的集合是 TE 初始：U = { u0 } ( u0∈V ) ， TE = Ø 重复执行下述操作：在所有 u ∈U， v∈W 的边 (u，v) ∈E 中找一条代价最小的边 (ui ，v0) 并入集合 TE，同时 v0 并入 U，直到 U = V 为止 设置一个辅助数组 (最小代价数组)，对当前 V－U 集合 中的每个顶点，记录与顶点集 U 中顶点相连接的代价最小的边 void crt_graph(graphlink G) { printf(&#34;输入顶点数和边数（空格隔开）\n&#34;); scanf(&#34;%d %d&#34;, &G->vex, &G->arc); //顶点数和边数 printf(&#34;输入顶点信息\n&#34;); for (int i = 1; i <= G->vex; i++) scanf(&#34;%s&#34;, G->vexs[i]); //顶点信息 for (int i = 1; i <= G->vex; i++) for (int j = 1; j <= G->vex; j++) G->arcs[i][j] = INF; //邻接矩阵初始化 printf(&#34;输入边和权值（空格隔开）\n&#34;); for (int k = 1; k <= G->arc; k++) { //读入边 int i, j, w; scanf(&#34;%d%d%d&#34;, &i, &j, &w); G->arcs[i][j] = w; G->arcs[j][i] = w; } } void prim(graphlink G, int v, lowcost lc[]) { int total = 0; //边权总和 int st[MAX] = {0}; //存储每个点是否已经在生成树中 st[v] = 1; for (int i = 1; i <= G->vex; i++) { //初始化 lc[i]."><meta name=author content="Xan"><link rel=canonical href=https://zagxuy.github.io/posts/search/><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://zagxuy.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zagxuy.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zagxuy.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://zagxuy.github.io/apple-touch-icon.png><link rel=mask-icon href=https://zagxuy.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Search"><meta property="og:description" content="图
邻接矩阵 typedef struct { char vexs[MAX][NUM];; //顶点信息 int arcs[MAX][MAX]; //边或弧上的权值 int vex; //顶点数 int arc; //弧数 }graph, *graphlink; 邻接表 #define MAX 20 //最大顶点数 #define NUM 20 //最大字符串长度 //边结点 typedef struct arcnode { int adjvex; //弧所指向顶点下标 struct arcnode *next; //指向下一条弧 int weight; //边结点类型（权重） }arcnode; //表头结点 typedef struct vexnode { char vertex[NUM]; //存放结点值 arcnode *head; //存放边链表头指针 }vexnode; //邻接表 typedef struct graph{ vexnode adjlist[MAX]; int vex; //顶点数 int arc; //边数 }graph, *graphlink; 最小生成树 Prim 稠密图 设 G = (V, {E}) 是连通图，最小生成树 T 的顶点集合为 U，边的集合是 TE 初始：U = { u0 } ( u0∈V ) ， TE = Ø 重复执行下述操作：在所有 u ∈U， v∈W 的边 (u，v) ∈E 中找一条代价最小的边 (ui ，v0) 并入集合 TE，同时 v0 并入 U，直到 U = V 为止 设置一个辅助数组 (最小代价数组)，对当前 V－U 集合 中的每个顶点，记录与顶点集 U 中顶点相连接的代价最小的边 void crt_graph(graphlink G) { printf(&#34;输入顶点数和边数（空格隔开）\n&#34;); scanf(&#34;%d %d&#34;, &G->vex, &G->arc); //顶点数和边数 printf(&#34;输入顶点信息\n&#34;); for (int i = 1; i <= G->vex; i++) scanf(&#34;%s&#34;, G->vexs[i]); //顶点信息 for (int i = 1; i <= G->vex; i++) for (int j = 1; j <= G->vex; j++) G->arcs[i][j] = INF; //邻接矩阵初始化 printf(&#34;输入边和权值（空格隔开）\n&#34;); for (int k = 1; k <= G->arc; k++) { //读入边 int i, j, w; scanf(&#34;%d%d%d&#34;, &i, &j, &w); G->arcs[i][j] = w; G->arcs[j][i] = w; } } void prim(graphlink G, int v, lowcost lc[]) { int total = 0; //边权总和 int st[MAX] = {0}; //存储每个点是否已经在生成树中 st[v] = 1; for (int i = 1; i <= G->vex; i++) { //初始化 lc[i]."><meta property="og:type" content="article"><meta property="og:url" content="https://zagxuy.github.io/posts/search/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-10-09T20:00:23+08:00"><meta property="article:modified_time" content="2022-10-09T20:00:23+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Search"><meta name=twitter:description content="图
邻接矩阵 typedef struct { char vexs[MAX][NUM];; //顶点信息 int arcs[MAX][MAX]; //边或弧上的权值 int vex; //顶点数 int arc; //弧数 }graph, *graphlink; 邻接表 #define MAX 20 //最大顶点数 #define NUM 20 //最大字符串长度 //边结点 typedef struct arcnode { int adjvex; //弧所指向顶点下标 struct arcnode *next; //指向下一条弧 int weight; //边结点类型（权重） }arcnode; //表头结点 typedef struct vexnode { char vertex[NUM]; //存放结点值 arcnode *head; //存放边链表头指针 }vexnode; //邻接表 typedef struct graph{ vexnode adjlist[MAX]; int vex; //顶点数 int arc; //边数 }graph, *graphlink; 最小生成树 Prim 稠密图 设 G = (V, {E}) 是连通图，最小生成树 T 的顶点集合为 U，边的集合是 TE 初始：U = { u0 } ( u0∈V ) ， TE = Ø 重复执行下述操作：在所有 u ∈U， v∈W 的边 (u，v) ∈E 中找一条代价最小的边 (ui ，v0) 并入集合 TE，同时 v0 并入 U，直到 U = V 为止 设置一个辅助数组 (最小代价数组)，对当前 V－U 集合 中的每个顶点，记录与顶点集 U 中顶点相连接的代价最小的边 void crt_graph(graphlink G) { printf(&#34;输入顶点数和边数（空格隔开）\n&#34;); scanf(&#34;%d %d&#34;, &G->vex, &G->arc); //顶点数和边数 printf(&#34;输入顶点信息\n&#34;); for (int i = 1; i <= G->vex; i++) scanf(&#34;%s&#34;, G->vexs[i]); //顶点信息 for (int i = 1; i <= G->vex; i++) for (int j = 1; j <= G->vex; j++) G->arcs[i][j] = INF; //邻接矩阵初始化 printf(&#34;输入边和权值（空格隔开）\n&#34;); for (int k = 1; k <= G->arc; k++) { //读入边 int i, j, w; scanf(&#34;%d%d%d&#34;, &i, &j, &w); G->arcs[i][j] = w; G->arcs[j][i] = w; } } void prim(graphlink G, int v, lowcost lc[]) { int total = 0; //边权总和 int st[MAX] = {0}; //存储每个点是否已经在生成树中 st[v] = 1; for (int i = 1; i <= G->vex; i++) { //初始化 lc[i]."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zagxuy.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Search","item":"https://zagxuy.github.io/posts/search/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Search","name":"Search","description":"图\n邻接矩阵 typedef struct { char vexs[MAX][NUM];; //顶点信息 int arcs[MAX][MAX]; //边或弧上的权值 int vex; //顶点数 int arc; //弧数 }graph, *graphlink; 邻接表 #define MAX 20 //最大顶点数 #define NUM 20 //最大字符串长度 //边结点 typedef struct arcnode { int adjvex; //弧所指向顶点下标 struct arcnode *next; //指向下一条弧 int weight; //边结点类型（权重） }arcnode; //表头结点 typedef struct vexnode { char vertex[NUM]; //存放结点值 arcnode *head; //存放边链表头指针 }vexnode; //邻接表 typedef struct graph{ vexnode adjlist[MAX]; int vex; //顶点数 int arc; //边数 }graph, *graphlink; 最小生成树 Prim 稠密图 设 G = (V, {E}) 是连通图，最小生成树 T 的顶点集合为 U，边的集合是 TE 初始：U = { u0 } ( u0∈V ) ， TE = Ø 重复执行下述操作：在所有 u ∈U， v∈W 的边 (u，v) ∈E 中找一条代价最小的边 (ui ，v0) 并入集合 TE，同时 v0 并入 U，直到 U = V 为止 设置一个辅助数组 (最小代价数组)，对当前 V－U 集合 中的每个顶点，记录与顶点集 U 中顶点相连接的代价最小的边 void crt_graph(graphlink G) { printf(\u0026#34;输入顶点数和边数（空格隔开）\\n\u0026#34;); scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;G-\u0026gt;vex, \u0026amp;G-\u0026gt;arc); //顶点数和边数 printf(\u0026#34;输入顶点信息\\n\u0026#34;); for (int i = 1; i \u0026lt;= G-\u0026gt;vex; i++) scanf(\u0026#34;%s\u0026#34;, G-\u0026gt;vexs[i]); //顶点信息 for (int i = 1; i \u0026lt;= G-\u0026gt;vex; i++) for (int j = 1; j \u0026lt;= G-\u0026gt;vex; j++) G-\u0026gt;arcs[i][j] = INF; //邻接矩阵初始化 printf(\u0026#34;输入边和权值（空格隔开）\\n\u0026#34;); for (int k = 1; k \u0026lt;= G-\u0026gt;arc; k++) { //读入边 int i, j, w; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;i, \u0026amp;j, \u0026amp;w); G-\u0026gt;arcs[i][j] = w; G-\u0026gt;arcs[j][i] = w; } } void prim(graphlink G, int v, lowcost lc[]) { int total = 0; //边权总和 int st[MAX] = {0}; //存储每个点是否已经在生成树中 st[v] = 1; for (int i = 1; i \u0026lt;= G-\u0026gt;vex; i++) { //初始化 lc[i].","keywords":["数据结构"],"articleBody":"图\n邻接矩阵 typedef struct { char vexs[MAX][NUM];; //顶点信息 int arcs[MAX][MAX]; //边或弧上的权值 int vex; //顶点数 int arc; //弧数 }graph, *graphlink; 邻接表 #define MAX 20 //最大顶点数 #define NUM 20 //最大字符串长度 //边结点 typedef struct arcnode { int adjvex; //弧所指向顶点下标 struct arcnode *next; //指向下一条弧 int weight; //边结点类型（权重） }arcnode; //表头结点 typedef struct vexnode { char vertex[NUM]; //存放结点值 arcnode *head; //存放边链表头指针 }vexnode; //邻接表 typedef struct graph{ vexnode adjlist[MAX]; int vex; //顶点数 int arc; //边数 }graph, *graphlink; 最小生成树 Prim 稠密图 设 G = (V, {E}) 是连通图，最小生成树 T 的顶点集合为 U，边的集合是 TE 初始：U = { u0 } ( u0∈V ) ， TE = Ø 重复执行下述操作：在所有 u ∈U， v∈W 的边 (u，v) ∈E 中找一条代价最小的边 (ui ，v0) 并入集合 TE，同时 v0 并入 U，直到 U = V 为止 设置一个辅助数组 (最小代价数组)，对当前 V－U 集合 中的每个顶点，记录与顶点集 U 中顶点相连接的代价最小的边 void crt_graph(graphlink G) { printf(\"输入顶点数和边数（空格隔开）\\n\"); scanf(\"%d %d\", \u0026G-\u003evex, \u0026G-\u003earc); //顶点数和边数 printf(\"输入顶点信息\\n\"); for (int i = 1; i \u003c= G-\u003evex; i++) scanf(\"%s\", G-\u003evexs[i]); //顶点信息 for (int i = 1; i \u003c= G-\u003evex; i++) for (int j = 1; j \u003c= G-\u003evex; j++) G-\u003earcs[i][j] = INF; //邻接矩阵初始化 printf(\"输入边和权值（空格隔开）\\n\"); for (int k = 1; k \u003c= G-\u003earc; k++) { //读入边 int i, j, w; scanf(\"%d%d%d\", \u0026i, \u0026j, \u0026w); G-\u003earcs[i][j] = w; G-\u003earcs[j][i] = w; } } void prim(graphlink G, int v, lowcost lc[]) { int total = 0; //边权总和 int st[MAX] = {0}; //存储每个点是否已经在生成树中 st[v] = 1; for (int i = 1; i \u003c= G-\u003evex; i++) { //初始化 lc[i].weight = G-\u003earcs[v][i]; if (lc[i].weight == INF) lc[i].adjnode = -1; else lc[i].adjnode = v; } for (int i = 1; i \u003c= G-\u003evex - 1; i++) { //循环 G-\u003evex - 1 次 int min = INF; //其他点到当前最小生成树的最短距离 int pos = -1; //到当前最小生成树的最短距离的点 for (int k = 1; k \u003c= G-\u003evex; k++) //选出权值最小的边 if (st[k] == 0 \u0026\u0026 lc[k].weight \u003c min) { min = lc[k].weight; pos = k; } total += min; st[pos] = 1; //已在最小生成树中的点 //更新其他点到当前最小生成树的距离 for (int k = 1; k \u003c= G-\u003evex; k++) if (st[k] == 0 \u0026\u0026 G-\u003earcs[pos][k] \u003c lc[k].weight) { lc[k].weight = G-\u003earcs[pos][k]; lc[k].adjnode = pos; } } printf(\"边权总和为：%d\\n\", total); print_MST(G, lc); } Kruskal 稀疏图 先构造一个只含 n 个顶点的子图 SG，然后从权值最小的 边 (u, v) 开始 (u, v 不在同一个连通图)，若它的添加不使 SG 中产生回路，则在 SG 中加上这条边，如此重复，直至加上 n-1 条边为止 void crt_graph(graphlink G) { printf(\"输入顶点数和边数（空格隔开）\\n\"); scanf(\"%d %d\", \u0026G-\u003evex, \u0026G-\u003earc); //顶点数和边数 printf(\"输入顶点信息\\n\"); for (int i = 1; i \u003c= G-\u003evex; i++) scanf(\"%s\", G-\u003evexs[i]); //顶点信息 for (int i = 1; i \u003c= G-\u003evex; i++) for (int j = 1; j \u003c= G-\u003evex; j++) G-\u003earcs[i][j] = INF; //邻接矩阵初始化 printf(\"输入边和权值（空格隔开）\\n\"); for (int k = 1; k \u003c= G-\u003earc; k++) { //读入边 int i, j, w; scanf(\"%d%d%d\", \u0026i, \u0026j, \u0026w); G-\u003earcs[i][j] = w; G-\u003earcs[j][i] = w; } } void Kruskal(graphlink G, edge edges[], int fa[]) { init(G, edges, fa); //初始化 int cnt = 0; //合并次数 int k = 0; //边的下标 int total = 0; //边权总和 while (cnt \u003c G-\u003evex - 1) { int x = get_father(edges[k].a, fa); int y = get_father(edges[k].b, fa); if (x != y) { fa[x] = y; //合并到一棵生成树 total += edges[k].w; edges[k].flag = 1; cnt++; } k++; } printf(\"边权总和为：%d\\n\", total); print_MST(G, edges, k); } 最短路径 Dijkstra 稠密图\n从源点到其余各点的最短路径\n首先将网中的所有顶点分成两个集合S和T：\nS：凡以v0为源点，已经确定了最短路径的终点并入集合S。S的初始状态只包含v0。\nT：尚未确定最短路径的顶点的集合。其初始状态包含除源点外的所有顶点\n引进两个辅助数组来记源点 (设其编号为 v0) 到其它顶点的最短路径长度和路径集合\nDist[i]：表示 v0 到顶点 vi 的最短路径的长度 Path[i]: 表示以上路径中所经过的顶点集合 重复执行下述操作，直到选够 n-1 条路径：\n设下一条所选路径的终点为 vk ，则：dist[k]= min{dist[i]︱i∈T}，将 k 加入到 S 中 修改 dist[i] {i∈T}， dist[i]=min{dist[i]，dist[k] + arcs[k][i]︱k∈S，i∈T} void crt_graph(graphlink G) { printf(\"输入顶点数和边数（空格隔开）\\n\"); scanf(\"%d %d\", \u0026G-\u003evex, \u0026G-\u003earc); //顶点数和边数 printf(\"输入顶点信息\\n\"); for (int i = 1; i \u003c= G-\u003evex; i++) scanf(\"%s\", G-\u003evexs[i]); //顶点信息 for (int i = 1; i \u003c= G-\u003evex; i++) for (int j = 1; j \u003c= G-\u003evex; j++) { G-\u003earcs[i][j] = INF; //邻接矩阵初始化 if (i == j) G-\u003earcs[i][j] = 0; } printf(\"输入边和权值（空格隔开）\\n\"); for (int k = 1; k \u003c= G-\u003earc; k++) { //读入边 int i, j, w; scanf(\"%d%d%d\", \u0026i, \u0026j, \u0026w); G-\u003earcs[i][j] = w; } } void dijkstra(graphlink G, int v, shortdist dist[]) { int flag[MAX] = {0}; flag[v] = 1; for (int i = 1; i \u003c= G-\u003evex; i++) { //dist数组初始化 dist[i].distance = G-\u003earcs[v][i]; if (G-\u003earcs[v][i] != INF) dist[i].path = v; else dist[i].path = -1; } while (1) { //按距离递增顺序找出从v出发到其余各顶点的最短路径 int pos = v; int min = INF; //距离最小值 for (int i = 1; i \u003c= G-\u003evex; i++) if(flag[i] == 0 \u0026\u0026 dist[i].distance \u003c min) { min = dist[i].distance; pos = i; } if (min == INF) break; //算法结束 flag[pos] = 1; //对已完成的顶点做标记 for (int i = 1; i \u003c= G-\u003evex; i++) //更新dist if (flag[i] == 0 \u0026\u0026 dist[pos].distance + G-\u003earcs[pos][i] \u003c dist[i].distance) { dist[i].distance = dist[pos].distance + G-\u003earcs[pos][i]; dist[i].path = pos; } } print_path(G ,dist, v); } Floyd 稠密图 每一对顶点之间的最短路径 dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]) void crt_graph(graphlink G) { printf(\"输入顶点数和边数（空格隔开）\\n\"); scanf(\"%d %d\", \u0026G-\u003evex, \u0026G-\u003earc); //顶点数和边数 printf(\"输入顶点信息\\n\"); for (int i = 1; i \u003c= G-\u003evex; i++) scanf(\"%s\", G-\u003evexs[i]); //顶点信息 for (int i = 1; i \u003c= G-\u003evex; i++) for (int j = 1; j \u003c= G-\u003evex; j++) { G-\u003earcs[i][j] = INF; //邻接矩阵初始化 if (i == j) G-\u003earcs[i][j] = 0; } printf(\"输入边和权值（空格隔开）\\n\"); for (int k = 1; k \u003c= G-\u003earc; k++) { //读入边 int i, j, w; scanf(\"%d%d%d\", \u0026i, \u0026j, \u0026w); G-\u003earcs[i][j] = w; } } \u001b[Ovoid floyd(graphlink G, int dist[][MAX], int path[][MAX]) { for (int i = 1; i \u003c= G-\u003evex; i++) //初始化 for (int j = 1; j \u003c= G-\u003evex; j++) { dist[i][j] = G-\u003earcs[i][j]; path[i][j] = i; if (dist[i][j] == 0 || dist[i][j] == INF) path[i][j] = -1; \u001b[I } for (int k = 1; k \u003c= G-\u003evex; k++) //对每一个顶点做一次迭代 for (int i = 1; i \u003c= G-\u003evex; i++) for (int j = 1; j \u003c= G-\u003evex; j++) if (dist[i][k] + dist[k][j] \u003c dist[i][j]) { dist[i][j] = dist[i][k] + dist[k][j]; path[i][j] = k; } print_path(G, dist, path); } 拓扑排序 特点 一个有向图的拓扑序列一般不唯一 有向无环图一定存在拓扑序列 算法描述 如果顶点没有全部输出，则说明有向图中存在环 在有向图中选一个 入度为零的顶点 且输出 将图中与该顶点有关的边的 弧头顶点的入度减 1 重复上述两步，直至所有满足条件的顶点均已输出 AOE 网络关键路径 AOE 网络：以顶点表示事件，弧表示活动，权表示活动持续的时间的带权有向无环图\n只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始\n只有在指向某一顶点的各有向边所代表的活动都己经结束后，该顶点所代表的事件才能发生\n假设 AOE 网络表示施工流程图，弧上权值表示完成该子工程所需时间\n关键活动：关键路径上的所有活动 关键路径：整个工程完成的最短时间（从 AOE 网络的 源点 到 汇点 的最长路径长度） 如何求关键活动\n假设活动 a(i) 是弧 上的活动，j 为弧尾顶点，k 为弧头 事件（顶点）最早发生时间ve[j]：从 源点 开始到 顶点 j 的最大路径长度 事件（顶点）最迟发生时间vl[k]：从 顶点 k 到 汇点 的最大路径长度 活动 ai（弧）最早开始时间ee[i] ：ee[i] = ve[j] 活动 ai（弧）最迟开始时间el[i] ：el[i] = vl[k] - w () el [i] - ee [i]： 完成活动 ai 的余量 当 el [i] = ee [i]时，ai 为关键活动 事件发生时间计算公式\n初始化每个点 Ve (i) = 0 Vl (i) = Ve (汇点) 求 Ve (j) 和 Vl (j) 需分两步进行 从 Ve(i) = 0 开始向前递推: Ve(j) = max{Ve(i) + weight ()} i∈P (j)\n其中：P(j) 是以 j 为弧头的弧尾顶点的集合，计算时按拓扑顺序进行 从 Vl (i) = Ve (汇点) 起向后递推: **Vl (j) = min{Vl (k) - weight (}**k∈S (j)\n其中：S (j) 是以 j 为弧尾的弧头顶点的集合，计算时按逆拓扑顺序进行 填空题 n 个顶点 e 条边的图，若采用邻接矩阵存储，则空间复杂度为 O (n2) n 个顶点 e 条边的图，若采用 邻接表 存储，则空间复杂度为 O (n + e) n 个顶点 e 条边的图采用 邻接矩阵 存储，深度优先遍历算法和广度优先遍历算法的时间复杂度都为 O (n2)；若采用 邻接表 存储时，算法的时间复杂度为 O (n + e) 用 普里姆 (Prim) 算法求具有 n 个顶点 e 条边的图的最小生成树的时间复杂度为 O (n2) ；用 克鲁斯卡尔 (Kruskal) 算法的时间复杂度是 O (elog2e) 若要求一个稀疏图 G 的最小生成树，最好用 克鲁斯卡尔 (Kruskal) 算法来求解 若要求一个稠密图 G 的最小生成树，最好用 普里姆 (Prim) 算法来求解 图的深度优先等价于树的先序遍历 AOV 网中, 结点表示活动，边表示活动间的优先关系。AOE 网中, 结点表示事件，边表示活动 下列 AOE 网表示一项包含 8 个活动的工程。通过同时加快若干活动的进度可以缩短整个工程的工期。下列选项中，加快其进度就可以缩短工程工期的是（ ） 用有向无环图描述表达式 (A+B)*((A+B)/A), 至少需要顶点的数目为 ( ) 若无向图 G = (V, E) 中含 7 个顶点，则保证图 G 在任何连边方式下都是连通的，则需要的边数最少是（ ）\n","wordCount":"1136","inLanguage":"en","datePublished":"2022-10-09T20:00:23+08:00","dateModified":"2022-10-09T20:00:23+08:00","author":[{"@type":"Person","name":"Xan"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://zagxuy.github.io/posts/search/"},"publisher":{"@type":"Organization","name":"Xan's Blog","logo":{"@type":"ImageObject","url":"https://zagxuy.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zagxuy.github.io/ accesskey=h title="Xan's Blog (Alt + H)"><img src=https://zagxuy.github.io/img/Headshot.jpg alt aria-label=logo height=35>Xan's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zagxuy.github.io/ title=Home><span>Home</span></a></li><li><a href=https://zagxuy.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://zagxuy.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://zagxuy.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://zagxuy.github.io/links/ title=Links><span>Links</span></a></li><li><a href=https://zagxuy.github.io/about/ title=About><span>About</span></a></li><li><a href=https://zagxuy.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zagxuy.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://zagxuy.github.io/posts/>Posts</a></div><h1 class=post-title>Search</h1><div class=post-meta><span title='2022-10-09 20:00:23 +0800 CST'>October 9, 2022</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Xan&nbsp;|&nbsp;<a href=https://github.com/ZagXuY/Xan-s-Blog/tree/main/content/posts/search.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e9%82%bb%e6%8e%a5%e7%9f%a9%e9%98%b5 aria-label=邻接矩阵>邻接矩阵</a></li><li><a href=#%e9%82%bb%e6%8e%a5%e8%a1%a8 aria-label=邻接表>邻接表</a></li><li><a href=#%e6%9c%80%e5%b0%8f%e7%94%9f%e6%88%90%e6%a0%91 aria-label=最小生成树>最小生成树</a><ul><li><a href=#prim aria-label=Prim>Prim</a></li><li><a href=#kruskal aria-label=Kruskal>Kruskal</a></li></ul></li><li><a href=#%e6%9c%80%e7%9f%ad%e8%b7%af%e5%be%84 aria-label=最短路径>最短路径</a><ul><li><a href=#dijkstra aria-label=Dijkstra>Dijkstra</a></li><li><a href=#floyd aria-label=Floyd>Floyd</a></li></ul></li><li><a href=#%e6%8b%93%e6%89%91%e6%8e%92%e5%ba%8f aria-label=拓扑排序>拓扑排序</a><ul><li><a href=#%e7%89%b9%e7%82%b9 aria-label=特点>特点</a></li><li><a href=#%e7%ae%97%e6%b3%95%e6%8f%8f%e8%bf%b0 aria-label=算法描述>算法描述</a></li></ul></li><li><a href=#aoe-%e7%bd%91%e7%bb%9c%e5%85%b3%e9%94%ae%e8%b7%af%e5%be%84 aria-label="AOE 网络关键路径">AOE 网络关键路径</a></li><li><a href=#%e5%a1%ab%e7%a9%ba%e9%a2%98 aria-label=填空题>填空题</a></li></ul></div></details></div><div class=post-content><p><a href=https://git.acwing.com/ZagY/learn-data-structures/-/blob/main/Graph/Algorithm/README.md>图</a></p><h1 id=邻接矩阵>邻接矩阵<a hidden class=anchor aria-hidden=true href=#邻接矩阵>#</a></h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> vexs[MAX][NUM];;  <span style=color:#75715e>//顶点信息
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> arcs[MAX][MAX];  <span style=color:#75715e>//边或弧上的权值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> vex;  <span style=color:#75715e>//顶点数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> arc;  <span style=color:#75715e>//弧数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}graph, <span style=color:#f92672>*</span>graphlink;
</span></span></code></pre></div><h1 id=邻接表>邻接表<a hidden class=anchor aria-hidden=true href=#邻接表>#</a></h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define MAX 20  </span><span style=color:#75715e>//最大顶点数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#define NUM 20  </span><span style=color:#75715e>//最大字符串长度
</span></span></span><span style=display:flex><span><span style=color:#75715e>//边结点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>arcnode</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> adjvex;  <span style=color:#75715e>//弧所指向顶点下标
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>arcnode</span> <span style=color:#f92672>*</span>next;  <span style=color:#75715e>//指向下一条弧
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> weight;  <span style=color:#75715e>//边结点类型（权重）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}arcnode;
</span></span><span style=display:flex><span><span style=color:#75715e>//表头结点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>vexnode</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> vertex[NUM];  <span style=color:#75715e>//存放结点值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    arcnode <span style=color:#f92672>*</span>head;  <span style=color:#75715e>//存放边链表头指针
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}vexnode;
</span></span><span style=display:flex><span><span style=color:#75715e>//邻接表
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>graph</span>{
</span></span><span style=display:flex><span>    vexnode adjlist[MAX];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> vex;  <span style=color:#75715e>//顶点数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> arc;  <span style=color:#75715e>//边数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}graph, <span style=color:#f92672>*</span>graphlink;
</span></span></code></pre></div><h1 id=最小生成树>最小生成树<a hidden class=anchor aria-hidden=true href=#最小生成树>#</a></h1><h2 id=prim>Prim<a hidden class=anchor aria-hidden=true href=#prim>#</a></h2><ul><li><strong>稠密图</strong></li><li>设 <code>G = (V, {E})</code> 是连通图，最小生成树 T 的<strong>顶点</strong>集合为 <code>U</code>，<strong>边</strong>的集合是 <code>TE</code></li><li>初始：<strong>U = { u<sub>0</sub> }</strong>  ( u<sub>0</sub>∈V ) ， <code>TE = Ø</code></li><li>重复执行下述操作：在所有 <code>u ∈U</code>， <code>v∈W</code> 的边 (u，v) ∈E 中找一条代价最小的边 (u<sub>i</sub> ，v<sub>0</sub>) 并入集合 TE，同时 v<sub>0</sub> 并入 U，直到 U = V 为止</li><li>设置一个辅助数组 (<strong>最小代价数组</strong>)，对当前 <code>V－U 集合</code> 中的每个顶点，记录与顶点集 U 中顶点相连接的代价最小的边</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>crt_graph</span>(graphlink G) {
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;输入顶点数和边数（空格隔开）</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    scanf(<span style=color:#e6db74>&#34;%d %d&#34;</span>, <span style=color:#f92672>&amp;</span>G<span style=color:#f92672>-&gt;</span>vex, <span style=color:#f92672>&amp;</span>G<span style=color:#f92672>-&gt;</span>arc);  <span style=color:#75715e>//顶点数和边数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    printf(<span style=color:#e6db74>&#34;输入顶点信息</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> G<span style=color:#f92672>-&gt;</span>vex; i<span style=color:#f92672>++</span>) scanf(<span style=color:#e6db74>&#34;%s&#34;</span>, G<span style=color:#f92672>-&gt;</span>vexs[i]);  <span style=color:#75715e>//顶点信息
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> G<span style=color:#f92672>-&gt;</span>vex; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; j <span style=color:#f92672>&lt;=</span> G<span style=color:#f92672>-&gt;</span>vex; j<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            G<span style=color:#f92672>-&gt;</span>arcs[i][j] <span style=color:#f92672>=</span> INF;  <span style=color:#75715e>//邻接矩阵初始化
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    printf(<span style=color:#e6db74>&#34;输入边和权值（空格隔开）</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; k <span style=color:#f92672>&lt;=</span> G<span style=color:#f92672>-&gt;</span>arc; k<span style=color:#f92672>++</span>) {  <span style=color:#75715e>//读入边
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> i, j, w;
</span></span><span style=display:flex><span>        scanf(<span style=color:#e6db74>&#34;%d%d%d&#34;</span>, <span style=color:#f92672>&amp;</span>i, <span style=color:#f92672>&amp;</span>j, <span style=color:#f92672>&amp;</span>w);
</span></span><span style=display:flex><span>        G<span style=color:#f92672>-&gt;</span>arcs[i][j] <span style=color:#f92672>=</span> w;
</span></span><span style=display:flex><span>        G<span style=color:#f92672>-&gt;</span>arcs[j][i] <span style=color:#f92672>=</span> w;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>prim</span>(graphlink G, <span style=color:#66d9ef>int</span> v, lowcost lc[]) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> total <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;  <span style=color:#75715e>//边权总和
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> st[MAX] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>};  <span style=color:#75715e>//存储每个点是否已经在生成树中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    st[v] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> G<span style=color:#f92672>-&gt;</span>vex; i<span style=color:#f92672>++</span>) {  <span style=color:#75715e>//初始化
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        lc[i].weight <span style=color:#f92672>=</span> G<span style=color:#f92672>-&gt;</span>arcs[v][i];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (lc[i].weight <span style=color:#f92672>==</span> INF) lc[i].adjnode <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> lc[i].adjnode <span style=color:#f92672>=</span> v;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> G<span style=color:#f92672>-&gt;</span>vex <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>; i<span style=color:#f92672>++</span>) {  <span style=color:#75715e>//循环 G-&gt;vex - 1 次
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> min <span style=color:#f92672>=</span> INF;  <span style=color:#75715e>//其他点到当前最小生成树的最短距离
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> pos <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;  <span style=color:#75715e>//到当前最小生成树的最短距离的点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; k <span style=color:#f92672>&lt;=</span> G<span style=color:#f92672>-&gt;</span>vex; k<span style=color:#f92672>++</span>)  <span style=color:#75715e>//选出权值最小的边
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> (st[k] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> lc[k].weight <span style=color:#f92672>&lt;</span> min) {
</span></span><span style=display:flex><span>                min <span style=color:#f92672>=</span> lc[k].weight;
</span></span><span style=display:flex><span>                pos <span style=color:#f92672>=</span> k;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        total <span style=color:#f92672>+=</span> min;
</span></span><span style=display:flex><span>        st[pos] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;  <span style=color:#75715e>//已在最小生成树中的点
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//更新其他点到当前最小生成树的距离
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; k <span style=color:#f92672>&lt;=</span> G<span style=color:#f92672>-&gt;</span>vex; k<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (st[k] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> G<span style=color:#f92672>-&gt;</span>arcs[pos][k] <span style=color:#f92672>&lt;</span> lc[k].weight) {
</span></span><span style=display:flex><span>                lc[k].weight <span style=color:#f92672>=</span> G<span style=color:#f92672>-&gt;</span>arcs[pos][k];
</span></span><span style=display:flex><span>                lc[k].adjnode <span style=color:#f92672>=</span> pos;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;边权总和为：%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, total);
</span></span><span style=display:flex><span>    print_MST(G, lc);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=kruskal>Kruskal<a hidden class=anchor aria-hidden=true href=#kruskal>#</a></h2><ul><li><strong>稀疏图</strong></li><li>先构造一个只含 <code>n</code> 个顶点的子图 <code>SG</code>，然后从<strong>权值最小</strong>的 <code>边 (u, v)</code> 开始 (u, v 不在同一个连通图)，若它的添加不使 <code>SG</code> 中产生回路，则在 <code>SG</code> 中加上这条边，如此重复，直至加上 <code>n-1</code> 条边为止</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>crt_graph</span>(graphlink G) {
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;输入顶点数和边数（空格隔开）</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    scanf(<span style=color:#e6db74>&#34;%d %d&#34;</span>, <span style=color:#f92672>&amp;</span>G<span style=color:#f92672>-&gt;</span>vex, <span style=color:#f92672>&amp;</span>G<span style=color:#f92672>-&gt;</span>arc);  <span style=color:#75715e>//顶点数和边数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    printf(<span style=color:#e6db74>&#34;输入顶点信息</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> G<span style=color:#f92672>-&gt;</span>vex; i<span style=color:#f92672>++</span>) scanf(<span style=color:#e6db74>&#34;%s&#34;</span>, G<span style=color:#f92672>-&gt;</span>vexs[i]);  <span style=color:#75715e>//顶点信息
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> G<span style=color:#f92672>-&gt;</span>vex; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; j <span style=color:#f92672>&lt;=</span> G<span style=color:#f92672>-&gt;</span>vex; j<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            G<span style=color:#f92672>-&gt;</span>arcs[i][j] <span style=color:#f92672>=</span> INF;  <span style=color:#75715e>//邻接矩阵初始化
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    printf(<span style=color:#e6db74>&#34;输入边和权值（空格隔开）</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; k <span style=color:#f92672>&lt;=</span> G<span style=color:#f92672>-&gt;</span>arc; k<span style=color:#f92672>++</span>) {  <span style=color:#75715e>//读入边
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> i, j, w;
</span></span><span style=display:flex><span>        scanf(<span style=color:#e6db74>&#34;%d%d%d&#34;</span>, <span style=color:#f92672>&amp;</span>i, <span style=color:#f92672>&amp;</span>j, <span style=color:#f92672>&amp;</span>w);
</span></span><span style=display:flex><span>        G<span style=color:#f92672>-&gt;</span>arcs[i][j] <span style=color:#f92672>=</span> w;
</span></span><span style=display:flex><span>        G<span style=color:#f92672>-&gt;</span>arcs[j][i] <span style=color:#f92672>=</span> w;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Kruskal</span>(graphlink G, edge edges[], <span style=color:#66d9ef>int</span> fa[]) {
</span></span><span style=display:flex><span>    init(G, edges, fa);  <span style=color:#75715e>//初始化
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> cnt <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;  <span style=color:#75715e>//合并次数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;  <span style=color:#75715e>//边的下标
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> total <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;  <span style=color:#75715e>//边权总和
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>while</span> (cnt <span style=color:#f92672>&lt;</span> G<span style=color:#f92672>-&gt;</span>vex <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> get_father(edges[k].a, fa);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> y <span style=color:#f92672>=</span> get_father(edges[k].b, fa);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (x <span style=color:#f92672>!=</span> y) {
</span></span><span style=display:flex><span>            fa[x] <span style=color:#f92672>=</span> y;  <span style=color:#75715e>//合并到一棵生成树
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            total <span style=color:#f92672>+=</span> edges[k].w;  edges[k].flag <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;  cnt<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        k<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;边权总和为：%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, total);
</span></span><span style=display:flex><span>    print_MST(G, edges, k);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=最短路径>最短路径<a hidden class=anchor aria-hidden=true href=#最短路径>#</a></h1><h2 id=dijkstra>Dijkstra<a hidden class=anchor aria-hidden=true href=#dijkstra>#</a></h2><ul><li><p><strong>稠密图</strong></p></li><li><p>从源点到其余各点的最短路径</p></li><li><p>首先将网中的所有顶点分成两个集合<code>S</code>和<code>T</code>：</p><ul><li><p>S：凡以v<sub>0</sub>为源点，已经确定了最短路径的终点并入集合S。S的<strong>初始状态</strong>只包含v<sub>0</sub>。</p></li><li><p>T：尚未确定最短路径的顶点的集合。其<strong>初始状态</strong>包含除源点外的所有顶点</p></li></ul></li><li><p>引进两个辅助数组来记源点 (设其编号为 v<sub>0</sub>) 到其它顶点的<strong>最短路径长度</strong>和<strong>路径集合</strong></p><ul><li>Dist[i]：表示 v<sub>0</sub> 到顶点 v<sub>i</sub> 的最短路径的长度</li><li>Path[i]:  表示以上路径中所经过的顶点集合</li></ul></li><li><p>重复执行下述操作，直到选够 <code>n-1</code> 条路径：</p><ol><li>设下一条所选路径的终点为 v<sub>k</sub> ，则：<code>dist[k]= min{dist[i]︱i∈T}</code>，将 k 加入到 S 中</li><li>修改 dist[i] {i∈T}， <code>dist[i]=min{dist[i]，dist[k] + arcs[k][i]︱k∈S，i∈T}</code></li></ol></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>crt_graph</span>(graphlink G) {
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;输入顶点数和边数（空格隔开）</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    scanf(<span style=color:#e6db74>&#34;%d %d&#34;</span>, <span style=color:#f92672>&amp;</span>G<span style=color:#f92672>-&gt;</span>vex, <span style=color:#f92672>&amp;</span>G<span style=color:#f92672>-&gt;</span>arc);  <span style=color:#75715e>//顶点数和边数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    printf(<span style=color:#e6db74>&#34;输入顶点信息</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> G<span style=color:#f92672>-&gt;</span>vex; i<span style=color:#f92672>++</span>) scanf(<span style=color:#e6db74>&#34;%s&#34;</span>, G<span style=color:#f92672>-&gt;</span>vexs[i]);  <span style=color:#75715e>//顶点信息
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> G<span style=color:#f92672>-&gt;</span>vex; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; j <span style=color:#f92672>&lt;=</span> G<span style=color:#f92672>-&gt;</span>vex; j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            G<span style=color:#f92672>-&gt;</span>arcs[i][j] <span style=color:#f92672>=</span> INF;  <span style=color:#75715e>//邻接矩阵初始化
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>==</span> j) G<span style=color:#f92672>-&gt;</span>arcs[i][j] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;输入边和权值（空格隔开）</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; k <span style=color:#f92672>&lt;=</span> G<span style=color:#f92672>-&gt;</span>arc; k<span style=color:#f92672>++</span>) {  <span style=color:#75715e>//读入边
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> i, j, w;
</span></span><span style=display:flex><span>        scanf(<span style=color:#e6db74>&#34;%d%d%d&#34;</span>, <span style=color:#f92672>&amp;</span>i, <span style=color:#f92672>&amp;</span>j, <span style=color:#f92672>&amp;</span>w);
</span></span><span style=display:flex><span>        G<span style=color:#f92672>-&gt;</span>arcs[i][j] <span style=color:#f92672>=</span> w;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dijkstra</span>(graphlink G, <span style=color:#66d9ef>int</span> v, shortdist dist[]) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> flag[MAX] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>    flag[v] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> G<span style=color:#f92672>-&gt;</span>vex; i<span style=color:#f92672>++</span>) {  <span style=color:#75715e>//dist数组初始化
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        dist[i].distance <span style=color:#f92672>=</span> G<span style=color:#f92672>-&gt;</span>arcs[v][i];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (G<span style=color:#f92672>-&gt;</span>arcs[v][i] <span style=color:#f92672>!=</span> INF) dist[i].path <span style=color:#f92672>=</span> v;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> dist[i].path <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (<span style=color:#ae81ff>1</span>) {  <span style=color:#75715e>//按距离递增顺序找出从v出发到其余各顶点的最短路径
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> pos <span style=color:#f92672>=</span> v;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> min <span style=color:#f92672>=</span> INF;  <span style=color:#75715e>//距离最小值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> G<span style=color:#f92672>-&gt;</span>vex; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(flag[i] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> dist[i].distance <span style=color:#f92672>&lt;</span> min) {
</span></span><span style=display:flex><span>                min <span style=color:#f92672>=</span> dist[i].distance;
</span></span><span style=display:flex><span>                pos <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (min <span style=color:#f92672>==</span> INF) <span style=color:#66d9ef>break</span>;  <span style=color:#75715e>//算法结束
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        flag[pos] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;  <span style=color:#75715e>//对已完成的顶点做标记
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> G<span style=color:#f92672>-&gt;</span>vex; i<span style=color:#f92672>++</span>)   <span style=color:#75715e>//更新dist
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> (flag[i] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> dist[pos].distance <span style=color:#f92672>+</span> G<span style=color:#f92672>-&gt;</span>arcs[pos][i] <span style=color:#f92672>&lt;</span> dist[i].distance) {
</span></span><span style=display:flex><span>                dist[i].distance <span style=color:#f92672>=</span> dist[pos].distance <span style=color:#f92672>+</span> G<span style=color:#f92672>-&gt;</span>arcs[pos][i];
</span></span><span style=display:flex><span>                dist[i].path <span style=color:#f92672>=</span> pos;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    print_path(G ,dist, v);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=floyd>Floyd<a hidden class=anchor aria-hidden=true href=#floyd>#</a></h2><ul><li><strong>稠密图</strong></li><li>每一对顶点之间的最短路径</li><li><code>dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>crt_graph</span>(graphlink G) {
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;输入顶点数和边数（空格隔开）</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    scanf(<span style=color:#e6db74>&#34;%d %d&#34;</span>, <span style=color:#f92672>&amp;</span>G<span style=color:#f92672>-&gt;</span>vex, <span style=color:#f92672>&amp;</span>G<span style=color:#f92672>-&gt;</span>arc);  <span style=color:#75715e>//顶点数和边数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    printf(<span style=color:#e6db74>&#34;输入顶点信息</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> G<span style=color:#f92672>-&gt;</span>vex; i<span style=color:#f92672>++</span>) scanf(<span style=color:#e6db74>&#34;%s&#34;</span>, G<span style=color:#f92672>-&gt;</span>vexs[i]);  <span style=color:#75715e>//顶点信息
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> G<span style=color:#f92672>-&gt;</span>vex; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; j <span style=color:#f92672>&lt;=</span> G<span style=color:#f92672>-&gt;</span>vex; j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            G<span style=color:#f92672>-&gt;</span>arcs[i][j] <span style=color:#f92672>=</span> INF;  <span style=color:#75715e>//邻接矩阵初始化
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>==</span> j) G<span style=color:#f92672>-&gt;</span>arcs[i][j] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;输入边和权值（空格隔开）</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; k <span style=color:#f92672>&lt;=</span> G<span style=color:#f92672>-&gt;</span>arc; k<span style=color:#f92672>++</span>) {  <span style=color:#75715e>//读入边
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>int</span> i, j, w;
</span></span><span style=display:flex><span>        scanf(<span style=color:#e6db74>&#34;%d%d%d&#34;</span>, <span style=color:#f92672>&amp;</span>i, <span style=color:#f92672>&amp;</span>j, <span style=color:#f92672>&amp;</span>w);
</span></span><span style=display:flex><span>        G<span style=color:#f92672>-&gt;</span>arcs[i][j] <span style=color:#f92672>=</span> w;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>[Ovoid floyd(graphlink G, <span style=color:#66d9ef>int</span> dist[][MAX], <span style=color:#66d9ef>int</span> path[][MAX]) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> G<span style=color:#f92672>-&gt;</span>vex; i<span style=color:#f92672>++</span>)  <span style=color:#75715e>//初始化
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; j <span style=color:#f92672>&lt;=</span> G<span style=color:#f92672>-&gt;</span>vex; j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            dist[i][j] <span style=color:#f92672>=</span> G<span style=color:#f92672>-&gt;</span>arcs[i][j];
</span></span><span style=display:flex><span>            path[i][j] <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (dist[i][j] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> dist[i][j] <span style=color:#f92672>==</span> INF) path[i][j] <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>[I        }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; k <span style=color:#f92672>&lt;=</span> G<span style=color:#f92672>-&gt;</span>vex; k<span style=color:#f92672>++</span>)  <span style=color:#75715e>//对每一个顶点做一次迭代
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> G<span style=color:#f92672>-&gt;</span>vex; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; j <span style=color:#f92672>&lt;=</span> G<span style=color:#f92672>-&gt;</span>vex; j<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (dist[i][k] <span style=color:#f92672>+</span> dist[k][j] <span style=color:#f92672>&lt;</span> dist[i][j]) {
</span></span><span style=display:flex><span>                    dist[i][j] <span style=color:#f92672>=</span> dist[i][k] <span style=color:#f92672>+</span> dist[k][j];
</span></span><span style=display:flex><span>                    path[i][j] <span style=color:#f92672>=</span> k;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    print_path(G, dist, path);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=拓扑排序>拓扑排序<a hidden class=anchor aria-hidden=true href=#拓扑排序>#</a></h1><h2 id=特点>特点<a hidden class=anchor aria-hidden=true href=#特点>#</a></h2><ol><li>一个有向图的拓扑序列一般不唯一</li><li>有向无环图一定存在拓扑序列</li></ol><h2 id=算法描述>算法描述<a hidden class=anchor aria-hidden=true href=#算法描述>#</a></h2><ul><li><strong>如果顶点没有全部输出，则说明有向图中存在环</strong></li></ul><ol><li>在有向图中选一个 <code>入度为零的顶点</code> 且输出</li><li>将图中与该顶点有关的边的 <code>弧头顶点的入度减 1</code></li><li>重复上述两步，直至所有满足条件的顶点均已输出</li></ol><h1 id=aoe-网络关键路径>AOE 网络关键路径<a hidden class=anchor aria-hidden=true href=#aoe-网络关键路径>#</a></h1><ul><li><p>AOE 网络：以<strong>顶点</strong>表示事件，<strong>弧</strong>表示活动，<strong>权</strong>表示活动持续的时间的<strong>带权有向无环图</strong></p></li><li><p>只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始</p></li><li><p>只有在指向某一顶点的各有向边所代表的活动都己经结束后，该顶点所代表的事件才能发生</p></li><li><p>假设 AOE 网络表示<strong>施工流程图</strong>，弧上权值表示完成该子工程所需<strong>时间</strong></p><ul><li><strong>关键活动</strong>：关键路径上的所有活动</li><li><strong>关键路径</strong>：整个工程完成的最短时间（从 AOE 网络的 <code>源点</code> 到 <code>汇点</code> 的最长路径长度）</li></ul></li><li><p>如何求关键活动</p><ul><li>假设活动 <code>a(i)</code> 是弧 <code>&lt;j,k></code> 上的活动，<code>j</code> 为弧尾顶点，<code>k</code> 为弧头</li><li>事件（顶点）<u>最早发生时间</u>v<sub>e</sub>[j]：从 <code>源点</code> 开始到 <code>顶点 j</code> 的最大路径长度</li><li>事件（顶点）<u>最迟发生时间</u>v<sub>l</sub>[k]：从 <code>顶点 k</code> 到 <code>汇点</code> 的最大路径长度</li><li>活动 a<sub>i</sub>（弧）<u>最早开始时间</u>e<sub>e</sub>[i] ：<strong>e<sub>e</sub>[i] = v<sub>e</sub>[j]</strong></li><li>活动 a<sub>i</sub>（弧）<u>最迟开始时间</u>e<sub>l</sub>[i] ：<strong>e<sub>l</sub>[i] = v<sub>l</sub>[k] - w (&lt;j, k>)</strong></li><li>e<sub>l</sub> [i] - e<sub>e</sub> [i]： 完成活动 <strong>a<sub>i</sub></strong> 的余量</li><li>当 e<sub>l</sub> [i] = e<sub>e</sub> [i]时，<strong>a<sub>i</sub></strong> 为关键活动</li></ul></li><li><p>事件发生时间计算公式</p><ul><li>初始化每个点<ul><li>V<sub>e</sub> (i) = 0  </li><li>V<sub>l</sub> (i) = V<sub>e</sub> (汇点)</li></ul></li><li>求 V<sub>e</sub> (j) 和 V<sub>l </sub>(j) 需分两步进行<ol><li><p>从 V<sub>e</sub>(i) = 0 开始向前递推: <strong>V<sub>e</sub>(j) = max{V<sub>e</sub>(i) + weight (&lt;i，j>)}</strong> i∈P (j)</p><ul><li>其中：<code>P(j)</code> 是以 <code>j</code> 为弧头的弧尾顶点的集合，计算时按<strong>拓扑顺序</strong>进行</li></ul></li><li><p>从 V<sub>l</sub> (i) = V<sub>e</sub> (汇点) 起向后递推: **V<sub>l</sub> (j) = min{V<sub>l</sub> (k) - weight (&lt;j，k>}**k∈S (j)</p><ul><li>其中：<code>S (j)</code> 是以 <code>j</code> 为弧尾的弧头顶点的集合，计算时按<strong>逆拓扑顺序</strong>进行</li></ul></li></ol></li></ul></li></ul><h1 id=填空题>填空题<a hidden class=anchor aria-hidden=true href=#填空题>#</a></h1><ul><li>n 个顶点 e 条边的图，若采用<code>邻接矩阵</code>存储，则空间复杂度为 <strong>O (n<sup>2</sup>)</strong></li><li>n 个顶点 e 条边的图，若采用 <code>邻接表</code> 存储，则空间复杂度为 <strong>O (n + e)</strong></li><li> n 个顶点 e 条边的图采用 <code>邻接矩阵</code> 存储，<u>深度优先遍历算法</u>和<u>广度优先遍历算法</u>的时间复杂度都为 <strong>O (n<sup>2</sup>)</strong>；若采用 <code>邻接表</code> 存储时，算法的时间复杂度为  <strong>O (n + e)</strong></li><li> 用 <code>普里姆 (Prim)</code> 算法求具有 n 个顶点 e 条边的图的最小生成树的时间复杂度为  <strong>O (n<sup>2</sup>)</strong>     ；用 <code>克鲁斯卡尔 (Kruskal)</code> 算法的时间复杂度是   <strong>O (elog<sub>2</sub>e)</strong></li><li> 若要求一个<strong>稀疏图 G</strong> 的最小生成树，最好用 <code>克鲁斯卡尔 (Kruskal)</code>  算法来求解</li><li> 若要求一个<strong>稠密图 G</strong> 的最小生成树，最好用 <code>普里姆 (Prim)</code>   算法来求解</li><li> 图的深度优先等价于树的<strong>先序</strong>遍历</li><li> AOV 网中, 结点表示<strong>活动</strong>，边表示<strong>活动间的优先关系</strong>。AOE 网中, 结点表示<strong>事件</strong>，边表示<strong>活动</strong></li></ul><p><a href=https://www.nowcoder.com/questionTerminal/77072bd4872e46df80f2203c2f0eb260>下列 AOE 网表示一项包含 8 个活动的工程。通过同时加快若干活动的进度可以缩短整个工程的工期。下列选项中，加快其进度就可以缩短工程工期的是（ ）</a>
<a href="https://www.nowcoder.com/questionTerminal/bdd3941ff3a8400d86651d32c6bcf1b9?source=relative">用有向无环图描述表达式 (A+B)*((A+B)/A), 至少需要顶点的数目为 ( )</a>
<a href=https://www.nowcoder.com/questionTerminal/f71a61d49690436fade01028428c7a9c>若无向图 G = (V, E) 中含 7 个顶点，则保证图 G 在任何连边方式下都是连通的，则需要的边数最少是（ ）</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://zagxuy.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/>数据结构</a></li></ul><nav class=paginav><a class=prev href=https://zagxuy.github.io/posts/table/><span class=title>« Prev</span><br><span>Table</span></a>
<a class=next href=https://zagxuy.github.io/posts/sort/><span class=title>Next »</span><br><span>Sort</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://zagxuy.github.io/>Xan's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>