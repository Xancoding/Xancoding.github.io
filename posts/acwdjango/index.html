<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>AcWing Django 框架课 | Xan's Blog</title><meta name=keywords content="Tech,AcWing,Django,新技能"><meta name=description content="AcWing Django 框架课 | Colopen&rsquo;s blog AcWing Django 框架课 Django 项目创建 2.1上课笔记 | 栎 2.1上课笔记 | Andrew1729 启动初始项目 django-admin startproject acapp：在当前目录下创建名为acapp的djan"><meta name=author content="
作者:&nbsp;Xan"><link rel=canonical href=https://xancoding.cn/posts/acwdjango/><link crossorigin=anonymous href=/assets/css/stylesheet.7a104f3188f0feeede33760a48139f6901c979a68fcae908a25f8a2ed54ecdc7.css integrity="sha256-ehBPMYjw/u7eM3YKSBOfaQHJeaaPyukIol+KLtVOzcc=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://xancoding.cn/img/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://xancoding.cn/img/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://xancoding.cn/img/favicon.ico><link rel=apple-touch-icon href=https://xancoding.cn/img/favicon.ico><link rel=mask-icon href=https://xancoding.cn/img/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["[[","]]"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"})</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style><link rel=stylesheet href=//cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.css><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="AcWing Django 框架课"><meta property="og:description" content="AcWing Django 框架课 | Colopen&rsquo;s blog AcWing Django 框架课 Django 项目创建 2.1上课笔记 | 栎 2.1上课笔记 | Andrew1729 启动初始项目 django-admin startproject acapp：在当前目录下创建名为acapp的djan"><meta property="og:type" content="article"><meta property="og:url" content="https://xancoding.cn/posts/acwdjango/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-10-29T18:23:59+08:00"><meta property="article:modified_time" content="2022-10-29T18:23:59+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="AcWing Django 框架课"><meta name=twitter:description content="AcWing Django 框架课 | Colopen&rsquo;s blog AcWing Django 框架课 Django 项目创建 2.1上课笔记 | 栎 2.1上课笔记 | Andrew1729 启动初始项目 django-admin startproject acapp：在当前目录下创建名为acapp的djan"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://xancoding.cn/posts/"},{"@type":"ListItem","position":3,"name":"AcWing Django 框架课","item":"https://xancoding.cn/posts/acwdjango/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"AcWing Django 框架课","name":"AcWing Django 框架课","description":"AcWing Django 框架课 | Colopen\u0026rsquo;s blog AcWing Django 框架课 Django 项目创建 2.1上课笔记 | 栎 2.1上课笔记 | Andrew1729 启动初始项目 django-admin startproject acapp：在当前目录下创建名为acapp的djan","keywords":["Tech","AcWing","Django","新技能"],"articleBody":" AcWing Django 框架课 | Colopen’s blog AcWing Django 框架课 Django 项目创建 2.1上课笔记 | 栎 2.1上课笔记 | Andrew1729 启动初始项目 django-admin startproject acapp：在当前目录下创建名为acapp的django项目 python3 manage.py runserver 0.0.0.0:8000：启动项目 打开settings.py，找到ALLOWED_HOSTS=[]，修改成ALLOWED_HOSTS=[\"自己的服务器的公网IP\"] 通过自己的服务器公网IP:8000 打开Django页面 创建管理员登录页面 在一级acapp文件夹下，python3 manage.py startapp XXX，XXX是可以自定义的app名，这里用game示例，这时候会多一个文件夹game，树形结构如图： |-- game | |-- __init__.py | |-- admin.py # 管理员页面 | |-- apps.py # 用的不多 | |-- migrations # 存储数据库 | | `-- __init__.py | |-- models.py # 定义网站里的数据库表 | |-- tests.py | `-- views.py # 视图，即函数 python3 manage.py migrate：将所有修改更新进数据库 创建一个 管理员用户： $ python3 manage.py createsuperuser \u003e Username (leave blank to use 'acs'): admin \u003e Email address: \u003e Password: 123456 \u003e Password (again): 123456 \u003e Superuser created successfully. 然后利用该 管理员用户 登录 admin 页面，即可成功登陆\n创建用户登录页面 game 下的各个文件作用 templates目录：管理 html 文件 urls目录：管理路由，即链接与函数的对应关系 (接收链接，调用相对应的函数) views目录：管理 http 函数（接收浏览器请求，返回字符串至浏览器） models目录：管理数据库数据 static目录：管理静态文件 consumers目录：管理websocket函数 实现一个路由重定向 url 输入网址 -\u003e acapp.urls -\u003e game.urls -\u003e game.views.index -\u003e 展示页面 game.views\n这其中，HttpResponse()内部使用html的语法，返回的响应就直接用这个字符串作为页面，转换成html\nfrom django.http import HttpResponse def index(request): line1 = ' 第一个网页 ' return HttpResponse(line1) game.urls\n这其中，path('PATH', function, name)的含义是，在用户访问网站的时候，如果是网站/game/PATH，就会调用function，名字为name，这是在/game/目录下的调用，所以这个PATH是在/game/的基础上的相对路径，所以他的绝对路径是网站/game/PATH\nfrom django.urls import path from game.views import index urlpatterns = [ path(\"\", index, name=\"index\"), ] acapp.urls\n这其中，path('PATH', include('game.urls'))的含义是：在用户访问网站的时候，如果是网站/PATH，就会走到/game/urls，并根据/game/urls.py来跑路由，就是说，用户在访问网站/的时候，由于此时调用的函数是include('game.urls')，所以访问网站/相当于根据game/urls访问\nfrom django.contrib import admin from django.urls import path, include urlpatterns = [ path('', include('game.urls')), path('admin/', admin.site.urls), ] 然后直接打开 ip:socket 可以直接显示 index 返回的网页\n创建菜单界面 3. 创建菜单界面 | 讲义 3.1 上课笔记 | 大家好今天是 3.1 上课笔记 | 栎 构建项目框架 项目系统设计 menu：菜单页面 playground：游戏界面 settings：设置界面 项目文件结构 . |-- README.md |-- acapp | |-- __init__.py # 文件夹在加上 __init__.py 文件后，python 便可以通过 import 来引用该文件夹 | |-- asgi.py | |-- settings.py | |-- urls.py | `-- wsgi.py |-- db.sqlite3 |-- game | |-- __init__.py | |-- admin.py | |-- apps.py | |-- migrations | | `-- __init__.py | |-- models | | `-- __init__.py | |-- static | | |-- css | | | `-- game.css # 一般一个工程，只有一个 css 文件就足够了 | | |-- image | | | `-- menu | | | `-- background.gif | | `-- js | | |-- dist | | | `-- game.js | | `-- src | | `-- zbase.js # 总的 js 文件，命名以 z 开头会自动在字典序最后 | |-- templates | | `-- multiends | | `-- web.html | |-- tests.py | |-- urls | | |-- __init__.py | | |-- index.py | | |-- menu | | | |-- __init__.py | | | `-- index.py | | |-- playground | | | |-- __init__.py | | | `-- index.py | | `-- settings | | |-- __init__.py | | `-- index.py | `-- views | |-- __init__.py | |-- index.py | |-- menu | | `-- __init__.py | |-- playground | | `-- __init__.py | `-- settings | `-- __init__.py |-- manage.py `-- scripts `-- compress_game_js.sh js 文件管理 一般一个工程会有很多个 .js 源文件，为了加快网络的传输，也为了每次写新的 .js 文件不用每个 html 都额外引入一次\n考虑用一个 src 源文件夹来存储所有的 .js 源文件\n然后用 dist 文件夹来存放由 src 下所有源文件整合生成的一个目标 .js 文件\n这样既实现了快速传输的好处，也方便了后续编写 html 文件时，引入 .js 的便利\n创建一个脚本实现上述 整合 的功能 ~/acapp/scripts/compress_game_js.sh\n#! /bin/bash JS_PATH=/home/acs/acapp/game/static/js/ JS_PATH_DIST=${JS_PATH}dist/ JS_PATH_SRC=${JS_PATH}src/ find $JS_PATH_SRC -type f -name '*.js' | sort | xargs cat \u003e ${JS_PATH_DIST}game.js html 文件管理 在 templates 文件夹下创建 menu、playground、settings、multiends 四个文件夹，用于存储三个模块和终端的 html 文件\n在 multiends 下创建 web.html 文件\n{% load static %} views 视图管理 在 views 文件夹下新建三个模块的视图文件夹\n写一个 index.py 文件，目的是在 web 端被访问时，返回上面写的 web.html 文件\nfrom django.shortcuts import render def index(request): return render(request, \"multiends/web.html\") urls 路由管理 /-- \"\" -- index / -- \"menu/\" -- menu.index / \"\" --\u003e \"game.url\" --\u003e / \\ -- \"playground/\" -- playground.index id:scoket -\u003e \\-- \"settings/\" -- settings.index \\ \\ \"/admin\" -- 到达管理员页面 ~/acapp/acapp/urls.py\nfrom django.contrib import admin from django.urls import path, include urlpatterns = [ path('', include('game.urls.index')), path('admin/', admin.site.urls), ] ~/acapp/game/urls/index.py\nfrom django.urls import path, include from game.views.index import index urlpatterns = [ path(\"\", index, name=\"index\"), path(\"menu/\", include(\"game.urls.menu.index\")), path(\"playground/\", include(\"game.urls.playground.index\")), path(\"settings/\", include(\"game.urls.settings.index\")) ] 网页渲染流程 根据用户的链接，首先进入acapp/urls.py，根据path再进入game/urls/index.py，再根据path进入下一层url或调用相对应的views中的index.py函数，函数接收参数，在网页端渲染templates/multiends下的web.html，html中有JS执行\n注意：本项目为前后端分离，即通过JS在client中渲染项目(动态生成页面)，而不是在server渲染项目\n修改全局配置 设置时区 修改项目的 UTC 时间为 CN 时间\n$ vim /acapp/settings.py ****** TIME_ZONE = 'Asia/Shanghai' # 原来默认是 UTC ****** 添加配置文件 将新创建的 game 下的 apps.py 中的 GameConfig 加到 settings.py 下\n$ vim /acapp/settings.py ****** INSTALLED_APPS = [ 'game.apps.GameConfig', ...... ] ****** 声明将静态文件路径 STATIC_ROOT 和 MEDIA_ROOT\n$ vim /acapp/settings.py ****** import os ...... STATIC_ROOT = os.path.join(BASE_DIR, 'static') STATIC_URL = '/static/' MEDIA_ROOT = os.path.join(BASE_DIR, 'media') MEDIA_URL = '/media/' ****** 创建菜单 menu 界面 搭建菜单 menu 界面的框架 我们采用的 前后端分离式 开发，所有的 html 渲染都要求在前端完成\n开发流程就是，先在 html 里创建好一个有 id 的 div\n然后利用 js 文件，捕获到该 div，并进行 渲染\n/templates/multiends/web.html\n... ... js/src/zbase.js\nclass AcGame { constructor(id) { this.id = id; this.$ac_game = $('#' + id); this.menu = new AcGameMenu(this); } } js/src/menu/zbase.js\nclass AcGameMenu { constructor(root) { this.root = root; this.$menu = $(` `); this.root.$ac_game.append(this.$menu); } css/game.css\n.ac-game-menu { width: 100%; height: 100%; background-image: url('/static/image/menu/background.gif'); background-size: 100% 100%; user-select: none; } 这里的 代码逻辑 如下：\nhtml 页面执行到 js 代码，利用 AcGame类 创建对象 ac_game 同时传递参数 div 的 id AcGame 开始执行构造函数，在构造函数中，捕获 html 标签，并利用 AcGameMenu类 创建对象 menu，并将整个对象作为参数下传 AcGameMenu 开始执行构造函数，然后创建 html 代码，加到捕获到的 html 代码下 最终成功渲染出背景图片 设置菜单 menu 页面的内容 主要内容就是在主页面中，显示：单人模式、多人模式、设置，三个按钮的选项 js/src/menu/zbase.js\nclass AcGameMenu { constructor(root) { this.root = root; this.$menu = $(` 单人模式 多人模式 设置 `); this.root.$ac_game.append(this.$menu); this.$single_mode = this.$menu.find('.ac-game-menu-field-item-single-mode'); this.$multi_mode = this.$menu.find('.ac-game-menu-field-item-multi-mode'); this.$settings_mode = this.$menu.find('.ac-game-menu-field-item-settings-mode'); } } css/game.css\n.ac-game-menu { width: 100%; height: 100%; background-image: url('/static/image/menu/background.gif'); background-size: 100% 100%; user-select: none; } .ac-game-menu-field { width: 20vw; position: relative; top: 40vh; left: 19vh; } .ac-game-menu-field-item { height: 7vh; width: 18vw; color: white; font-size: 6vh; font-style: italic; padding: 2vh; margin: 1vh 0; cursor: pointer; text-align: center; background-color: rgba(39, 21, 28, 0.6); border-radius: 10px; letter-spacing: 0.5vw; } .ac-game-menu-field-item:hover { transform: scale(1.2); transition: 100ms; } 添加 ‘单人模式’ 监听函数 —— 打开游戏界面 功能 这里要实现的 逻辑：\n点击 ‘单人模式’ 按钮触发 click 事件，随即触发监听函数，开始执行 关闭 menu 页面 打开 playground 页面 因此，我们先简易的实现一个 playground 页面，方便调试该功能 js/src/playground/zbase.js\nclass AcGamePlayground { constructor(root) { this.root = root; this.$playground = $(`游戏界面`); this.hide(); this.root.$ac_game.append(this.$playground); this.start(); } start() { } show() { //打开 playground 界面 this.$playground.show(); } hide() { //关闭 playground 界面 this.$playground.hide(); } } 在实现监听函数功能之前，先在 /src/zbase.js 即主 js 文件下，利用 AcGamePlayground 类创建好 playground 对象\n这样我们就能在前端，渲染出两个界面了，分别是：menu 和 playground\njs/src/zbase.js\nclass AcGame { constructor(id) { this.id = id; this.$ac_game = $('#' + id); this.menu = new AcGameMenu(this); // 把 playground 对象也建好，这样我们就同时有两个界面了 this.playground = new AcGamePlayground(this); this.start(); } start() { } } 然后，我们开始实现 ac-game-menu-field-item-single-mode 标签的 click 事件的监听函数\n其功能之前讲过了，就是关闭 menu 页面，打开 playground 页面\njs/src/menu/zbase.js\nclass AcGameMenu { constructor(root) { this.root = root; this.$menu = $(` 单人模式 多人模式 设置 `); this.root.$ac_game.append(this.$menu); this.$single_mode = this.$menu.find('.ac-game-menu-field-item-single-mode'); this.$multi_mode = this.$menu.find('.ac-game-menu-field-item-multi-mode'); this.$settings_mode = this.$menu.find('.ac-game-menu-field-item-settings-mode'); this.start(); } start() { this.add_listening_events(); } add_listening_events() { let outer = this; this.$single_mode.click(function(){ outer.hide(); // 关闭主页面 outer.root.playground.show(); // 打开游戏界面 }); } show() { //显示menu界面 this.$menu.show(); } hide() { //隐藏menu界面 this.$menu.hide(); } } 创建游戏界面 4.1 上课笔记 | Andrew1729 若修改static文件夹下的相关文件，需在~/acapp下执行./scripts/compress_game_js.sh来打包文件\n前端的模块化引入 由于在 html 代码部分，是将整个 game.js 文件引入\n这样会导致在 game.js 中定义的变量，会变成整个网页的 全局变量（之后可能会引起变量重名的诸多问题）\n因此，我们考虑使用 模块化引入 的功能，让网页只引入在 html 中需要的部分\n修改 web.html\n...... ...... 此外，还有修改引入的类，在前面加上 export，如下修改 js/src/zbase.js\nexport class AcGame { ...... } 这样，在全局中，只会出现引入的模块，其他的 .js 代码不会出现在全局中\n构建游戏界面框架 static/js/src/playground/zbase.js\n...... this.$playground = $(``); ...... game.css\n...... .ac-game-playground { height: 100%; width: 100%; user-select: none; // 禁用右键弹菜单 } 实现游戏引擎框架 游戏中，物体在移动，其实现原理是：每一个动作都会渲染多张图片出来，然后图片快速的切换，从而实现动的过程\n因此，需要先实现一个游戏引擎的基类 AcGameObject ，使得每帧能渲染一张图片出来\n该基类需要具备的功能有：\nstart() 在游戏开始的第一帧时需要执行的任务（一般是创建对象） update() 在游戏开始后的每一帧均会执行的任务（一般是渲染当前对象的各种状态） on_destroy() 删掉该物体前需要执行的任务（一般是删掉动画，或者给对手加分） destroy() 删掉该物体 根据上述逻辑，我们就可以基本搭建出来一个游戏引擎的基类了，具体如下： /static/js/playground/ac_game_object/zbase.js\nlet AC_GAME_OBJECTS = []; // 用于记录当前画布中，需要渲染的对象有哪些 class AcGameObject { constructor() { AC_GAME_OBJECTS.push(this); // 将当前新建的对象，加入到全局的画布中去，参与渲染 this.has_called_start = false; // 是否执行过 start 函数 this.timedelta = 0; // 当前帧距离上一帧的时间间隔 // 该数据记录是为了后续计算速度等参数的 } start() { // 只会在第一帧执行一次 } update() { // 每一帧均会执行一次 } on_destroy() { // 在被销毁前执行一次 } destroy() { // 删掉该物体 this.on_destroy(); //删掉该物体前，执行删前的操作 // 在全局渲染物体中，找到该物体，并将其删掉 for (let i = 0; i \u003c AC_GAME_OBJECTS.length; i ++ ) { if (AC_GAME_OBJECTS[i] === this) { // 三等号，在js里额外加了一层类型相等约束 AC_GAME_OBJECTS.splice(i, 1); break; } } } } let last_timestamp; let AC_GAME_ANIMATION = function(timestamp) { // 回调函数，实现：每一帧重绘时，都会执行一遍 for (let i = 0; i \u003c AC_GAME_OBJECTS.length; i ++ ) { let obj = AC_GAME_OBJECTS[i]; if (!obj.has_called_start) { // 如果还未执行初始帧动作，就先执行 obj.start(); obj.has_called_start = true; } else { // 执行过初始帧，就执行每一帧的任务 obj.timedelta = timestamp - last_timestamp; obj.update(); } } last_timestamp = timestamp; // 更新最后一次时间戳 requestAnimationFrame(AC_GAME_ANIMATION); } requestAnimationFrame(AC_GAME_ANIMATION); // JS的API，可以调用1帧里面的函数。(有些浏览器的一秒帧数不一定相等) 接下来所有的一切游戏，都是基于这个引擎的基类完成的\n实现游戏地图功能 目标：实现一个每一秒都在渲染的纯黑背景\n虽然现阶段要实现的地图较为简单，但为了后期的拓展性，故还是考虑新建一个文件夹来完成\n然后在 js 中，已经封装好了一个 canvas 的 api 来帮助实现背景画布，直接调用即可\n先铺开画布，然后设置为黑色\nstatic/js/playground/zbase.js\nclass AcGamePlayground { constructor(root) { ...... // $('.playground')对象已经在 css 文件里渲染出高宽了 // 现在把他的高宽存下来，往下传递 this.width = this.$playground.width(); this.height = this.$playground.height(); this.game_map = new GameMap(this); ...... } ..... } static/js/playground/game-map/zbase.js\nclass GameMap extends AcGameObject { // 继承自游戏引擎基类 constructor(playground) { super(); // 自函数功能：调用基类的构造函数 this.playground = playground; this.$canvas = $(``); // 创建一个canvas的jQuery对象，就是我们要实现的画布 this.ctx = this.$canvas[0].getContext('2d'); // jQuery对象是一个数组，第一个索引是html对象 // 设置画布的宽高 this.ctx.canvas.width = this.playground.width; this.ctx.canvas.height = this.playground.height; this.playground.$playground.append(this.$canvas); } start() { } update() { // 游戏地图每帧都要渲染 this.render(); } render() { this.ctx.fillStyle = \"rgba(0, 0, 0, 0.2)\"; this.ctx.fillRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height); } } 实现玩家显示功能 毛坯版玩家显示，每个玩家定义成一个圆，然后渲染在前端\n需要对于玩家类定义多个参数，以方便日后拓展：\nx 当前位置的横坐标 y 当前位置的纵坐标 radius 当前的半径 speed 当前的速度 is_me 该对象是否是当前玩家操控的对象（一是区别于 bot，二是区别于 日后联机的其他玩家） static/js/playground/zbase.js\nclass AcGamePlayground { constructor(root) { ...... this.players = []; // 存放当前游戏中的所有玩家 // 将玩家加入游戏中 this.players.push(new Player(this, this.width / 2, this.height / 2, this.height * 0.05, \"white\", this.height * 0.15, true)); ...... } ..... } static/js/playground/player/zbase.js\nclass Player extends AcGameObject { constructor(playground, x, y, radius, color, speed, is_me) { super(); // 把信息都存下来 this.playground = playground; this.ctx = this.playground.game_map.ctx; this.x = x; this.y = y; this.color = color; this.speed = speed; this.radius = radius; this.is_me = is_me; // 用于浮点数运算 this.eps = 0.1; } start() { } update() { this.render(); } render() { // 渲染一个圆 this.ctx.beginPath(); this.ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI, false); this.ctx.fillStyle = this.color; this.ctx.fill(); } on_destroy() { } } 实现玩家移动功能 移动的实现逻辑很简单，就是让每帧渲染的圆的位置发生移动即可\n上述简单逻辑的实现如下：\nclass Player extends AcGameObject { constructor(....) { ... this.vx = 1; this.vy = 1; ... } ... update() { this.x += x; this.y += y; this.render(); } } 然后我们来实现一个向鼠标点击位置移动的功能\n这就需要设置一个 click 事件的监听函数，分别传递：\n鼠标点击事件 鼠标点击位置的横坐标 鼠标点击位置的纵坐标 然后开始让圆的位置逐步向鼠标点击位置进行移动\nstart() { if (this.is_me) { // 对于用户玩家，加上监听函数 this.add_listening_events(); } } add_listening_events() { let outer = this; // 把鼠标右键调出菜单栏的功能关掉 this.playground.game_map.$canvas.on(\"contextmenu\", function() { return false; }); // 把右键控制移动功能加上 this.playground.game_map.$canvas.mousedown(function(e) { // 左键:1 中键:2 右键:3 if (e.which === 3) { outer.move_to(e.clientX, e.clientY); } }); } 然后，我们来实现移动功能的函数 move_to(tx, ty)\nconstructor(...){ ... this.vx = 0; // x方向上的移动速度 this.vy = 0; // y方向上的移动速度 this.move_length = 0; // 剩余移动距离 ... } ... get_dist (x1, y1, x2, y2) { // 求两点的欧几里得距离 let dx = x2 - x1; let dy = y2 - y1; return Math.sqrt(dx * dx + dy * dy); } move_to(tx, ty) { // 计算移动距离 this.move_length = this.get_dist(this.x, this.y, tx, ty); // 计算移动角度，api接口：atan2(dy, dx) let angle = Math.atan2(ty - this.y, tx - this.x); // 位移 1 个单位长度（向着矢量方向移动到单位圆上） this.vx = Math.cos(angle); // 极直互化 this.vy = Math.sin(angle); } update() { // 浮点数精度运算 if (this.move_length \u003c this.eps) { this.move_length = 0; this.vx = this.vy = 0; } else { // 计算单位帧里的移动距离 let moved = Math.min(this.move_length, this.speed * this.timedelta / 1000); this.x += this.vx * moved; this.y += this.vy * moved; // 还要减掉移动的距离 this.move_length -= moved; } this.render(); } ... 这样就实现了玩家的移动功能了，可以登录 id:socket 调试该功能\n实现火球技能的功能 火球对象的建立与玩家基本一致，直接照搬，在从细节上改改即可\njs/src/playground/skill/fireball/zbase.js\nclass FireBall extends AcGameObject { constructor(playground, player, x, y, radius, vx, vy, color, speed, move_length, damage) { super(); this.playground = playground; this.ctx = this.playground.game_map.ctx; this.player = player; this.x = x; this.y = y; this.vx = vx; this.vy = vy; this.radius = radius; this.color = color; this.speed = speed; this.move_length = move.length; this.damage = damage; this.eps = 0.1; } start() { } update() { if (this.move_length \u003c this.eps) { this.destroy(); return false; } else { let moved = Math.min(this.move_length, this.speed * this.timedelta / 1000); this.x += this.vx * moved; this.y += this.vy * moved; this.move_length -= moved; } this.render(); } render() { this.ctx.beginPath(); this.ctx.arc(this.x, this.y, this.radius, 0, 2 * Math * Pi, false); this.ctx.fillStyle = this.color; this.ctx.fill(); } } 然后在玩家身上实现发火球的功能\n基本实现逻辑：当前选中了火球技能，鼠标左键点击一处，向该处发射一个火球\n因此，为了知道用户是否选择了技能，需要加一个键盘触发事件监听函数，然后加一个鼠标左键触发事件监听函数\n然后发射一个火球即可\njs/src/playground/player/zbase.js\nconstructor(...) { ... this.cur_skill = null; // 记录当前选择的技能 ... } add_listening_events() { ... this.playground.game_map.$canvas.mousedown(function(e) { // 左键:1 中键:2 右键:3 if (e.which === 3) { outer.move_to(e.clientX, e.clientY); } else if (e.which === 1) { // 鼠标左键事件 if (outer.cur_skill === \"fireball\") { // 当前已经选中火球技能 outer.shoot_fireball(e.clientX, e.clientY); } } outer.cur_skill = null; // 清空当前技能 }); $(window).keydown(function(e) { if (e.which === 81) { // 键盘按下事件 outer.cur_skill = \"fireball\"; return false; } }); } shoot_fireball(tx, ty) { // 确定火球的参数 let x = this.x, y = this.y; // 火球发射点就是当前玩家的位置 let radius = this.playground.height * 0.01; let angle = Math.atan2(ty - this.y, tx - this.x); let vx = Math.cos(angle), vy = Math.sin(angle); let color = \"orange\"; let speed = this.playground.height * 0.5; let move_length = this.playground.height * 1.0; let damage = this.playground.height * 0.01; new FireBall(this.playground, this, x, y, radius, vx, vy, color, speed, move_length, damage); } 这样就成功实现了玩家发射火球的功能了\n实现单人模式下的人机功能 先创建好 5 个人机 playground/zbase.js\n... //创建好 5 个人机 for (len i = 0; i \u003c 5; i ++ ) { this.players.push(new Player(this, this.width / 2, this.height / 2, this.height * 0.05, \"blue\", this.height * 0.15, false)); } ... 这样创建出来的 5 个人机是不会行动的\n我们写一个简易的 AI 程序，让他们也会移动\n这里实现的逻辑是：每次随机一个目的地，向目的地移动，然后再随机一个目的地，循环下去\n根据该逻辑，修改两个函数即可\nplayground/player/zbase.js\n... start() { if (this.is_me) { // 对于用户玩家，加上监听函数 this.add_listening_events(); } else { let tx = Math.random() * this.playground.width; let ty = Math.random() * this.playground.height; this.move_to(tx, ty); } } ... update() { if (this.move_length \u003c this.eps) { this.move_length = 0; this.vx = this.vy = 0; if (!this.is_me) { // 如果是人机，停下来时再随机一个方向前进 let tx = Math.random() * this.playground.width; let ty = Math.random() * this.playground.height; this.move_to(tx, ty); } } ... } on_destroy() { for (let i = 0; i \u003c this.playground.players.length; i ++ ) { if (this.playground.players[i] === this) { this.playground.players.splice(i, 1); } } } 实现技能命中效果（碰撞检测功能） 实现逻辑：检测两个圆的中心距离是否小于两个圆的半径之和\n小于等于时，代表发生碰撞，开始执行命中效果：\n被击中用户掉血 被击中用户收到向后击退效果 碰撞检测写在火球类里，击退效果写在玩家类里\nfireball/zbase.js\nupdate() { if (...) { ... } else { ... // 碰撞检测 for (let i = 0; i \u003c this.playground.players.length; i ++ ) { let player = this.playground.players[i]; if (this.player !== player \u0026\u0026 this.is_collision(player)) { // 碰撞发生一定是在非施法者身上 this.attack(player); // 火球命中，目标玩家执行击退效果 } } } this.render(); } get_dist(x1, y1, x2, y2) { // 获得两点的欧几里得距离 let dx = x2 - x1; let dy = y2 - y1; return Math.sqrt(dx * dx + dy * dy); } is_collision(player) { // 检测两个圆的中心距离是否小于两个圆的半径之和 let distance = this.get_dist(this.x, this.y, player.x, player.y); if (distance \u003c (this.radius + player.radius)) return true; return false; } attack(player) { // 火球命中，目标玩家执行击退效果 let angle = Math.atan2(player.y - this.y, player.x - this.x); // 计算角度 player.is_attacked(angle, this.damage); // 火球命中，目标玩家执行击退效果 this.destroy(); // 火球命中后，自然消失 } 被击退的时候，原来的移动速度应该置为 0，当前的移动应该转为向被击中方向上的移动 player/zbase.js\nis_attacked(angle, damage) { this.radius -= damage; // 受伤，半径减少 if (this.radius \u003c 10) { // 当半径小于10像素时，代表死亡 this.destroy(); return false; } // 开始执行击退效果 this.damage_vx = Math.cos(angle); this.damage_vy = Math.sin(angle); this.damage_speed = damage * 100; this.speed *= 0.5; // 被击中以后移动速度减半 } update() { if (this.damage_speed \u003e this.eps) { // 当前仍处于击退效果中 this.vx = this.vy = 0; this.move_length = 0; this.x += this.damage_vx * this.damage_speed * this.timedelta / 1000; this.y += this.damage_vy * this.damage_speed * this.timedelta / 1000; this.damage_speed *= this.friction; // 击退速度乘以摩擦系数，已达到削减的目的 } else { ... } ... } 被击中以后的粒子效果特效 实现逻辑：被击中以后，在玩家附近随机生成一些粒子小球\n因此我们要先实现 粒子小球 对象\nstatic/js/src/playground/particle/zbase.js\nclass Particle extends AcGameObject { constructor(playground, x, y, radius, vx, vy, color, speed) { super(); this.playground = playground; this.ctx = this.playground.game_map.ctx; this.x = x; this.y = y; this.radius = radius; this.vx = vx; this.vy = vy; this.color = color; this.speed = speed; this.friction = 0.9; } start() { } update() { if (this.speed \u003c this.eps) { this.destroy; return false; } this.x += this.vx * this.speed * this.timedelta / 1000; this.y += this.vy * this.speed * this.timedelta / 1000; this.speed *= this.friction; this.render(); } render() { this.ctx.beginPath(); this.ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI, false); this.ctx.fillStyle = this.color; this.ctx.fill(); } } 然后我们在被击退功能模块，实现生成粒子小球的效果\n粒子小球释放弧度为 $[0,2π)$ 的随机数 粒子小球的 x, y 分量比率根据弧度来设定 粒子小球的起始坐标应与玩家的坐标相同 粒子小球的颜色与玩家颜色相同 粒子小球的速度为玩家移动速度的 $10$ 倍 js/src/playground/player/zbase.js\nis_attacked(angle, damage) { // 粒子小球效果 for (let i = 0; i \u003c 10 + Math.random() * 5; i ++ ) { let x = this.x, y = this.y; let radius = this.radius * Math.random() * 0.1; let angle = 2 * Math.PI * Math.random(); let vx = Math.cos(angle), vy = Math.sin(angle); let color = this.color; let speed = this.speed * 10; new Particle(this.playground, x, y, radius, vx, vy, color, speed); } ... } 一些小优化 人机随机颜色 js/src/playground/zbase.js\nconstructor(root) { ...... // 创建好 5 个人机 for (let i = 0; i \u003c 5; i ++ ) { this.players.push(new Player(this, this.width / 2, this.height / 2, this.height * 0.05, this.get_random_color(), this.height * 0.15, false)); } ...... } get_random_color() { let colors = [\"blue\", \"red\", \"pink\", \"grey\", \"green\"]; return colors[Math.floor(Math.random() * 5)]; } 人机AI随机攻击操作 js/src/playground/player/zbase.js\nconstructor (...) { ... this.spent_time = 0; // 初始人机冷却攻击时间 } ... update() { this.spent_time += this.timedelta / 1000; if (!this.is_me \u0026\u0026 this.spent_time \u003e 4 \u0026\u0026 Math.random() * 180 \u003c 1) { let player = this.playground.players[Math.floor(Math.random() * this.playground.players.length)]; this.shoot_fireball(player.x, player.y); } 部署nginx与对接acapp 5. 部署nginx与对接acapp | 讲义 5.1 上课笔记 | Andrew1729 5.1. 上课笔记 | 菊花 Ngnix 介绍 nginx 和uwsgi的区别与作用 Nginx是什么？ Nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器\nNginx可以作为一个HTTP服务器进行网站的发布处理，另外Nginx可以作为反向代理进行负载均衡的实现\nNginx中HttpUwsgiModule的作用是与uWSGI服务器进行交换\nuWSGI是什么？ uWSGI是一个全功能的HTTP服务器，实现了WSGI、uwsgi、http等协议\n它要做的就是把HTTP协议转化成语言支持的网络协议。比如把HTTP协议转化成WSGI协议，让Python可以直接使用\nWSGI协议是Python 语言定义的 Web 服务器和 Web 应用程序或框架之间的一种简单而通用的接口\n简单来说uWSGI就是用来沟通nginx和django的一座桥梁\nNginx+uWSGI+Diango 工作流程 nginx 是对外的服务接口，外部浏览器通过url访问nginx\nnginx 接收到浏览器发送过来的http请求，将包进行解析\n分析url，如果是静态文件请求就直接访问用户给nginx配置的静态文件目录，直接返回用户请求的静态文件\n如果不是静态文件，而是一个动态的请求，那么nginx就将请求转发给uwsgi，uwsgi 接收到请求之后将包进行处理，处理成wsgi可以接受的格式，并发给wsgi，wsgi 根据请求调用应用程序的某个文件，某个文件的某个函数，最后处理完将返回值再次交给wsgi，wsgi将返回值进行打包，打包成uwsgi能够接收的格式，uwsgi接收wsgi 发送的请求，并转发给nginx, nginx最终将返回值返回给浏览器\nuwsgi服务的开启\u0026\u0026关闭 在~/acapp启动uwsgi服务：uwsgi --ini scripts/uwsgi.ini 关闭uwsgi服务：sudo pkill -f uwsgi -9 针对 acapp 的优化 打包脚本优化 由于现在 发布版本的脚本文件 用的是打包在根目录里的 static 文件夹\n每次修改好 static 文件夹后，不仅需要对 js 文件打包，还需要对 static 文件夹打包\n不放把 “将static文件夹打包” 的 shell 代码一起加入 js 打包脚本中，从而实现一键打包\nscripts/compress_game_js.sh\n#! /bin/bash JS_PATH=/home/acs/acapp/game/static/js/ JS_PATH_DIST=${JS_PATH}dist/ JS_PATH_SRC=${JS_PATH}src/ find $JS_PATH_SRC -type f -name '*.js' | sort | xargs cat \u003e ${JS_PATH_DIST}game.js echo \"yes\" | python3 manage.py collectstatic 鼠标点击事件的相对偏移 由于写游戏界面的时候，玩家移动是按照鼠标相对于当前整个浏览器取的位置参数 e.clientX\n而 acapp 里，每个应用是一个小窗口，鼠标点击位置的参数应当是 相对于整个游戏窗口的位置参数\n所有会导致出现，点击的位置与移动的位置不同，这里需要做出小优化\n优化的逻辑 :\n$clientX−窗口左侧到浏览器左侧的距离=玩家的目标X$ $clientY−窗口上侧到浏览器上侧的距离=玩家的目标Y$ 这就要用到一个 js 的 API 了 : getBoundingClientRect() rectObject = object.getBoundingClientRect(); rectObject.top : 元素上边到视窗上边的距离; rectObject.right : 元素右边到视窗左边的距离; rectObject.bottom : 元素下边到视窗上边的距离; rectObject.left : 元素左边到视窗左边的距离; rectObject.width : 是元素自身的宽 rectObject.height : 是元素自身的高 player/zbase.js\n... add_listening_events() { ... this.playground.game_map.$canvas.mousedown(function(e) { // 创建 rect 对象 const rect = outer.ctx.canvas.getBoundingClientRect(); if (e.which === 3) { // 调整偏移量 outer.move_to(e.clientX - rect.left, e.clientY - rect.top); } else if (e.which === 1) { if (outer.cur_skill === \"fireball\") { // 调整偏移量 outer.shoot_fireball(e.clientX - rect.left, e.clientY - rect.top); } } ... }); ... } ... 将菜单界面重新设为主界面 js/zbase.js 的注释取消，使之创建出 menu 对象\njs/playground/zbase.js 的注释取消，并设置逻辑，让 playground 打开后，才进行游戏界面初始化\nclass AcGamePlayground { constructor(root) { this.root = root; this.$playground = $(``); this.hide(); // 初始时隐藏 // 游戏界面生成代码在下面展示 playground 时执行 this.start(); } ... show() { // 打开 playground 界面 this.$playground.show(); // 开始生成游戏界面 this.root.$ac_game.append(this.$playground); this.width = this.$playground.width(); this.height = this.$playground.height(); this.game_map = new GameMap(this); this.players = []; // 存放当前游戏中的所有玩家 // 将玩家加入游戏中 this.players.push(new Player(this, this.width / 2, this.height / 2, this.height * 0.05, \"white\", this.height * 0.15, true)); // 创建好 5 个人机 for (let i = 0; i \u003c 5; i ++ ) { this.players.push(new Player(this, this.width / 2, this.height / 2, this.height * 0.05, this.get_random_color(), this.height * 0.15, false)); } } ... } 调整 css 文件，适应窗口 在设置 web 网页的时候，有些设置了绝对值，可能对于窗口化的 acapp 显示效果差\n将他们修改成相对数值\ngame.css\n... .ac-game-menu-field { ... top: 40%; left: 20%; } .ac-game-menu-field-item { height: 6vh; ... font-size: 4vh; ... } ... ","wordCount":"8529","inLanguage":"en","datePublished":"2022-10-29T18:23:59+08:00","dateModified":"2022-10-29T18:23:59+08:00","author":[{"@type":"Person","name":"Xan"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://xancoding.cn/posts/acwdjango/"},"publisher":{"@type":"Organization","name":"Xan's Blog","logo":{"@type":"ImageObject","url":"https://xancoding.cn/img/favicon.ico"}}}</script><script src=https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css><script src=https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js></script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://xancoding.cn accesskey=h title="Xan's Blog (Alt + H)"><img src=https://xancoding.cn/img/Headshot.jpg alt aria-label=logo height=35>Xan's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://xancoding.cn/ title=Home><span>Home</span></a></li><li><a href=https://xancoding.cn/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://xancoding.cn/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://xancoding.cn/links/ title=Links><span>Links</span></a></li><li><a href=https://xancoding.cn/about/ title=About><span>About</span></a></li><li><a href=https://xancoding.cn/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://xancoding.cn>Home</a>&nbsp;»&nbsp;<a href=https://xancoding.cn/posts/>Posts</a></div><h1 class=post-title>AcWing Django 框架课</h1><div class=post-meta>&nbsp;<span title='2022-10-29 18:23:59 +0800 CST'>2022-10-29</span>&nbsp;|&nbsp;<a href=https://github.com/Xancoding/Blog/tree/main/content/posts/acwDjango.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#django-%e9%a1%b9%e7%9b%ae%e5%88%9b%e5%bb%ba aria-label="Django 项目创建">Django 项目创建</a><ul><li><a href=#%e5%90%af%e5%8a%a8%e5%88%9d%e5%a7%8b%e9%a1%b9%e7%9b%ae aria-label=启动初始项目>启动初始项目</a></li><li><a href=#%e5%88%9b%e5%bb%ba%e7%ae%a1%e7%90%86%e5%91%98%e7%99%bb%e5%bd%95%e9%a1%b5%e9%9d%a2 aria-label=创建管理员登录页面>创建管理员登录页面</a></li><li><a href=#%e5%88%9b%e5%bb%ba%e7%94%a8%e6%88%b7%e7%99%bb%e5%bd%95%e9%a1%b5%e9%9d%a2 aria-label=创建用户登录页面>创建用户登录页面</a><ul><li><a href=#game-%e4%b8%8b%e7%9a%84%e5%90%84%e4%b8%aa%e6%96%87%e4%bb%b6%e4%bd%9c%e7%94%a8 aria-label="game 下的各个文件作用"><code>game</code> 下的各个文件作用</a></li><li><a href=#%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%e8%b7%af%e7%94%b1%e9%87%8d%e5%ae%9a%e5%90%91 aria-label=实现一个路由重定向><strong>实现一个路由重定向</strong></a></li></ul></li></ul></li><li><a href=#%e5%88%9b%e5%bb%ba%e8%8f%9c%e5%8d%95%e7%95%8c%e9%9d%a2 aria-label=创建菜单界面>创建菜单界面</a><ul><li><a href=#%e6%9e%84%e5%bb%ba%e9%a1%b9%e7%9b%ae%e6%a1%86%e6%9e%b6 aria-label=构建项目框架>构建项目框架</a><ul><li><a href=#%e9%a1%b9%e7%9b%ae%e7%b3%bb%e7%bb%9f%e8%ae%be%e8%ae%a1 aria-label=项目系统设计>项目系统设计</a></li><li><a href=#%e9%a1%b9%e7%9b%ae%e6%96%87%e4%bb%b6%e7%bb%93%e6%9e%84 aria-label=项目文件结构>项目文件结构</a><ul><li><a href=#js-%e6%96%87%e4%bb%b6%e7%ae%a1%e7%90%86 aria-label="js 文件管理"><code>js</code> 文件管理</a></li><li><a href=#html-%e6%96%87%e4%bb%b6%e7%ae%a1%e7%90%86 aria-label="html 文件管理"><code>html</code> 文件管理</a></li><li><a href=#views-%e8%a7%86%e5%9b%be%e7%ae%a1%e7%90%86 aria-label="views 视图管理"><code>views</code> 视图管理</a></li><li><a href=#urls-%e8%b7%af%e7%94%b1%e7%ae%a1%e7%90%86 aria-label="urls 路由管理"><code>urls</code> 路由管理</a></li><li><a href=#%e7%bd%91%e9%a1%b5%e6%b8%b2%e6%9f%93%e6%b5%81%e7%a8%8b aria-label=网页渲染流程><strong>网页渲染流程</strong></a></li></ul></li><li><a href=#%e4%bf%ae%e6%94%b9%e5%85%a8%e5%b1%80%e9%85%8d%e7%bd%ae aria-label=修改全局配置>修改全局配置</a><ul><li><a href=#%e8%ae%be%e7%bd%ae%e6%97%b6%e5%8c%ba aria-label=设置时区>设置时区</a></li><li><a href=#%e6%b7%bb%e5%8a%a0%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6 aria-label=添加配置文件>添加配置文件</a></li></ul></li></ul></li><li><a href=#%e5%88%9b%e5%bb%ba%e8%8f%9c%e5%8d%95-menu-%e7%95%8c%e9%9d%a2 aria-label="创建菜单 menu 界面">创建菜单 <code>menu</code> 界面</a><ul><li><a href=#%e6%90%ad%e5%bb%ba%e8%8f%9c%e5%8d%95-menu-%e7%95%8c%e9%9d%a2%e7%9a%84%e6%a1%86%e6%9e%b6 aria-label="搭建菜单 menu 界面的框架">搭建菜单 <code>menu</code> 界面的框架</a></li><li><a href=#%e8%ae%be%e7%bd%ae%e8%8f%9c%e5%8d%95-menu-%e9%a1%b5%e9%9d%a2%e7%9a%84%e5%86%85%e5%ae%b9 aria-label="设置菜单 menu 页面的内容">设置菜单 <code>menu</code> 页面的内容</a></li><li><a href=#%e6%b7%bb%e5%8a%a0-%e5%8d%95%e4%ba%ba%e6%a8%a1%e5%bc%8f-%e7%9b%91%e5%90%ac%e5%87%bd%e6%95%b0--%e6%89%93%e5%bc%80%e6%b8%b8%e6%88%8f%e7%95%8c%e9%9d%a2-%e5%8a%9f%e8%83%bd aria-label="添加 &amp;lsquo;单人模式&amp;rsquo; 监听函数 —— 打开游戏界面 功能">添加 &lsquo;单人模式&rsquo; 监听函数 —— 打开游戏界面 功能</a></li></ul></li></ul></li><li><a href=#%e5%88%9b%e5%bb%ba%e6%b8%b8%e6%88%8f%e7%95%8c%e9%9d%a2 aria-label=创建游戏界面>创建游戏界面</a><ul><li><a href=#%e5%89%8d%e7%ab%af%e7%9a%84%e6%a8%a1%e5%9d%97%e5%8c%96%e5%bc%95%e5%85%a5 aria-label=前端的模块化引入>前端的模块化引入</a></li><li><a href=#%e6%9e%84%e5%bb%ba%e6%b8%b8%e6%88%8f%e7%95%8c%e9%9d%a2%e6%a1%86%e6%9e%b6 aria-label=构建游戏界面框架>构建游戏界面框架</a></li><li><a href=#%e5%ae%9e%e7%8e%b0%e6%b8%b8%e6%88%8f%e5%bc%95%e6%93%8e%e6%a1%86%e6%9e%b6 aria-label=实现游戏引擎框架><strong>实现游戏引擎框架</strong></a></li><li><a href=#%e5%ae%9e%e7%8e%b0%e6%b8%b8%e6%88%8f%e5%9c%b0%e5%9b%be%e5%8a%9f%e8%83%bd aria-label=实现游戏地图功能>实现游戏地图功能</a></li><li><a href=#%e5%ae%9e%e7%8e%b0%e7%8e%a9%e5%ae%b6%e6%98%be%e7%a4%ba%e5%8a%9f%e8%83%bd aria-label=实现玩家显示功能>实现玩家显示功能</a></li><li><a href=#%e5%ae%9e%e7%8e%b0%e7%8e%a9%e5%ae%b6%e7%a7%bb%e5%8a%a8%e5%8a%9f%e8%83%bd aria-label=实现玩家移动功能>实现玩家移动功能</a></li><li><a href=#%e5%ae%9e%e7%8e%b0%e7%81%ab%e7%90%83%e6%8a%80%e8%83%bd%e7%9a%84%e5%8a%9f%e8%83%bd aria-label=实现火球技能的功能>实现火球技能的功能</a></li><li><a href=#%e5%ae%9e%e7%8e%b0%e5%8d%95%e4%ba%ba%e6%a8%a1%e5%bc%8f%e4%b8%8b%e7%9a%84%e4%ba%ba%e6%9c%ba%e5%8a%9f%e8%83%bd aria-label=实现单人模式下的人机功能>实现单人模式下的人机功能</a></li><li><a href=#%e5%ae%9e%e7%8e%b0%e6%8a%80%e8%83%bd%e5%91%bd%e4%b8%ad%e6%95%88%e6%9e%9c%e7%a2%b0%e6%92%9e%e6%a3%80%e6%b5%8b%e5%8a%9f%e8%83%bd aria-label=实现技能命中效果（碰撞检测功能）>实现技能命中效果（碰撞检测功能）</a></li><li><a href=#%e8%a2%ab%e5%87%bb%e4%b8%ad%e4%bb%a5%e5%90%8e%e7%9a%84%e7%b2%92%e5%ad%90%e6%95%88%e6%9e%9c%e7%89%b9%e6%95%88 aria-label=被击中以后的粒子效果特效>被击中以后的粒子效果特效</a></li><li><a href=#%e4%b8%80%e4%ba%9b%e5%b0%8f%e4%bc%98%e5%8c%96 aria-label=一些小优化>一些小优化</a><ul><li><a href=#%e4%ba%ba%e6%9c%ba%e9%9a%8f%e6%9c%ba%e9%a2%9c%e8%89%b2 aria-label=人机随机颜色>人机随机颜色</a></li><li><a href=#%e4%ba%ba%e6%9c%baai%e9%9a%8f%e6%9c%ba%e6%94%bb%e5%87%bb%e6%93%8d%e4%bd%9c aria-label=人机AI随机攻击操作>人机AI随机攻击操作</a></li></ul></li></ul></li><li><a href=#%e9%83%a8%e7%bd%b2nginx%e4%b8%8e%e5%af%b9%e6%8e%a5acapp aria-label=部署nginx与对接acapp>部署nginx与对接acapp</a><ul><li><a href=#nginx%e6%98%af%e4%bb%80%e4%b9%88 aria-label=Nginx是什么？>Nginx是什么？</a></li><li><a href=#uwsgi%e6%98%af%e4%bb%80%e4%b9%88 aria-label=uWSGI是什么？>uWSGI是什么？</a></li><li><a href=#nginxuwsgidiango-%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b aria-label="Nginx+uWSGI+Diango 工作流程">Nginx+uWSGI+Diango 工作流程</a></li><li><a href=#uwsgi%e6%9c%8d%e5%8a%a1%e7%9a%84%e5%bc%80%e5%90%af%e5%85%b3%e9%97%ad aria-label=uwsgi服务的开启&amp;amp;&amp;amp;关闭>uwsgi服务的开启&&关闭</a></li><li><a href=#%e9%92%88%e5%af%b9-acapp-%e7%9a%84%e4%bc%98%e5%8c%96 aria-label="针对 acapp 的优化">针对 acapp 的优化</a><ul><li><a href=#%e6%89%93%e5%8c%85%e8%84%9a%e6%9c%ac%e4%bc%98%e5%8c%96 aria-label=打包脚本优化>打包脚本优化</a></li><li><a href=#%e9%bc%a0%e6%a0%87%e7%82%b9%e5%87%bb%e4%ba%8b%e4%bb%b6%e7%9a%84%e7%9b%b8%e5%af%b9%e5%81%8f%e7%a7%bb aria-label=鼠标点击事件的相对偏移>鼠标点击事件的相对偏移</a></li><li><a href=#%e5%b0%86%e8%8f%9c%e5%8d%95%e7%95%8c%e9%9d%a2%e9%87%8d%e6%96%b0%e8%ae%be%e4%b8%ba%e4%b8%bb%e7%95%8c%e9%9d%a2 aria-label=将菜单界面重新设为主界面>将菜单界面重新设为主界面</a></li><li><a href=#%e8%b0%83%e6%95%b4-css-%e6%96%87%e4%bb%b6%e9%80%82%e5%ba%94%e7%aa%97%e5%8f%a3 aria-label="调整 css 文件，适应窗口">调整 css 文件，适应窗口</a></li></ul></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><ul><li><a href=https://www.colopen-blog.com/Engineer/acw_django/>AcWing Django 框架课 | Colopen&rsquo;s blog</a></li><li><a href=https://www.acwing.com/activity/content/punch_the_clock/72/>AcWing Django 框架课</a></li></ul><hr><h1 id=django-项目创建>Django 项目创建<a hidden class=anchor aria-hidden=true href=#django-项目创建>#</a></h1><ul><li><a href=https://www.acwing.com/solution/content/72577/>2.1上课笔记 | 栎</a></li><li><a href=https://www.acwing.com/solution/content/73097/>2.1上课笔记 | Andrew1729</a></li></ul><hr><h2 id=启动初始项目>启动初始项目<a hidden class=anchor aria-hidden=true href=#启动初始项目>#</a></h2><ol><li><code>django-admin startproject acapp</code>：在当前目录下创建名为<code>acapp</code>的<code>django</code>项目</li><li><code>python3 manage.py runserver 0.0.0.0:8000</code>：启动项目<ol><li>打开<code>settings.py</code>，找到<code>ALLOWED_HOSTS=[]</code>，修改成<code>ALLOWED_HOSTS=["自己的服务器的公网IP"]</code></li><li>通过<code>自己的服务器公网IP:8000</code> 打开Django页面</li></ol></li></ol><h2 id=创建管理员登录页面>创建管理员登录页面<a hidden class=anchor aria-hidden=true href=#创建管理员登录页面>#</a></h2><ol><li>在一级<code>acapp</code>文件夹下，<code>python3 manage.py startapp XXX</code>，<code>XXX</code>是可以自定义的app名，这里用<code>game</code>示例，这时候会多一个文件夹<code>game</code>，树形结构如图：</li></ol><pre tabindex=0><code>|-- game
|   |-- __init__.py
|   |-- admin.py          # 管理员页面
|   |-- apps.py           # 用的不多
|   |-- migrations        # 存储数据库
|   |   `-- __init__.py
|   |-- models.py         # 定义网站里的数据库表
|   |-- tests.py
|   `-- views.py          # 视图，即函数
</code></pre><ol start=2><li><code>python3 manage.py migrate</code>：将所有修改更新进数据库</li><li>创建一个 <strong>管理员用户</strong>：</li></ol><pre tabindex=0><code>$ python3 manage.py createsuperuser
&gt; Username (leave blank to use &#39;acs&#39;): admin
&gt; Email address: 
&gt; Password: 123456
&gt; Password (again): 123456
&gt; Superuser created successfully.
</code></pre><p>然后利用该 <strong>管理员用户</strong> 登录 <code>admin</code> 页面，即可成功登陆</p><h2 id=创建用户登录页面>创建用户登录页面<a hidden class=anchor aria-hidden=true href=#创建用户登录页面>#</a></h2><h3 id=game-下的各个文件作用><code>game</code> 下的各个文件作用<a hidden class=anchor aria-hidden=true href=#game-下的各个文件作用>#</a></h3><ol><li><code>templates</code>目录：管理 <code>html</code> 文件</li><li><code>urls</code>目录：管理路由，即链接与函数的对应关系 (接收链接，调用相对应的函数)</li><li><code>views</code>目录：管理 <code>http</code> 函数（接收浏览器请求，返回字符串至浏览器）</li><li><code>models</code>目录：管理数据库数据</li><li><code>static</code>目录：管理静态文件</li><li><code>consumers</code>目录：管理<code>websocket</code>函数</li></ol><h3 id=实现一个路由重定向><strong>实现一个路由重定向</strong><a hidden class=anchor aria-hidden=true href=#实现一个路由重定向>#</a></h3><ul><li><code>url</code> 输入网址 -> <code>acapp.urls</code> -> <code>game.urls</code> -> <code>game.views.index</code> -> 展示页面</li></ul><p><strong>game.views</strong></p><p>这其中，<code>HttpResponse()</code>内部使用<code>html</code>的语法，返回的响应就直接用这个字符串作为页面，转换成<code>html</code></p><pre tabindex=0><code>from django.http import HttpResponse

def index(request):
    line1 = &#39;&lt;h1 style=&#34;text-align: center&#34;&gt; 第一个网页 &lt;/h1&gt;&#39;
    return HttpResponse(line1)
</code></pre><p><strong>game.urls</strong></p><p>这其中，<code>path('PATH', function, name)</code>的含义是，在用户访问网站的时候，如果是<code>网站/game/PATH</code>，就会调用<code>function</code>，名字为<code>name</code>，这是在<code>/game/</code>目录下的调用，所以这个<code>PATH</code>是在<code>/game/</code>的基础上的<strong>相对路径</strong>，所以他的<strong>绝对路径</strong>是<code>网站/game/PATH</code></p><pre tabindex=0><code>from django.urls import path
from game.views import index

urlpatterns = [ 
    path(&#34;&#34;, index, name=&#34;index&#34;),
]
</code></pre><p><strong>acapp.urls</strong></p><p>这其中，<code>path('PATH', include('game.urls'))</code>的含义是：在用户访问网站的时候，如果是<code>网站/PATH</code>，就会走到<code>/game/urls</code>，并根据<code>/game/urls.py</code>来跑路由，就是说，用户在访问<code>网站/</code>的时候，由于此时调用的函数是<code>include('game.urls')</code>，所以访问<code>网站/</code>相当于根据<code>game/urls</code>访问</p><pre tabindex=0><code>from django.contrib import admin
from django.urls import path, include

urlpatterns = [ 
    path(&#39;&#39;, include(&#39;game.urls&#39;)),
    path(&#39;admin/&#39;, admin.site.urls),
] 
</code></pre><p>然后直接打开 <code>ip:socket</code> 可以直接显示 <code>index</code> 返回的网页</p><h1 id=创建菜单界面>创建菜单界面<a hidden class=anchor aria-hidden=true href=#创建菜单界面>#</a></h1><ul><li><a href=https://www.acwing.com/file_system/file/content/whole/index/content/3199626/>3. 创建菜单界面 | 讲义</a></li><li><a href=https://www.acwing.com/solution/content/73121/>3.1 上课笔记 | 大家好今天是</a></li><li><a href=https://www.acwing.com/solution/content/73707/>3.1 上课笔记 | 栎</a></li></ul><hr><h2 id=构建项目框架>构建项目框架<a hidden class=anchor aria-hidden=true href=#构建项目框架>#</a></h2><h3 id=项目系统设计>项目系统设计<a hidden class=anchor aria-hidden=true href=#项目系统设计>#</a></h3><ul><li><code>menu</code>：菜单页面</li><li><code>playground</code>：游戏界面</li><li><code>settings</code>：设置界面</li></ul><h3 id=项目文件结构>项目文件结构<a hidden class=anchor aria-hidden=true href=#项目文件结构>#</a></h3><pre tabindex=0><code>.
|-- README.md
|-- acapp
|   |-- __init__.py    # 文件夹在加上 __init__.py 文件后，python 便可以通过 import 来引用该文件夹
|   |-- asgi.py
|   |-- settings.py
|   |-- urls.py
|   `-- wsgi.py
|-- db.sqlite3
|-- game
|   |-- __init__.py
|   |-- admin.py
|   |-- apps.py
|   |-- migrations
|   |   `-- __init__.py
|   |-- models
|   |   `-- __init__.py
|   |-- static
|   |   |-- css
|   |   |   `-- game.css    # 一般一个工程，只有一个 css 文件就足够了
|   |   |-- image
|   |   |   `-- menu
|   |   |       `-- background.gif
|   |   `-- js
|   |       |-- dist
|   |       |   `-- game.js
|   |       `-- src
|   |           `-- zbase.js    # 总的 js 文件，命名以 z 开头会自动在字典序最后
|   |-- templates
|   |   `-- multiends
|   |       `-- web.html
|   |-- tests.py
|   |-- urls
|   |   |-- __init__.py
|   |   |-- index.py
|   |   |-- menu
|   |   |   |-- __init__.py
|   |   |   `-- index.py
|   |   |-- playground
|   |   |   |-- __init__.py
|   |   |   `-- index.py
|   |   `-- settings
|   |       |-- __init__.py
|   |       `-- index.py
|   `-- views
|       |-- __init__.py
|       |-- index.py
|       |-- menu
|       |   `-- __init__.py
|       |-- playground
|       |   `-- __init__.py
|       `-- settings
|           `-- __init__.py
|-- manage.py
`-- scripts
    `-- compress_game_js.sh
</code></pre><h4 id=js-文件管理><code>js</code> 文件管理<a hidden class=anchor aria-hidden=true href=#js-文件管理>#</a></h4><p>一般一个工程会有很多个 <code>.js</code> 源文件，为了加快网络的传输，也为了每次写新的 <code>.js</code> 文件不用每个 <code>html</code> 都额外引入一次</p><p>考虑用一个 <code>src</code> 源文件夹来存储所有的 <code>.js</code> 源文件</p><p>然后用 <code>dist</code> 文件夹来存放由 <code>src</code> 下所有源文件整合生成的一个目标 <code>.js</code> 文件</p><p>这样既实现了快速传输的好处，也方便了后续编写 <code>html</code> 文件时，引入 <code>.js</code> 的便利</p><p>创建一个脚本实现上述 <strong>整合</strong> 的功能
<code>~/acapp/scripts/compress_game_js.sh</code></p><pre tabindex=0><code>#! /bin/bash

JS_PATH=/home/acs/acapp/game/static/js/
JS_PATH_DIST=${JS_PATH}dist/
JS_PATH_SRC=${JS_PATH}src/

find $JS_PATH_SRC -type f -name &#39;*.js&#39; | sort | xargs cat &gt; ${JS_PATH_DIST}game.js
</code></pre><h4 id=html-文件管理><code>html</code> 文件管理<a hidden class=anchor aria-hidden=true href=#html-文件管理>#</a></h4><p>在 <code>templates</code> 文件夹下创建 <code>menu</code>、<code>playground</code>、<code>settings</code>、<code>multiends</code> 四个文件夹，用于存储三个模块和终端的 <code>html</code> 文件</p><p>在 <code>multiends</code> 下创建 <code>web.html</code> 文件</p><pre tabindex=0><code>{% load static %}
&lt;!-- Django 中引入全局setting里的变量 static 的语法--&gt;
&lt;head&gt;
    &lt;link rel=&#34;stylesheet&#34; href=&#34;https://cdn.acwing.com/static/jquery-ui-dist/jquery-ui.min.css&#34;&gt;
    &lt;script src=&#34;https://cdn.acwing.com/static/jquery/js/jquery-3.3.1.min.js&#34;&gt;&lt;/script&gt;
    &lt;!-- 上述两句引入 jQuery 库 --&gt;
    &lt;!-- 使用引入的变量 static 的语法如下 --&gt;
    &lt;link rel=&#34;stylesheet&#34; href=&#34;{% static &#39;css/game.css&#39; %}&#34;&gt;
    &lt;script src=&#34;{% static &#39;js/dist/game.js&#39; %}&#34;&gt;&lt;/script&gt;
    &lt;!-- 分别引入 css 文件和总的 js 文件 --&gt;
&lt;/head&gt;

&lt;body style=&#34;margin: 0&#34;&gt;
    &lt;div id=&#34;ac_game_12345678&#34;&gt;&lt;/div&gt;
    &lt;script&gt;
        $(document).ready(function(){
            let ac_game = new AcGame(&#34;ac_game_12345678&#34;)
        })
    &lt;/script&gt;
&lt;/body&gt;
</code></pre><h4 id=views-视图管理><code>views</code> 视图管理<a hidden class=anchor aria-hidden=true href=#views-视图管理>#</a></h4><p>在 <code>views</code> 文件夹下新建三个模块的视图文件夹</p><p>写一个 <code>index.py</code> 文件，目的是在 <code>web</code> 端被访问时，返回上面写的 <code>web.html</code> 文件</p><pre tabindex=0><code>from django.shortcuts import render

def index(request):
  return render(request, &#34;multiends/web.html&#34;)
</code></pre><h4 id=urls-路由管理><code>urls</code> 路由管理<a hidden class=anchor aria-hidden=true href=#urls-路由管理>#</a></h4><pre tabindex=0><code>                                     /-- &#34;&#34; -- index
                                    / -- &#34;menu/&#34; -- menu.index
             / &#34;&#34; --&gt; &#34;game.url&#34; --&gt; 
            /                       \ -- &#34;playground/&#34; -- playground.index
id:scoket -&gt;                         \-- &#34;settings/&#34; -- settings.index
            \
             \ &#34;/admin&#34; -- 到达管理员页面
</code></pre><p><code>~/acapp/acapp/urls.py</code></p><pre tabindex=0><code>from django.contrib import admin
from django.urls import path, include

urlpatterns = [
  path(&#39;&#39;, include(&#39;game.urls.index&#39;)),
  path(&#39;admin/&#39;, admin.site.urls),
]
</code></pre><p><code>~/acapp/game/urls/index.py</code></p><pre tabindex=0><code>from django.urls import path, include
from game.views.index import index

urlpatterns = [ 
    path(&#34;&#34;, index, name=&#34;index&#34;),
    path(&#34;menu/&#34;, include(&#34;game.urls.menu.index&#34;)),
    path(&#34;playground/&#34;, include(&#34;game.urls.playground.index&#34;)),
    path(&#34;settings/&#34;, include(&#34;game.urls.settings.index&#34;))
]
</code></pre><h4 id=网页渲染流程><strong>网页渲染流程</strong><a hidden class=anchor aria-hidden=true href=#网页渲染流程>#</a></h4><p>根据用户的链接，首先进入<code>acapp/urls.py</code>，根据<code>path</code>再进入<code>game/urls/index.py</code>，再根据<code>path</code>进入下一层<code>url</code>或调用相对应的<code>views</code>中的<code>index.py</code>函数，函数接收参数，在网页端渲染<code>templates/multiends</code>下的<code>web.html</code>，<code>html</code>中有<code>JS</code>执行</p><p>注意：本项目为前后端分离，即通过<code>JS</code>在<code>client</code>中渲染项目(动态生成页面)，而不是在<code>server</code>渲染项目</p><h3 id=修改全局配置>修改全局配置<a hidden class=anchor aria-hidden=true href=#修改全局配置>#</a></h3><h4 id=设置时区>设置时区<a hidden class=anchor aria-hidden=true href=#设置时区>#</a></h4><p>修改项目的 <strong>UTC</strong> 时间为 <strong>CN</strong> 时间</p><pre tabindex=0><code>$ vim /acapp/settings.py

******
TIME_ZONE = &#39;Asia/Shanghai&#39; # 原来默认是 UTC
******
</code></pre><h4 id=添加配置文件>添加配置文件<a hidden class=anchor aria-hidden=true href=#添加配置文件>#</a></h4><p>将新创建的 <code>game</code> 下的 <code>apps.py</code> 中的 <code>GameConfig</code> 加到 <code>settings.py</code> 下</p><pre tabindex=0><code>$ vim /acapp/settings.py

******
INSTALLED_APPS = [
  &#39;game.apps.GameConfig&#39;,
  ......
]
******
</code></pre><p>声明将静态文件路径 <code>STATIC_ROOT</code> 和 <code>MEDIA_ROOT</code></p><pre tabindex=0><code>$ vim /acapp/settings.py

******
import os

......

STATIC_ROOT = os.path.join(BASE_DIR, &#39;static&#39;)
STATIC_URL = &#39;/static/&#39;

MEDIA_ROOT = os.path.join(BASE_DIR, &#39;media&#39;)
MEDIA_URL = &#39;/media/&#39;
******
</code></pre><h2 id=创建菜单-menu-界面>创建菜单 <code>menu</code> 界面<a hidden class=anchor aria-hidden=true href=#创建菜单-menu-界面>#</a></h2><h3 id=搭建菜单-menu-界面的框架>搭建菜单 <code>menu</code> 界面的框架<a hidden class=anchor aria-hidden=true href=#搭建菜单-menu-界面的框架>#</a></h3><p>我们采用的 <strong>前后端分离式</strong> 开发，所有的 <strong>html</strong> 渲染都要求在前端完成</p><p>开发流程就是，先在 <strong>html</strong> 里创建好一个有 <strong>id</strong> 的 <strong>div</strong></p><p>然后利用 <strong>js</strong> 文件，捕获到该 <strong>div</strong>，并进行 <strong>渲染</strong></p><p><code>/templates/multiends/web.html</code></p><pre tabindex=0><code>...
    &lt;div id=&#34;ac_game_12345678&#34;&gt;&lt;/div&gt;
    &lt;script&gt;
        $(document).ready(function(){
            let ac_game = new AcGame(&#34;ac_game_12345678&#34;)
        })
    &lt;/script&gt;
...
</code></pre><p><code>js/src/zbase.js</code></p><pre tabindex=0><code>class AcGame {
    constructor(id) {
        this.id = id; 
        this.$ac_game = $(&#39;#&#39; + id);
        this.menu = new AcGameMenu(this);
    }   
}
</code></pre><p><code>js/src/menu/zbase.js</code></p><pre tabindex=0><code>class AcGameMenu {
    constructor(root) {
        this.root = root;
        this.$menu = $(` 
&lt;div class=&#34;ac-game-menu&#34;&gt;
&lt;/div&gt;
`);
        this.root.$ac_game.append(this.$menu); 
}
</code></pre><p><code>css/game.css</code></p><pre tabindex=0><code>.ac-game-menu {
    width: 100%;
    height: 100%;
    background-image: url(&#39;/static/image/menu/background.gif&#39;);
    background-size: 100% 100%;
    user-select: none;
}
</code></pre><p>这里的 <strong>代码逻辑</strong> 如下：</p><ol><li><code>html</code> 页面执行到 <code>js</code> 代码，利用 <code>AcGame类</code> 创建对象 <code>ac_game</code> 同时传递参数 <code>div</code> 的 <code>id</code></li><li><code>AcGame</code> 开始执行构造函数，在构造函数中，捕获 <code>html</code> 标签，并利用 <code>AcGameMenu类</code> 创建对象 <code>menu</code>，并将整个对象作为参数下传</li><li><code>AcGameMenu</code> 开始执行构造函数，然后创建 <code>html</code> 代码，加到捕获到的 <code>html</code> 代码下</li><li>最终成功渲染出背景图片</li></ol><h3 id=设置菜单-menu-页面的内容>设置菜单 <code>menu</code> 页面的内容<a hidden class=anchor aria-hidden=true href=#设置菜单-menu-页面的内容>#</a></h3><p>主要内容就是在主页面中，显示：单人模式、多人模式、设置，三个按钮的选项
<code>js/src/menu/zbase.js</code></p><pre tabindex=0><code>class AcGameMenu {
    constructor(root) {
        this.root = root;
        this.$menu = $(`
&lt;div class=&#34;ac-game-menu&#34;&gt;
    &lt;div class=&#34;ac-game-menu-field&#34;&gt;
        &lt;div class=&#34;ac-game-menu-field-item ac-game-menu-field-item-single-mode&#34;&gt;
            单人模式
        &lt;/div&gt;
        &lt;div class=&#34;ac-game-menu-field-item ac-game-menu-field-item-multi-mode&#34;&gt;
            多人模式
        &lt;/div&gt;
        &lt;div class=&#34;ac-game-menu-field-item ac-game-menu-field-item-settings-mode&#34;&gt;
            设置
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
`);
        this.root.$ac_game.append(this.$menu);
        this.$single_mode = this.$menu.find(&#39;.ac-game-menu-field-item-single-mode&#39;);
        this.$multi_mode = this.$menu.find(&#39;.ac-game-menu-field-item-multi-mode&#39;);
        this.$settings_mode = this.$menu.find(&#39;.ac-game-menu-field-item-settings-mode&#39;);
    }
}
</code></pre><p><code>css/game.css</code></p><pre tabindex=0><code>.ac-game-menu {
    width: 100%;
    height: 100%;
    background-image: url(&#39;/static/image/menu/background.gif&#39;);
    background-size: 100% 100%;
    user-select: none;
}
.ac-game-menu-field {
    width: 20vw;
    position: relative;
    top: 40vh;
    left: 19vh;
}
.ac-game-menu-field-item {
    height: 7vh;
    width: 18vw;
    color: white;
    font-size: 6vh;
    font-style: italic;
    padding: 2vh;
    margin: 1vh 0;
    cursor: pointer;
    text-align: center;
    background-color: rgba(39, 21, 28, 0.6);
    border-radius: 10px;
    letter-spacing: 0.5vw;
}
.ac-game-menu-field-item:hover {
    transform: scale(1.2);
    transition: 100ms;
}
</code></pre><h3 id=添加-单人模式-监听函数--打开游戏界面-功能>添加 &lsquo;单人模式&rsquo; 监听函数 —— 打开游戏界面 功能<a hidden class=anchor aria-hidden=true href=#添加-单人模式-监听函数--打开游戏界面-功能>#</a></h3><p>这里要实现的 <strong>逻辑</strong>：</p><ol><li>点击 &lsquo;单人模式&rsquo; 按钮触发 <code>click</code> 事件，随即触发监听函数，开始执行</li><li>关闭 <code>menu</code> 页面</li><li>打开 <code>playground</code> 页面</li></ol><p>因此，我们先简易的实现一个 <code>playground</code> 页面，方便调试该功能
<code>js/src/playground/zbase.js</code></p><pre tabindex=0><code>class AcGamePlayground {
    constructor(root) {
        this.root = root;
        this.$playground = $(`&lt;div&gt;游戏界面&lt;/div&gt;`);

        this.hide();
        this.root.$ac_game.append(this.$playground);

        this.start();
    }
    start() {

    }
    show() {    //打开 playground 界面
        this.$playground.show();
    }
    hide() {    //关闭 playground 界面
        this.$playground.hide();
    }

}
</code></pre><p>在实现监听函数功能之前，先在 <code>/src/zbase.js</code> 即主 <code>js</code> 文件下，利用 <code>AcGamePlayground</code> 类创建好 <code>playground</code> 对象</p><p>这样我们就能在前端，渲染出两个界面了，分别是：<code>menu</code> 和 <code>playground</code></p><p><code>js/src/zbase.js</code></p><pre tabindex=0><code>class AcGame {
    constructor(id) {
        this.id = id;
        this.$ac_game = $(&#39;#&#39; + id);
        this.menu = new AcGameMenu(this);
        // 把 playground 对象也建好，这样我们就同时有两个界面了
        this.playground = new AcGamePlayground(this);

        this.start();
    }                    
    start() {

    }
}
</code></pre><p>然后，我们开始实现 <code>ac-game-menu-field-item-single-mode</code> 标签的 <code>click</code> 事件的监听函数</p><p>其功能之前讲过了，就是关闭 <code>menu</code> 页面，打开 <code>playground</code> 页面</p><p><code>js/src/menu/zbase.js</code></p><pre tabindex=0><code>class AcGameMenu {
    constructor(root) {
        this.root = root;
        this.$menu = $(`
&lt;div class=&#34;ac-game-menu&#34;&gt;
    &lt;div class=&#34;ac-game-menu-field&#34;&gt;
        &lt;div class=&#34;ac-game-menu-field-item ac-game-menu-field-item-single-mode&#34;&gt;
            单人模式
        &lt;/div&gt;
        &lt;div class=&#34;ac-game-menu-field-item ac-game-menu-field-item-multi-mode&#34;&gt;
            多人模式
        &lt;/div&gt;
        &lt;div class=&#34;ac-game-menu-field-item ac-game-menu-field-item-settings-mode&#34;&gt;
            设置
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
`);
        this.root.$ac_game.append(this.$menu);
        this.$single_mode = this.$menu.find(&#39;.ac-game-menu-field-item-single-mode&#39;);
        this.$multi_mode = this.$menu.find(&#39;.ac-game-menu-field-item-multi-mode&#39;);
        this.$settings_mode = this.$menu.find(&#39;.ac-game-menu-field-item-settings-mode&#39;);

        this.start();
    }
    start() {
        this.add_listening_events();
    }
    add_listening_events() {
        let outer = this;
        this.$single_mode.click(function(){
            outer.hide();   // 关闭主页面
            outer.root.playground.show();   // 打开游戏界面
        });
    }

    show() {    //显示menu界面
        this.$menu.show();
    }
    hide() {    //隐藏menu界面
        this.$menu.hide();
    }
}
</code></pre><h1 id=创建游戏界面>创建游戏界面<a hidden class=anchor aria-hidden=true href=#创建游戏界面>#</a></h1><ul><li><a href=https://www.acwing.com/solution/content/79181/>4.1 上课笔记 | Andrew1729</a></li></ul><hr><blockquote><p><strong>若修改<code>static文件夹</code>下的相关文件，需在<code>~/acapp</code>下执行<code>./scripts/compress_game_js.sh</code>来打包文件</strong></p></blockquote><h2 id=前端的模块化引入>前端的模块化引入<a hidden class=anchor aria-hidden=true href=#前端的模块化引入>#</a></h2><p>由于在 <code>html</code> 代码部分，是将整个 <code>game.js</code> 文件引入</p><p>这样会导致在 <code>game.js</code> 中定义的变量，会变成整个网页的 <strong>全局变量</strong>（之后可能会引起变量重名的诸多问题）</p><p>因此，我们考虑使用 <strong>模块化引入</strong> 的功能，让网页只引入在 <code>html</code> 中需要的部分</p><p>修改 <code>web.html</code></p><pre tabindex=0><code>&lt;!-- 首先，先删掉上面整个引入 game.js 的部分 --&gt;
&lt;!-- 然后，下方创建对象的部分，先使用模块化引入 --&gt;
......
    &lt;script type=&#34;module&#34;&gt;
        import {AcGame} from &#34;{% static &#39;js/dist/game.js&#39; %}&#34;
        $(document).ready(function(){
            let ac_game = new AcGame(&#34;ac_game_12345678&#34;)
        })
    &lt;/script&gt;
......
</code></pre><p>此外，还有修改引入的类，在前面加上 <code>export</code>，如下修改 <code>js/src/zbase.js</code></p><pre tabindex=0><code>export class AcGame {
    ......
}
</code></pre><p>这样，在全局中，只会出现引入的模块，其他的 <code>.js</code> 代码不会出现在全局中</p><h2 id=构建游戏界面框架>构建游戏界面框架<a hidden class=anchor aria-hidden=true href=#构建游戏界面框架>#</a></h2><p><code>static/js/src/playground/zbase.js</code></p><pre tabindex=0><code>......
    this.$playground = $(`&lt;div class=&#34;ac-game-playground&#34;&gt;&lt;/div&gt;`);
......
</code></pre><p><code>game.css</code></p><pre tabindex=0><code>......
.ac-game-playground {
    height: 100%;
    width: 100%;
    user-select: none;  // 禁用右键弹菜单
} 
</code></pre><h2 id=实现游戏引擎框架><strong>实现游戏引擎框架</strong><a hidden class=anchor aria-hidden=true href=#实现游戏引擎框架>#</a></h2><p>游戏中，物体在移动，其实现原理是：每一个动作都会渲染多张图片出来，然后图片快速的切换，从而实现动的过程</p><p>因此，需要先实现一个游戏引擎的基类 <code>AcGameObject</code> ，使得每帧能渲染一张图片出来</p><p>该基类需要具备的功能有：</p><ol><li><code>start()</code> 在游戏开始的第一帧时需要执行的任务（一般是创建对象）</li><li><code>update()</code> 在游戏开始后的每一帧均会执行的任务（一般是渲染当前对象的各种状态）</li><li><code>on_destroy()</code> 删掉该物体前需要执行的任务（一般是删掉动画，或者给对手加分）</li><li><code>destroy()</code> 删掉该物体</li></ol><p>根据上述逻辑，我们就可以基本搭建出来一个游戏引擎的基类了，具体如下：
<code>/static/js/playground/ac_game_object/zbase.js</code></p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#fff;font-weight:700>let</span> AC_GAME_OBJECTS = [];   <span style=color:#007f7f>// 用于记录当前画布中，需要渲染的对象有哪些
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>class</span> AcGameObject {
</span></span><span style=display:flex><span>    constructor() {
</span></span><span style=display:flex><span>        AC_GAME_OBJECTS.push(<span style=color:#fff;font-weight:700>this</span>);  <span style=color:#007f7f>// 将当前新建的对象，加入到全局的画布中去，参与渲染
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.has_called_start = <span style=color:#fff;font-weight:700>false</span>;  <span style=color:#007f7f>// 是否执行过 start 函数
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>        <span style=color:#fff;font-weight:700>this</span>.timedelta = <span style=color:#ff0;font-weight:700>0</span>;             <span style=color:#007f7f>// 当前帧距离上一帧的时间间隔
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>        <span style=color:#007f7f>// 该数据记录是为了后续计算速度等参数的
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    }
</span></span><span style=display:flex><span>    start() {   <span style=color:#007f7f>// 只会在第一帧执行一次
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    update() {  <span style=color:#007f7f>// 每一帧均会执行一次
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    on_destroy() {  <span style=color:#007f7f>// 在被销毁前执行一次
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    destroy() { <span style=color:#007f7f>// 删掉该物体
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>        <span style=color:#fff;font-weight:700>this</span>.on_destroy();  <span style=color:#007f7f>//删掉该物体前，执行删前的操作
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span>        <span style=color:#007f7f>// 在全局渲染物体中，找到该物体，并将其删掉
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>        <span style=color:#fff;font-weight:700>for</span> (<span style=color:#fff;font-weight:700>let</span> i = <span style=color:#ff0;font-weight:700>0</span>; i &lt; AC_GAME_OBJECTS.length; i ++ ) {
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>if</span> (AC_GAME_OBJECTS[i] === <span style=color:#fff;font-weight:700>this</span>) {  <span style=color:#007f7f>// 三等号，在js里额外加了一层类型相等约束
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>                AC_GAME_OBJECTS.splice(i, <span style=color:#ff0;font-weight:700>1</span>);
</span></span><span style=display:flex><span>                <span style=color:#fff;font-weight:700>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>let</span> last_timestamp;
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>let</span> AC_GAME_ANIMATION = <span style=color:#fff;font-weight:700>function</span>(timestamp) {  <span style=color:#007f7f>// 回调函数，实现：每一帧重绘时，都会执行一遍
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>for</span> (<span style=color:#fff;font-weight:700>let</span> i = <span style=color:#ff0;font-weight:700>0</span>; i &lt; AC_GAME_OBJECTS.length; i ++ ) {
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>let</span> obj = AC_GAME_OBJECTS[i];
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>if</span> (!obj.has_called_start) { <span style=color:#007f7f>// 如果还未执行初始帧动作，就先执行
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>            obj.start();
</span></span><span style=display:flex><span>            obj.has_called_start = <span style=color:#fff;font-weight:700>true</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>else</span> {  <span style=color:#007f7f>// 执行过初始帧，就执行每一帧的任务
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>            obj.timedelta = timestamp - last_timestamp;
</span></span><span style=display:flex><span>            obj.update();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    last_timestamp = timestamp; <span style=color:#007f7f>// 更新最后一次时间戳
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    requestAnimationFrame(AC_GAME_ANIMATION);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>requestAnimationFrame(AC_GAME_ANIMATION);   <span style=color:#007f7f>// JS的API，可以调用1帧里面的函数。(有些浏览器的一秒帧数不一定相等)
</span></span></span></code></pre></div><blockquote><p><strong>接下来所有的一切游戏，都是基于这个引擎的基类完成的</strong></p></blockquote><h2 id=实现游戏地图功能>实现游戏地图功能<a hidden class=anchor aria-hidden=true href=#实现游戏地图功能>#</a></h2><p>目标：实现一个每一秒都在渲染的纯黑背景</p><p>虽然现阶段要实现的地图较为简单，但为了后期的拓展性，故还是考虑新建一个文件夹来完成</p><p>然后在 <code>js</code> 中，已经封装好了一个 <code>canvas</code> 的 <code>api</code> 来帮助实现背景画布，直接调用即可</p><p>先铺开画布，然后设置为黑色</p><p><code>static/js/playground/zbase.js</code></p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#fff;font-weight:700>class</span> AcGamePlayground {
</span></span><span style=display:flex><span>    constructor(root) {
</span></span><span style=display:flex><span>        ......
</span></span><span style=display:flex><span>        <span style=color:#007f7f>// $(&#39;.playground&#39;)对象已经在 css 文件里渲染出高宽了
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>        <span style=color:#007f7f>// 现在把他的高宽存下来，往下传递
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>        <span style=color:#fff;font-weight:700>this</span>.width = <span style=color:#fff;font-weight:700>this</span>.$playground.width();
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.height = <span style=color:#fff;font-weight:700>this</span>.$playground.height();
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.game_map = <span style=color:#fff;font-weight:700>new</span> GameMap(<span style=color:#fff;font-weight:700>this</span>);
</span></span><span style=display:flex><span>        ......
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    .....
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>static/js/playground/game-map/zbase.js</code></p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#fff;font-weight:700>class</span> GameMap <span style=color:#fff;font-weight:700>extends</span> AcGameObject {    <span style=color:#007f7f>// 继承自游戏引擎基类
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    constructor(playground) {
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>super</span>();    <span style=color:#007f7f>// 自函数功能：调用基类的构造函数
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>        <span style=color:#fff;font-weight:700>this</span>.playground = playground;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.$canvas = $(<span style=color:#0ff;font-weight:700>`&lt;canvas&gt;&lt;/canvas&gt;`</span>); <span style=color:#007f7f>// 创建一个canvas的jQuery对象，就是我们要实现的画布
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>        <span style=color:#fff;font-weight:700>this</span>.ctx = <span style=color:#fff;font-weight:700>this</span>.$canvas[<span style=color:#ff0;font-weight:700>0</span>].getContext(<span style=color:#0ff;font-weight:700>&#39;2d&#39;</span>); <span style=color:#007f7f>// jQuery对象是一个数组，第一个索引是html对象
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>        <span style=color:#007f7f>// 设置画布的宽高
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>        <span style=color:#fff;font-weight:700>this</span>.ctx.canvas.width = <span style=color:#fff;font-weight:700>this</span>.playground.width;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.ctx.canvas.height = <span style=color:#fff;font-weight:700>this</span>.playground.height;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.playground.$playground.append(<span style=color:#fff;font-weight:700>this</span>.$canvas);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    start() {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    update() {  <span style=color:#007f7f>// 游戏地图每帧都要渲染
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>        <span style=color:#fff;font-weight:700>this</span>.render();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    render() {
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.ctx.fillStyle = <span style=color:#0ff;font-weight:700>&#34;rgba(0, 0, 0, 0.2)&#34;</span>;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.ctx.fillRect(<span style=color:#ff0;font-weight:700>0</span>, <span style=color:#ff0;font-weight:700>0</span>, <span style=color:#fff;font-weight:700>this</span>.ctx.canvas.width, <span style=color:#fff;font-weight:700>this</span>.ctx.canvas.height);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span> }
</span></span></code></pre></div><h2 id=实现玩家显示功能>实现玩家显示功能<a hidden class=anchor aria-hidden=true href=#实现玩家显示功能>#</a></h2><p>毛坯版玩家显示，每个玩家定义成一个圆，然后渲染在前端</p><p>需要对于玩家类定义多个参数，以方便日后拓展：</p><ol><li><code>x</code> 当前位置的横坐标</li><li><code>y</code> 当前位置的纵坐标</li><li><code>radius</code> 当前的半径</li><li><code>speed</code> 当前的速度</li><li><code>is_me</code> 该对象是否是当前玩家操控的对象（一是区别于 bot，二是区别于 日后联机的其他玩家）</li></ol><p><code>static/js/playground/zbase.js</code></p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#fff;font-weight:700>class</span> AcGamePlayground {
</span></span><span style=display:flex><span>    constructor(root) {
</span></span><span style=display:flex><span>        ......
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.players = [];  <span style=color:#007f7f>// 存放当前游戏中的所有玩家
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>        <span style=color:#007f7f>// 将玩家加入游戏中
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>        <span style=color:#fff;font-weight:700>this</span>.players.push(<span style=color:#fff;font-weight:700>new</span> Player(<span style=color:#fff;font-weight:700>this</span>, <span style=color:#fff;font-weight:700>this</span>.width / <span style=color:#ff0;font-weight:700>2</span>, <span style=color:#fff;font-weight:700>this</span>.height / <span style=color:#ff0;font-weight:700>2</span>, <span style=color:#fff;font-weight:700>this</span>.height * <span style=color:#ff0;font-weight:700>0.05</span>, <span style=color:#0ff;font-weight:700>&#34;white&#34;</span>, <span style=color:#fff;font-weight:700>this</span>.height * <span style=color:#ff0;font-weight:700>0.15</span>, <span style=color:#fff;font-weight:700>true</span>));
</span></span><span style=display:flex><span>        ......
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    .....
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>static/js/playground/player/zbase.js</code></p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#fff;font-weight:700>class</span> Player <span style=color:#fff;font-weight:700>extends</span> AcGameObject {
</span></span><span style=display:flex><span>    constructor(playground, x, y, radius, color, speed, is_me) {
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>super</span>();
</span></span><span style=display:flex><span>        <span style=color:#007f7f>// 把信息都存下来
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>        <span style=color:#fff;font-weight:700>this</span>.playground = playground;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.ctx = <span style=color:#fff;font-weight:700>this</span>.playground.game_map.ctx;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.x = x;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.y = y;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.color = color;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.speed = speed;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.radius = radius;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.is_me = is_me;
</span></span><span style=display:flex><span>        <span style=color:#007f7f>// 用于浮点数运算
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>        <span style=color:#fff;font-weight:700>this</span>.eps = <span style=color:#ff0;font-weight:700>0.1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    start() {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    update() {
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.render();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    render() {  <span style=color:#007f7f>// 渲染一个圆
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>        <span style=color:#fff;font-weight:700>this</span>.ctx.beginPath();
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.ctx.arc(<span style=color:#fff;font-weight:700>this</span>.x, <span style=color:#fff;font-weight:700>this</span>.y, <span style=color:#fff;font-weight:700>this</span>.radius, <span style=color:#ff0;font-weight:700>0</span>, <span style=color:#ff0;font-weight:700>2</span> * <span style=color:#fff;font-weight:700>Math</span>.PI, <span style=color:#fff;font-weight:700>false</span>);
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.ctx.fillStyle = <span style=color:#fff;font-weight:700>this</span>.color;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.ctx.fill();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    on_destroy() {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=实现玩家移动功能>实现玩家移动功能<a hidden class=anchor aria-hidden=true href=#实现玩家移动功能>#</a></h2><p>移动的实现逻辑很简单，就是让每帧渲染的圆的位置发生移动即可</p><p>上述简单逻辑的实现如下：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#fff;font-weight:700>class</span> Player <span style=color:#fff;font-weight:700>extends</span> AcGameObject {
</span></span><span style=display:flex><span>    constructor(....)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.vx = <span style=color:#ff0;font-weight:700>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.vy = <span style=color:#ff0;font-weight:700>1</span>;
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    update() {
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.x += x;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.y += y;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.render();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>然后我们来实现一个向鼠标点击位置移动的功能</p><p>这就需要设置一个 <code>click</code> 事件的监听函数，分别传递：</p><ol><li>鼠标点击事件</li><li>鼠标点击位置的横坐标</li><li>鼠标点击位置的纵坐标</li></ol><p>然后开始让圆的位置逐步向鼠标点击位置进行移动</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>start() {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>if</span> (<span style=color:#fff;font-weight:700>this</span>.is_me) {   <span style=color:#007f7f>// 对于用户玩家，加上监听函数
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>        <span style=color:#fff;font-weight:700>this</span>.add_listening_events();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>add_listening_events() {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>let</span> outer = <span style=color:#fff;font-weight:700>this</span>;
</span></span><span style=display:flex><span>    <span style=color:#007f7f>// 把鼠标右键调出菜单栏的功能关掉
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>this</span>.playground.game_map.$canvas.on(<span style=color:#0ff;font-weight:700>&#34;contextmenu&#34;</span>, <span style=color:#fff;font-weight:700>function</span>() {
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>return</span> <span style=color:#fff;font-weight:700>false</span>;
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>    <span style=color:#007f7f>// 把右键控制移动功能加上
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>this</span>.playground.game_map.$canvas.mousedown(<span style=color:#fff;font-weight:700>function</span>(e) {
</span></span><span style=display:flex><span>        <span style=color:#007f7f>// 左键:1 中键:2 右键:3
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>        <span style=color:#fff;font-weight:700>if</span> (e.which === <span style=color:#ff0;font-weight:700>3</span>) {
</span></span><span style=display:flex><span>            outer.move_to(e.clientX, e.clientY);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>然后，我们来实现移动功能的函数 <code>move_to(tx, ty)</code></p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>constructor(...){
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>this</span>.vx = <span style=color:#ff0;font-weight:700>0</span>;    <span style=color:#007f7f>// x方向上的移动速度
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>this</span>.vy = <span style=color:#ff0;font-weight:700>0</span>;    <span style=color:#007f7f>// y方向上的移动速度
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>this</span>.move_length = <span style=color:#ff0;font-weight:700>0</span>;   <span style=color:#007f7f>// 剩余移动距离
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    ...
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>get_dist (x1, y1, x2, y2) { <span style=color:#007f7f>// 求两点的欧几里得距离
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>let</span> dx = x2 - x1;
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>let</span> dy = y2 - y1;
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#fff;font-weight:700>Math</span>.sqrt(dx * dx + dy * dy);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>move_to(tx, ty) {
</span></span><span style=display:flex><span>    <span style=color:#007f7f>// 计算移动距离
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>this</span>.move_length = <span style=color:#fff;font-weight:700>this</span>.get_dist(<span style=color:#fff;font-weight:700>this</span>.x, <span style=color:#fff;font-weight:700>this</span>.y, tx, ty);
</span></span><span style=display:flex><span>    <span style=color:#007f7f>// 计算移动角度，api接口：atan2(dy, dx)
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>let</span> angle = <span style=color:#fff;font-weight:700>Math</span>.atan2(ty - <span style=color:#fff;font-weight:700>this</span>.y, tx - <span style=color:#fff;font-weight:700>this</span>.x);
</span></span><span style=display:flex><span>    <span style=color:#007f7f>// 位移 1 个单位长度（向着矢量方向移动到单位圆上）
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>this</span>.vx = <span style=color:#fff;font-weight:700>Math</span>.cos(angle);  <span style=color:#007f7f>// 极直互化
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>this</span>.vy = <span style=color:#fff;font-weight:700>Math</span>.sin(angle);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>update() {
</span></span><span style=display:flex><span>    <span style=color:#007f7f>// 浮点数精度运算
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>if</span> (<span style=color:#fff;font-weight:700>this</span>.move_length &lt; <span style=color:#fff;font-weight:700>this</span>.eps) {
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.move_length = <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.vx = <span style=color:#fff;font-weight:700>this</span>.vy = <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>    } <span style=color:#fff;font-weight:700>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#007f7f>// 计算单位帧里的移动距离
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>        <span style=color:#fff;font-weight:700>let</span> moved = <span style=color:#fff;font-weight:700>Math</span>.min(<span style=color:#fff;font-weight:700>this</span>.move_length, <span style=color:#fff;font-weight:700>this</span>.speed * <span style=color:#fff;font-weight:700>this</span>.timedelta / <span style=color:#ff0;font-weight:700>1000</span>);
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.x += <span style=color:#fff;font-weight:700>this</span>.vx * moved;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.y += <span style=color:#fff;font-weight:700>this</span>.vy * moved;
</span></span><span style=display:flex><span>        <span style=color:#007f7f>// 还要减掉移动的距离
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>        <span style=color:#fff;font-weight:700>this</span>.move_length -= moved;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>this</span>.render();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>这样就实现了玩家的移动功能了，可以登录 <code>id:socket</code> 调试该功能</p><h2 id=实现火球技能的功能>实现火球技能的功能<a hidden class=anchor aria-hidden=true href=#实现火球技能的功能>#</a></h2><p>火球对象的建立与玩家基本一致，直接照搬，在从细节上改改即可</p><p><code>js/src/playground/skill/fireball/zbase.js</code></p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#fff;font-weight:700>class</span> FireBall <span style=color:#fff;font-weight:700>extends</span> AcGameObject {
</span></span><span style=display:flex><span>    constructor(playground, player, x, y, radius, vx, vy, color, speed, move_length, damage) {
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>super</span>();
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.playground = playground;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.ctx = <span style=color:#fff;font-weight:700>this</span>.playground.game_map.ctx;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.player = player;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.x = x;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.y = y;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.vx = vx;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.vy = vy;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.radius = radius;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.color = color;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.speed = speed;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.move_length = move.length;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.damage = damage;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.eps = <span style=color:#ff0;font-weight:700>0.1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    start() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    update() {
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>if</span> (<span style=color:#fff;font-weight:700>this</span>.move_length &lt; <span style=color:#fff;font-weight:700>this</span>.eps) {
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>this</span>.destroy();
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>return</span> <span style=color:#fff;font-weight:700>false</span>;
</span></span><span style=display:flex><span>        } <span style=color:#fff;font-weight:700>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>let</span> moved = <span style=color:#fff;font-weight:700>Math</span>.min(<span style=color:#fff;font-weight:700>this</span>.move_length, <span style=color:#fff;font-weight:700>this</span>.speed * <span style=color:#fff;font-weight:700>this</span>.timedelta / <span style=color:#ff0;font-weight:700>1000</span>);
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>this</span>.x += <span style=color:#fff;font-weight:700>this</span>.vx * moved;
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>this</span>.y += <span style=color:#fff;font-weight:700>this</span>.vy * moved;
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>this</span>.move_length -= moved;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.render();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    render() {
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.ctx.beginPath();
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.ctx.arc(<span style=color:#fff;font-weight:700>this</span>.x, <span style=color:#fff;font-weight:700>this</span>.y, <span style=color:#fff;font-weight:700>this</span>.radius, <span style=color:#ff0;font-weight:700>0</span>, <span style=color:#ff0;font-weight:700>2</span> * <span style=color:#fff;font-weight:700>Math</span> * Pi, <span style=color:#fff;font-weight:700>false</span>);
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.ctx.fillStyle = <span style=color:#fff;font-weight:700>this</span>.color;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.ctx.fill();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>} 
</span></span></code></pre></div><p>然后在玩家身上实现发火球的功能</p><p>基本实现逻辑：当前选中了火球技能，鼠标左键点击一处，向该处发射一个火球</p><p>因此，为了知道用户是否选择了技能，需要加一个键盘触发事件监听函数，然后加一个鼠标左键触发事件监听函数</p><p>然后发射一个火球即可</p><p><code>js/src/playground/player/zbase.js</code></p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>constructor(...) {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>this</span>.cur_skill = <span style=color:#fff;font-weight:700>null</span>;  <span style=color:#007f7f>// 记录当前选择的技能
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    ...
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>add_listening_events() {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>this</span>.playground.game_map.$canvas.mousedown(<span style=color:#fff;font-weight:700>function</span>(e) {
</span></span><span style=display:flex><span>        <span style=color:#007f7f>// 左键:1 中键:2 右键:3
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>        <span style=color:#fff;font-weight:700>if</span> (e.which === <span style=color:#ff0;font-weight:700>3</span>) {
</span></span><span style=display:flex><span>            outer.move_to(e.clientX, e.clientY);
</span></span><span style=display:flex><span>        } <span style=color:#fff;font-weight:700>else</span> <span style=color:#fff;font-weight:700>if</span> (e.which === <span style=color:#ff0;font-weight:700>1</span>) {     <span style=color:#007f7f>// 鼠标左键事件
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>            <span style=color:#fff;font-weight:700>if</span> (outer.cur_skill === <span style=color:#0ff;font-weight:700>&#34;fireball&#34;</span>) {   <span style=color:#007f7f>// 当前已经选中火球技能
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>                outer.shoot_fireball(e.clientX, e.clientY);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        outer.cur_skill = <span style=color:#fff;font-weight:700>null</span>; <span style=color:#007f7f>// 清空当前技能
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    });
</span></span><span style=display:flex><span>    $(<span style=color:#fff;font-weight:700>window</span>).keydown(<span style=color:#fff;font-weight:700>function</span>(e) {
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>if</span> (e.which === <span style=color:#ff0;font-weight:700>81</span>) {       <span style=color:#007f7f>// 键盘按下事件
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>            outer.cur_skill = <span style=color:#0ff;font-weight:700>&#34;fireball&#34;</span>;
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>return</span> <span style=color:#fff;font-weight:700>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>shoot_fireball(tx, ty) {
</span></span><span style=display:flex><span>    <span style=color:#007f7f>// 确定火球的参数
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>let</span> x = <span style=color:#fff;font-weight:700>this</span>.x, y = <span style=color:#fff;font-weight:700>this</span>.y; <span style=color:#007f7f>// 火球发射点就是当前玩家的位置
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>let</span> radius = <span style=color:#fff;font-weight:700>this</span>.playground.height * <span style=color:#ff0;font-weight:700>0.01</span>;
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>let</span> angle = <span style=color:#fff;font-weight:700>Math</span>.atan2(ty - <span style=color:#fff;font-weight:700>this</span>.y, tx - <span style=color:#fff;font-weight:700>this</span>.x);
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>let</span> vx = <span style=color:#fff;font-weight:700>Math</span>.cos(angle), vy = <span style=color:#fff;font-weight:700>Math</span>.sin(angle);
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>let</span> color = <span style=color:#0ff;font-weight:700>&#34;orange&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>let</span> speed = <span style=color:#fff;font-weight:700>this</span>.playground.height * <span style=color:#ff0;font-weight:700>0.5</span>;
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>let</span> move_length = <span style=color:#fff;font-weight:700>this</span>.playground.height * <span style=color:#ff0;font-weight:700>1.0</span>;
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>let</span> damage = <span style=color:#fff;font-weight:700>this</span>.playground.height * <span style=color:#ff0;font-weight:700>0.01</span>;
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>new</span> FireBall(<span style=color:#fff;font-weight:700>this</span>.playground, <span style=color:#fff;font-weight:700>this</span>, x, y, radius, vx, vy, color, speed, move_length, damage);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这样就成功实现了玩家发射火球的功能了</p><h2 id=实现单人模式下的人机功能>实现单人模式下的人机功能<a hidden class=anchor aria-hidden=true href=#实现单人模式下的人机功能>#</a></h2><p>先创建好 5 个人机
<code>playground/zbase.js</code></p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#007f7f>//创建好 5 个人机
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>for</span> (len i = <span style=color:#ff0;font-weight:700>0</span>; i &lt; <span style=color:#ff0;font-weight:700>5</span>; i ++ ) {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>this</span>.players.push(<span style=color:#fff;font-weight:700>new</span> Player(<span style=color:#fff;font-weight:700>this</span>, <span style=color:#fff;font-weight:700>this</span>.width / <span style=color:#ff0;font-weight:700>2</span>, <span style=color:#fff;font-weight:700>this</span>.height / <span style=color:#ff0;font-weight:700>2</span>, <span style=color:#fff;font-weight:700>this</span>.height * <span style=color:#ff0;font-weight:700>0.05</span>, <span style=color:#0ff;font-weight:700>&#34;blue&#34;</span>, <span style=color:#fff;font-weight:700>this</span>.height * <span style=color:#ff0;font-weight:700>0.15</span>, <span style=color:#fff;font-weight:700>false</span>));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>这样创建出来的 5 个人机是不会行动的</p><p>我们写一个简易的 AI 程序，让他们也会移动</p><p>这里实现的逻辑是：每次随机一个目的地，向目的地移动，然后再随机一个目的地，循环下去</p><p>根据该逻辑，修改两个函数即可</p><p><code>playground/player/zbase.js</code></p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>...
</span></span><span style=display:flex><span>start() {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>if</span> (<span style=color:#fff;font-weight:700>this</span>.is_me) {   <span style=color:#007f7f>// 对于用户玩家，加上监听函数
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>        <span style=color:#fff;font-weight:700>this</span>.add_listening_events();
</span></span><span style=display:flex><span>    } <span style=color:#fff;font-weight:700>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>let</span> tx = <span style=color:#fff;font-weight:700>Math</span>.random() * <span style=color:#fff;font-weight:700>this</span>.playground.width;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>let</span> ty = <span style=color:#fff;font-weight:700>Math</span>.random() * <span style=color:#fff;font-weight:700>this</span>.playground.height;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.move_to(tx, ty);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span> update() {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>if</span> (<span style=color:#fff;font-weight:700>this</span>.move_length &lt; <span style=color:#fff;font-weight:700>this</span>.eps) {
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.move_length = <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.vx = <span style=color:#fff;font-weight:700>this</span>.vy = <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>if</span> (!<span style=color:#fff;font-weight:700>this</span>.is_me) {   <span style=color:#007f7f>// 如果是人机，停下来时再随机一个方向前进
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>            <span style=color:#fff;font-weight:700>let</span> tx = <span style=color:#fff;font-weight:700>Math</span>.random() * <span style=color:#fff;font-weight:700>this</span>.playground.width;
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>let</span> ty = <span style=color:#fff;font-weight:700>Math</span>.random() * <span style=color:#fff;font-weight:700>this</span>.playground.height;
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>this</span>.move_to(tx, ty);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>on_destroy() {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>for</span> (<span style=color:#fff;font-weight:700>let</span> i = <span style=color:#ff0;font-weight:700>0</span>; i &lt; <span style=color:#fff;font-weight:700>this</span>.playground.players.length; i ++ ) {
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>if</span> (<span style=color:#fff;font-weight:700>this</span>.playground.players[i] === <span style=color:#fff;font-weight:700>this</span>) {
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>this</span>.playground.players.splice(i, <span style=color:#ff0;font-weight:700>1</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=实现技能命中效果碰撞检测功能>实现技能命中效果（碰撞检测功能）<a hidden class=anchor aria-hidden=true href=#实现技能命中效果碰撞检测功能>#</a></h2><p>实现逻辑：检测两个圆的中心距离是否小于两个圆的半径之和</p><p>小于等于时，代表发生碰撞，开始执行命中效果：</p><ol><li>被击中用户掉血</li><li>被击中用户收到向后击退效果</li></ol><p>碰撞检测写在火球类里，击退效果写在玩家类里</p><p><code>fireball/zbase.js</code></p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>update() {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>if</span> (...) {
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    } <span style=color:#fff;font-weight:700>else</span> {
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#007f7f>// 碰撞检测
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>        <span style=color:#fff;font-weight:700>for</span> (<span style=color:#fff;font-weight:700>let</span> i = <span style=color:#ff0;font-weight:700>0</span>; i &lt; <span style=color:#fff;font-weight:700>this</span>.playground.players.length; i ++ ) {
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>let</span> player = <span style=color:#fff;font-weight:700>this</span>.playground.players[i];
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>if</span> (<span style=color:#fff;font-weight:700>this</span>.player !== player &amp;&amp; <span style=color:#fff;font-weight:700>this</span>.is_collision(player)) {  <span style=color:#007f7f>// 碰撞发生一定是在非施法者身上
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>                <span style=color:#fff;font-weight:700>this</span>.attack(player);    <span style=color:#007f7f>// 火球命中，目标玩家执行击退效果
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>this</span>.render();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>get_dist(x1, y1, x2, y2) {  <span style=color:#007f7f>// 获得两点的欧几里得距离
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>        <span style=color:#fff;font-weight:700>let</span> dx = x2 - x1;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>let</span> dy = y2 - y1;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>return</span> <span style=color:#fff;font-weight:700>Math</span>.sqrt(dx * dx + dy * dy);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>is_collision(player) {  <span style=color:#007f7f>// 检测两个圆的中心距离是否小于两个圆的半径之和
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>let</span> distance = <span style=color:#fff;font-weight:700>this</span>.get_dist(<span style=color:#fff;font-weight:700>this</span>.x, <span style=color:#fff;font-weight:700>this</span>.y, player.x, player.y);
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>if</span> (distance &lt; (<span style=color:#fff;font-weight:700>this</span>.radius + player.radius))
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>return</span> <span style=color:#fff;font-weight:700>true</span>;
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> <span style=color:#fff;font-weight:700>false</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>attack(player) {    <span style=color:#007f7f>// 火球命中，目标玩家执行击退效果
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>let</span> angle = <span style=color:#fff;font-weight:700>Math</span>.atan2(player.y - <span style=color:#fff;font-weight:700>this</span>.y, player.x - <span style=color:#fff;font-weight:700>this</span>.x);   <span style=color:#007f7f>// 计算角度
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    player.is_attacked(angle, <span style=color:#fff;font-weight:700>this</span>.damage); <span style=color:#007f7f>// 火球命中，目标玩家执行击退效果
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>this</span>.destroy(); <span style=color:#007f7f>// 火球命中后，自然消失
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>}
</span></span></code></pre></div><p><strong>被击退的时候，原来的移动速度应该置为 0，当前的移动应该转为向被击中方向上的移动</strong>
<code>player/zbase.js</code></p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>is_attacked(angle, damage) {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>this</span>.radius -= damage;  <span style=color:#007f7f>// 受伤，半径减少
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>if</span> (<span style=color:#fff;font-weight:700>this</span>.radius &lt; <span style=color:#ff0;font-weight:700>10</span>) { <span style=color:#007f7f>// 当半径小于10像素时，代表死亡
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>        <span style=color:#fff;font-weight:700>this</span>.destroy();
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>return</span> <span style=color:#fff;font-weight:700>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#007f7f>// 开始执行击退效果
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>this</span>.damage_vx = <span style=color:#fff;font-weight:700>Math</span>.cos(angle);
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>this</span>.damage_vy = <span style=color:#fff;font-weight:700>Math</span>.sin(angle);
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>this</span>.damage_speed = damage * <span style=color:#ff0;font-weight:700>100</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>this</span>.speed *= <span style=color:#ff0;font-weight:700>0.5</span>;  <span style=color:#007f7f>// 被击中以后移动速度减半
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>}
</span></span><span style=display:flex><span>update() {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>if</span> (<span style=color:#fff;font-weight:700>this</span>.damage_speed &gt; <span style=color:#fff;font-weight:700>this</span>.eps) {   <span style=color:#007f7f>// 当前仍处于击退效果中
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>        <span style=color:#fff;font-weight:700>this</span>.vx = <span style=color:#fff;font-weight:700>this</span>.vy = <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.move_length = <span style=color:#ff0;font-weight:700>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.x += <span style=color:#fff;font-weight:700>this</span>.damage_vx * <span style=color:#fff;font-weight:700>this</span>.damage_speed * <span style=color:#fff;font-weight:700>this</span>.timedelta / <span style=color:#ff0;font-weight:700>1000</span>;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.y += <span style=color:#fff;font-weight:700>this</span>.damage_vy * <span style=color:#fff;font-weight:700>this</span>.damage_speed * <span style=color:#fff;font-weight:700>this</span>.timedelta / <span style=color:#ff0;font-weight:700>1000</span>;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.damage_speed *= <span style=color:#fff;font-weight:700>this</span>.friction; <span style=color:#007f7f>// 击退速度乘以摩擦系数，已达到削减的目的
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    } <span style=color:#fff;font-weight:700>else</span> {
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=被击中以后的粒子效果特效>被击中以后的粒子效果特效<a hidden class=anchor aria-hidden=true href=#被击中以后的粒子效果特效>#</a></h2><p>实现逻辑：被击中以后，在玩家附近随机生成一些粒子小球</p><p>因此我们要先实现 粒子小球 对象</p><p><code>static/js/src/playground/particle/zbase.js</code></p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#fff;font-weight:700>class</span> Particle <span style=color:#fff;font-weight:700>extends</span> AcGameObject {
</span></span><span style=display:flex><span>    constructor(playground, x, y, radius, vx, vy, color, speed) {
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>super</span>();
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.playground = playground;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.ctx = <span style=color:#fff;font-weight:700>this</span>.playground.game_map.ctx;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.x = x;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.y = y;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.radius = radius;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.vx = vx;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.vy = vy;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.color = color;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.speed = speed;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.friction = <span style=color:#ff0;font-weight:700>0.9</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    start() {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    update() {
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>if</span> (<span style=color:#fff;font-weight:700>this</span>.speed &lt; <span style=color:#fff;font-weight:700>this</span>.eps) {
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>this</span>.destroy;
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>return</span> <span style=color:#fff;font-weight:700>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.x += <span style=color:#fff;font-weight:700>this</span>.vx * <span style=color:#fff;font-weight:700>this</span>.speed * <span style=color:#fff;font-weight:700>this</span>.timedelta / <span style=color:#ff0;font-weight:700>1000</span>;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.y += <span style=color:#fff;font-weight:700>this</span>.vy * <span style=color:#fff;font-weight:700>this</span>.speed * <span style=color:#fff;font-weight:700>this</span>.timedelta / <span style=color:#ff0;font-weight:700>1000</span>;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.speed *= <span style=color:#fff;font-weight:700>this</span>.friction;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.render();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    render() {
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.ctx.beginPath();
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.ctx.arc(<span style=color:#fff;font-weight:700>this</span>.x, <span style=color:#fff;font-weight:700>this</span>.y, <span style=color:#fff;font-weight:700>this</span>.radius, <span style=color:#ff0;font-weight:700>0</span>, <span style=color:#ff0;font-weight:700>2</span> * <span style=color:#fff;font-weight:700>Math</span>.PI, <span style=color:#fff;font-weight:700>false</span>);
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.ctx.fillStyle = <span style=color:#fff;font-weight:700>this</span>.color;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.ctx.fill();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>} 
</span></span></code></pre></div><p>然后我们在被击退功能模块，实现生成粒子小球的效果</p><ul><li>粒子小球释放弧度为 $[0,2π)$ 的随机数<ul><li>粒子小球的 x, y 分量比率根据弧度来设定</li></ul></li><li>粒子小球的起始坐标应与玩家的坐标相同</li><li>粒子小球的颜色与玩家颜色相同</li><li>粒子小球的速度为玩家移动速度的 $10$ 倍</li></ul><p><code>js/src/playground/player/zbase.js</code></p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>is_attacked(angle, damage) {
</span></span><span style=display:flex><span>    <span style=color:#007f7f>// 粒子小球效果
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>for</span> (<span style=color:#fff;font-weight:700>let</span> i = <span style=color:#ff0;font-weight:700>0</span>; i &lt; <span style=color:#ff0;font-weight:700>10</span> + <span style=color:#fff;font-weight:700>Math</span>.random() * <span style=color:#ff0;font-weight:700>5</span>; i ++ ) {
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>let</span> x = <span style=color:#fff;font-weight:700>this</span>.x, y = <span style=color:#fff;font-weight:700>this</span>.y;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>let</span> radius = <span style=color:#fff;font-weight:700>this</span>.radius * <span style=color:#fff;font-weight:700>Math</span>.random() * <span style=color:#ff0;font-weight:700>0.1</span>;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>let</span> angle = <span style=color:#ff0;font-weight:700>2</span> * <span style=color:#fff;font-weight:700>Math</span>.PI * <span style=color:#fff;font-weight:700>Math</span>.random();
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>let</span> vx = <span style=color:#fff;font-weight:700>Math</span>.cos(angle), vy = <span style=color:#fff;font-weight:700>Math</span>.sin(angle);
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>let</span> color = <span style=color:#fff;font-weight:700>this</span>.color;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>let</span> speed = <span style=color:#fff;font-weight:700>this</span>.speed * <span style=color:#ff0;font-weight:700>10</span>;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>new</span> Particle(<span style=color:#fff;font-weight:700>this</span>.playground, x, y, radius, vx, vy, color, speed);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=一些小优化>一些小优化<a hidden class=anchor aria-hidden=true href=#一些小优化>#</a></h2><h3 id=人机随机颜色>人机随机颜色<a hidden class=anchor aria-hidden=true href=#人机随机颜色>#</a></h3><p><code>js/src/playground/zbase.js</code></p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>constructor(root) {
</span></span><span style=display:flex><span>    ......
</span></span><span style=display:flex><span>    <span style=color:#007f7f>// 创建好 5 个人机
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>    <span style=color:#fff;font-weight:700>for</span> (<span style=color:#fff;font-weight:700>let</span> i = <span style=color:#ff0;font-weight:700>0</span>; i &lt; <span style=color:#ff0;font-weight:700>5</span>; i ++ ) {
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.players.push(<span style=color:#fff;font-weight:700>new</span> Player(<span style=color:#fff;font-weight:700>this</span>, <span style=color:#fff;font-weight:700>this</span>.width / <span style=color:#ff0;font-weight:700>2</span>, <span style=color:#fff;font-weight:700>this</span>.height / <span style=color:#ff0;font-weight:700>2</span>, <span style=color:#fff;font-weight:700>this</span>.height * <span style=color:#ff0;font-weight:700>0.05</span>, <span style=color:#fff;font-weight:700>this</span>.get_random_color(), <span style=color:#fff;font-weight:700>this</span>.height * <span style=color:#ff0;font-weight:700>0.15</span>, <span style=color:#fff;font-weight:700>false</span>));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    ......
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>get_random_color() {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>let</span> colors = [<span style=color:#0ff;font-weight:700>&#34;blue&#34;</span>, <span style=color:#0ff;font-weight:700>&#34;red&#34;</span>, <span style=color:#0ff;font-weight:700>&#34;pink&#34;</span>, <span style=color:#0ff;font-weight:700>&#34;grey&#34;</span>, <span style=color:#0ff;font-weight:700>&#34;green&#34;</span>];
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>return</span> colors[<span style=color:#fff;font-weight:700>Math</span>.floor(<span style=color:#fff;font-weight:700>Math</span>.random() * <span style=color:#ff0;font-weight:700>5</span>)];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=人机ai随机攻击操作>人机AI随机攻击操作<a hidden class=anchor aria-hidden=true href=#人机ai随机攻击操作>#</a></h3><p><code>js/src/playground/player/zbase.js</code></p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>constructor (...) {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>this</span>.spent_time = <span style=color:#ff0;font-weight:700>0</span>;    <span style=color:#007f7f>// 初始人机冷却攻击时间
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>}
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>update() {
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>this</span>.spent_time += <span style=color:#fff;font-weight:700>this</span>.timedelta / <span style=color:#ff0;font-weight:700>1000</span>;
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>if</span> (!<span style=color:#fff;font-weight:700>this</span>.is_me &amp;&amp; <span style=color:#fff;font-weight:700>this</span>.spent_time &gt; <span style=color:#ff0;font-weight:700>4</span> &amp;&amp; <span style=color:#fff;font-weight:700>Math</span>.random() * <span style=color:#ff0;font-weight:700>180</span> &lt; <span style=color:#ff0;font-weight:700>1</span>) {
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>let</span> player = <span style=color:#fff;font-weight:700>this</span>.playground.players[<span style=color:#fff;font-weight:700>Math</span>.floor(<span style=color:#fff;font-weight:700>Math</span>.random() * <span style=color:#fff;font-weight:700>this</span>.playground.players.length)];
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.shoot_fireball(player.x, player.y);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=部署nginx与对接acapp>部署nginx与对接acapp<a hidden class=anchor aria-hidden=true href=#部署nginx与对接acapp>#</a></h1><ul><li><a href=https://www.acwing.com/file_system/file/content/whole/index/content/3257028/>5. 部署nginx与对接acapp | 讲义</a></li><li><a href=https://www.acwing.com/solution/content/79244/>5.1 上课笔记 | Andrew1729</a></li><li><a href=https://www.acwing.com/solution/content/78903/>5.1. 上课笔记 | 菊花</a></li><li><a href=https://zhuanlan.zhihu.com/p/364622127>Ngnix 介绍</a></li><li><a href=https://www.jianshu.com/p/36187963b553>nginx 和uwsgi的区别与作用</a></li></ul><hr><h2 id=nginx是什么>Nginx是什么？<a hidden class=anchor aria-hidden=true href=#nginx是什么>#</a></h2><blockquote><p><strong>Nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器</strong></p><p><strong>Nginx可以作为一个HTTP服务器进行网站的发布处理，另外Nginx可以作为反向代理进行负载均衡的实现</strong></p><p><strong>Nginx中HttpUwsgiModule的作用是与uWSGI服务器进行交换</strong></p></blockquote><h2 id=uwsgi是什么>uWSGI是什么？<a hidden class=anchor aria-hidden=true href=#uwsgi是什么>#</a></h2><blockquote><p><strong>uWSGI是一个全功能的HTTP服务器，实现了WSGI、uwsgi、http等协议</strong></p><p><strong>它要做的就是把HTTP协议转化成语言支持的网络协议。比如把HTTP协议转化成WSGI协议，让Python可以直接使用</strong></p><p><strong>WSGI协议是Python 语言定义的 Web 服务器和 Web 应用程序或框架之间的一种简单而通用的接口</strong></p><p><strong>简单来说uWSGI就是用来沟通nginx和django的一座桥梁</strong></p></blockquote><h2 id=nginxuwsgidiango-工作流程>Nginx+uWSGI+Diango 工作流程<a hidden class=anchor aria-hidden=true href=#nginxuwsgidiango-工作流程>#</a></h2><blockquote><p><strong><code>nginx</code> 是对外的服务接口，外部浏览器通过<code>url</code>访问<code>nginx</code></strong></p><p><strong><code>nginx</code> 接收到浏览器发送过来的<code>http</code>请求，将包进行解析</strong></p><p><strong>分析<code>url</code>，如果是静态文件请求就直接访问用户给<code>nginx</code>配置的静态文件目录，直接返回用户请求的静态文件</strong></p><p><strong>如果不是静态文件，而是一个动态的请求，那么<code>nginx</code>就将请求转发给<code>uwsgi</code>，<code>uwsgi</code> 接收到请求之后将包进行处理，处理成<code>wsgi</code>可以接受的格式，并发给<code>wsgi</code>，<code>wsgi</code> 根据请求调用应用程序的某个文件，某个文件的某个函数，最后处理完将返回值再次交给<code>wsgi</code>，<code>wsgi</code>将返回值进行打包，打包成<code>uwsgi</code>能够接收的格式，<code>uwsgi</code>接收<code>wsgi</code> 发送的请求，并转发给<code>nginx</code>, <code>nginx</code>最终将返回值返回给浏览器</strong></p></blockquote><h2 id=uwsgi服务的开启关闭>uwsgi服务的开启&&关闭<a hidden class=anchor aria-hidden=true href=#uwsgi服务的开启关闭>#</a></h2><ul><li>在<code>~/acapp</code>启动uwsgi服务：<strong><code>uwsgi --ini scripts/uwsgi.ini</code></strong></li><li>关闭uwsgi服务：<code>sudo pkill -f uwsgi -9</code></li></ul><h2 id=针对-acapp-的优化>针对 acapp 的优化<a hidden class=anchor aria-hidden=true href=#针对-acapp-的优化>#</a></h2><h3 id=打包脚本优化>打包脚本优化<a hidden class=anchor aria-hidden=true href=#打包脚本优化>#</a></h3><p>由于现在 <strong>发布版本的脚本文件</strong> 用的是打包在根目录里的 <strong>static</strong> 文件夹</p><p>每次修改好 <strong>static</strong> 文件夹后，不仅需要对 <strong>js</strong> 文件打包，还需要对 <strong>static</strong> 文件夹打包</p><p>不放把 &ldquo;将static文件夹打包&rdquo; 的 <strong>shell</strong> 代码一起加入 <strong>js</strong> 打包脚本中，从而实现一键打包</p><p><code>scripts/compress_game_js.sh</code></p><pre tabindex=0><code>#! /bin/bash

JS_PATH=/home/acs/acapp/game/static/js/
JS_PATH_DIST=${JS_PATH}dist/
JS_PATH_SRC=${JS_PATH}src/

find $JS_PATH_SRC -type f -name &#39;*.js&#39; | sort | xargs cat &gt; ${JS_PATH_DIST}game.js

echo &#34;yes&#34; | python3 manage.py collectstatic
</code></pre><h3 id=鼠标点击事件的相对偏移>鼠标点击事件的相对偏移<a hidden class=anchor aria-hidden=true href=#鼠标点击事件的相对偏移>#</a></h3><p>由于写游戏界面的时候，玩家移动是按照鼠标相对于当前整个浏览器取的位置参数 <code>e.clientX</code></p><p>而 <code>acapp</code> 里，每个应用是一个小窗口，鼠标点击位置的参数应当是 <strong>相对于整个游戏窗口的位置参数</strong></p><p>所有会导致出现，点击的位置与移动的位置不同，这里需要做出小优化</p><p>优化的逻辑 :</p><ol><li>$clientX−窗口左侧到浏览器左侧的距离=玩家的目标X$</li><li>$clientY−窗口上侧到浏览器上侧的距离=玩家的目标Y$
这就要用到一个 <code>js</code> 的 <code>API</code> 了 : <code>getBoundingClientRect()</code></li></ol><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>rectObject = object.getBoundingClientRect();
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>rectObject.top : 元素上边到视窗上边的距离;
</span></span><span style=display:flex><span>rectObject.right : 元素右边到视窗左边的距离;
</span></span><span style=display:flex><span>rectObject.bottom : 元素下边到视窗上边的距离;
</span></span><span style=display:flex><span>rectObject.left : 元素左边到视窗左边的距离;
</span></span><span style=display:flex><span>rectObject.width : 是元素自身的宽
</span></span><span style=display:flex><span>rectObject.height : 是元素自身的高
</span></span></code></pre></div><p><code>player/zbase.js</code></p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>...
</span></span><span style=display:flex><span> add_listening_events() {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>this</span>.playground.game_map.$canvas.mousedown(<span style=color:#fff;font-weight:700>function</span>(e) {
</span></span><span style=display:flex><span>        <span style=color:#007f7f>// 创建 rect 对象
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>        <span style=color:#fff;font-weight:700>const</span> rect = outer.ctx.canvas.getBoundingClientRect();
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>if</span> (e.which === <span style=color:#ff0;font-weight:700>3</span>) {
</span></span><span style=display:flex><span>            <span style=color:#007f7f>// 调整偏移量
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>            outer.move_to(e.clientX - rect.left, e.clientY - rect.top);
</span></span><span style=display:flex><span>        } <span style=color:#fff;font-weight:700>else</span> <span style=color:#fff;font-weight:700>if</span> (e.which === <span style=color:#ff0;font-weight:700>1</span>) {
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>if</span> (outer.cur_skill === <span style=color:#0ff;font-weight:700>&#34;fireball&#34;</span>) {
</span></span><span style=display:flex><span>                <span style=color:#007f7f>// 调整偏移量
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>                outer.shoot_fireball(e.clientX - rect.left, e.clientY - rect.top);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><h3 id=将菜单界面重新设为主界面>将菜单界面重新设为主界面<a hidden class=anchor aria-hidden=true href=#将菜单界面重新设为主界面>#</a></h3><p><code>js/zbase.js</code> 的注释取消，使之创建出 <strong>menu</strong> 对象</p><p><code>js/playground/zbase.js</code> 的注释取消，并设置逻辑，让 <strong>playground</strong> 打开后，才进行游戏界面初始化</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#fff;font-weight:700>class</span> AcGamePlayground {
</span></span><span style=display:flex><span>    constructor(root) {
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.root = root;
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.$playground = $(<span style=color:#0ff;font-weight:700>`&lt;div class=&#34;ac-game-playground&#34;&gt;&lt;/div&gt;`</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.hide();    <span style=color:#007f7f>// 初始时隐藏
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>        <span style=color:#007f7f>// 游戏界面生成代码在下面展示 playground 时执行
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>        <span style=color:#fff;font-weight:700>this</span>.start();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    show() {    <span style=color:#007f7f>// 打开 playground 界面
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>        <span style=color:#fff;font-weight:700>this</span>.$playground.show();
</span></span><span style=display:flex><span>        <span style=color:#007f7f>// 开始生成游戏界面
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>        <span style=color:#fff;font-weight:700>this</span>.root.$ac_game.append(<span style=color:#fff;font-weight:700>this</span>.$playground);
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.width = <span style=color:#fff;font-weight:700>this</span>.$playground.width();
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.height = <span style=color:#fff;font-weight:700>this</span>.$playground.height();
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.game_map = <span style=color:#fff;font-weight:700>new</span> GameMap(<span style=color:#fff;font-weight:700>this</span>);
</span></span><span style=display:flex><span>        <span style=color:#fff;font-weight:700>this</span>.players = [];  <span style=color:#007f7f>// 存放当前游戏中的所有玩家
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>        <span style=color:#007f7f>// 将玩家加入游戏中
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>        <span style=color:#fff;font-weight:700>this</span>.players.push(<span style=color:#fff;font-weight:700>new</span> Player(<span style=color:#fff;font-weight:700>this</span>, <span style=color:#fff;font-weight:700>this</span>.width / <span style=color:#ff0;font-weight:700>2</span>, <span style=color:#fff;font-weight:700>this</span>.height / <span style=color:#ff0;font-weight:700>2</span>, <span style=color:#fff;font-weight:700>this</span>.height * <span style=color:#ff0;font-weight:700>0.05</span>, <span style=color:#0ff;font-weight:700>&#34;white&#34;</span>, <span style=color:#fff;font-weight:700>this</span>.height * <span style=color:#ff0;font-weight:700>0.15</span>, <span style=color:#fff;font-weight:700>true</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#007f7f>// 创建好 5 个人机
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>        <span style=color:#fff;font-weight:700>for</span> (<span style=color:#fff;font-weight:700>let</span> i = <span style=color:#ff0;font-weight:700>0</span>; i &lt; <span style=color:#ff0;font-weight:700>5</span>; i ++ ) {
</span></span><span style=display:flex><span>            <span style=color:#fff;font-weight:700>this</span>.players.push(<span style=color:#fff;font-weight:700>new</span> Player(<span style=color:#fff;font-weight:700>this</span>, <span style=color:#fff;font-weight:700>this</span>.width / <span style=color:#ff0;font-weight:700>2</span>, <span style=color:#fff;font-weight:700>this</span>.height / <span style=color:#ff0;font-weight:700>2</span>, <span style=color:#fff;font-weight:700>this</span>.height * <span style=color:#ff0;font-weight:700>0.05</span>, <span style=color:#fff;font-weight:700>this</span>.get_random_color(), <span style=color:#fff;font-weight:700>this</span>.height * <span style=color:#ff0;font-weight:700>0.15</span>, <span style=color:#fff;font-weight:700>false</span>));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=调整-css-文件适应窗口>调整 css 文件，适应窗口<a hidden class=anchor aria-hidden=true href=#调整-css-文件适应窗口>#</a></h3><p>在设置 <code>web</code> 网页的时候，有些设置了绝对值，可能对于窗口化的 <code>acapp</code> 显示效果差</p><p>将他们修改成相对数值</p><p><code>game.css</code></p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>...
</span></span><span style=display:flex><span>.ac-game-menu-field {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    top: <span style=color:#ff0;font-weight:700>40</span>%;
</span></span><span style=display:flex><span>    left: <span style=color:#ff0;font-weight:700>20</span>%;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>.ac-game-menu-field-item {
</span></span><span style=display:flex><span>    height: <span style=color:#ff0;font-weight:700>6</span>vh;
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    font-size: <span style=color:#ff0;font-weight:700>4</span>vh;
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>...
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://xancoding.cn/tags/tech/>Tech</a></li><li><a href=https://xancoding.cn/tags/acwing/>AcWing</a></li><li><a href=https://xancoding.cn/tags/django/>Django</a></li><li><a href=https://xancoding.cn/tags/%E6%96%B0%E6%8A%80%E8%83%BD/>新技能</a></li></ul><nav class=paginav><a class=next href=https://xancoding.cn/posts/computernetwork/><span class=title>Next »</span><br><span>计算机网络</span></a></nav></footer><div><div class=pagination__title><span class=pagination__title-h style=font-size:20px>💬评论</span><hr></div><div id=tcomment></div><script src=https://cdn.staticfile.org/twikoo/1.6.7/twikoo.all.min.js></script>
<script>twikoo.init({envId:"https://twikoo-zagxuy.vercel.app/",el:"#tcomment",lang:"zh-CN",region:"ap-beijing",path:window.TWIKOO_MAGIC_PATH||window.location.pathname})</script></div></article></main><footer class=footer><span>&copy; 2022 <a href=https://xancoding.cn>Xan's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>