<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Xan&#39;s Blog</title>
    <link>https://zagxuy.github.io/</link>
    <description>Recent content on Xan&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 09 Oct 2022 12:11:31 +0800</lastBuildDate><atom:link href="https://zagxuy.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Blog</title>
      <link>https://zagxuy.github.io/post/blog/</link>
      <pubDate>Sun, 09 Oct 2022 12:11:31 +0800</pubDate>
      
      <guid>https://zagxuy.github.io/post/blog/</guid>
      <description>~ 排序
插入排序 直接插入排序 稳定 将 a[i]插入前面已经排好序的 a[1]~a[i - 1]中 在 a[0] 处设置岗哨，使 a[0] == a[i] 避免查找插入位置时对下标越界的检查 将 a[i]依次与 a[i - 1]，a[i - 2]，&amp;hellip; ，a[1]比较，直到 a[j] &amp;lt;= a[i]，再将 a[i]插到 a[j]之后 希尔排序 不稳定 基本思想：先取一个正整数 d1 &amp;lt; n，把所有相隔 d1 的记录放一组，组内进行直接插入排序；然后取 d2 &amp;lt; d1，重复上述分组和排序操作；直至 di = 1，即所有记录放进一个组中进行一趟直接插入排序为止 具体做法： 取 d1 = ⌊n / 2⌋ 每一趟 d i = ⌊d i - 1 / 2⌋ 直至 d k = 1结束 void shell_pass(int a[], int step) { for (int i = step + 1; i &amp;lt;= n; i++) { int tmp = a[i]; int j = i - step; while(j &amp;gt;= 1 &amp;amp;&amp;amp; tmp &amp;lt; a[j]) { a[j + step] = a[j]; j = j - step; } a[j + step] = tmp; } } void shell_sort(int a[], int d[]) {	//需t趟完成排序 for (int k = 0; k &amp;lt; t; k++) shell_pass (a, d[k]); } 交换排序 冒泡排序 稳定 沉底法 快速排序 不稳定</description>
    </item>
    
  </channel>
</rss>
