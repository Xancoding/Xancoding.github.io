<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Tech on Xan&#39;s Blog</title>
    <link>https://xancoding.github.io/tags/tech/</link>
    <description>Recent content in Tech on Xan&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 11 Oct 2022 19:52:46 +0800</lastBuildDate><atom:link href="https://xancoding.github.io/tags/tech/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>观光之旅</title>
      <link>https://xancoding.github.io/posts/sight/</link>
      <pubDate>Tue, 11 Oct 2022 19:52:46 +0800</pubDate>
      
      <guid>https://xancoding.github.io/posts/sight/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.acwing.com/problem/content/346/&#34;&gt;观光之旅&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;bits/stdc++.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;namespace&lt;/span&gt; std ;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; N = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;110&lt;/span&gt; , M = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;10010&lt;/span&gt; , INF = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x3f3f3f3f&lt;/span&gt; ;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;long&lt;/span&gt; LL ;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; n, m;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; g[N][N];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; d[N][N];  &lt;span style=&#34;color:#007f7f&#34;&gt;// 最短距离
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; pos[N][N];  &lt;span style=&#34;color:#007f7f&#34;&gt;// pos[i][j] = k  从 i 到 j 的最短路径是从 k 转移来的
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; path[N], cnt;  &lt;span style=&#34;color:#007f7f&#34;&gt;// 当前最小环的方案
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;// 递归加入从 i 到 j 的中间路径
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt; get_path(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; i, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; j) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (pos[i][j] == &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; k = pos[i][j];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    get_path(i, k);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    path[cnt ++] = k;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    get_path(k, j);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    memset(g, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x3f&lt;/span&gt;, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;sizeof&lt;/span&gt; g);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;; i &amp;lt;= n; i ++) g[i][i] = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;while&lt;/span&gt; (m --) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; a, b, c;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b &amp;gt;&amp;gt; c;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        g[a][b] = g[b][a] = min(g[a][b], c);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; res = INF;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    memcpy(d, g, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;sizeof&lt;/span&gt; g);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; k = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;; k &amp;lt;= n; ++ k) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#007f7f&#34;&gt;// 枚举以 k 为最大编号的环
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#007f7f&#34;&gt;// 由于是无向图，i j 顺序可互换，所以不用都枚举
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;; i &amp;lt; k; ++ i)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; j = i + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;; j &amp;lt; k; ++ j)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; ((LL)d[i][j] + g[i][k] + g[k][j] &amp;lt; res) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    res = d[i][j] + g[i][k] + g[k][j];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    cnt = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    path[cnt ++] = k;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    path[cnt ++] = i;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    get_path(i, j);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    path[cnt ++] = j;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#007f7f&#34;&gt;// floyd
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;; i &amp;lt;= n; ++ i)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; j = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;; j &amp;lt;= n; ++ j)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (d[i][j] &amp;gt; d[i][k] + d[k][j]) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    d[i][j] = d[i][k] + d[k][j];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    pos[i][j] = k;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (res == INF) puts(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;No solution.&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; i = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;; i &amp;lt; cnt; ++ i)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            cout &amp;lt;&amp;lt; path[i] &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39; &amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        cout &amp;lt;&amp;lt; endl;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
      <content:encoded><![CDATA[<p><a href="https://www.acwing.com/problem/content/346/">观光之旅</a></p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span><span style="color:#0f0;font-weight:bold">&lt;bits/stdc++.h&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold"></span><span style="color:#fff;font-weight:bold">using</span> <span style="color:#fff;font-weight:bold">namespace</span> std ;
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">int</span> N = <span style="color:#ff0;font-weight:bold">110</span> , M = <span style="color:#ff0;font-weight:bold">10010</span> , INF = <span style="color:#ff0;font-weight:bold">0x3f3f3f3f</span> ;
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">typedef</span> <span style="color:#fff;font-weight:bold">long</span> <span style="color:#fff;font-weight:bold">long</span> LL ;
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> n, m;
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> g[N][N];
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> d[N][N];  <span style="color:#007f7f">// 最短距离
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">int</span> pos[N][N];  <span style="color:#007f7f">// pos[i][j] = k  从 i 到 j 的最短路径是从 k 转移来的
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">int</span> path[N], cnt;  <span style="color:#007f7f">// 当前最小环的方案
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// 递归加入从 i 到 j 的中间路径
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">void</span> get_path(<span style="color:#fff;font-weight:bold">int</span> i, <span style="color:#fff;font-weight:bold">int</span> j) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span> (pos[i][j] == <span style="color:#ff0;font-weight:bold">0</span>) <span style="color:#fff;font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> k = pos[i][j];
</span></span><span style="display:flex;"><span>    get_path(i, k);
</span></span><span style="display:flex;"><span>    path[cnt ++] = k;
</span></span><span style="display:flex;"><span>    get_path(k, j);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> main() {
</span></span><span style="display:flex;"><span>    cin &gt;&gt; n &gt;&gt; m;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    memset(g, <span style="color:#ff0;font-weight:bold">0x3f</span>, <span style="color:#fff;font-weight:bold">sizeof</span> g);
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">1</span>; i &lt;= n; i ++) g[i][i] = <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">while</span> (m --) {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">int</span> a, b, c;
</span></span><span style="display:flex;"><span>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
</span></span><span style="display:flex;"><span>        g[a][b] = g[b][a] = min(g[a][b], c);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> res = INF;
</span></span><span style="display:flex;"><span>    memcpy(d, g, <span style="color:#fff;font-weight:bold">sizeof</span> g);
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> k = <span style="color:#ff0;font-weight:bold">1</span>; k &lt;= n; ++ k) {
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 枚举以 k 为最大编号的环
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        <span style="color:#007f7f">// 由于是无向图，i j 顺序可互换，所以不用都枚举
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">1</span>; i &lt; k; ++ i)
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> j = i + <span style="color:#ff0;font-weight:bold">1</span>; j &lt; k; ++ j)
</span></span><span style="display:flex;"><span>                <span style="color:#fff;font-weight:bold">if</span> ((LL)d[i][j] + g[i][k] + g[k][j] &lt; res) {
</span></span><span style="display:flex;"><span>                    res = d[i][j] + g[i][k] + g[k][j];
</span></span><span style="display:flex;"><span>                    cnt = <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>                    path[cnt ++] = k;
</span></span><span style="display:flex;"><span>                    path[cnt ++] = i;
</span></span><span style="display:flex;"><span>                    get_path(i, j);
</span></span><span style="display:flex;"><span>                    path[cnt ++] = j;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// floyd
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">1</span>; i &lt;= n; ++ i)
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> j = <span style="color:#ff0;font-weight:bold">1</span>; j &lt;= n; ++ j)
</span></span><span style="display:flex;"><span>                <span style="color:#fff;font-weight:bold">if</span> (d[i][j] &gt; d[i][k] + d[k][j]) {
</span></span><span style="display:flex;"><span>                    d[i][j] = d[i][k] + d[k][j];
</span></span><span style="display:flex;"><span>                    pos[i][j] = k;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span> (res == INF) puts(<span style="color:#0ff;font-weight:bold">&#34;No solution.&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">0</span>; i &lt; cnt; ++ i)
</span></span><span style="display:flex;"><span>            cout &lt;&lt; path[i] &lt;&lt; <span style="color:#0ff;font-weight:bold">&#39; &#39;</span>;
</span></span><span style="display:flex;"><span>        cout &lt;&lt; endl;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>]]></content:encoded>
    </item>
    
  </channel>
</rss>
