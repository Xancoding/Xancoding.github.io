<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>C&#43;&#43; on Xan&#39;s Blog</title>
    <link>https://xancoding.cn/tags/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on Xan&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 29 May 2023 17:24:38 +0800</lastBuildDate><atom:link href="https://xancoding.cn/tags/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>C&#43;&#43; Project</title>
      <link>https://xancoding.cn/posts/2023-05-29-17-24-38/</link>
      <pubDate>Mon, 29 May 2023 17:24:38 +0800</pubDate>
      
      <guid>https://xancoding.cn/posts/2023-05-29-17-24-38/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1bd4y1D7on/?spm_id_from=333.788&amp;amp;vd_source=ae16ff6478eb15c1b87880540263910b&#34;&gt;# C/C++项目实战（前置知识）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 单例模式&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 工厂模式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.yuque.com/jackyao/ifeq8i/vyigt9?#%20%E3%80%8AC/C++%E5%88%B7%E9%A2%98%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%E3%80%8B&#34;&gt;# C/C++刷题常用技巧&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;a href=&#34;https://www.bilibili.com/video/BV1XB4y1b7Fy/?spm_id_from=333.788&amp;amp;vd_source=ae16ff6478eb15c1b87880540263910b&#34;&gt;# C/C++项目实战（数据库）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;a href=&#34;https://github.com/SYaoJun/CPPInterview/blob/master/Basic/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.md&#34;&gt;# 数据库原理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;大纲&#34;&gt;大纲&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-markdown&#34; data-lang=&#34;markdown&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;1.&lt;/span&gt; 开发环境
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; Git     # 版本管理工具
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; Cmake   # 代码构建工具，管理源文件和依赖
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; Gcc     # 编译器
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; Clion   # 编辑器
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; Postman # 模拟客户端
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; MySQL(navicat)   # 在 docker Container 中起一个 mySQL 数据库，并可以在 navicat 中进行可视化操作
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; Docker  # 部署
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;1.&lt;/span&gt; 目录结构
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; build   # 项目编译目录
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; debug 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; release 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; include # .h 头文件目录
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; src     # .cpp  源文件目录
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; docs    # 需求设计文档
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; others
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;2.&lt;/span&gt; 设计模式
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; 单例模式
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; 构造函数私有
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; 实例只有一份
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; 工厂模式
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; 一个类别对应一个工厂
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; 不需要亲自创建对象，只需要从工厂中去取
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;3.&lt;/span&gt; 数据库
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; MySQL 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; 关系型
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; 支持事务
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; 行锁
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; 支持种存储引擎InnoDB，MyISAM，Memory
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; B+树索引
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;init-project&#34;&gt;init-project&lt;/h1&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://bu.dusays.com/2023/05/29/64748c8482b68.png&#34;&gt;
&lt;img src=&#34;https://bu.dusays.com/2023/05/29/64748c8482b68.png&#34; alt=&#34;3.png&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;h2 id=&#34;build&#34;&gt;build&lt;/h2&gt;
&lt;p&gt;添加 &lt;code&gt;Release&lt;/code&gt; 模块，并将 &lt;code&gt;Debug&lt;/code&gt; 和 &lt;code&gt;Release&lt;/code&gt; 模块移至 &lt;code&gt;build&lt;/code&gt; 目录下

&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://bu.dusays.com/2023/05/29/64748ec74bc6c.png&#34;&gt;
&lt;img src=&#34;https://bu.dusays.com/2023/05/29/64748ec74bc6c.png&#34; alt=&#34;1.png&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;



&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://bu.dusays.com/2023/05/29/64748ec74bc31.png&#34;&gt;
&lt;img src=&#34;https://bu.dusays.com/2023/05/29/64748ec74bc31.png&#34; alt=&#34;2.png&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;h2 id=&#34;include&#34;&gt;include&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;User.h&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;//  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;// Created by 24398 on 2023/5/29.  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;//  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#ifndef NEW_PROJECT_USER_H  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#define NEW_PROJECT_USER_H  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;# include &amp;lt;string&amp;gt;  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;class&lt;/span&gt; User {  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;private&lt;/span&gt;:  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; age{};  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std::string name{};  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;public&lt;/span&gt;:  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std::string get_name();  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;User(std::string name_);  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#endif &lt;/span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;//NEW_PROJECT_USER_H
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;src&#34;&gt;src&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;main.cpp&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;iostream&amp;gt;  &lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;#34;User.h&amp;#34;  &lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main() {  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;auto&lt;/span&gt; *user = &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;new&lt;/span&gt; User(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;John&amp;#34;&lt;/span&gt;);  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std::cout &amp;lt;&amp;lt; user-&amp;gt;get_name() &amp;lt;&amp;lt; std::endl;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;User.cpp&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;//  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;// Created by 24398 on 2023/5/29.  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;//  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;#34;User.h&amp;#34;  &lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;User::User(std::string name_): name(name_){};  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std::string User::get_name() {  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;this&lt;/span&gt;-&amp;gt;name;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;cmakeliststxt&#34;&gt;CMakelists.txt&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Cmake&#34; data-lang=&#34;Cmake&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;cmake_minimum_required&lt;/span&gt;(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;VERSION&lt;/span&gt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;3.25&lt;/span&gt;)  &lt;span style=&#34;color:#f00&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;project&lt;/span&gt;(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;new_project&lt;/span&gt;)  &lt;span style=&#34;color:#f00&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;# C++ 17  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;set&lt;/span&gt;(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;CMAKE_CXX_STANDARD&lt;/span&gt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;17&lt;/span&gt;)  &lt;span style=&#34;color:#f00&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;# 添加头文件  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;include_directories&lt;/span&gt;(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;include&lt;/span&gt;)  &lt;span style=&#34;color:#f00&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;# 添加源文件  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;aux_source_directory&lt;/span&gt;(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;./src&lt;/span&gt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;DIR_SRCS&lt;/span&gt;)  &lt;span style=&#34;color:#f00&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;# 所有需要编译的可执行文件  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;add_executable&lt;/span&gt;(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;new_project&lt;/span&gt; ${DIR_SRCS})&lt;span style=&#34;color:#f00&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;include_directories([AFTER|BEFORE] [SYSTEM] directory1 [directory2 ...])&lt;/code&gt;&lt;br&gt;
在这个例子中，命令&lt;code&gt;include_directories(include)&lt;/code&gt;表示你想将&lt;code&gt;include&lt;/code&gt;目录添加到包含路径中。这意味着编译器在编译源文件时会在&lt;code&gt;include&lt;/code&gt;目录中搜索头文件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;aux_source_directory(&amp;lt;dir&amp;gt; &amp;lt;variable&amp;gt;)&lt;/code&gt;&lt;br&gt;
在这个例子中，命令&lt;code&gt;aux_source_directory(src DIR_SRCS)&lt;/code&gt;表示你想从&lt;code&gt;./src&lt;/code&gt;目录收集所有的源文件，并将它们赋值给变量&lt;code&gt;DIR_SRCS&lt;/code&gt;。&lt;/p&gt;
</description>
      <content:encoded><![CDATA[<ul>
<li><a href="https://www.bilibili.com/video/BV1bd4y1D7on/?spm_id_from=333.788&amp;vd_source=ae16ff6478eb15c1b87880540263910b"># C/C++项目实战（前置知识）</a>
<ul>
<li><input disabled="" type="checkbox"> 单例模式</li>
<li><input disabled="" type="checkbox"> 工厂模式</li>
</ul>
</li>
<li><a href="https://www.yuque.com/jackyao/ifeq8i/vyigt9?#%20%E3%80%8AC/C++%E5%88%B7%E9%A2%98%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%E3%80%8B"># C/C++刷题常用技巧</a></li>
<li><input disabled="" type="checkbox"> <a href="https://www.bilibili.com/video/BV1XB4y1b7Fy/?spm_id_from=333.788&amp;vd_source=ae16ff6478eb15c1b87880540263910b"># C/C++项目实战（数据库）</a></li>
<li><input disabled="" type="checkbox"> <a href="https://github.com/SYaoJun/CPPInterview/blob/master/Basic/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.md"># 数据库原理</a></li>
</ul>
<h1 id="大纲">大纲</h1>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-markdown" data-lang="markdown"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">1.</span> 开发环境
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">-</span> Git     # 版本管理工具
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">-</span> Cmake   # 代码构建工具，管理源文件和依赖
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">-</span> Gcc     # 编译器
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">-</span> Clion   # 编辑器
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">-</span> Postman # 模拟客户端
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">-</span> MySQL(navicat)   # 在 docker Container 中起一个 mySQL 数据库，并可以在 navicat 中进行可视化操作
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">-</span> Docker  # 部署
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">1.</span> 目录结构
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">-</span> build   # 项目编译目录
</span></span><span style="display:flex;"><span>		<span style="color:#fff;font-weight:bold">-</span> debug 
</span></span><span style="display:flex;"><span>		<span style="color:#fff;font-weight:bold">-</span> release 
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">-</span> include # .h 头文件目录
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">-</span> src     # .cpp  源文件目录
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">-</span> docs    # 需求设计文档
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">-</span> others
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">2.</span> 设计模式
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">-</span> 单例模式
</span></span><span style="display:flex;"><span>		<span style="color:#fff;font-weight:bold">-</span> 构造函数私有
</span></span><span style="display:flex;"><span>		<span style="color:#fff;font-weight:bold">-</span> 实例只有一份
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">-</span> 工厂模式
</span></span><span style="display:flex;"><span>		<span style="color:#fff;font-weight:bold">-</span> 一个类别对应一个工厂
</span></span><span style="display:flex;"><span>		<span style="color:#fff;font-weight:bold">-</span> 不需要亲自创建对象，只需要从工厂中去取
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">3.</span> 数据库
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">-</span> MySQL 
</span></span><span style="display:flex;"><span>		<span style="color:#fff;font-weight:bold">-</span> 关系型
</span></span><span style="display:flex;"><span>		<span style="color:#fff;font-weight:bold">-</span> 支持事务
</span></span><span style="display:flex;"><span>		<span style="color:#fff;font-weight:bold">-</span> 行锁
</span></span><span style="display:flex;"><span>		<span style="color:#fff;font-weight:bold">-</span> 支持种存储引擎InnoDB，MyISAM，Memory
</span></span><span style="display:flex;"><span>		<span style="color:#fff;font-weight:bold">-</span> B+树索引
</span></span></code></pre></div><h1 id="init-project">init-project</h1>
<p>
<div class="post-img-view">
<a data-fancybox="gallery" href="https://bu.dusays.com/2023/05/29/64748c8482b68.png">
<img src="https://bu.dusays.com/2023/05/29/64748c8482b68.png" alt="3.png"  />
</a>
</div>

</p>
<h2 id="build">build</h2>
<p>添加 <code>Release</code> 模块，并将 <code>Debug</code> 和 <code>Release</code> 模块移至 <code>build</code> 目录下

<div class="post-img-view">
<a data-fancybox="gallery" href="https://bu.dusays.com/2023/05/29/64748ec74bc6c.png">
<img src="https://bu.dusays.com/2023/05/29/64748ec74bc6c.png" alt="1.png"  />
</a>
</div>



<div class="post-img-view">
<a data-fancybox="gallery" href="https://bu.dusays.com/2023/05/29/64748ec74bc31.png">
<img src="https://bu.dusays.com/2023/05/29/64748ec74bc31.png" alt="2.png"  />
</a>
</div>

</p>
<h2 id="include">include</h2>
<p><code>User.h</code></p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#007f7f">//  
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">// Created by 24398 on 2023/5/29.  
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">//  
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>  
</span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#ifndef NEW_PROJECT_USER_H  
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#define NEW_PROJECT_USER_H  
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold"># include &lt;string&gt;  
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold"></span>  
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">class</span> User {  
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">private</span>:  
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> age{};  
</span></span><span style="display:flex;"><span>std::string name{};  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span>:  
</span></span><span style="display:flex;"><span>std::string get_name();  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>User(std::string name_);  
</span></span><span style="display:flex;"><span>};  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#endif </span><span style="color:#007f7f">//NEW_PROJECT_USER_H
</span></span></span></code></pre></div><h2 id="src">src</h2>
<p><code>main.cpp</code></p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;iostream&gt;  </span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&#34;User.h&#34;  </span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold"></span>  
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> main() {  
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">auto</span> *user = <span style="color:#fff;font-weight:bold">new</span> User(<span style="color:#0ff;font-weight:bold">&#34;John&#34;</span>);  
</span></span><span style="display:flex;"><span>std::cout &lt;&lt; user-&gt;get_name() &lt;&lt; std::endl;  
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>User.cpp</code></p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#007f7f">//  
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">// Created by 24398 on 2023/5/29.  
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">//  
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&#34;User.h&#34;  </span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold"></span>  
</span></span><span style="display:flex;"><span>User::User(std::string name_): name(name_){};  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>std::string User::get_name() {  
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">this</span>-&gt;name;  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="cmakeliststxt">CMakelists.txt</h2>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Cmake" data-lang="Cmake"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">cmake_minimum_required</span>(<span style="color:#0ff;font-weight:bold">VERSION</span> <span style="color:#0ff;font-weight:bold">3.25</span>)  <span style="color:#f00">
</span></span></span><span style="display:flex;"><span><span style="color:#f00"></span><span style="color:#fff;font-weight:bold">project</span>(<span style="color:#0ff;font-weight:bold">new_project</span>)  <span style="color:#f00">
</span></span></span><span style="display:flex;"><span><span style="color:#f00"></span>  <span style="color:#f00">
</span></span></span><span style="display:flex;"><span><span style="color:#f00"></span><span style="color:#007f7f"># C++ 17  
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">set</span>(<span style="color:#0ff;font-weight:bold">CMAKE_CXX_STANDARD</span> <span style="color:#0ff;font-weight:bold">17</span>)  <span style="color:#f00">
</span></span></span><span style="display:flex;"><span><span style="color:#f00"></span><span style="color:#007f7f"># 添加头文件  
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">include_directories</span>(<span style="color:#0ff;font-weight:bold">include</span>)  <span style="color:#f00">
</span></span></span><span style="display:flex;"><span><span style="color:#f00"></span>  <span style="color:#f00">
</span></span></span><span style="display:flex;"><span><span style="color:#f00"></span><span style="color:#007f7f"># 添加源文件  
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">aux_source_directory</span>(<span style="color:#0ff;font-weight:bold">./src</span> <span style="color:#0ff;font-weight:bold">DIR_SRCS</span>)  <span style="color:#f00">
</span></span></span><span style="display:flex;"><span><span style="color:#f00"></span>  <span style="color:#f00">
</span></span></span><span style="display:flex;"><span><span style="color:#f00"></span><span style="color:#007f7f"># 所有需要编译的可执行文件  
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">add_executable</span>(<span style="color:#0ff;font-weight:bold">new_project</span> ${DIR_SRCS})<span style="color:#f00">
</span></span></span></code></pre></div><p><code>include_directories([AFTER|BEFORE] [SYSTEM] directory1 [directory2 ...])</code><br>
在这个例子中，命令<code>include_directories(include)</code>表示你想将<code>include</code>目录添加到包含路径中。这意味着编译器在编译源文件时会在<code>include</code>目录中搜索头文件。</p>
<p><code>aux_source_directory(&lt;dir&gt; &lt;variable&gt;)</code><br>
在这个例子中，命令<code>aux_source_directory(src DIR_SRCS)</code>表示你想从<code>./src</code>目录收集所有的源文件，并将它们赋值给变量<code>DIR_SRCS</code>。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>C&#43;&#43;中的Sort函数与Priority_queue优先队列</title>
      <link>https://xancoding.cn/posts/2023-04-24-14-17-47/</link>
      <pubDate>Mon, 24 Apr 2023 14:17:47 +0800</pubDate>
      
      <guid>https://xancoding.cn/posts/2023-04-24-14-17-47/</guid>
      <description>&lt;p&gt;当待排列的元素为一个对象时，我们既可以通过自定义比较函数，也可以通过重载运算符来达到目的。&lt;br&gt;
下面我以在对象中重载运算符来达到排序的目的展开说明。&lt;br&gt;
下面是针对 &lt;code&gt;sort函数&lt;/code&gt; 和 &lt;code&gt;Priority_queue优先队列&lt;/code&gt;，关于重载运算符所需要注意的要点&lt;/p&gt;
&lt;h1 id=&#34;结构体排序&#34;&gt;结构体排序&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;struct&lt;/span&gt; node{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; a, b;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#007f7f&#34;&gt;// 从小到大排序
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;operator&lt;/span&gt; &amp;lt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;const&lt;/span&gt; node&amp;amp; node_)&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;const&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt;(a != node_.a) &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; a &amp;lt; node_.a;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; b &amp;lt; node_.b;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main(){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    vector&amp;lt;node&amp;gt; tt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    tt.push_back({&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;5&lt;/span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    tt.push_back({&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;3&lt;/span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    sort(tt.begin(), tt.end());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;auto&lt;/span&gt; &amp;amp;node: tt){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        cout&amp;lt;&amp;lt;node.a&amp;lt;&amp;lt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;node.b&amp;lt;&amp;lt;endl;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;执行结果：
1 5
2 3
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;优先队列自定义排序&#34;&gt;优先队列自定义排序&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;struct&lt;/span&gt; node{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; a, b;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#007f7f&#34;&gt;// 在优先队列中，跟排序的规则是反的，这里是指a大的排在前面，a相同时，b大的排在前面
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;operator&lt;/span&gt; &amp;lt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;const&lt;/span&gt; node&amp;amp; node_)&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;const&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt;(a != node_.a) &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; a &amp;lt; node_.a;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; b &amp;lt; node_.b;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main(){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    priority_queue&amp;lt;node&amp;gt; pq;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    pq.push({&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;5&lt;/span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    pq.push({&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;3&lt;/span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    pq.push({&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;5&lt;/span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;while&lt;/span&gt;(!pq.empty()) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        cout&amp;lt;&amp;lt;pq.top().a&amp;lt;&amp;lt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;pq.top().b&amp;lt;&amp;lt;endl;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        pq.pop();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;执行结果： 
2 5
2 3
1 5
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;sort函数&#34;&gt;Sort函数&lt;/h1&gt;
&lt;p&gt;sort函数在默认情况下使用&lt;code&gt;std::less&lt;/code&gt;作为比较函数类，而&lt;code&gt;std::less&lt;/code&gt;定义了小于号&lt;code&gt;&amp;lt;&lt;/code&gt;运算符的重载。因此，在sort函数中如果不指定自定义的比较函数对象，就默认使用&lt;code&gt;std::less&lt;/code&gt;来进行排序，即升序排序。如果要实现降序排序，则需要提供自定义的比较函数对象，或者使用&lt;code&gt;std::greater&lt;/code&gt;作为比较函数类。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sort&lt;/code&gt;函数并不能直接重载大于号运算符。&lt;code&gt;sort&lt;/code&gt;函数默认使用小于号运算符来对元素进行排序，因此在对对象进行排序时，我们通常会&lt;strong&gt;重载小于号运算符&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当第一个元素 &amp;lt; 第二个元素时，为&lt;code&gt;true&lt;/code&gt;，则最终的排序结果为升序&lt;/p&gt;
&lt;p&gt;同理，当我把 &lt;code&gt;this-&amp;gt;age &amp;lt; other.age&lt;/code&gt; 修改为 &lt;code&gt;this-&amp;gt;age &amp;gt; other.age&lt;/code&gt;时，说明当第一个元素 &amp;gt; 第二个元素时，为&lt;code&gt;true&lt;/code&gt;，则结果为降序&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;  
#include &amp;lt;vector&amp;gt;  
using namespace std;  
  
// 定义一个自定义对象  
class Person {  
public:  
string name;  
int age;  
Person(string name, int age) {  
this-&amp;gt;name = name;  
this-&amp;gt;age = age;  
}  
  
// 第一个元素 &amp;lt; 第二个元素，true，升序  
bool operator&amp;lt; (const Person&amp;amp; other) const  
{  
return this-&amp;gt;age &amp;lt; other.age;  
}  
};  
  
int main() {  
// 创建一组Person对象并排序  
Person p1(&amp;#34;Alice&amp;#34;, 25);  
Person p2(&amp;#34;Bob&amp;#34;, 30);  
Person p3(&amp;#34;Charlie&amp;#34;, 20);  
  
vector&amp;lt;Person&amp;gt; people = {p1, p2, p3};  
sort(people.begin(), people.end());  
  
for (auto &amp;amp;p: people)  
{  
cout &amp;lt;&amp;lt; &amp;#34;Name:&amp;#34; &amp;lt;&amp;lt; p.name &amp;lt;&amp;lt; &amp;#39;\t&amp;#39; &amp;lt;&amp;lt; &amp;#34;Age:&amp;#34; &amp;lt;&amp;lt; p.age &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;  
}  
  
return 0;  
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Name:Charlie    Age:20
Name:Alice      Age:25
Name:Bob        Age:30
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过下述代码，我们可以在调用&lt;code&gt;sort&lt;/code&gt;时将比较函数类从默认的&lt;code&gt;std::less&lt;/code&gt;改为&lt;code&gt;std::greater&lt;/code&gt;，实现降序排序&amp;ndash;前提是记得在对象中重载大于运算符，否则编译器将会报错！！！&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sort(people.begin(), people.end(), greater&amp;lt;&amp;gt;());
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;priority_queue堆优先队列&#34;&gt;Priority_queue堆优先队列&lt;/h1&gt;
&lt;p&gt;堆是一种数据结构，可以用数组或树实现，常用于实现优先队列、排序算法等。&lt;/p&gt;
&lt;p&gt;优先队列（priority queue）就是堆（heap）的一种应用。&lt;/p&gt;
&lt;p&gt;C++中的优先队列实现就是堆优先队列，底层使用堆来实现。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;std::priority_queue&lt;/code&gt;是一个模板类，它的模板参数有三个，分别是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;T&lt;/code&gt;：指定队列中存储的元素类型。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Container&lt;/code&gt;：指定用于存储元素的容器类型，默认是&lt;code&gt;std::vector&amp;lt;T&amp;gt;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Compare&lt;/code&gt;：指定用于比较元素优先级的比较函数类型，默认是&lt;code&gt;std::less&amp;lt;T&amp;gt;&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;std::less&amp;lt;T&amp;gt;&lt;/code&gt;和&lt;code&gt;std::greater&amp;lt;T&amp;gt;&lt;/code&gt;是STL中预定义的两个比较函数类，分别表示小于和大于。它们重载了小于号运算符&lt;code&gt;&amp;lt;&lt;/code&gt;和大于号运算符&lt;code&gt;&amp;gt;&lt;/code&gt;，用于比较元素的优先级。因此，当我们在定义&lt;code&gt;std::priority_queue&lt;/code&gt;时，使用&lt;code&gt;std::less&amp;lt;T&amp;gt;&lt;/code&gt;作为比较函数类时，实际上是默认按照小于号进行比较元素优先级；而使用&lt;code&gt;std::greater&amp;lt;T&amp;gt;&lt;/code&gt;作为比较函数类时，则是按照大于号进行比较元素优先级。&lt;/p&gt;
&lt;p&gt;如果在使用&lt;code&gt;std::less&amp;lt;T&amp;gt;&lt;/code&gt;作为比较函数类时，重载大于号&lt;code&gt;&amp;gt;&lt;/code&gt;，或者在使用&lt;code&gt;std::greater&amp;lt;T&amp;gt;&lt;/code&gt;作为比较函数类时，重载小于号&lt;code&gt;&amp;lt;&lt;/code&gt;，都会导致编译错误，因为这些比较函数类内部的比较操作都是用小于号&lt;code&gt;&amp;lt;&lt;/code&gt;或者大于号&lt;code&gt;&amp;gt;&lt;/code&gt;实现的，而你重载了不符合预期的运算符，导致编译器无法正确地进行比较操作。&lt;/p&gt;
&lt;p&gt;在C++中，优先队列可以通过指定比较函数来控制是使用大根堆还是小根堆。如果使用 std::greater&amp;lt;&amp;gt; 作为比较函数，则意味着使用小根堆，即优先级高的元素会被放在队列的顶部；如果使用 std::less&amp;lt;&amp;gt; 作为比较函数，则意味着使用大根堆，即优先级高的元素会被放在队列的底部。&lt;/p&gt;
&lt;p&gt;堆中元素之间的优先级关系，这是通过定义比较函数来实现的，比较函数中使用 &lt;code&gt;greater&amp;lt;&amp;gt;&lt;/code&gt; 表示元素之间的优先级关系为第一个参数视为较小的元素；使用 &lt;code&gt;less&amp;lt;&amp;gt;&lt;/code&gt; 表示元素之间的优先级关系为第一个参数视为较大的元素。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;greater&amp;lt;&amp;gt;&lt;/code&gt; 作为比较函数时，会将元素之间的优先级关系视为第一个参数较小，也就是说，若 &lt;code&gt;greater&amp;lt;&amp;gt;&lt;/code&gt; 作为比较函数返回 true，则表示第二个参数优先级高于第一个参数，应当排在第一个参数之前。因此，这里的“将第一个参数视为较小的元素”指的是将第一个参数作为比较时的较小值，从而实现小根堆的效果。&lt;/p&gt;
&lt;p&gt;在一个二元比较函数中，第一个参数一般是被比较的左侧参数，第二个参数是被比较的右侧参数。比如在 &lt;code&gt;operator&amp;gt;&lt;/code&gt; 函数中，第一个参数就是使用 &lt;code&gt;&amp;gt;&lt;/code&gt; 运算符的左侧参数，第二个参数是右侧参数。在优先队列中，第一个参数也就是堆顶元素。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;  
#include &amp;lt;queue&amp;gt;  
#include &amp;lt;functional&amp;gt;  
using namespace std;  
  
class Person {  
public:  
string name;  
int age;  
  
Person(string name, int age) : name(name), age(age) {}  
  
bool operator&amp;gt;(const Person&amp;amp; other) const {  
return age &amp;gt; other.age;  
}  
};  
  
int main() {  
priority_queue&amp;lt;Person, vector&amp;lt;Person&amp;gt;, greater&amp;lt;&amp;gt;&amp;gt; pq;  
  
// 插入元素  
pq.push(Person(&amp;#34;张三&amp;#34;, 20));  
pq.push(Person(&amp;#34;李四&amp;#34;, 30));  
pq.push(Person(&amp;#34;王五&amp;#34;, 25));  
  
cout &amp;lt;&amp;lt; &amp;#34;这是一个小根堆！！！\n&amp;#34;;  
while (!pq.empty())  
{  
auto&amp;amp; p = pq.top();  
cout &amp;lt;&amp;lt; &amp;#34;Name:&amp;#34; &amp;lt;&amp;lt; p.name &amp;lt;&amp;lt; &amp;#39;\t&amp;#39; &amp;lt;&amp;lt; &amp;#34;Age:&amp;#34; &amp;lt;&amp;lt; p.age &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;  
pq.pop();  
}  
  
return 0;  
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;这是一个小根堆！！！
Name:张三       Age:20
Name:王五       Age:25
Name:李四       Age:30
&lt;/code&gt;&lt;/pre&gt;</description>
      <content:encoded><![CDATA[<p>当待排列的元素为一个对象时，我们既可以通过自定义比较函数，也可以通过重载运算符来达到目的。<br>
下面我以在对象中重载运算符来达到排序的目的展开说明。<br>
下面是针对 <code>sort函数</code> 和 <code>Priority_queue优先队列</code>，关于重载运算符所需要注意的要点</p>
<h1 id="结构体排序">结构体排序</h1>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">struct</span> node{
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> a, b;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 从小到大排序
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">bool</span> <span style="color:#fff;font-weight:bold">operator</span> &lt; (<span style="color:#fff;font-weight:bold">const</span> node&amp; node_)<span style="color:#fff;font-weight:bold">const</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">if</span>(a != node_.a) <span style="color:#fff;font-weight:bold">return</span> a &lt; node_.a;
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> b &lt; node_.b;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> main(){
</span></span><span style="display:flex;"><span>    vector&lt;node&gt; tt;
</span></span><span style="display:flex;"><span>    tt.push_back({<span style="color:#ff0;font-weight:bold">1</span>,<span style="color:#ff0;font-weight:bold">5</span>});
</span></span><span style="display:flex;"><span>    tt.push_back({<span style="color:#ff0;font-weight:bold">2</span>,<span style="color:#ff0;font-weight:bold">3</span>});
</span></span><span style="display:flex;"><span>    sort(tt.begin(), tt.end());
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span>(<span style="color:#fff;font-weight:bold">auto</span> &amp;node: tt){
</span></span><span style="display:flex;"><span>        cout&lt;&lt;node.a&lt;&lt;<span style="color:#0ff;font-weight:bold">&#34; &#34;</span>&lt;&lt;node.b&lt;&lt;endl;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code>执行结果：
1 5
2 3
</code></pre><h1 id="优先队列自定义排序">优先队列自定义排序</h1>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">struct</span> node{
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> a, b;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 在优先队列中，跟排序的规则是反的，这里是指a大的排在前面，a相同时，b大的排在前面
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">bool</span> <span style="color:#fff;font-weight:bold">operator</span> &lt; (<span style="color:#fff;font-weight:bold">const</span> node&amp; node_)<span style="color:#fff;font-weight:bold">const</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">if</span>(a != node_.a) <span style="color:#fff;font-weight:bold">return</span> a &lt; node_.a;
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> b &lt; node_.b;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> main(){
</span></span><span style="display:flex;"><span>    priority_queue&lt;node&gt; pq;
</span></span><span style="display:flex;"><span>    pq.push({<span style="color:#ff0;font-weight:bold">1</span>,<span style="color:#ff0;font-weight:bold">5</span>});
</span></span><span style="display:flex;"><span>    pq.push({<span style="color:#ff0;font-weight:bold">2</span>,<span style="color:#ff0;font-weight:bold">3</span>});
</span></span><span style="display:flex;"><span>    pq.push({<span style="color:#ff0;font-weight:bold">2</span>,<span style="color:#ff0;font-weight:bold">5</span>});
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">while</span>(!pq.empty()) {
</span></span><span style="display:flex;"><span>        cout&lt;&lt;pq.top().a&lt;&lt;<span style="color:#0ff;font-weight:bold">&#34; &#34;</span>&lt;&lt;pq.top().b&lt;&lt;endl;
</span></span><span style="display:flex;"><span>        pq.pop();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code>执行结果： 
2 5
2 3
1 5
</code></pre><h1 id="sort函数">Sort函数</h1>
<p>sort函数在默认情况下使用<code>std::less</code>作为比较函数类，而<code>std::less</code>定义了小于号<code>&lt;</code>运算符的重载。因此，在sort函数中如果不指定自定义的比较函数对象，就默认使用<code>std::less</code>来进行排序，即升序排序。如果要实现降序排序，则需要提供自定义的比较函数对象，或者使用<code>std::greater</code>作为比较函数类。</p>
<p><code>sort</code>函数并不能直接重载大于号运算符。<code>sort</code>函数默认使用小于号运算符来对元素进行排序，因此在对对象进行排序时，我们通常会<strong>重载小于号运算符</strong>。</p>
<p>当第一个元素 &lt; 第二个元素时，为<code>true</code>，则最终的排序结果为升序</p>
<p>同理，当我把 <code>this-&gt;age &lt; other.age</code> 修改为 <code>this-&gt;age &gt; other.age</code>时，说明当第一个元素 &gt; 第二个元素时，为<code>true</code>，则结果为降序</p>
<pre tabindex="0"><code>#include &lt;iostream&gt;  
#include &lt;vector&gt;  
using namespace std;  
  
// 定义一个自定义对象  
class Person {  
public:  
string name;  
int age;  
Person(string name, int age) {  
this-&gt;name = name;  
this-&gt;age = age;  
}  
  
// 第一个元素 &lt; 第二个元素，true，升序  
bool operator&lt; (const Person&amp; other) const  
{  
return this-&gt;age &lt; other.age;  
}  
};  
  
int main() {  
// 创建一组Person对象并排序  
Person p1(&#34;Alice&#34;, 25);  
Person p2(&#34;Bob&#34;, 30);  
Person p3(&#34;Charlie&#34;, 20);  
  
vector&lt;Person&gt; people = {p1, p2, p3};  
sort(people.begin(), people.end());  
  
for (auto &amp;p: people)  
{  
cout &lt;&lt; &#34;Name:&#34; &lt;&lt; p.name &lt;&lt; &#39;\t&#39; &lt;&lt; &#34;Age:&#34; &lt;&lt; p.age &lt;&lt; &#39;\n&#39;;  
}  
  
return 0;  
}
</code></pre><p>输出结果：</p>
<pre tabindex="0"><code>Name:Charlie    Age:20
Name:Alice      Age:25
Name:Bob        Age:30
</code></pre><p>通过下述代码，我们可以在调用<code>sort</code>时将比较函数类从默认的<code>std::less</code>改为<code>std::greater</code>，实现降序排序&ndash;前提是记得在对象中重载大于运算符，否则编译器将会报错！！！</p>
<pre tabindex="0"><code>sort(people.begin(), people.end(), greater&lt;&gt;());
</code></pre><h1 id="priority_queue堆优先队列">Priority_queue堆优先队列</h1>
<p>堆是一种数据结构，可以用数组或树实现，常用于实现优先队列、排序算法等。</p>
<p>优先队列（priority queue）就是堆（heap）的一种应用。</p>
<p>C++中的优先队列实现就是堆优先队列，底层使用堆来实现。</p>
<p><code>std::priority_queue</code>是一个模板类，它的模板参数有三个，分别是：</p>
<ol>
<li><code>T</code>：指定队列中存储的元素类型。</li>
<li><code>Container</code>：指定用于存储元素的容器类型，默认是<code>std::vector&lt;T&gt;</code>。</li>
<li><code>Compare</code>：指定用于比较元素优先级的比较函数类型，默认是<code>std::less&lt;T&gt;</code>。</li>
</ol>
<p><code>std::less&lt;T&gt;</code>和<code>std::greater&lt;T&gt;</code>是STL中预定义的两个比较函数类，分别表示小于和大于。它们重载了小于号运算符<code>&lt;</code>和大于号运算符<code>&gt;</code>，用于比较元素的优先级。因此，当我们在定义<code>std::priority_queue</code>时，使用<code>std::less&lt;T&gt;</code>作为比较函数类时，实际上是默认按照小于号进行比较元素优先级；而使用<code>std::greater&lt;T&gt;</code>作为比较函数类时，则是按照大于号进行比较元素优先级。</p>
<p>如果在使用<code>std::less&lt;T&gt;</code>作为比较函数类时，重载大于号<code>&gt;</code>，或者在使用<code>std::greater&lt;T&gt;</code>作为比较函数类时，重载小于号<code>&lt;</code>，都会导致编译错误，因为这些比较函数类内部的比较操作都是用小于号<code>&lt;</code>或者大于号<code>&gt;</code>实现的，而你重载了不符合预期的运算符，导致编译器无法正确地进行比较操作。</p>
<p>在C++中，优先队列可以通过指定比较函数来控制是使用大根堆还是小根堆。如果使用 std::greater&lt;&gt; 作为比较函数，则意味着使用小根堆，即优先级高的元素会被放在队列的顶部；如果使用 std::less&lt;&gt; 作为比较函数，则意味着使用大根堆，即优先级高的元素会被放在队列的底部。</p>
<p>堆中元素之间的优先级关系，这是通过定义比较函数来实现的，比较函数中使用 <code>greater&lt;&gt;</code> 表示元素之间的优先级关系为第一个参数视为较小的元素；使用 <code>less&lt;&gt;</code> 表示元素之间的优先级关系为第一个参数视为较大的元素。</p>
<p>使用 <code>greater&lt;&gt;</code> 作为比较函数时，会将元素之间的优先级关系视为第一个参数较小，也就是说，若 <code>greater&lt;&gt;</code> 作为比较函数返回 true，则表示第二个参数优先级高于第一个参数，应当排在第一个参数之前。因此，这里的“将第一个参数视为较小的元素”指的是将第一个参数作为比较时的较小值，从而实现小根堆的效果。</p>
<p>在一个二元比较函数中，第一个参数一般是被比较的左侧参数，第二个参数是被比较的右侧参数。比如在 <code>operator&gt;</code> 函数中，第一个参数就是使用 <code>&gt;</code> 运算符的左侧参数，第二个参数是右侧参数。在优先队列中，第一个参数也就是堆顶元素。</p>
<pre tabindex="0"><code>#include &lt;iostream&gt;  
#include &lt;queue&gt;  
#include &lt;functional&gt;  
using namespace std;  
  
class Person {  
public:  
string name;  
int age;  
  
Person(string name, int age) : name(name), age(age) {}  
  
bool operator&gt;(const Person&amp; other) const {  
return age &gt; other.age;  
}  
};  
  
int main() {  
priority_queue&lt;Person, vector&lt;Person&gt;, greater&lt;&gt;&gt; pq;  
  
// 插入元素  
pq.push(Person(&#34;张三&#34;, 20));  
pq.push(Person(&#34;李四&#34;, 30));  
pq.push(Person(&#34;王五&#34;, 25));  
  
cout &lt;&lt; &#34;这是一个小根堆！！！\n&#34;;  
while (!pq.empty())  
{  
auto&amp; p = pq.top();  
cout &lt;&lt; &#34;Name:&#34; &lt;&lt; p.name &lt;&lt; &#39;\t&#39; &lt;&lt; &#34;Age:&#34; &lt;&lt; p.age &lt;&lt; &#39;\n&#39;;  
pq.pop();  
}  
  
return 0;  
}
</code></pre><p>输出结果：</p>
<pre tabindex="0"><code>这是一个小根堆！！！
Name:张三       Age:20
Name:王五       Age:25
Name:李四       Age:30
</code></pre>]]></content:encoded>
    </item>
    
    <item>
      <title>Learning C&#43;&#43;</title>
      <link>https://xancoding.cn/posts/2022-11-15-12-54-07/</link>
      <pubDate>Tue, 15 Nov 2022 12:54:07 +0800</pubDate>
      
      <guid>https://xancoding.cn/posts/2022-11-15-12-54-07/</guid>
      <description>&lt;h2 id=&#34;数据类型大小&#34;&gt;数据类型大小&lt;/h2&gt;
&lt;p&gt;数据类型的大小取决于编译器和计算机体系结构！&lt;/p&gt;
&lt;p&gt;C++ 仅保证每个基本数据类型都具有最小大小

&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://bu.dusays.com/2022/11/26/6381d2545c3fa.png&#34;&gt;
&lt;img src=&#34;https://bu.dusays.com/2022/11/26/6381d2545c3fa.png&#34; alt=&#34;1&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;p&gt;为了获得最大的兼容性，您不应假设变量大于指定的最小大小&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;bool:&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\t\t&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;bool&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34; bytes&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;char:&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\t\t&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;char&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34; bytes&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;wchar_t:&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\t&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;wchar_t&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34; bytes&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;char16_t:&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\t&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;char16_t&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34; bytes&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;char32_t:&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\t&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;char32_t&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34; bytes&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;short:&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\t\t&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;short&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34; bytes&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;int:&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\t\t&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34; bytes&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;long:&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\t\t&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;long&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34; bytes&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;long long:&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\t&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;long&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34; bytes&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;float:&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\t\t&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;float&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34; bytes&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;double:&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\t\t&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;double&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34; bytes&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;long double:&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\t&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;double&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34; bytes&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;下面是我的 x64 机器的输出，使用 Clion：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;bool:           1 bytes
char:           1 bytes
wchar_t:        2 bytes
char16_t:       2 bytes
char32_t:       4 bytes
short:          2 bytes
int:            4 bytes
long:           4 bytes
long long:      8 bytes
float:          4 bytes
double:         8 bytes
long double:    16 bytes
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果您使用不同类型的机器或不同的编译器，您的结果可能会有所不同。请注意，您不能对 void 类型使用 sizeof 运算符，因为它没有大小（这样做会导致编译错误）&lt;/p&gt;
&lt;h2 id=&#34;无符号整数和有符号整数&#34;&gt;无符号整数和有符号整数&lt;/h2&gt;
&lt;p&gt;有符号整数范围：

&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://bu.dusays.com/2022/11/26/6381d81f385fa.png&#34;&gt;
&lt;img src=&#34;https://bu.dusays.com/2022/11/26/6381d81f385fa.png&#34; alt=&#34;1&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;p&gt;无符号整数范围：

&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://bu.dusays.com/2022/11/26/6381d91f961eb.png&#34;&gt;
&lt;img src=&#34;https://bu.dusays.com/2022/11/26/6381d91f961eb.png&#34; alt=&#34;1&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;p&gt;如果无符号整数超出范围，则将其除以大于该类型的最大数，只保留余数&lt;/p&gt;
&lt;p&gt;在 C++ 的数学运算中（例如算术或比较），如果使用一个有符号整数和一个无符号整数，则&lt;strong&gt;有符号整数将转换为无符号整数&lt;/strong&gt;。并且无符号整数不能存储负数，这会导致数据丢失&lt;/p&gt;
&lt;p&gt;在保存整数（甚至应该是非负的整数）和数学运算时，有符号数优于无符号数。避免混合有符号和无符号数字&lt;/p&gt;
&lt;p&gt;在 C++ 中仍然有一些情况必须使用无符号数：&lt;/p&gt;
&lt;p&gt;首先，在处理位操作时首选无符号数。当需要明确定义的环绕行为时，它们也很有用（在某些算法中很有用，例如加密和随机数生成）&lt;/p&gt;
&lt;p&gt;其次，无符号数的使用在某些情况下仍然是不可避免的，主要是那些与数组索引有关的情况。。在这些情况下，无符号值可以转换为有符号值&lt;/p&gt;
&lt;h2 id=&#34;固定宽度整数和-size_t&#34;&gt;固定宽度整数和 size_t&lt;/h2&gt;
&lt;h3 id=&#34;fixed-width-整数&#34;&gt;Fixed-width 整数&lt;/h3&gt;
&lt;p&gt;为什么整数变量的大小不固定？&lt;/p&gt;
&lt;p&gt;这可以追溯到 C，当时计算机速度很慢，性能是最受关注的问题。 C 选择有意保留整数的大小，以便编译器实现者可以选择在目标计算机体系结构上表现最佳的 int 大小&lt;/p&gt;
&lt;p&gt;C99 定义了一组固定宽度的整数（在 stdint.h 头文件中），保证在任何体系结构上都具有相同的大小&lt;/p&gt;
&lt;p&gt;C++ 正式采用这些固定宽度整数作为 C++11 的一部分。可以通过包含 &lt;code&gt;&amp;lt;cstdint&amp;gt;&lt;/code&gt; 头文件来访问它们，它们在 std 命名空间内定义&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://bu.dusays.com/2022/11/26/6381dcb67d0e0.png&#34;&gt;
&lt;img src=&#34;https://bu.dusays.com/2022/11/26/6381dcb67d0e0.png&#34; alt=&#34;1&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;h3 id=&#34;fast-and-least-整数&#34;&gt;Fast and least 整数&lt;/h3&gt;
&lt;p&gt;The fast 类型（&lt;code&gt;std::int_fast#_t&lt;/code&gt; 和 &lt;code&gt;std::uint_fast#_t&lt;/code&gt;）提供最快的有符号/无符号整数类型，宽度至少为 # 位（其中 # = 8、16、32 或 64）。例如，&lt;code&gt;std::int_fast32_t&lt;/code&gt; 将为您提供最快的至少 32 位的有符号整数类型&lt;/p&gt;
&lt;p&gt;The least 类型（&lt;code&gt;std::int_least#_t&lt;/code&gt; 和 &lt;code&gt;std::uint_least#_t&lt;/code&gt;）提供宽度至少为 # 位（其中 # = 8、16、32 或 64）的最小有符号/无符号整数类型。例如，&lt;code&gt;std::uint_least32_t&lt;/code&gt; 将为您提供至少 32 位的最小无符号整数类型&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;cstdint&amp;gt; // for fixed-width integers&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;least 8:  &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int_least8_t&lt;/span&gt;) * &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;8&lt;/span&gt; &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34; bits&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;least 16: &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int_least16_t&lt;/span&gt;) * &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;8&lt;/span&gt; &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34; bits&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;least 32: &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int_least32_t&lt;/span&gt;) * &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;8&lt;/span&gt; &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34; bits&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;fast 8:  &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int_fast8_t&lt;/span&gt;) * &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;8&lt;/span&gt; &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34; bits&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;fast 16: &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int_fast16_t&lt;/span&gt;) * &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;8&lt;/span&gt; &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34; bits&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;fast 32: &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int_fast32_t&lt;/span&gt;) * &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;8&lt;/span&gt; &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34; bits&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Result：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;least 8:  8 bits
least 16: 16 bits
least 32: 32 bits

fast 8:  8 bits
fast 16: 16 bits
fast 32: 32 bits
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然而，这些快速且最小的整数有其自身的缺点：首先，真正使用它们的程序员并不多，不熟悉会导致错误。其次，快速类型会导致与我们在 4 字节整数中看到的相同类型的内存浪费。最严重的是，由于快速/最小整数的大小可能会有所不同，因此您的程序可能会在解析为不同大小的架构上表现出不同的行为&lt;/p&gt;
&lt;h3 id=&#34;stdint8_t-和-stduint8_t-可能表现得像字符而不是整数&#34;&gt;std::int8_t 和 std::uint8_t 可能表现得像字符而不是整数&lt;/h3&gt;
&lt;p&gt;由于 C++ 规范中的疏忽，大多数编译器分别将 std::int8_t 和 std::uint8_t（以及相应的快速和最小固定宽度类型）定义为 signed char 和 unsigned char 类型，并将其视为相同的类型。这意味着这些 8 位类型的行为可能（或可能不）与其他固定宽度类型不同，这可能会导致错误。此行为是系统相关的，因此在一种体系结构上正确运行的程序可能无法编译或在另一种体系结构上正确运行&lt;/p&gt;
&lt;p&gt;为了保持一致性，最好完全避免使用 std::int8_t 和 std::uint8_t（以及相关的快速和最少类型）（改用 std::int16_t 或 std::uint16_t）&lt;/p&gt;
&lt;p&gt;8 位固定宽度整数类型通常被视为字符而不是整数值（这可能因系统而异）。大多数情况下首选 16 位固定整数类型&lt;/p&gt;
&lt;h3 id=&#34;best-practice&#34;&gt;Best practice&lt;/h3&gt;
&lt;p&gt;我们的立场是正确比快速更好，在编译时失败比运行时更好——因此，我们建议避免使用快速/最少的类型，而使用固定宽度的类型。如果您后来发现需要支持无法编译固定宽度类型的平台，那么您可以在此时决定如何迁移您的程序（并彻底测试）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当整数的大小无关紧要时，首选 int（例如，数字将始终适合 2 字节有符号整数的范围）。例如，如果您要求用户输入他们的年龄，或者从 1 数到 10，则 int 是 16 位还是 32 位都没有关系（数字将适合任何一种方式）。这将涵盖您可能遇到的绝大多数情况&lt;/li&gt;
&lt;li&gt;存储需要保证范围的数量时，首选 &lt;code&gt;std::int#_t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在进行位操作或需要明确定义的环绕行为时，首选 &lt;code&gt;std::uint#_t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;尽可能避免以下情况：
&lt;ol&gt;
&lt;li&gt;存储数量的无符号类型&lt;/li&gt;
&lt;li&gt;8 位固定宽度整数类型&lt;/li&gt;
&lt;li&gt;Fast and least 整数类型&lt;/li&gt;
&lt;li&gt;任何特定于编译器的固定宽度整数——例如，Visual Studio 定义了 &lt;code&gt;__int8&lt;/code&gt;、&lt;code&gt;__int16&lt;/code&gt; ……&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;size_t&#34;&gt;size_t&lt;/h3&gt;
&lt;p&gt;sizeof（以及许多返回大小或长度值的函数）返回一个 std::size_t 类型的值。 std::size_t 被定义为无符号整数类型，通常用于表示对象的大小或长度&lt;/p&gt;
&lt;p&gt;有趣的是，我们可以使用 sizeof 运算符（返回 std::size_t 类型的值）来询问 std::size_t 本身的大小：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;cstddef&amp;gt; // std::size_t&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;sizeof&lt;/span&gt;(std::size_t) &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;就像整数的大小会因系统而异一样，std::size_t 的大小也会有所不同。 std::size_t 保证为无符号且至少为 16 位，但在大多数系统上将等同于应用程序的地址宽度。也就是说，对于 32 位应用程序，std::size_t 通常是 32 位无符号整数，而对于 64 位应用程序，size_t 通常是 64 位无符号整数。 size_t 被定义为足够大以容纳系统上可创建的最大对象的大小（以字节为单位）。例如，如果 std::size_t 为 4 字节宽，则系统上可创建的最大对象不能大于 4,294,967,295 字节，因为 4,294,967,295 是 4 字节无符号整数可以存储的最大数字。这只是对象大小的上限，实际大小限制可能会更低，具体取决于您使用的编译器&lt;/p&gt;
&lt;p&gt;根据定义，任何大小（以字节为单位）大于 size_t 可以容纳的最大整数值的对象都被视为格式错误（并将导致编译错误），因为 sizeof 运算符将无法在不环绕的情况下返回大小&lt;/p&gt;
&lt;h2 id=&#34;浮点数ieee-754&#34;&gt;浮点数（IEEE 754）&lt;/h2&gt;
&lt;h3 id=&#34;浮点范围和浮点精度&#34;&gt;浮点范围和浮点精度&lt;/h3&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://bu.dusays.com/2022/11/26/63820f12cc479.png&#34;&gt;
&lt;img src=&#34;https://bu.dusays.com/2022/11/26/63820f12cc479.png&#34; alt=&#34;1&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;p&gt;使用浮点文字时，始终至少包含一位小数（即使小数为 0）。这有助于编译器理解该数字是浮点数而不是整数&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int x{5}; // 5 means integer
double y{5.0}; // 5.0 is a floating point literal (no suffix means double type by default)
float z{5.0f}; // 5.0 is a floating point literal, f suffix means float type
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;始终确保字面量的类型与分配给它们或用于初始化的变量的类型相匹配。否则会导致不必要的转换，可能会导致精度损失&lt;/p&gt;
&lt;p&gt;确保在应该使用浮点文字的地方不使用整数文字。这包括初始化浮点对象或为浮点对象赋值、进行浮点运算以及调用需要浮点值的函数&lt;/p&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://bu.dusays.com/2022/11/26/6382110b7d067.png&#34;&gt;
&lt;img src=&#34;https://bu.dusays.com/2022/11/26/6382110b7d067.png&#34; alt=&#34;&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;p&gt;输出浮点数时，std::cout 的默认精度为 6——也就是说，它假定所有浮点变量仅对 6 位有效（浮点数的最小精度），因此它将截断之后的任何内容&lt;/p&gt;
&lt;p&gt;浮点变量的精度位数取决于大小（浮点数的精度低于双精度数）和存储的特定值（某些值的精度高于其他值）。浮点值的精度在 6 到 9 位之间，大多数浮点值至少有 7 位有效数字。双精度值的精度在 15 到 18 位之间，大多数双精度值至少有 16 位有效数字。 Long double 的最小精度为 15、18 或 33 位有效数字，具体取决于它占用的字节数&lt;/p&gt;
&lt;h3 id=&#34;舍入误差&#34;&gt;舍入误差&lt;/h3&gt;
&lt;p&gt;我们可以使用名为 std::setprecision() 的输出操纵器函数覆盖 std::cout 显示的默认精度。输出操纵器改变数据的输出方式，并在 iomanip 标头中定义&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;iomanip&amp;gt; // for output manipulator std::setprecision()

int main()
{
    std::cout &amp;lt;&amp;lt; std::setprecision(16); // show 16 digits of precision
    std::cout &amp;lt;&amp;lt; 3.33333333333333333333333333333333333333f &amp;lt;&amp;lt;&amp;#39;\n&amp;#39;; // f suffix means float
    std::cout &amp;lt;&amp;lt; 3.33333333333333333333333333333333333333 &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; // no suffix means double

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在使用需要比变量所能容纳的精度更高的浮点数时，必须小心&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;除非空间非常宝贵，否则最好使用 double over float，因为 float 缺乏精度通常会导致不准确&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;值 123456789.0 具有 10 位有效数字，但浮点值通常具有 7 位精度（而 123456792 的结果仅精确到 7 位有效数字）。我们失去了一些精度！当由于无法精确存储数字而导致精度丢失时，这称为&lt;strong&gt;舍入误差&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数学运算（例如加法和乘法）往往会使舍入误差增大。所以即使0.1在第17位有效位有舍入误差，但是当我们加上0.1十次时，舍入误差已经爬到第16位有效位了。继续操作会导致此错误变得越来越严重&lt;/p&gt;
&lt;h3 id=&#34;nan-和-inf&#34;&gt;NaN 和 Inf&lt;/h3&gt;
&lt;p&gt;有两种特殊类别的浮点数。第一个是 &lt;code&gt;Inf&lt;/code&gt;，代表无穷大。 Inf 可以是正数或负数。第二个是 &lt;code&gt;NaN&lt;/code&gt;，代表“不是数字”。有几种不同类型的 NaN（我们不会在这里讨论）。 NaN 和 Inf 仅在编译器对浮点数使用特定格式 (IEEE 754) 时可用&lt;/p&gt;
&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;总而言之，关于浮点数你应该记住两件事：&lt;/p&gt;
&lt;p&gt;浮点数对于存储非常大或非常小的数字很有用，包括带有小数部分的数字&lt;/p&gt;
&lt;p&gt;浮点数通常有小的舍入误差，即使数字的有效数字少于精度也是如此。很多时候这些都没有引起注意，因为它们太小了，而且因为输出的数字被截断了。但是，浮点数的比较可能不会给出预期的结果。对这些值执行数学运算将导致舍入误差变大&lt;/p&gt;
&lt;h2 id=&#34;布尔值&#34;&gt;布尔值&lt;/h2&gt;
&lt;p&gt;如果您希望 std::cout 打印“true”或“false”而不是 0 或 1，您可以使用 std::boolalpha。这是一个例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;true&lt;/span&gt; &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;false&lt;/span&gt; &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::cout &amp;lt;&amp;lt; std::boolalpha; &lt;span style=&#34;color:#007f7f&#34;&gt;// print bools as true or false
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;true&lt;/span&gt; &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;false&lt;/span&gt; &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;您可以使用 std::noboolalpha 将其关闭&lt;/p&gt;
&lt;p&gt;您不能使用除 0 1 外的整数初始化布尔值：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;bool&lt;/span&gt; b{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;4&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// error: narrowing conversions disallowed
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;	std::cout &amp;lt;&amp;lt; b;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;但是，在任何可以将整数转换为布尔值的上下文中，整数 0 将转换为 false，而任何其他整数将转换为 true&lt;/p&gt;
&lt;p&gt;事实证明，std::cin 只接受布尔变量的两个输入：0 和 1（不是 true 或 false）。任何其他输入都会导致 std::cin 无声地失败。在这种情况下，因为我们输入了 true，所以 std::cin 默默地失败了。失败的输入也会将变量清零，因此 b 也被赋值 false。因此，当 std::cout 打印 b 的值时，它打印 0&lt;/p&gt;
&lt;p&gt;要允许 std::cin 接受“false”和“true”作为输入，必须启用 std::boolalpha 选项：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;bool&lt;/span&gt; b{};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Enter a boolean value: &amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#007f7f&#34;&gt;// Allow the user to enter &amp;#39;true&amp;#39; or &amp;#39;false&amp;#39; for boolean values
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#007f7f&#34;&gt;// This is case-sensitive, so True or TRUE will not work
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;	std::cin &amp;gt;&amp;gt; std::boolalpha;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	std::cin &amp;gt;&amp;gt; b;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;You entered: &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;但是，当启用 std::boolalpha 时，“0”和“1”将不再被视为布尔值&lt;/p&gt;
&lt;h2 id=&#34;chars&#34;&gt;Chars&lt;/h2&gt;
&lt;p&gt;char 数据类型旨在保存单个字符。字符可以是单个字母、数字、符号或空格&lt;/p&gt;
&lt;p&gt;char 数据类型是整数类型，这意味着基础值存储为整数。类似于布尔值 0 被解释为 false 而非零被解释为 true 的方式，char 变量存储的整数被解释为 ASCII 字符&lt;/p&gt;
&lt;p&gt;Char 由 C++ 定义为大小始终为 1 个字节。默认情况下，char 可以是有符号的或无符号的（尽管它通常是有符号的）。如果您使用 chars 来保存 ASCII 字符，则不需要指定符号（因为有符号和无符号字符都可以保存 0 到 127 之间的值）&lt;/p&gt;
&lt;p&gt;如果您使用 char 来保存小整数（除非您明确优化空间，否则您不应该这样做），您应该始终指定它是有符号的还是无符号的。 signed char 可以保存 -128 到 127 之间的数字。unsigned char 可以保存 0 到 255 之间的数字&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;将单个字符放在单引号中（ e.g. &lt;code&gt;&#39;t&#39;&lt;/code&gt; or &lt;code&gt;&#39;\n&#39;&lt;/code&gt;, not &lt;code&gt;&amp;quot;t&amp;quot;&lt;/code&gt; or &lt;code&gt;&amp;quot;\n&amp;quot;&lt;/code&gt;）这有助于编译器更有效地进行优化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;出于向后兼容性的原因，许多 C++ 编译器支持多字符文字，即包含多个字符（例如“56”）的字符文字。如果支持，它们具有实现定义的值（意味着它因编译器而异）。因为它们不是 C++ 标准的一部分，而且它们的值也没有严格定义，所以应该避免使用多字符文字&lt;/p&gt;
&lt;p&gt;ASCII 之外最著名的映射是 Unicode 标准，它将超过 144,000 个整数映射到许多不同语言的字符。由于 Unicode 包含如此多的代码点，因此单个 Unicode 代码点需要 32 位来表示一个字符（称为 UTF-32）。但是，Unicode 字符也可以使用多个 16 位或 8 位字符（分别称为 UTF-16 和 UTF-8）进行编码&lt;/p&gt;
&lt;p&gt;char16_t 和 char32_t 添加到 C++11 以提供对 16 位和 32 位 Unicode 字符的明确支持。 C++20 中添加了 char8_t&lt;/p&gt;
&lt;p&gt;您不需要使用 char8_t、char16_t 或 char32_t，除非您计划让您的程序与 Unicode 兼容&lt;/p&gt;
&lt;p&gt;同时，在处理字符（和字符串）时，您应该只使用 ASCII 字符。使用来自其他字符集的字符可能会导致您的字符显示不正确&lt;/p&gt;
&lt;h2 id=&#34;常量和符号常量&#34;&gt;常量和符号常量&lt;/h2&gt;
&lt;h3 id=&#34;const-variables&#34;&gt;const variables&lt;/h3&gt;
&lt;p&gt;Const 变量必须在定义它们时进行初始化，然后不能通过赋值更改该值&lt;/p&gt;
&lt;p&gt;Const 变量可以从其他变量（包括非常量变量）初始化&lt;/p&gt;
&lt;p&gt;命名时以 “k” 开头, 大小写混合,例如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;const int kDaysInAWeek = 7;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;符号常量&#34;&gt;符号常量&lt;/h3&gt;
&lt;p&gt;符号常量指的是&lt;strong&gt;被赋予常量值的名称&lt;/strong&gt;。&lt;code&gt;const variables&lt;/code&gt; 是一种符号常量，因为变量有一个名称（它的标识符）和一个常量值&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#define MAX_STUDENTS_PER_CLASS 30
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;The class has &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; MAX_STUDENTS_PER_CLASS &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34; students.&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;编译此程序时，预处理器会将 MAX_STUDENTS_PER_CLASS 替换为字面值 30，然后编译器会将其编译为您的可执行文件&lt;/p&gt;
&lt;p&gt;因为类对象宏有一个名字，并且替换文本是一个常量值，所以带有替换文本的类对象宏也是符号常量&lt;/p&gt;
&lt;h3 id=&#34;对于符号常量更喜欢常量变量而不是类对象宏&#34;&gt;对于符号常量，更喜欢常量变量而不是类对象宏&lt;/h3&gt;
&lt;p&gt;首先，因为宏是由预处理器解析的，所有出现的宏都在编译之前被定义的值替换。如果您正在调试代码，您将看不到实际值（例如 30）——您只会看到符号常量的名称（例如 MAX_STUDENTS_PER_CLASS）。因为这些#defined 值不是变量，所以您无法在调试器中添加监视来查看它们的值。如果您想知道 MAX_STUDENTS_PER_CLASS 解析为什么值，您必须找到 MAX_STUDENTS_PER_CLASS 的定义（可能在不同的文件中）。这会使您的程序更难调试&lt;/p&gt;
&lt;p&gt;其次，宏可能与普通代码有命名冲突&lt;/p&gt;
&lt;p&gt;第三，宏不遵循正常的作用域规则，这意味着在极少数情况下，在程序的一部分中定义的宏可能会与在程序的另一部分中编写的代码发生冲突，而它不应该与之交互&lt;/p&gt;
&lt;h2 id=&#34;编译时常量常量表达式和-constexpr&#34;&gt;编译时常量、常量表达式和 constexpr&lt;/h2&gt;
&lt;h3 id=&#34;constant-expressions&#34;&gt;Constant expressions&lt;/h3&gt;
&lt;p&gt;常量表达式是可以在编译时由编译器求值的表达式。要成为常量表达式，表达式中的所有值必须在编译时已知（并且所有调用的运算符和函数必须支持编译时求值）&lt;/p&gt;
&lt;p&gt;在编译时对常量表达式求值会使我们的编译时间变长（因为编译器必须做更多的工作），但这样的表达式只需要求值一次（而不是每次程序运行时）。生成的可执行文件速度更快，使用的内存更少&lt;/p&gt;
&lt;h3 id=&#34;compile-time-constants&#34;&gt;Compile-time constants&lt;/h3&gt;
&lt;p&gt;编译时常量是其值在编译时已知的常量。文字（例如“1”、“2.3”和“Hello, world!”）是一种编译时常量&lt;/p&gt;
&lt;p&gt;Const 变量可能是也可能不是编译时常量&lt;/p&gt;
&lt;h3 id=&#34;compile-time-const&#34;&gt;Compile-time const&lt;/h3&gt;
&lt;p&gt;如果 const 变量的初始值设定项是常量表达式，则它是编译时常量&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; x { &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;3&lt;/span&gt; };  &lt;span style=&#34;color:#007f7f&#34;&gt;// x is a compile-time const
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; y { &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;4&lt;/span&gt; };  &lt;span style=&#34;color:#007f7f&#34;&gt;// y is a compile-time const
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; z { x + y }; &lt;span style=&#34;color:#007f7f&#34;&gt;// x + y is a compile-time expression
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	std::cout &amp;lt;&amp;lt; z &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;因为 x 和 y 的初始化值是常量表达式，所以 x 和 y 是编译时常量。这意味着 x + y 也是常量表达式。所以当编译器编译这个程序时，它可以计算 x + y 的值，并将常量表达式替换为结果文字 7&lt;/p&gt;
&lt;h3 id=&#34;runtime-const&#34;&gt;Runtime const&lt;/h3&gt;
&lt;p&gt;任何使用非常量表达式初始化的 const 变量都是运行时常量。运行时常量是其初始化值直到运行时才知道的常量&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; getNumber()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Enter a number: &amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; y{};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::cin &amp;gt;&amp;gt; y;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; y;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; x{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;3&lt;/span&gt; };           &lt;span style=&#34;color:#007f7f&#34;&gt;// x is a compile time constant
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; y{ getNumber() }; &lt;span style=&#34;color:#007f7f&#34;&gt;// y is a runtime constant
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; z{ x + y };       &lt;span style=&#34;color:#007f7f&#34;&gt;// x + y is a runtime expression
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    std::cout &amp;lt;&amp;lt; z &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;;     &lt;span style=&#34;color:#007f7f&#34;&gt;// this is also a runtime expression
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;即使 y 是常量，初始化值（getNumber() 的返回值）直到运行时才知道。因此，y 是运行时常量，而不是编译时常量。因此，表达式 x + y 是一个运行时表达式&lt;/p&gt;
&lt;h3 id=&#34;constexpr-关键字&#34;&gt;constexpr 关键字&lt;/h3&gt;
&lt;p&gt;当你声明一个 const 变量时，编译器会隐式地跟踪它是运行时常量还是编译时常量。在大多数情况下，除了优化目的之外，这无关紧要，但有一些奇怪的情况，C++ 需要编译时常量而不是运行时常量&lt;/p&gt;
&lt;p&gt;因为编译时常量通常允许更好的优化（并且几乎没有缺点），所以我们通常希望尽可能使用编译时常量&lt;/p&gt;
&lt;p&gt;我们可以寻求编译器的帮助，以确保我们得到一个我们期望的编译时常量。为此，我们在变量声明中使用 constexpr 关键字而不是 const。 constexpr（“常量表达式”的缩写）变量只能是编译时常量。如果 constexpr 变量的初始化值不是常量表达式，编译器会出错&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; five()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;5&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;double&lt;/span&gt; gravity { &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;9.8&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// ok: 9.8 is a constant expression
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; sum { &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;4&lt;/span&gt; + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;5&lt;/span&gt; };      &lt;span style=&#34;color:#007f7f&#34;&gt;// ok: 4 + 5 is a constant expression
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; something { sum };  &lt;span style=&#34;color:#007f7f&#34;&gt;// ok: sum is a constant expression
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Enter your age: &amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; age{};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::cin &amp;gt;&amp;gt; age;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; myAge { age };      &lt;span style=&#34;color:#007f7f&#34;&gt;// compile error: age is not a constant expression
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; f { five() };       &lt;span style=&#34;color:#007f7f&#34;&gt;// compile error: return value of five() is not a constant expression
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;任何在初始化后不应修改且其初始值设定项在编译时已知的变量都应声明为 &lt;code&gt;constexpr&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;任何在初始化后不应修改且其初始值设定项在编译时未知的变量都应声明为 &lt;code&gt;const&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;literals&#34;&gt;Literals&lt;/h2&gt;
&lt;p&gt;文字是直接插入代码中的未命名值。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;5&lt;/span&gt;;                   &lt;span style=&#34;color:#007f7f&#34;&gt;// 5 is an integer literal
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;bool&lt;/span&gt; myNameIsAlex { &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;true&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// true is a boolean literal
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;3.4&lt;/span&gt;;           &lt;span style=&#34;color:#007f7f&#34;&gt;// 3.4 is a double literal
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如对象有类型一样，所有文字都有类型。文字的类型是从文字的值推导出来的&lt;/p&gt;
&lt;h2 id=&#34;十进制二进制十六进制和八进制&#34;&gt;十进制、二进制、十六进制和八进制&lt;/h2&gt;
&lt;h3 id=&#34;二进制文字和数字分隔符&#34;&gt;二进制文字和数字分隔符&lt;/h3&gt;
&lt;p&gt;在 C++14 之前，不支持二进制文字。然而，十六进制文字为我们提供了一个有用的解决方法（您可能仍会在现有代码库中看到）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; bin{};    &lt;span style=&#34;color:#007f7f&#34;&gt;// assume 16-bit ints
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    bin = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x0001&lt;/span&gt;; &lt;span style=&#34;color:#007f7f&#34;&gt;// assign binary 0000 0000 0000 0001 to the variable
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    bin = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x0002&lt;/span&gt;; &lt;span style=&#34;color:#007f7f&#34;&gt;// assign binary 0000 0000 0000 0010 to the variable
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    bin = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x0004&lt;/span&gt;; &lt;span style=&#34;color:#007f7f&#34;&gt;// assign binary 0000 0000 0000 0100 to the variable
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    bin = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x0008&lt;/span&gt;; &lt;span style=&#34;color:#007f7f&#34;&gt;// assign binary 0000 0000 0000 1000 to the variable
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    bin = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x0010&lt;/span&gt;; &lt;span style=&#34;color:#007f7f&#34;&gt;// assign binary 0000 0000 0001 0000 to the variable
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    bin = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x0020&lt;/span&gt;; &lt;span style=&#34;color:#007f7f&#34;&gt;// assign binary 0000 0000 0010 0000 to the variable
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    bin = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x0040&lt;/span&gt;; &lt;span style=&#34;color:#007f7f&#34;&gt;// assign binary 0000 0000 0100 0000 to the variable
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    bin = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x0080&lt;/span&gt;; &lt;span style=&#34;color:#007f7f&#34;&gt;// assign binary 0000 0000 1000 0000 to the variable
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    bin = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x00FF&lt;/span&gt;; &lt;span style=&#34;color:#007f7f&#34;&gt;// assign binary 0000 0000 1111 1111 to the variable
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    bin = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x00B3&lt;/span&gt;; &lt;span style=&#34;color:#007f7f&#34;&gt;// assign binary 0000 0000 1011 0011 to the variable
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    bin = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0xF770&lt;/span&gt;; &lt;span style=&#34;color:#007f7f&#34;&gt;// assign binary 1111 0111 0111 0000 to the variable
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 C++14 中，我们可以通过使用 0b 前缀来使用二进制文字：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; bin{};        &lt;span style=&#34;color:#007f7f&#34;&gt;// assume 16-bit ints
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    bin = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b1&lt;/span&gt;;        &lt;span style=&#34;color:#007f7f&#34;&gt;// assign binary 0000 0000 0000 0001 to the variable
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    bin = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b11&lt;/span&gt;;       &lt;span style=&#34;color:#007f7f&#34;&gt;// assign binary 0000 0000 0000 0011 to the variable
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    bin = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b1010&lt;/span&gt;;     &lt;span style=&#34;color:#007f7f&#34;&gt;// assign binary 0000 0000 0000 1010 to the variable
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    bin = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b11110000&lt;/span&gt;; &lt;span style=&#34;color:#007f7f&#34;&gt;// assign binary 0000 0000 1111 0000 to the variable
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;由于长文本可能难以阅读，C++14 还添加了使用引号 (‘) 作为数字分隔符的功能（分隔符不能出现在值的第一位数字之前）（数字分隔符纯粹是视觉上的，不会以任何方式影响字面值）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; bin { &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b1011&amp;#39;0010&lt;/span&gt; };  &lt;span style=&#34;color:#007f7f&#34;&gt;// assign binary 1011 0010 to the variable
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;long&lt;/span&gt; value { &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&amp;#39;132&amp;#39;673&amp;#39;462&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// much easier to read than 2132673462
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;以十进制八进制或十六进制输出值&#34;&gt;以十进制、八进制或十六进制输出值&lt;/h3&gt;
&lt;p&gt;默认情况下，C++ 以十进制形式输出值。但是，您可以通过使用 std::dec、std::oct 和 std::hex I/O 操纵器更改输出格式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; x { &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;12&lt;/span&gt; };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;; &lt;span style=&#34;color:#007f7f&#34;&gt;// decimal (by default)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    std::cout &amp;lt;&amp;lt; std::hex &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;; &lt;span style=&#34;color:#007f7f&#34;&gt;// hexadecimal
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;; &lt;span style=&#34;color:#007f7f&#34;&gt;// now hexadecimal
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    std::cout &amp;lt;&amp;lt; std::oct &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;; &lt;span style=&#34;color:#007f7f&#34;&gt;// octal
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    std::cout &amp;lt;&amp;lt; std::dec &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;; &lt;span style=&#34;color:#007f7f&#34;&gt;// return to decimal
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;; &lt;span style=&#34;color:#007f7f&#34;&gt;// decimal
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;以二进制输出值&#34;&gt;以二进制输出值&lt;/h3&gt;
&lt;p&gt;以二进制形式输出值有点困难，因为 std::cout 没有内置此功能。幸运的是，C++ 标准库包含一个名为 std::bitset 的类型，它将为我们完成此操作（在 &lt;code&gt;&amp;lt;bitset&amp;gt;&lt;/code&gt; 标头中）。要使用 std::bitset，我们可以定义一个 std::bitset 变量并告诉 std::bitset 我们要存储多少位。位数必须是编译时常量。 std::bitset 可以用无符号整数值（任何格式，包括十进制、八进制、十六进制或二进制）初始化&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;bitset&amp;gt; // for std::bitset&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#007f7f&#34;&gt;// std::bitset&amp;lt;8&amp;gt; means we want to store 8 bits
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;	std::bitset&amp;lt;&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;8&lt;/span&gt;&amp;gt; bin1{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b1100&amp;#39;0101&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// binary literal for binary 1100 0101
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;	std::bitset&amp;lt;&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;8&lt;/span&gt;&amp;gt; bin2{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0xC5&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// hexadecimal literal for binary 1100 0101
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	std::cout &amp;lt;&amp;lt; bin1 &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt; &amp;lt;&amp;lt; bin2 &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	std::cout &amp;lt;&amp;lt; std::bitset&amp;lt;&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;4&lt;/span&gt;&amp;gt;{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b1010&lt;/span&gt; } &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;; &lt;span style=&#34;color:#007f7f&#34;&gt;// create a temporary std::bitset and print it
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;stdstring&#34;&gt;std::string&lt;/h2&gt;
&lt;h3 id=&#34;使用-stdgetline-输入文本&#34;&gt;使用 std::getline() 输入文本&lt;/h3&gt;
&lt;p&gt;事实证明，当使用 operator&amp;raquo; 从 std::cin 中提取字符串时，operator&amp;raquo; 只返回它遇到的第一个空格之前的字符。任何其他字符都留在 std::cin 中，等待下一次提取&lt;/p&gt;
&lt;p&gt;要将整行输入读入字符串，最好改用 &lt;code&gt;std::getline()&lt;/code&gt; 函数。 std::getline() 需要两个参数：第一个是 std::cin，第二个是您的字符串变量&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;string&amp;gt; // For std::string and std::getline&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Enter your full name: &amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::string name{};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::getline(std::cin &amp;gt;&amp;gt; std::ws, name); &lt;span style=&#34;color:#007f7f&#34;&gt;// read a full line of text into name
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Enter your age: &amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::string age{};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::getline(std::cin &amp;gt;&amp;gt; std::ws, age); &lt;span style=&#34;color:#007f7f&#34;&gt;// read a full line of text into age
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Your name is &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34; and your age is &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; age &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;std::ws&lt;/code&gt; 输入操纵器告诉 std::cin 在提取之前&lt;strong&gt;忽略任何前导空格&lt;/strong&gt;。前导空白是出现在字符串开头的任何空白字符（空格、制表符、换行符）&lt;/p&gt;
&lt;p&gt;如果使用 &lt;code&gt;std::getline()&lt;/code&gt; 读取字符串，请使用 &lt;code&gt;std::cin &amp;gt;&amp;gt; std::ws&lt;/code&gt; 输入操纵器忽略前导空格&lt;/p&gt;
&lt;p&gt;将提取运算符 (&amp;raquo;) 与 std::cin 一起使用会忽略前导空格&lt;/p&gt;
&lt;p&gt;std::getline() 不会忽略前导空格，除非您使用输入操纵器 std::ws&lt;/p&gt;
&lt;h3 id=&#34;字符串长度&#34;&gt;字符串长度&lt;/h3&gt;
&lt;p&gt;如果我们想知道 std::string 中有多少个字符，我们可以向 std::string 对象询问它的长度。注意 std::string::length() 返回一个无符号整数值（很可能是 size_t 类型）。如果你想将长度分配给一个 int 变量，你应该对其进行 static_cast 以避免编译器关于有符号/无符号转换的警告：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; length { &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;static_cast&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt;&amp;gt;(name.length()) };
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;stdstring-的初始化和复制开销很大&#34;&gt;std::string 的初始化和复制开销很大&lt;/h3&gt;
&lt;p&gt;每当初始化 std::string 时，都会生成用于初始化它的字符串的副本。每当 std::string 按值传递给 std::string 参数时，都会生成另一个副本。不要按值传递 std::string，因为生成 std::string 的副本开销很大。更喜欢 std::string_view 参数&lt;/p&gt;
&lt;h3 id=&#34;literals-forstdstring--stdstring_view&#34;&gt;Literals for &lt;code&gt;std::string&lt;/code&gt; &amp;amp; &lt;code&gt;std::string_view&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;双引号字符串文字（比如“Hello, world!”）默认是 C 风格的字符串&lt;/p&gt;
&lt;p&gt;我们可以通过在双引号字符串文字后使用 s 后缀来创建类型为 std::string 的字符串文字&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;string&amp;gt;      // for std::string&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;string_view&amp;gt; // for std::string_view&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;namespace&lt;/span&gt; std::literals; &lt;span style=&#34;color:#007f7f&#34;&gt;// easiest way to access the s and sv suffixes
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;foo&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;;   &lt;span style=&#34;color:#007f7f&#34;&gt;// no suffix is a C-style string literal
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;goo&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;s;  &lt;span style=&#34;color:#007f7f&#34;&gt;// s suffix is a std::string literal
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;moo&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;sv; &lt;span style=&#34;color:#007f7f&#34;&gt;// sv suffix is a std::string_view literal
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;“s”后缀位于命名空间 std::literals::string_literals 中。“sv”后缀位于命名空间 std::literals::string_view_literals 中。访问文字后缀的最简单方法是通过使用指令使用命名空间 std::literals。这是可以使用整个命名空间的例外情况之一，因为其中定义的后缀不太可能与您的任何代码冲突&lt;/p&gt;
&lt;p&gt;你可能不需要经常使用 std::string 文字（因为用 C 风格的字符串文字初始化 std::string 对象很好），但我们会在以后的课程中看到一些使用 std 的情况::string literals 而不是 C 风格的 string literals 使事情变得更容易&lt;/p&gt;
&lt;h3 id=&#34;constexpr-字符串&#34;&gt;Constexpr 字符串&lt;/h3&gt;
&lt;p&gt;如果您尝试定义一个 constexpr std::string，您的编译器可能会产生一个错误&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;namespace&lt;/span&gt; std::literals;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::string name{ &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Alex&amp;#34;&lt;/span&gt;s }; &lt;span style=&#34;color:#007f7f&#34;&gt;// compile error
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;My name is: &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; name;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;发生这种情况是因为 constexpr std::string 在 C++17 或更早版本中不受支持，并且在 C++20 中仅提供最低限度的支持。如果您需要 constexpr 字符串，请改用 std::string_view&lt;/p&gt;
&lt;h2 id=&#34;stdstring_view&#34;&gt;std::string_view&lt;/h2&gt;
&lt;h3 id=&#34;stdstring_view-c17&#34;&gt;std::string_view C++17&lt;/h3&gt;
&lt;p&gt;为了解决 std::string 初始化（或复制）成本高昂的问题，C++17 引入了 std::string_view（位于 &amp;lt;string_view&amp;gt; 标头中）。 std::string_view 提供对现有字符串（C 风格字符串文字、std::string 或 char 数组）的只读访问，而无需制作副本&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;string_view&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt; printSV(std::string_view str) &lt;span style=&#34;color:#007f7f&#34;&gt;// now a std::string_view
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::cout &amp;lt;&amp;lt; str &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::string_view s{ &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Hello, world!&amp;#34;&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// now a std::string_view
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    printSV(s);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当我们用 C 风格的字符串文字“Hello, world!”初始化 std::string_view s 时，s 提供对“Hello, world!”的只读访问。无需复制字符串。当我们将 s 传递给 printSV() 时，参数 str 从 s 初始化。这使我们能够通过 str 访问“Hello, world!”，不用再次复制字符串&lt;/p&gt;
&lt;p&gt;当您需要只读字符串时，尤其是对于函数参数，优先使用 std::string_view 而不是 std::string&lt;/p&gt;
&lt;h3 id=&#34;constexpr-stdstring_view&#34;&gt;constexpr std::string_view&lt;/h3&gt;
&lt;p&gt;std::string_view 完全支持 constexpr：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;string_view&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::string_view s{ &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Hello, world!&amp;#34;&lt;/span&gt; };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;; &lt;span style=&#34;color:#007f7f&#34;&gt;// s will be replaced with &amp;#34;Hello, world!&amp;#34; at compile-time
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;stdstring--stdstring_view&#34;&gt;std::string &amp;amp; std::string_view&lt;/h3&gt;
&lt;p&gt;可以使用 std::string 初始值设定项创建 std::string_view，并且 std::string 将隐式转换为 std::string_view：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;string_view&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt; printSV(std::string_view str)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::cout &amp;lt;&amp;lt; str &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::string s{ &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Hello, world&amp;#34;&lt;/span&gt; };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::string_view sv{ s }; &lt;span style=&#34;color:#007f7f&#34;&gt;// Initialize a std::string_view from a std::string
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    std::cout &amp;lt;&amp;lt; sv &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    printSV(s); &lt;span style=&#34;color:#007f7f&#34;&gt;// implicitly convert a std::string to std::string_view
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;因为 std::string 复制了它的初始化器（这开销很大），C++ 不允许将 std::string_view 隐式转换为 std::string。但是，我们可以使用 std::string_view 初始值设定项显式创建 std::string，或者我们可以使用 static_cast 将现有的 std::string_view 转换为 std::string&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;string_view&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt; printString(std::string str)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::cout &amp;lt;&amp;lt; str &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  std::string_view sv{ &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;balloon&amp;#34;&lt;/span&gt; };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  std::string str{ sv }; &lt;span style=&#34;color:#007f7f&#34;&gt;// okay, we can create std::string using std::string_view initializer
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#007f7f&#34;&gt;// printString(sv);   // compile error: won&amp;#39;t implicitly convert std::string_view to a std::string
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  printString(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;static_cast&lt;/span&gt;&amp;lt;std::string&amp;gt;(sv)); &lt;span style=&#34;color:#007f7f&#34;&gt;// okay, we can explicitly cast a std::string_view to a std::string
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;operators操作符&#34;&gt;Operators（操作符）&lt;/h1&gt;
&lt;h2 id=&#34;----运算符&#34;&gt;&lt;code&gt;,&lt;/code&gt; &amp;amp; &lt;code&gt;? :&lt;/code&gt; 运算符&lt;/h2&gt;
&lt;p&gt;C++ 没有定义函数参数或运算符操作数的计算顺序&lt;/p&gt;
&lt;p&gt;不要在给定语句中多次使用具有副作用的变量。如果这样做，结果可能是未定义的&lt;/p&gt;
&lt;p&gt;逗号在所有运算符中的优先级最低，甚至低于赋值&lt;/p&gt;
&lt;p&gt;请注意， &lt;code&gt;? :&lt;/code&gt; 运算符的优先级非常低。如果除了将结果分配给变量之外做任何事情，整个 &lt;code&gt;? :&lt;/code&gt; 运算符也需要用括号括起来&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std::cout &amp;lt;&amp;lt; ((x &amp;gt; y) ? x : y) &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果在上述情况下我们不将整个条件运算符括起来会发生什么。因为 &amp;laquo; 运算符的优先级高于 ?: 运算符，所以语句：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std::cout &amp;lt;&amp;lt; (x &amp;gt; y) ? x : y &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;将评估为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;(std::cout &amp;lt;&amp;lt; (x &amp;gt; y)) ? x : y &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;比较浮点数大小&#34;&gt;比较浮点数大小&lt;/h2&gt;
&lt;p&gt;进行浮点相等的最常见方法涉及使用一个函数来查看两个数字是否几乎相同。如果它们“足够接近”，那么我们称它们相等。用于表示“足够接近”的值传统上称为 epsilon。 Epsilon 通常被定义为一个小的正数（例如 0.00000001，有时写作 1e-8）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;cmath&amp;gt; // for std::abs()&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;// epsilon is an absolute value
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;bool&lt;/span&gt; approximatelyEqualAbs(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;double&lt;/span&gt; a, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;double&lt;/span&gt; b, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;double&lt;/span&gt; absEpsilon)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#007f7f&#34;&gt;// if the distance between a and b is less than absEpsilon, then a and b are &amp;#34;close enough&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; std::abs(a - b) &amp;lt;= absEpsilon;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;虽然这个功能可以工作，但不是很好。 0.00001 的 epsilon 适用于 1.0 左右的输入，对于 0.0000001 左右的输入太大，对于 10,000 这样的输入太小&lt;/p&gt;
&lt;p&gt;著名计算机科学家唐纳德·高德纳 (Donald Knuth) 在他的著作“计算机编程的艺术，第二卷：半数值算法 (Addison-Wesley, 1969)”一书中提出了以下方法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;algorithm&amp;gt; // std::max&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;cmath&amp;gt; // std::abs&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;// return true if the difference between a and b is within epsilon percent of the larger of a and b
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;bool&lt;/span&gt; approximatelyEqualRel(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;double&lt;/span&gt; a, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;double&lt;/span&gt; b, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;double&lt;/span&gt; relEpsilon)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; (std::abs(a - b) &amp;lt;= (std::max(std::abs(a), std::abs(b)) * relEpsilon));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在这种情况下，epsilon 不是绝对数字，而是相对于 a 或 b 的大小。在 &amp;lt;= 运算符的左侧，std::abs(a - b) 告诉我们 a 和 b 之间的距离为正数。在 &amp;lt;= 运算符的右侧，我们需要计算我们愿意接受的“足够接近”的最大值。为此，该算法选择 a 和 b 中较大的一个（作为数字总体大小的粗略指标），然后将其乘以 relEpsilon。在此函数中，relEpsilon 表示百分比。例如，如果我们想说“足够接近”意味着 a 和 b 在 a 和 b 中较大者的 1% 以内，我们传入 0.01 (1% = 1/100 = 0.01) 的 relEpsilon。 relEpsilon 的值可以根据情况调整为最合适的值（例如，0.002 的 epsilon 表示在 0.2% 以内）&lt;/p&gt;
&lt;p&gt;要执行不等式 (!=) 而不是相等，只需调用此函数并使用逻辑 NOT 运算符 (!) 翻转结果：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (!approximatelyEqualRel(a, b, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0.001&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34; is not equal to &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;虽然 approximatelyEqualRel() 函数适用于大多数情况，但它并不完美，尤其是当数字接近零时：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;algorithm&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;cmath&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;// return true if the difference between a and b is within epsilon percent of the larger of a and b
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;bool&lt;/span&gt; approximatelyEqualRel(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;double&lt;/span&gt; a, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;double&lt;/span&gt; b, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;double&lt;/span&gt; relEpsilon)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; (std::abs(a - b) &amp;lt;= (std::max(std::abs(a), std::abs(b)) * relEpsilon));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#007f7f&#34;&gt;// a is really close to 1.0, but has rounding errors, so it&amp;#39;s slightly smaller than 1.0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;double&lt;/span&gt; a{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0.1&lt;/span&gt; + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0.1&lt;/span&gt; + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0.1&lt;/span&gt; + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0.1&lt;/span&gt; + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0.1&lt;/span&gt; + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0.1&lt;/span&gt; + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0.1&lt;/span&gt; + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0.1&lt;/span&gt; + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0.1&lt;/span&gt; + &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0.1&lt;/span&gt; };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#007f7f&#34;&gt;// First, let&amp;#39;s compare a (almost 1.0) to 1.0.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;	std::cout &amp;lt;&amp;lt; approximatelyEqualRel(a, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1.0&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1e-8&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#007f7f&#34;&gt;// Second, let&amp;#39;s compare a-1.0 (almost 0.0) to 0.0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;	std::cout &amp;lt;&amp;lt; approximatelyEqualRel(a-&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1.0&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0.0&lt;/span&gt;, &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1e-8&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这会返回：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;1
0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;避免这种情况的一种方法是同时使用绝对 epsilon（如我们在第一种方法中所做的）和相对 epsilon（如我们在 Knuth 的方法中所做的）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;// return true if the difference between a and b is less than absEpsilon, or within relEpsilon percent of the larger of a and b
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;bool&lt;/span&gt; approximatelyEqualAbsRel(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;double&lt;/span&gt; a, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;double&lt;/span&gt; b, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;double&lt;/span&gt; absEpsilon, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;double&lt;/span&gt; relEpsilon)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#007f7f&#34;&gt;// Check if the numbers are really close -- needed when comparing numbers near zero.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;double&lt;/span&gt; diff{ std::abs(a - b) };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (diff &amp;lt;= absEpsilon)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;true&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#007f7f&#34;&gt;// Otherwise fall back to Knuth&amp;#39;s algorithm
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; (diff &amp;lt;= (std::max(std::abs(a), std::abs(b)) * relEpsilon));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在这个算法中，我们首先检查 a 和 b 在绝对值上是否接近，这处理了 a 和 b 都接近于零的情况。 absEpsilon 参数应设置为非常小的值（例如 1e-12）。如果失败，则我们使用相对 epsilon 回退到 Knuth 的算法&lt;/p&gt;
&lt;p&gt;浮点数的比较是一个困难的话题，并且没有适用于所有情况的“一刀切”算法。但是，absEpsilon 为 1e-12 和 relEpsilon 为 1e-8 的 approximatesEqualAbsRel() 应该足以处理您将遇到的大多数情况&lt;/p&gt;
&lt;h2 id=&#34;逻辑-xor-运算符&#34;&gt;逻辑 XOR 运算符&lt;/h2&gt;
&lt;p&gt;C++ 不提供逻辑 XOR 运算符。与逻辑或或逻辑与不同，逻辑异或不能进行短路评估。因此，从逻辑 OR 和逻辑 AND 运算符中创建逻辑 XOR 运算符具有挑战性。但是，您可以使用不等运算符 (!=) 轻松模拟逻辑 XOR：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (a != b) ... &lt;span style=&#34;color:#007f7f&#34;&gt;// a XOR b, assuming a and b are Booleans
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这可以扩展到多个操作数，如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (a != b != c != d) ... &lt;span style=&#34;color:#007f7f&#34;&gt;// a XOR b XOR c XOR d, assuming a, b, c, and d are Booleans
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;请注意，上述 XOR 模式仅在操作数为布尔值（而非整数）时才有效。如果您需要一种适用于非布尔操作数的逻辑 XOR 形式，您可以将它们静态转换为布尔值：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;static_cast&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;bool&lt;/span&gt;&amp;gt;(a) != &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;static_cast&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;bool&lt;/span&gt;&amp;gt;(b) != &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;static_cast&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;bool&lt;/span&gt;&amp;gt;(c) != &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;static_cast&lt;/span&gt;&amp;lt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;bool&lt;/span&gt;&amp;gt;(d)) ... &lt;span style=&#34;color:#007f7f&#34;&gt;// a XOR b XOR c XOR d, for any type that can be converted to bool
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;位操作&#34;&gt;位操作&lt;/h1&gt;
&lt;h2 id=&#34;位标志-and-位操作-via-stdbitset&#34;&gt;位标志 and 位操作 via std::bitset&lt;/h2&gt;
&lt;p&gt;要定义一组位标志，我们通常会使用适当大小的无符号整数（8 位、16 位、32 位等……取决于我们有多少标志），或 std::bitset&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;bitset&amp;gt; // for std::bitset&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std::bitset&amp;lt;&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;8&lt;/span&gt;&amp;gt; mybitset {}; &lt;span style=&#34;color:#007f7f&#34;&gt;// 8 bits in size means room for 8 flags
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;位操作是您应该明确使用无符号整数（或 std::bitset）的少数情况之一&lt;/p&gt;
&lt;p&gt;std::bitset 提供了 4 个可用于位操作的关键函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;test() 允许我们查询某个位是 0 还是 1&lt;/li&gt;
&lt;li&gt;set() 允许我们打开一个位（如果位已经打开，这将不执行任何操作）&lt;/li&gt;
&lt;li&gt;reset() 允许我们关闭一个位（如果该位已经关闭，这将不执行任何操作）&lt;/li&gt;
&lt;li&gt;flip() 允许我们将位值从 0 翻转为 1，反之亦然&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些函数中的每一个都将我们要操作的位的位置作为它们唯一的参数&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;bitset&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::bitset&amp;lt;&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;8&lt;/span&gt;&amp;gt; bits{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0000&amp;#39;0101&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// we need 8 bits, start with bit pattern 0000 0101
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    bits.set(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;3&lt;/span&gt;); &lt;span style=&#34;color:#007f7f&#34;&gt;// set bit position 3 to 1 (now we have 0000 1101)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    bits.flip(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;4&lt;/span&gt;); &lt;span style=&#34;color:#007f7f&#34;&gt;// flip bit 4 (now we have 0001 1101)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    bits.reset(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;4&lt;/span&gt;); &lt;span style=&#34;color:#007f7f&#34;&gt;// set bit 4 back to 0 (now we have 0000 1101)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;All the bits: &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; bits &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Bit 3 has value: &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; bits.test(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;3&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;Bit 4 has value: &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; bits.test(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;4&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;\n&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;按位运算符&#34;&gt;按位运算符&lt;/h2&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://bu.dusays.com/2022/11/27/638344de90243.png&#34;&gt;
&lt;img src=&#34;https://bu.dusays.com/2022/11/27/638344de90243.png&#34; alt=&#34;&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;


为避免意外，请使用无符号操作数或 std::bitset 的按位运算符&lt;/p&gt;
&lt;p&gt;在计算按位 XOR 时，如果一列中有奇数个 1 位，则该列的结果为 1&lt;/p&gt;
&lt;h2 id=&#34;位掩码&#34;&gt;位掩码&lt;/h2&gt;
&lt;p&gt;位掩码是一组预定义的位，用于选择哪些特定位将被后续操作修改。位掩码阻止按位运算符接触我们不想修改的位，并允许访问我们确实想要修改的位&lt;/p&gt;
&lt;p&gt;最简单的一组位掩码是为每个位位置定义一个位掩码。我们用 0 来屏蔽我们不关心的位，用 1 来表示我们想要修改的位&lt;/p&gt;
&lt;p&gt;尽管位掩码可以是文字，但它们通常被定义为符号常量，因此可以为它们指定一个有意义的名称并易于重用&lt;/p&gt;
&lt;h3 id=&#34;在-c14-中定义位掩码&#34;&gt;在 C++14 中定义位掩码&lt;/h3&gt;
&lt;p&gt;因为 C++14 支持二进制文字，所以定义这些位掩码很容易：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;cstdint&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask0{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0000&amp;#39;0001&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask1{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0000&amp;#39;0010&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask2{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0000&amp;#39;0100&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask3{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0000&amp;#39;1000&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 3
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask4{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0001&amp;#39;0000&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 4
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask5{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0010&amp;#39;0000&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 5
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask6{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0100&amp;#39;0000&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 6
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask7{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b1000&amp;#39;0000&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 7
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;在-c11-或更早版本中定义位掩码&#34;&gt;在 C++11 或更早版本中定义位掩码&lt;/h3&gt;
&lt;p&gt;由于 C++11 不支持二进制文字，我们必须使用其他方法来设置符号常量&lt;/p&gt;
&lt;p&gt;第一种方法是使用十六进制文字：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask0{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x01&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// hex for 0000 0001
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask1{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x02&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// hex for 0000 0010
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask2{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x04&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// hex for 0000 0100
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask3{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x08&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// hex for 0000 1000
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask4{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x10&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// hex for 0001 0000
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask5{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x20&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// hex for 0010 0000
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask6{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x40&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// hex for 0100 0000
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask7{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0x80&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// hex for 1000 0000
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;另一种更简单的方法是使用左移运算符将一位移动到正确的位置：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask0{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// 0000 0001
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask1{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// 0000 0010
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask2{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// 0000 0100
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask3{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;3&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// 0000 1000
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask4{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;4&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// 0001 0000
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask5{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;5&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// 0010 0000
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask6{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;6&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// 0100 0000
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask7{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;7&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// 1000 0000
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;testing-a-bit&#34;&gt;Testing a bit&lt;/h3&gt;
&lt;p&gt;要确定某个位是开还是关，我们使用 &lt;code&gt;&amp;amp;&lt;/code&gt; 结合相应位的位掩码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;cstdint&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask0{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0000&amp;#39;0001&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask1{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0000&amp;#39;0010&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask2{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0000&amp;#39;0100&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask3{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0000&amp;#39;1000&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 3
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask4{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0001&amp;#39;0000&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 4
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask5{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0010&amp;#39;0000&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 5
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask6{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0100&amp;#39;0000&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 6
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask7{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b1000&amp;#39;0000&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 7
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; flags{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0000&amp;#39;0101&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// 8 bits in size means room for 8 flags
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;bit 0 is &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; ((flags &amp;amp; mask0) ? &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;on&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt; : &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;off&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;bit 1 is &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; ((flags &amp;amp; mask1) ? &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;on&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt; : &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;off&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;setting-a-bit&#34;&gt;Setting a bit&lt;/h3&gt;
&lt;p&gt;要设置（打开）位，我们将按位或等于（运算符 &lt;code&gt;|=&lt;/code&gt;）与相应位的位掩码结合使用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;cstdint&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask0{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0000&amp;#39;0001&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask1{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0000&amp;#39;0010&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask2{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0000&amp;#39;0100&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask3{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0000&amp;#39;1000&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 3
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask4{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0001&amp;#39;0000&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 4
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask5{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0010&amp;#39;0000&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 5
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask6{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0100&amp;#39;0000&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 6
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask7{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b1000&amp;#39;0000&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 7
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; flags{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0000&amp;#39;0101&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// 8 bits in size means room for 8 flags
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;bit 1 is &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; ((flags &amp;amp; mask1) ? &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;on&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt; : &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;off&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    flags |= mask1; &lt;span style=&#34;color:#007f7f&#34;&gt;// turn on bit 1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;bit 1 is &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; ((flags &amp;amp; mask1) ? &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;on&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt; : &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;off&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们还可以使用按位或同时打开多个位：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;flags |= (mask4 | mask5); &lt;span style=&#34;color:#007f7f&#34;&gt;// turn bits 4 and 5 on at the same time
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;resetting-a-bit&#34;&gt;Resetting a bit&lt;/h3&gt;
&lt;p&gt;要清除位（关闭），我们同时使用 &lt;code&gt;&amp;amp;=&lt;/code&gt; 和 &lt;code&gt;~&lt;/code&gt; ：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;cstdint&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask0{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0000&amp;#39;0001&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask1{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0000&amp;#39;0010&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask2{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0000&amp;#39;0100&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask3{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0000&amp;#39;1000&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 3
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask4{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0001&amp;#39;0000&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 4
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask5{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0010&amp;#39;0000&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 5
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask6{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0100&amp;#39;0000&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 6
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask7{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b1000&amp;#39;0000&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 7
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; flags{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0000&amp;#39;0101&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// 8 bits in size means room for 8 flags
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;bit 2 is &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; ((flags &amp;amp; mask2) ? &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;on&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt; : &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;off&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    flags &amp;amp;= ~mask2; &lt;span style=&#34;color:#007f7f&#34;&gt;// turn off bit 2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;bit 2 is &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; ((flags &amp;amp; mask2) ? &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;on&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt; : &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;off&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们可以同时关闭多个位：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;flags &amp;amp;= ~(mask4 | mask5); &lt;span style=&#34;color:#007f7f&#34;&gt;// turn bits 4 and 5 off at the same time
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;flipping-a-bit&#34;&gt;Flipping a bit&lt;/h3&gt;
&lt;p&gt;要切换位状态，我们使用 &lt;code&gt;^=&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;cstdint&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask0{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0000&amp;#39;0001&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask1{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0000&amp;#39;0010&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask2{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0000&amp;#39;0100&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask3{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0000&amp;#39;1000&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 3
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask4{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0001&amp;#39;0000&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 4
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask5{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0010&amp;#39;0000&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 5
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask6{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0100&amp;#39;0000&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 6
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; mask7{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b1000&amp;#39;0000&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 7
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;uint8_t&lt;/span&gt; flags{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0000&amp;#39;0101&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// 8 bits in size means room for 8 flags
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;bit 2 is &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; ((flags &amp;amp; mask2) ? &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;on&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt; : &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;off&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    flags ^= mask2; &lt;span style=&#34;color:#007f7f&#34;&gt;// flip bit 2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;bit 2 is &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; ((flags &amp;amp; mask2) ? &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;on&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt; : &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;off&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    flags ^= mask2; &lt;span style=&#34;color:#007f7f&#34;&gt;// flip bit 2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;bit 2 is &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; ((flags &amp;amp; mask2) ? &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;on&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt; : &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;off&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们可以同时翻转多个位：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;flags ^= (mask4 | mask5); &lt;span style=&#34;color:#007f7f&#34;&gt;// flip bits 4 and 5 at the same time
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;位掩码和-stdbitset&#34;&gt;位掩码和 std::bitset&lt;/h2&gt;
&lt;p&gt;std::bitset 支持全套位运算符。因此，尽管使用函数（测试、设置、重置和翻转）修改单个位更容易，但如果需要，您可以使用按位运算符和位掩码&lt;/p&gt;
&lt;p&gt;函数只允许您一次修改单个位。按位运算符允许您一次修改多个位&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;cstdint&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;bitset&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::bitset&amp;lt;&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;8&lt;/span&gt;&amp;gt; mask0{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0000&amp;#39;0001&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::bitset&amp;lt;&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;8&lt;/span&gt;&amp;gt; mask1{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0000&amp;#39;0010&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::bitset&amp;lt;&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;8&lt;/span&gt;&amp;gt; mask2{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0000&amp;#39;0100&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::bitset&amp;lt;&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;8&lt;/span&gt;&amp;gt; mask3{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0000&amp;#39;1000&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 3
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::bitset&amp;lt;&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;8&lt;/span&gt;&amp;gt; mask4{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0001&amp;#39;0000&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 4
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::bitset&amp;lt;&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;8&lt;/span&gt;&amp;gt; mask5{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0010&amp;#39;0000&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 5
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::bitset&amp;lt;&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;8&lt;/span&gt;&amp;gt; mask6{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0100&amp;#39;0000&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 6
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;constexpr&lt;/span&gt; std::bitset&amp;lt;&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;8&lt;/span&gt;&amp;gt; mask7{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b1000&amp;#39;0000&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// represents bit 7
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	std::bitset&amp;lt;&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;8&lt;/span&gt;&amp;gt; flags{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0b0000&amp;#39;0101&lt;/span&gt; }; &lt;span style=&#34;color:#007f7f&#34;&gt;// 8 bits in size means room for 8 flags
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;	std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;bit 1 is &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; (flags.test(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;) ? &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;on&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt; : &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;off&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;bit 2 is &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; (flags.test(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;) ? &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;on&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt; : &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;off&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	flags ^= (mask1 | mask2); &lt;span style=&#34;color:#007f7f&#34;&gt;// flip bits 1 and 2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;	std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;bit 1 is &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; (flags.test(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;) ? &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;on&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt; : &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;off&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;bit 2 is &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; (flags.test(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;) ? &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;on&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt; : &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;off&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	flags |= (mask1 | mask2); &lt;span style=&#34;color:#007f7f&#34;&gt;// turn bits 1 and 2 on
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;	std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;bit 1 is &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; (flags.test(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;) ? &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;on&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt; : &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;off&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;bit 2 is &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; (flags.test(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;) ? &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;on&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt; : &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;off&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	flags &amp;amp;= ~(mask1 | mask2); &lt;span style=&#34;color:#007f7f&#34;&gt;// turn bits 1 and 2 off
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;	std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;bit 1 is &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; (flags.test(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;) ? &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;on&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt; : &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;off&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	std::cout &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;bit 2 is &amp;#34;&lt;/span&gt; &amp;lt;&amp;lt; (flags.test(&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;) ? &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;on&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt; : &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;off&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;query bit states&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (flags &amp;amp; option4) ... &lt;span style=&#34;color:#007f7f&#34;&gt;// if option4 is set, do something
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;set bits (turn on)&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;flags |= option4; &lt;span style=&#34;color:#007f7f&#34;&gt;// turn option 4 on.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;flags |= (option4 | option5); &lt;span style=&#34;color:#007f7f&#34;&gt;// turn options 4 and 5 on.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;clear bits (turn off)&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;flags &amp;amp;= ~option4; &lt;span style=&#34;color:#007f7f&#34;&gt;// turn option 4 off
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;flags &amp;amp;= ~(option4 | option5); &lt;span style=&#34;color:#007f7f&#34;&gt;// turn options 4 and 5 off
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;flip bit states&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;flags ^= option4; &lt;span style=&#34;color:#007f7f&#34;&gt;// flip option4 from on to off, or vice versa
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;flags ^= (option4 | option5); &lt;span style=&#34;color:#007f7f&#34;&gt;// flip options 4 and 5
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;运算符重载&#34;&gt;运算符重载&lt;/h1&gt;
&lt;h2 id=&#34;何时使用普通函数友元函数或成员函数重载运算符&#34;&gt;何时使用普通函数、友元函数或成员函数重载运算符&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;在处理不修改左操作数的二元运算符（例如 operator+）时，通常首选普通或友元函数版本，因为它适用于所有参数类型（即使左操作数不是类对象，或者是一个不可修改的类）。普通或友元函数版本具有“对称”的额外好处，因为所有操作数都成为显式参数（而不是左操作数成为 &lt;code&gt;*this&lt;/code&gt; 而右操作数成为显式参数）&lt;/li&gt;
&lt;li&gt;在处理确实修改左操作数的二元运算符时（例如 operator+=），通常首选成员函数版本。在这些情况下，最左边的操作数将始终是类类型，并且让被修改的对象成为 &lt;code&gt;*this&lt;/code&gt; 指向的对象是很自然的。因为最右边的操作数成为一个显式参数，所以不会混淆谁正在修改和谁正在评估&lt;/li&gt;
&lt;li&gt;一元运算符通常也作为成员函数重载，因为成员函数版本没有参数&lt;/li&gt;
&lt;li&gt;以下经验法则可以帮助您确定哪种形式最适合给定情况：
&lt;ol&gt;
&lt;li&gt;如果要重载赋值 (=)、下标 ([])、函数调用 (()) 或成员选择 (-&amp;gt;)，请将其作为成员函数进行重载&lt;/li&gt;
&lt;li&gt;如果要重载一元运算符，请将其作为成员函数&lt;/li&gt;
&lt;li&gt;如果要重载不修改其左操作数的二元运算符（例如 operator+），请将其作为普通函数（首选）或友元函数&lt;/li&gt;
&lt;li&gt;如果您正在重载修改其左操作数的二元运算符，但您不能将成员添加到左操作数的类定义中（例如，operator&amp;laquo;，它有一个 ostream 类型的左操作数），请像往常一样这样做函数（首选）或友元函数&lt;/li&gt;
&lt;li&gt;如果您正在重载修改其左操作数的二元运算符（例如 operator+=），并且您可以修改左操作数的定义，请将其作为成员函数进行&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;最小化比较冗余&#34;&gt;最小化比较冗余&lt;/h2&gt;
&lt;p&gt;也就是说我们只需要实现&lt;code&gt;operator==&lt;/code&gt;和&lt;code&gt;operator&amp;lt;&lt;/code&gt;的逻辑，其他四个比较运算符就可以根据这两个来定义了！这是一个更新的 &lt;code&gt;Cents&lt;/code&gt; 示例，说明了这一点：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

class Cents
{
private:
    int m_cents;

public:
    Cents(int cents)
        : m_cents{ cents }
    {}

    friend bool operator== (const Cents&amp;amp; c1, const Cents&amp;amp; c2) { return c1.m_cents == c2.m_cents; };
    friend bool operator!= (const Cents&amp;amp; c1, const Cents&amp;amp; c2) { return !(operator==(c1, c2)); };

    friend bool operator&amp;lt; (const Cents&amp;amp; c1, const Cents&amp;amp; c2) { return c1.m_cents &amp;lt; c2.m_cents; };
    friend bool operator&amp;gt; (const Cents&amp;amp; c1, const Cents&amp;amp; c2) { return operator&amp;lt;(c2, c1); };

    friend bool operator&amp;lt;= (const Cents&amp;amp; c1, const Cents&amp;amp; c2) { return !(operator&amp;gt;(c1, c2)); };
    friend bool operator&amp;gt;= (const Cents&amp;amp; c1, const Cents&amp;amp; c2) { return !(operator&amp;lt;(c1, c2)); };

};

int main()
{
    Cents dime{ 10 };
    Cents nickel{ 5 };

    if (nickel &amp;gt; dime)
        std::cout &amp;lt;&amp;lt; &amp;#34;a nickel is greater than a dime.\n&amp;#34;;
    if (nickel &amp;gt;= dime)
        std::cout &amp;lt;&amp;lt; &amp;#34;a nickel is greater than or equal to a dime.\n&amp;#34;;
    if (nickel &amp;lt; dime)
        std::cout &amp;lt;&amp;lt; &amp;#34;a dime is greater than a nickel.\n&amp;#34;;
    if (nickel &amp;lt;= dime)
        std::cout &amp;lt;&amp;lt; &amp;#34;a dime is greater than or equal to a nickel.\n&amp;#34;;
    if (nickel == dime)
        std::cout &amp;lt;&amp;lt; &amp;#34;a dime is equal to a nickel.\n&amp;#34;;
    if (nickel != dime)
        std::cout &amp;lt;&amp;lt; &amp;#34;a dime is not equal to a nickel.\n&amp;#34;;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样，如果我们需要更改某些内容，我们只需要更新 operator== 和 operator&amp;lt; 而不是所有六个比较运算符！&lt;/p&gt;
&lt;h1 id=&#34;浅拷贝与深拷贝&#34;&gt;浅拷贝与深拷贝&lt;/h1&gt;
&lt;p&gt;编译器提供的默认复制构造函数和默认赋值运算符如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;cassert&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;class&lt;/span&gt; Fraction
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;private&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; m_numerator { &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt; };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; m_denominator { &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt; };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;public&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#007f7f&#34;&gt;// Default constructor
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    Fraction(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; numerator = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; denominator = &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        : m_numerator{ numerator }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        , m_denominator{ denominator }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        assert(denominator != &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#007f7f&#34;&gt;// Possible implementation of implicit copy constructor
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    Fraction(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;const&lt;/span&gt; Fraction&amp;amp; f)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        : m_numerator{ f.m_numerator }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        , m_denominator{ f.m_denominator }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#007f7f&#34;&gt;// Possible implementation of implicit assignment operator
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    Fraction&amp;amp; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;operator&lt;/span&gt;= (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;const&lt;/span&gt; Fraction&amp;amp; fraction)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#007f7f&#34;&gt;// self-assignment guard
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;this&lt;/span&gt; == &amp;amp;fraction)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; *&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;this&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#007f7f&#34;&gt;// do the copy
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;        m_numerator = fraction.m_numerator;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        m_denominator = fraction.m_denominator;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#007f7f&#34;&gt;// return the existing object so we can chain this operator
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; *&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;this&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;friend&lt;/span&gt; std::ostream&amp;amp; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;operator&lt;/span&gt;&amp;lt;&amp;lt;(std::ostream&amp;amp; out, &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;const&lt;/span&gt; Fraction&amp;amp; f1)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	out &amp;lt;&amp;lt; f1.m_numerator &amp;lt;&amp;lt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#39;/&amp;#39;&lt;/span&gt; &amp;lt;&amp;lt; f1.m_denominator;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; out;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;请注意，因为这些默认版本可以很好地复制此类，所以在这种情况下真的没有理由编写我们自己的这些函数版本&lt;/p&gt;
&lt;p&gt;然而，在设计处理动态分配内存的类时，成员（浅）复制会给我们带来很多麻烦！这是因为指针的浅拷贝只是复制指针的地址——它不分配任何内存或复制指向的内容！&lt;/p&gt;
&lt;p&gt;深拷贝为副本分配内存，然后复制实际值，以便副本位于与源不同的内存中。这样，副本和来源是截然不同的，不会以任何方式相互影响。进行深度复制需要我们编写自己的复制构造函数和重载赋值运算符。&lt;/p&gt;
&lt;p&gt;默认复制构造函数和默认赋值运算符执行浅拷贝，这适用于不包含动态分配变量的类。&lt;br&gt;
具有动态分配变量的类需要有一个复制构造函数和赋值运算符来执行深复制。&lt;br&gt;
喜欢使用标准库中的类而不是自己进行内存管理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;深拷贝&lt;/strong&gt;为副本分配内存，然后复制实际值，以便副本位于与源不同的内存中。这样，副本和来源是截然不同的，不会以任何方式相互影响。进行深度复制需要我们编写自己的复制构造函数和重载赋值运算符。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;// assumes m_data is initialized
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;void&lt;/span&gt; MyString::deepCopy(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;const&lt;/span&gt; MyString&amp;amp; source)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#007f7f&#34;&gt;// first we need to deallocate any value that this string is holding!
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;delete&lt;/span&gt;[] m_data;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#007f7f&#34;&gt;// because m_length is not a pointer, we can shallow copy it
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    m_length = source.m_length;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#007f7f&#34;&gt;// m_data is a pointer, so we need to deep copy it if it is non-null
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (source.m_data)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#007f7f&#34;&gt;// allocate memory for our copy
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;        m_data = &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;char&lt;/span&gt;[m_length];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#007f7f&#34;&gt;// do the copy
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; i{ &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt; }; i &amp;lt; m_length; ++i)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            m_data[i] = source.m_data[i];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        m_data = &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;nullptr&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;// Copy constructor
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;MyString::MyString(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;const&lt;/span&gt; MyString&amp;amp; source)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    deepCopy(source);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这比简单的浅拷贝要复杂得多！&lt;/p&gt;
&lt;p&gt;现在让我们做重载的赋值运算符。重载的赋值运算符有点棘手：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;// Assignment operator
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;MyString&amp;amp; MyString::&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;operator&lt;/span&gt;=(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;const&lt;/span&gt; MyString&amp;amp; source)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#007f7f&#34;&gt;// check for self-assignment
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;this&lt;/span&gt; != &amp;amp;source)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#007f7f&#34;&gt;// now do the deep copy
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;        deepCopy(source);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; *&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;this&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
      <content:encoded><![CDATA[<h2 id="数据类型大小">数据类型大小</h2>
<p>数据类型的大小取决于编译器和计算机体系结构！</p>
<p>C++ 仅保证每个基本数据类型都具有最小大小

<div class="post-img-view">
<a data-fancybox="gallery" href="https://bu.dusays.com/2022/11/26/6381d2545c3fa.png">
<img src="https://bu.dusays.com/2022/11/26/6381d2545c3fa.png" alt="1"  />
</a>
</div>

</p>
<p>为了获得最大的兼容性，您不应假设变量大于指定的最小大小</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;iostream&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> main()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;bool:</span><span style="color:#0ff;font-weight:bold">\t\t</span><span style="color:#0ff;font-weight:bold">&#34;</span> &lt;&lt; <span style="color:#fff;font-weight:bold">sizeof</span>(<span style="color:#fff;font-weight:bold">bool</span>) &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34; bytes</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>;
</span></span><span style="display:flex;"><span>    std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;char:</span><span style="color:#0ff;font-weight:bold">\t\t</span><span style="color:#0ff;font-weight:bold">&#34;</span> &lt;&lt; <span style="color:#fff;font-weight:bold">sizeof</span>(<span style="color:#fff;font-weight:bold">char</span>) &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34; bytes</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>;
</span></span><span style="display:flex;"><span>    std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;wchar_t:</span><span style="color:#0ff;font-weight:bold">\t</span><span style="color:#0ff;font-weight:bold">&#34;</span> &lt;&lt; <span style="color:#fff;font-weight:bold">sizeof</span>(<span style="color:#fff;font-weight:bold">wchar_t</span>) &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34; bytes</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>;
</span></span><span style="display:flex;"><span>    std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;char16_t:</span><span style="color:#0ff;font-weight:bold">\t</span><span style="color:#0ff;font-weight:bold">&#34;</span> &lt;&lt; <span style="color:#fff;font-weight:bold">sizeof</span>(<span style="color:#fff;font-weight:bold">char16_t</span>) &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34; bytes</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>;
</span></span><span style="display:flex;"><span>    std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;char32_t:</span><span style="color:#0ff;font-weight:bold">\t</span><span style="color:#0ff;font-weight:bold">&#34;</span> &lt;&lt; <span style="color:#fff;font-weight:bold">sizeof</span>(<span style="color:#fff;font-weight:bold">char32_t</span>) &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34; bytes</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>;
</span></span><span style="display:flex;"><span>    std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;short:</span><span style="color:#0ff;font-weight:bold">\t\t</span><span style="color:#0ff;font-weight:bold">&#34;</span> &lt;&lt; <span style="color:#fff;font-weight:bold">sizeof</span>(<span style="color:#fff;font-weight:bold">short</span>) &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34; bytes</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>;
</span></span><span style="display:flex;"><span>    std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;int:</span><span style="color:#0ff;font-weight:bold">\t\t</span><span style="color:#0ff;font-weight:bold">&#34;</span> &lt;&lt; <span style="color:#fff;font-weight:bold">sizeof</span>(<span style="color:#fff;font-weight:bold">int</span>) &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34; bytes</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>;
</span></span><span style="display:flex;"><span>    std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;long:</span><span style="color:#0ff;font-weight:bold">\t\t</span><span style="color:#0ff;font-weight:bold">&#34;</span> &lt;&lt; <span style="color:#fff;font-weight:bold">sizeof</span>(<span style="color:#fff;font-weight:bold">long</span>) &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34; bytes</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>;
</span></span><span style="display:flex;"><span>    std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;long long:</span><span style="color:#0ff;font-weight:bold">\t</span><span style="color:#0ff;font-weight:bold">&#34;</span> &lt;&lt; <span style="color:#fff;font-weight:bold">sizeof</span>(<span style="color:#fff;font-weight:bold">long</span> <span style="color:#fff;font-weight:bold">long</span>) &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34; bytes</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>;
</span></span><span style="display:flex;"><span>    std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;float:</span><span style="color:#0ff;font-weight:bold">\t\t</span><span style="color:#0ff;font-weight:bold">&#34;</span> &lt;&lt; <span style="color:#fff;font-weight:bold">sizeof</span>(<span style="color:#fff;font-weight:bold">float</span>) &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34; bytes</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>;
</span></span><span style="display:flex;"><span>    std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;double:</span><span style="color:#0ff;font-weight:bold">\t\t</span><span style="color:#0ff;font-weight:bold">&#34;</span> &lt;&lt; <span style="color:#fff;font-weight:bold">sizeof</span>(<span style="color:#fff;font-weight:bold">double</span>) &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34; bytes</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>;
</span></span><span style="display:flex;"><span>    std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;long double:</span><span style="color:#0ff;font-weight:bold">\t</span><span style="color:#0ff;font-weight:bold">&#34;</span> &lt;&lt; <span style="color:#fff;font-weight:bold">sizeof</span>(<span style="color:#fff;font-weight:bold">long</span> <span style="color:#fff;font-weight:bold">double</span>) &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34; bytes</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>下面是我的 x64 机器的输出，使用 Clion：</p>
<pre tabindex="0"><code>bool:           1 bytes
char:           1 bytes
wchar_t:        2 bytes
char16_t:       2 bytes
char32_t:       4 bytes
short:          2 bytes
int:            4 bytes
long:           4 bytes
long long:      8 bytes
float:          4 bytes
double:         8 bytes
long double:    16 bytes
</code></pre><p>如果您使用不同类型的机器或不同的编译器，您的结果可能会有所不同。请注意，您不能对 void 类型使用 sizeof 运算符，因为它没有大小（这样做会导致编译错误）</p>
<h2 id="无符号整数和有符号整数">无符号整数和有符号整数</h2>
<p>有符号整数范围：

<div class="post-img-view">
<a data-fancybox="gallery" href="https://bu.dusays.com/2022/11/26/6381d81f385fa.png">
<img src="https://bu.dusays.com/2022/11/26/6381d81f385fa.png" alt="1"  />
</a>
</div>

</p>
<p>无符号整数范围：

<div class="post-img-view">
<a data-fancybox="gallery" href="https://bu.dusays.com/2022/11/26/6381d91f961eb.png">
<img src="https://bu.dusays.com/2022/11/26/6381d91f961eb.png" alt="1"  />
</a>
</div>

</p>
<p>如果无符号整数超出范围，则将其除以大于该类型的最大数，只保留余数</p>
<p>在 C++ 的数学运算中（例如算术或比较），如果使用一个有符号整数和一个无符号整数，则<strong>有符号整数将转换为无符号整数</strong>。并且无符号整数不能存储负数，这会导致数据丢失</p>
<p>在保存整数（甚至应该是非负的整数）和数学运算时，有符号数优于无符号数。避免混合有符号和无符号数字</p>
<p>在 C++ 中仍然有一些情况必须使用无符号数：</p>
<p>首先，在处理位操作时首选无符号数。当需要明确定义的环绕行为时，它们也很有用（在某些算法中很有用，例如加密和随机数生成）</p>
<p>其次，无符号数的使用在某些情况下仍然是不可避免的，主要是那些与数组索引有关的情况。。在这些情况下，无符号值可以转换为有符号值</p>
<h2 id="固定宽度整数和-size_t">固定宽度整数和 size_t</h2>
<h3 id="fixed-width-整数">Fixed-width 整数</h3>
<p>为什么整数变量的大小不固定？</p>
<p>这可以追溯到 C，当时计算机速度很慢，性能是最受关注的问题。 C 选择有意保留整数的大小，以便编译器实现者可以选择在目标计算机体系结构上表现最佳的 int 大小</p>
<p>C99 定义了一组固定宽度的整数（在 stdint.h 头文件中），保证在任何体系结构上都具有相同的大小</p>
<p>C++ 正式采用这些固定宽度整数作为 C++11 的一部分。可以通过包含 <code>&lt;cstdint&gt;</code> 头文件来访问它们，它们在 std 命名空间内定义</p>
<p>
<div class="post-img-view">
<a data-fancybox="gallery" href="https://bu.dusays.com/2022/11/26/6381dcb67d0e0.png">
<img src="https://bu.dusays.com/2022/11/26/6381dcb67d0e0.png" alt="1"  />
</a>
</div>

</p>
<h3 id="fast-and-least-整数">Fast and least 整数</h3>
<p>The fast 类型（<code>std::int_fast#_t</code> 和 <code>std::uint_fast#_t</code>）提供最快的有符号/无符号整数类型，宽度至少为 # 位（其中 # = 8、16、32 或 64）。例如，<code>std::int_fast32_t</code> 将为您提供最快的至少 32 位的有符号整数类型</p>
<p>The least 类型（<code>std::int_least#_t</code> 和 <code>std::uint_least#_t</code>）提供宽度至少为 # 位（其中 # = 8、16、32 或 64）的最小有符号/无符号整数类型。例如，<code>std::uint_least32_t</code> 将为您提供至少 32 位的最小无符号整数类型</p>
<p>示例：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;cstdint&gt; // for fixed-width integers</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;iostream&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> main()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;least 8:  &#34;</span> &lt;&lt; <span style="color:#fff;font-weight:bold">sizeof</span>(std::<span style="color:#fff;font-weight:bold">int_least8_t</span>) * <span style="color:#ff0;font-weight:bold">8</span> &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34; bits</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>;
</span></span><span style="display:flex;"><span>	std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;least 16: &#34;</span> &lt;&lt; <span style="color:#fff;font-weight:bold">sizeof</span>(std::<span style="color:#fff;font-weight:bold">int_least16_t</span>) * <span style="color:#ff0;font-weight:bold">8</span> &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34; bits</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>;
</span></span><span style="display:flex;"><span>	std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;least 32: &#34;</span> &lt;&lt; <span style="color:#fff;font-weight:bold">sizeof</span>(std::<span style="color:#fff;font-weight:bold">int_least32_t</span>) * <span style="color:#ff0;font-weight:bold">8</span> &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34; bits</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>;
</span></span><span style="display:flex;"><span>	std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>	std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;fast 8:  &#34;</span> &lt;&lt; <span style="color:#fff;font-weight:bold">sizeof</span>(std::<span style="color:#fff;font-weight:bold">int_fast8_t</span>) * <span style="color:#ff0;font-weight:bold">8</span> &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34; bits</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>;
</span></span><span style="display:flex;"><span>	std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;fast 16: &#34;</span> &lt;&lt; <span style="color:#fff;font-weight:bold">sizeof</span>(std::<span style="color:#fff;font-weight:bold">int_fast16_t</span>) * <span style="color:#ff0;font-weight:bold">8</span> &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34; bits</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>;
</span></span><span style="display:flex;"><span>	std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;fast 32: &#34;</span> &lt;&lt; <span style="color:#fff;font-weight:bold">sizeof</span>(std::<span style="color:#fff;font-weight:bold">int_fast32_t</span>) * <span style="color:#ff0;font-weight:bold">8</span> &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34; bits</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Result：</p>
<pre tabindex="0"><code>least 8:  8 bits
least 16: 16 bits
least 32: 32 bits

fast 8:  8 bits
fast 16: 16 bits
fast 32: 32 bits
</code></pre><p>然而，这些快速且最小的整数有其自身的缺点：首先，真正使用它们的程序员并不多，不熟悉会导致错误。其次，快速类型会导致与我们在 4 字节整数中看到的相同类型的内存浪费。最严重的是，由于快速/最小整数的大小可能会有所不同，因此您的程序可能会在解析为不同大小的架构上表现出不同的行为</p>
<h3 id="stdint8_t-和-stduint8_t-可能表现得像字符而不是整数">std::int8_t 和 std::uint8_t 可能表现得像字符而不是整数</h3>
<p>由于 C++ 规范中的疏忽，大多数编译器分别将 std::int8_t 和 std::uint8_t（以及相应的快速和最小固定宽度类型）定义为 signed char 和 unsigned char 类型，并将其视为相同的类型。这意味着这些 8 位类型的行为可能（或可能不）与其他固定宽度类型不同，这可能会导致错误。此行为是系统相关的，因此在一种体系结构上正确运行的程序可能无法编译或在另一种体系结构上正确运行</p>
<p>为了保持一致性，最好完全避免使用 std::int8_t 和 std::uint8_t（以及相关的快速和最少类型）（改用 std::int16_t 或 std::uint16_t）</p>
<p>8 位固定宽度整数类型通常被视为字符而不是整数值（这可能因系统而异）。大多数情况下首选 16 位固定整数类型</p>
<h3 id="best-practice">Best practice</h3>
<p>我们的立场是正确比快速更好，在编译时失败比运行时更好——因此，我们建议避免使用快速/最少的类型，而使用固定宽度的类型。如果您后来发现需要支持无法编译固定宽度类型的平台，那么您可以在此时决定如何迁移您的程序（并彻底测试）</p>
<ol>
<li>当整数的大小无关紧要时，首选 int（例如，数字将始终适合 2 字节有符号整数的范围）。例如，如果您要求用户输入他们的年龄，或者从 1 数到 10，则 int 是 16 位还是 32 位都没有关系（数字将适合任何一种方式）。这将涵盖您可能遇到的绝大多数情况</li>
<li>存储需要保证范围的数量时，首选 <code>std::int#_t</code></li>
<li>在进行位操作或需要明确定义的环绕行为时，首选 <code>std::uint#_t</code></li>
<li>尽可能避免以下情况：
<ol>
<li>存储数量的无符号类型</li>
<li>8 位固定宽度整数类型</li>
<li>Fast and least 整数类型</li>
<li>任何特定于编译器的固定宽度整数——例如，Visual Studio 定义了 <code>__int8</code>、<code>__int16</code> ……</li>
</ol>
</li>
</ol>
<h3 id="size_t">size_t</h3>
<p>sizeof（以及许多返回大小或长度值的函数）返回一个 std::size_t 类型的值。 std::size_t 被定义为无符号整数类型，通常用于表示对象的大小或长度</p>
<p>有趣的是，我们可以使用 sizeof 运算符（返回 std::size_t 类型的值）来询问 std::size_t 本身的大小：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;cstddef&gt; // std::size_t</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;iostream&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> main()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	std::cout &lt;&lt; <span style="color:#fff;font-weight:bold">sizeof</span>(std::size_t) &lt;&lt; <span style="color:#0ff;font-weight:bold">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>就像整数的大小会因系统而异一样，std::size_t 的大小也会有所不同。 std::size_t 保证为无符号且至少为 16 位，但在大多数系统上将等同于应用程序的地址宽度。也就是说，对于 32 位应用程序，std::size_t 通常是 32 位无符号整数，而对于 64 位应用程序，size_t 通常是 64 位无符号整数。 size_t 被定义为足够大以容纳系统上可创建的最大对象的大小（以字节为单位）。例如，如果 std::size_t 为 4 字节宽，则系统上可创建的最大对象不能大于 4,294,967,295 字节，因为 4,294,967,295 是 4 字节无符号整数可以存储的最大数字。这只是对象大小的上限，实际大小限制可能会更低，具体取决于您使用的编译器</p>
<p>根据定义，任何大小（以字节为单位）大于 size_t 可以容纳的最大整数值的对象都被视为格式错误（并将导致编译错误），因为 sizeof 运算符将无法在不环绕的情况下返回大小</p>
<h2 id="浮点数ieee-754">浮点数（IEEE 754）</h2>
<h3 id="浮点范围和浮点精度">浮点范围和浮点精度</h3>
<p>
<div class="post-img-view">
<a data-fancybox="gallery" href="https://bu.dusays.com/2022/11/26/63820f12cc479.png">
<img src="https://bu.dusays.com/2022/11/26/63820f12cc479.png" alt="1"  />
</a>
</div>

</p>
<p>使用浮点文字时，始终至少包含一位小数（即使小数为 0）。这有助于编译器理解该数字是浮点数而不是整数</p>
<pre tabindex="0"><code>int x{5}; // 5 means integer
double y{5.0}; // 5.0 is a floating point literal (no suffix means double type by default)
float z{5.0f}; // 5.0 is a floating point literal, f suffix means float type
</code></pre><p>始终确保字面量的类型与分配给它们或用于初始化的变量的类型相匹配。否则会导致不必要的转换，可能会导致精度损失</p>
<p>确保在应该使用浮点文字的地方不使用整数文字。这包括初始化浮点对象或为浮点对象赋值、进行浮点运算以及调用需要浮点值的函数</p>
<p>
<div class="post-img-view">
<a data-fancybox="gallery" href="https://bu.dusays.com/2022/11/26/6382110b7d067.png">
<img src="https://bu.dusays.com/2022/11/26/6382110b7d067.png" alt=""  />
</a>
</div>

</p>
<p>输出浮点数时，std::cout 的默认精度为 6——也就是说，它假定所有浮点变量仅对 6 位有效（浮点数的最小精度），因此它将截断之后的任何内容</p>
<p>浮点变量的精度位数取决于大小（浮点数的精度低于双精度数）和存储的特定值（某些值的精度高于其他值）。浮点值的精度在 6 到 9 位之间，大多数浮点值至少有 7 位有效数字。双精度值的精度在 15 到 18 位之间，大多数双精度值至少有 16 位有效数字。 Long double 的最小精度为 15、18 或 33 位有效数字，具体取决于它占用的字节数</p>
<h3 id="舍入误差">舍入误差</h3>
<p>我们可以使用名为 std::setprecision() 的输出操纵器函数覆盖 std::cout 显示的默认精度。输出操纵器改变数据的输出方式，并在 iomanip 标头中定义</p>
<pre tabindex="0"><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt; // for output manipulator std::setprecision()

int main()
{
    std::cout &lt;&lt; std::setprecision(16); // show 16 digits of precision
    std::cout &lt;&lt; 3.33333333333333333333333333333333333333f &lt;&lt;&#39;\n&#39;; // f suffix means float
    std::cout &lt;&lt; 3.33333333333333333333333333333333333333 &lt;&lt; &#39;\n&#39;; // no suffix means double

    return 0;
}
</code></pre><p>在使用需要比变量所能容纳的精度更高的浮点数时，必须小心</p>
<p><strong>除非空间非常宝贵，否则最好使用 double over float，因为 float 缺乏精度通常会导致不准确</strong></p>
<p>值 123456789.0 具有 10 位有效数字，但浮点值通常具有 7 位精度（而 123456792 的结果仅精确到 7 位有效数字）。我们失去了一些精度！当由于无法精确存储数字而导致精度丢失时，这称为<strong>舍入误差</strong></p>
<p>数学运算（例如加法和乘法）往往会使舍入误差增大。所以即使0.1在第17位有效位有舍入误差，但是当我们加上0.1十次时，舍入误差已经爬到第16位有效位了。继续操作会导致此错误变得越来越严重</p>
<h3 id="nan-和-inf">NaN 和 Inf</h3>
<p>有两种特殊类别的浮点数。第一个是 <code>Inf</code>，代表无穷大。 Inf 可以是正数或负数。第二个是 <code>NaN</code>，代表“不是数字”。有几种不同类型的 NaN（我们不会在这里讨论）。 NaN 和 Inf 仅在编译器对浮点数使用特定格式 (IEEE 754) 时可用</p>
<h3 id="conclusion">Conclusion</h3>
<p>总而言之，关于浮点数你应该记住两件事：</p>
<p>浮点数对于存储非常大或非常小的数字很有用，包括带有小数部分的数字</p>
<p>浮点数通常有小的舍入误差，即使数字的有效数字少于精度也是如此。很多时候这些都没有引起注意，因为它们太小了，而且因为输出的数字被截断了。但是，浮点数的比较可能不会给出预期的结果。对这些值执行数学运算将导致舍入误差变大</p>
<h2 id="布尔值">布尔值</h2>
<p>如果您希望 std::cout 打印“true”或“false”而不是 0 或 1，您可以使用 std::boolalpha。这是一个例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;iostream&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> main()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    std::cout &lt;&lt; <span style="color:#fff;font-weight:bold">true</span> &lt;&lt; <span style="color:#0ff;font-weight:bold">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    std::cout &lt;&lt; <span style="color:#fff;font-weight:bold">false</span> &lt;&lt; <span style="color:#0ff;font-weight:bold">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    std::cout &lt;&lt; std::boolalpha; <span style="color:#007f7f">// print bools as true or false
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span>    std::cout &lt;&lt; <span style="color:#fff;font-weight:bold">true</span> &lt;&lt; <span style="color:#0ff;font-weight:bold">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    std::cout &lt;&lt; <span style="color:#fff;font-weight:bold">false</span> &lt;&lt; <span style="color:#0ff;font-weight:bold">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>您可以使用 std::noboolalpha 将其关闭</p>
<p>您不能使用除 0 1 外的整数初始化布尔值：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;iostream&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> main()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">bool</span> b{ <span style="color:#ff0;font-weight:bold">4</span> }; <span style="color:#007f7f">// error: narrowing conversions disallowed
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>	std::cout &lt;&lt; b;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>但是，在任何可以将整数转换为布尔值的上下文中，整数 0 将转换为 false，而任何其他整数将转换为 true</p>
<p>事实证明，std::cin 只接受布尔变量的两个输入：0 和 1（不是 true 或 false）。任何其他输入都会导致 std::cin 无声地失败。在这种情况下，因为我们输入了 true，所以 std::cin 默默地失败了。失败的输入也会将变量清零，因此 b 也被赋值 false。因此，当 std::cout 打印 b 的值时，它打印 0</p>
<p>要允许 std::cin 接受“false”和“true”作为输入，必须启用 std::boolalpha 选项：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;iostream&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> main()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">bool</span> b{};
</span></span><span style="display:flex;"><span>	std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;Enter a boolean value: &#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#007f7f">// Allow the user to enter &#39;true&#39; or &#39;false&#39; for boolean values
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>	<span style="color:#007f7f">// This is case-sensitive, so True or TRUE will not work
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>	std::cin &gt;&gt; std::boolalpha;
</span></span><span style="display:flex;"><span>	std::cin &gt;&gt; b;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;You entered: &#34;</span> &lt;&lt; b &lt;&lt; <span style="color:#0ff;font-weight:bold">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>但是，当启用 std::boolalpha 时，“0”和“1”将不再被视为布尔值</p>
<h2 id="chars">Chars</h2>
<p>char 数据类型旨在保存单个字符。字符可以是单个字母、数字、符号或空格</p>
<p>char 数据类型是整数类型，这意味着基础值存储为整数。类似于布尔值 0 被解释为 false 而非零被解释为 true 的方式，char 变量存储的整数被解释为 ASCII 字符</p>
<p>Char 由 C++ 定义为大小始终为 1 个字节。默认情况下，char 可以是有符号的或无符号的（尽管它通常是有符号的）。如果您使用 chars 来保存 ASCII 字符，则不需要指定符号（因为有符号和无符号字符都可以保存 0 到 127 之间的值）</p>
<p>如果您使用 char 来保存小整数（除非您明确优化空间，否则您不应该这样做），您应该始终指定它是有符号的还是无符号的。 signed char 可以保存 -128 到 127 之间的数字。unsigned char 可以保存 0 到 255 之间的数字</p>
<p><strong>将单个字符放在单引号中（ e.g. <code>'t'</code> or <code>'\n'</code>, not <code>&quot;t&quot;</code> or <code>&quot;\n&quot;</code>）这有助于编译器更有效地进行优化</strong></p>
<p>出于向后兼容性的原因，许多 C++ 编译器支持多字符文字，即包含多个字符（例如“56”）的字符文字。如果支持，它们具有实现定义的值（意味着它因编译器而异）。因为它们不是 C++ 标准的一部分，而且它们的值也没有严格定义，所以应该避免使用多字符文字</p>
<p>ASCII 之外最著名的映射是 Unicode 标准，它将超过 144,000 个整数映射到许多不同语言的字符。由于 Unicode 包含如此多的代码点，因此单个 Unicode 代码点需要 32 位来表示一个字符（称为 UTF-32）。但是，Unicode 字符也可以使用多个 16 位或 8 位字符（分别称为 UTF-16 和 UTF-8）进行编码</p>
<p>char16_t 和 char32_t 添加到 C++11 以提供对 16 位和 32 位 Unicode 字符的明确支持。 C++20 中添加了 char8_t</p>
<p>您不需要使用 char8_t、char16_t 或 char32_t，除非您计划让您的程序与 Unicode 兼容</p>
<p>同时，在处理字符（和字符串）时，您应该只使用 ASCII 字符。使用来自其他字符集的字符可能会导致您的字符显示不正确</p>
<h2 id="常量和符号常量">常量和符号常量</h2>
<h3 id="const-variables">const variables</h3>
<p>Const 变量必须在定义它们时进行初始化，然后不能通过赋值更改该值</p>
<p>Const 变量可以从其他变量（包括非常量变量）初始化</p>
<p>命名时以 “k” 开头, 大小写混合,例如：</p>
<pre tabindex="0"><code>const int kDaysInAWeek = 7;
</code></pre><h3 id="符号常量">符号常量</h3>
<p>符号常量指的是<strong>被赋予常量值的名称</strong>。<code>const variables</code> 是一种符号常量，因为变量有一个名称（它的标识符）和一个常量值</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;iostream&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#define MAX_STUDENTS_PER_CLASS 30
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> main()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;The class has &#34;</span> &lt;&lt; MAX_STUDENTS_PER_CLASS &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34; students.</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>编译此程序时，预处理器会将 MAX_STUDENTS_PER_CLASS 替换为字面值 30，然后编译器会将其编译为您的可执行文件</p>
<p>因为类对象宏有一个名字，并且替换文本是一个常量值，所以带有替换文本的类对象宏也是符号常量</p>
<h3 id="对于符号常量更喜欢常量变量而不是类对象宏">对于符号常量，更喜欢常量变量而不是类对象宏</h3>
<p>首先，因为宏是由预处理器解析的，所有出现的宏都在编译之前被定义的值替换。如果您正在调试代码，您将看不到实际值（例如 30）——您只会看到符号常量的名称（例如 MAX_STUDENTS_PER_CLASS）。因为这些#defined 值不是变量，所以您无法在调试器中添加监视来查看它们的值。如果您想知道 MAX_STUDENTS_PER_CLASS 解析为什么值，您必须找到 MAX_STUDENTS_PER_CLASS 的定义（可能在不同的文件中）。这会使您的程序更难调试</p>
<p>其次，宏可能与普通代码有命名冲突</p>
<p>第三，宏不遵循正常的作用域规则，这意味着在极少数情况下，在程序的一部分中定义的宏可能会与在程序的另一部分中编写的代码发生冲突，而它不应该与之交互</p>
<h2 id="编译时常量常量表达式和-constexpr">编译时常量、常量表达式和 constexpr</h2>
<h3 id="constant-expressions">Constant expressions</h3>
<p>常量表达式是可以在编译时由编译器求值的表达式。要成为常量表达式，表达式中的所有值必须在编译时已知（并且所有调用的运算符和函数必须支持编译时求值）</p>
<p>在编译时对常量表达式求值会使我们的编译时间变长（因为编译器必须做更多的工作），但这样的表达式只需要求值一次（而不是每次程序运行时）。生成的可执行文件速度更快，使用的内存更少</p>
<h3 id="compile-time-constants">Compile-time constants</h3>
<p>编译时常量是其值在编译时已知的常量。文字（例如“1”、“2.3”和“Hello, world!”）是一种编译时常量</p>
<p>Const 变量可能是也可能不是编译时常量</p>
<h3 id="compile-time-const">Compile-time const</h3>
<p>如果 const 变量的初始值设定项是常量表达式，则它是编译时常量</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;iostream&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> main()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">int</span> x { <span style="color:#ff0;font-weight:bold">3</span> };  <span style="color:#007f7f">// x is a compile-time const
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>	<span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">int</span> y { <span style="color:#ff0;font-weight:bold">4</span> };  <span style="color:#007f7f">// y is a compile-time const
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">int</span> z { x + y }; <span style="color:#007f7f">// x + y is a compile-time expression
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span>	std::cout &lt;&lt; z &lt;&lt; <span style="color:#0ff;font-weight:bold">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>因为 x 和 y 的初始化值是常量表达式，所以 x 和 y 是编译时常量。这意味着 x + y 也是常量表达式。所以当编译器编译这个程序时，它可以计算 x + y 的值，并将常量表达式替换为结果文字 7</p>
<h3 id="runtime-const">Runtime const</h3>
<p>任何使用非常量表达式初始化的 const 变量都是运行时常量。运行时常量是其初始化值直到运行时才知道的常量</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;iostream&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> getNumber()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;Enter a number: &#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> y{};
</span></span><span style="display:flex;"><span>    std::cin &gt;&gt; y;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> y;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> main()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">int</span> x{ <span style="color:#ff0;font-weight:bold">3</span> };           <span style="color:#007f7f">// x is a compile time constant
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">int</span> y{ getNumber() }; <span style="color:#007f7f">// y is a runtime constant
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">const</span> <span style="color:#fff;font-weight:bold">int</span> z{ x + y };       <span style="color:#007f7f">// x + y is a runtime expression
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    std::cout &lt;&lt; z &lt;&lt; <span style="color:#0ff;font-weight:bold">&#39;\n&#39;</span>;     <span style="color:#007f7f">// this is also a runtime expression
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>即使 y 是常量，初始化值（getNumber() 的返回值）直到运行时才知道。因此，y 是运行时常量，而不是编译时常量。因此，表达式 x + y 是一个运行时表达式</p>
<h3 id="constexpr-关键字">constexpr 关键字</h3>
<p>当你声明一个 const 变量时，编译器会隐式地跟踪它是运行时常量还是编译时常量。在大多数情况下，除了优化目的之外，这无关紧要，但有一些奇怪的情况，C++ 需要编译时常量而不是运行时常量</p>
<p>因为编译时常量通常允许更好的优化（并且几乎没有缺点），所以我们通常希望尽可能使用编译时常量</p>
<p>我们可以寻求编译器的帮助，以确保我们得到一个我们期望的编译时常量。为此，我们在变量声明中使用 constexpr 关键字而不是 const。 constexpr（“常量表达式”的缩写）变量只能是编译时常量。如果 constexpr 变量的初始化值不是常量表达式，编译器会出错</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;iostream&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> five()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">5</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> main()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">constexpr</span> <span style="color:#fff;font-weight:bold">double</span> gravity { <span style="color:#ff0;font-weight:bold">9.8</span> }; <span style="color:#007f7f">// ok: 9.8 is a constant expression
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">constexpr</span> <span style="color:#fff;font-weight:bold">int</span> sum { <span style="color:#ff0;font-weight:bold">4</span> + <span style="color:#ff0;font-weight:bold">5</span> };      <span style="color:#007f7f">// ok: 4 + 5 is a constant expression
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">constexpr</span> <span style="color:#fff;font-weight:bold">int</span> something { sum };  <span style="color:#007f7f">// ok: sum is a constant expression
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span>    std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;Enter your age: &#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> age{};
</span></span><span style="display:flex;"><span>    std::cin &gt;&gt; age;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">constexpr</span> <span style="color:#fff;font-weight:bold">int</span> myAge { age };      <span style="color:#007f7f">// compile error: age is not a constant expression
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">constexpr</span> <span style="color:#fff;font-weight:bold">int</span> f { five() };       <span style="color:#007f7f">// compile error: return value of five() is not a constant expression
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>任何在初始化后不应修改且其初始值设定项在编译时已知的变量都应声明为 <code>constexpr</code></p>
<p>任何在初始化后不应修改且其初始值设定项在编译时未知的变量都应声明为 <code>const</code></p>
<h2 id="literals">Literals</h2>
<p>文字是直接插入代码中的未命名值。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">5</span>;                   <span style="color:#007f7f">// 5 is an integer literal
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">bool</span> myNameIsAlex { <span style="color:#fff;font-weight:bold">true</span> }; <span style="color:#007f7f">// true is a boolean literal
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>std::cout &lt;&lt; <span style="color:#ff0;font-weight:bold">3.4</span>;           <span style="color:#007f7f">// 3.4 is a double literal
</span></span></span></code></pre></div><p>如对象有类型一样，所有文字都有类型。文字的类型是从文字的值推导出来的</p>
<h2 id="十进制二进制十六进制和八进制">十进制、二进制、十六进制和八进制</h2>
<h3 id="二进制文字和数字分隔符">二进制文字和数字分隔符</h3>
<p>在 C++14 之前，不支持二进制文字。然而，十六进制文字为我们提供了一个有用的解决方法（您可能仍会在现有代码库中看到）：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;iostream&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> main()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> bin{};    <span style="color:#007f7f">// assume 16-bit ints
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    bin = <span style="color:#ff0;font-weight:bold">0x0001</span>; <span style="color:#007f7f">// assign binary 0000 0000 0000 0001 to the variable
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    bin = <span style="color:#ff0;font-weight:bold">0x0002</span>; <span style="color:#007f7f">// assign binary 0000 0000 0000 0010 to the variable
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    bin = <span style="color:#ff0;font-weight:bold">0x0004</span>; <span style="color:#007f7f">// assign binary 0000 0000 0000 0100 to the variable
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    bin = <span style="color:#ff0;font-weight:bold">0x0008</span>; <span style="color:#007f7f">// assign binary 0000 0000 0000 1000 to the variable
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    bin = <span style="color:#ff0;font-weight:bold">0x0010</span>; <span style="color:#007f7f">// assign binary 0000 0000 0001 0000 to the variable
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    bin = <span style="color:#ff0;font-weight:bold">0x0020</span>; <span style="color:#007f7f">// assign binary 0000 0000 0010 0000 to the variable
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    bin = <span style="color:#ff0;font-weight:bold">0x0040</span>; <span style="color:#007f7f">// assign binary 0000 0000 0100 0000 to the variable
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    bin = <span style="color:#ff0;font-weight:bold">0x0080</span>; <span style="color:#007f7f">// assign binary 0000 0000 1000 0000 to the variable
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    bin = <span style="color:#ff0;font-weight:bold">0x00FF</span>; <span style="color:#007f7f">// assign binary 0000 0000 1111 1111 to the variable
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    bin = <span style="color:#ff0;font-weight:bold">0x00B3</span>; <span style="color:#007f7f">// assign binary 0000 0000 1011 0011 to the variable
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    bin = <span style="color:#ff0;font-weight:bold">0xF770</span>; <span style="color:#007f7f">// assign binary 1111 0111 0111 0000 to the variable
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在 C++14 中，我们可以通过使用 0b 前缀来使用二进制文字：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;iostream&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> main()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> bin{};        <span style="color:#007f7f">// assume 16-bit ints
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    bin = <span style="color:#ff0;font-weight:bold">0b1</span>;        <span style="color:#007f7f">// assign binary 0000 0000 0000 0001 to the variable
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    bin = <span style="color:#ff0;font-weight:bold">0b11</span>;       <span style="color:#007f7f">// assign binary 0000 0000 0000 0011 to the variable
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    bin = <span style="color:#ff0;font-weight:bold">0b1010</span>;     <span style="color:#007f7f">// assign binary 0000 0000 0000 1010 to the variable
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    bin = <span style="color:#ff0;font-weight:bold">0b11110000</span>; <span style="color:#007f7f">// assign binary 0000 0000 1111 0000 to the variable
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>由于长文本可能难以阅读，C++14 还添加了使用引号 (‘) 作为数字分隔符的功能（分隔符不能出现在值的第一位数字之前）（数字分隔符纯粹是视觉上的，不会以任何方式影响字面值）</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;iostream&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> main()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> bin { <span style="color:#ff0;font-weight:bold">0b1011&#39;0010</span> };  <span style="color:#007f7f">// assign binary 1011 0010 to the variable
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">long</span> value { <span style="color:#ff0;font-weight:bold">2&#39;132&#39;673&#39;462</span> }; <span style="color:#007f7f">// much easier to read than 2132673462
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="以十进制八进制或十六进制输出值">以十进制、八进制或十六进制输出值</h3>
<p>默认情况下，C++ 以十进制形式输出值。但是，您可以通过使用 std::dec、std::oct 和 std::hex I/O 操纵器更改输出格式：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;iostream&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> main()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> x { <span style="color:#ff0;font-weight:bold">12</span> };
</span></span><span style="display:flex;"><span>    std::cout &lt;&lt; x &lt;&lt; <span style="color:#0ff;font-weight:bold">&#39;\n&#39;</span>; <span style="color:#007f7f">// decimal (by default)
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    std::cout &lt;&lt; std::hex &lt;&lt; x &lt;&lt; <span style="color:#0ff;font-weight:bold">&#39;\n&#39;</span>; <span style="color:#007f7f">// hexadecimal
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    std::cout &lt;&lt; x &lt;&lt; <span style="color:#0ff;font-weight:bold">&#39;\n&#39;</span>; <span style="color:#007f7f">// now hexadecimal
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    std::cout &lt;&lt; std::oct &lt;&lt; x &lt;&lt; <span style="color:#0ff;font-weight:bold">&#39;\n&#39;</span>; <span style="color:#007f7f">// octal
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    std::cout &lt;&lt; std::dec &lt;&lt; x &lt;&lt; <span style="color:#0ff;font-weight:bold">&#39;\n&#39;</span>; <span style="color:#007f7f">// return to decimal
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    std::cout &lt;&lt; x &lt;&lt; <span style="color:#0ff;font-weight:bold">&#39;\n&#39;</span>; <span style="color:#007f7f">// decimal
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="以二进制输出值">以二进制输出值</h3>
<p>以二进制形式输出值有点困难，因为 std::cout 没有内置此功能。幸运的是，C++ 标准库包含一个名为 std::bitset 的类型，它将为我们完成此操作（在 <code>&lt;bitset&gt;</code> 标头中）。要使用 std::bitset，我们可以定义一个 std::bitset 变量并告诉 std::bitset 我们要存储多少位。位数必须是编译时常量。 std::bitset 可以用无符号整数值（任何格式，包括十进制、八进制、十六进制或二进制）初始化</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;bitset&gt; // for std::bitset</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;iostream&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> main()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#007f7f">// std::bitset&lt;8&gt; means we want to store 8 bits
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>	std::bitset&lt;<span style="color:#ff0;font-weight:bold">8</span>&gt; bin1{ <span style="color:#ff0;font-weight:bold">0b1100&#39;0101</span> }; <span style="color:#007f7f">// binary literal for binary 1100 0101
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>	std::bitset&lt;<span style="color:#ff0;font-weight:bold">8</span>&gt; bin2{ <span style="color:#ff0;font-weight:bold">0xC5</span> }; <span style="color:#007f7f">// hexadecimal literal for binary 1100 0101
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span>	std::cout &lt;&lt; bin1 &lt;&lt; <span style="color:#0ff;font-weight:bold">&#39;\n&#39;</span> &lt;&lt; bin2 &lt;&lt; <span style="color:#0ff;font-weight:bold">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>	std::cout &lt;&lt; std::bitset&lt;<span style="color:#ff0;font-weight:bold">4</span>&gt;{ <span style="color:#ff0;font-weight:bold">0b1010</span> } &lt;&lt; <span style="color:#0ff;font-weight:bold">&#39;\n&#39;</span>; <span style="color:#007f7f">// create a temporary std::bitset and print it
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="stdstring">std::string</h2>
<h3 id="使用-stdgetline-输入文本">使用 std::getline() 输入文本</h3>
<p>事实证明，当使用 operator&raquo; 从 std::cin 中提取字符串时，operator&raquo; 只返回它遇到的第一个空格之前的字符。任何其他字符都留在 std::cin 中，等待下一次提取</p>
<p>要将整行输入读入字符串，最好改用 <code>std::getline()</code> 函数。 std::getline() 需要两个参数：第一个是 std::cin，第二个是您的字符串变量</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;string&gt; // For std::string and std::getline</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;iostream&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> main()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;Enter your full name: &#34;</span>;
</span></span><span style="display:flex;"><span>    std::string name{};
</span></span><span style="display:flex;"><span>    std::getline(std::cin &gt;&gt; std::ws, name); <span style="color:#007f7f">// read a full line of text into name
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span>    std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;Enter your age: &#34;</span>;
</span></span><span style="display:flex;"><span>    std::string age{};
</span></span><span style="display:flex;"><span>    std::getline(std::cin &gt;&gt; std::ws, age); <span style="color:#007f7f">// read a full line of text into age
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span>    std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;Your name is &#34;</span> &lt;&lt; name &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34; and your age is &#34;</span> &lt;&lt; age &lt;&lt; <span style="color:#0ff;font-weight:bold">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>std::ws</code> 输入操纵器告诉 std::cin 在提取之前<strong>忽略任何前导空格</strong>。前导空白是出现在字符串开头的任何空白字符（空格、制表符、换行符）</p>
<p>如果使用 <code>std::getline()</code> 读取字符串，请使用 <code>std::cin &gt;&gt; std::ws</code> 输入操纵器忽略前导空格</p>
<p>将提取运算符 (&raquo;) 与 std::cin 一起使用会忽略前导空格</p>
<p>std::getline() 不会忽略前导空格，除非您使用输入操纵器 std::ws</p>
<h3 id="字符串长度">字符串长度</h3>
<p>如果我们想知道 std::string 中有多少个字符，我们可以向 std::string 对象询问它的长度。注意 std::string::length() 返回一个无符号整数值（很可能是 size_t 类型）。如果你想将长度分配给一个 int 变量，你应该对其进行 static_cast 以避免编译器关于有符号/无符号转换的警告：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> length { <span style="color:#fff;font-weight:bold">static_cast</span>&lt;<span style="color:#fff;font-weight:bold">int</span>&gt;(name.length()) };
</span></span></code></pre></div><h3 id="stdstring-的初始化和复制开销很大">std::string 的初始化和复制开销很大</h3>
<p>每当初始化 std::string 时，都会生成用于初始化它的字符串的副本。每当 std::string 按值传递给 std::string 参数时，都会生成另一个副本。不要按值传递 std::string，因为生成 std::string 的副本开销很大。更喜欢 std::string_view 参数</p>
<h3 id="literals-forstdstring--stdstring_view">Literals for <code>std::string</code> &amp; <code>std::string_view</code></h3>
<p>双引号字符串文字（比如“Hello, world!”）默认是 C 风格的字符串</p>
<p>我们可以通过在双引号字符串文字后使用 s 后缀来创建类型为 std::string 的字符串文字</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;iostream&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;string&gt;      // for std::string</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;string_view&gt; // for std::string_view</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> main()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">using</span> <span style="color:#fff;font-weight:bold">namespace</span> std::literals; <span style="color:#007f7f">// easiest way to access the s and sv suffixes
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span>    std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;foo</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>;   <span style="color:#007f7f">// no suffix is a C-style string literal
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;goo</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>s;  <span style="color:#007f7f">// s suffix is a std::string literal
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;moo</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>sv; <span style="color:#007f7f">// sv suffix is a std::string_view literal
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>“s”后缀位于命名空间 std::literals::string_literals 中。“sv”后缀位于命名空间 std::literals::string_view_literals 中。访问文字后缀的最简单方法是通过使用指令使用命名空间 std::literals。这是可以使用整个命名空间的例外情况之一，因为其中定义的后缀不太可能与您的任何代码冲突</p>
<p>你可能不需要经常使用 std::string 文字（因为用 C 风格的字符串文字初始化 std::string 对象很好），但我们会在以后的课程中看到一些使用 std 的情况::string literals 而不是 C 风格的 string literals 使事情变得更容易</p>
<h3 id="constexpr-字符串">Constexpr 字符串</h3>
<p>如果您尝试定义一个 constexpr std::string，您的编译器可能会产生一个错误</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;iostream&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;string&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">using</span> <span style="color:#fff;font-weight:bold">namespace</span> std::literals;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> main()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">constexpr</span> std::string name{ <span style="color:#0ff;font-weight:bold">&#34;Alex&#34;</span>s }; <span style="color:#007f7f">// compile error
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span>    std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;My name is: &#34;</span> &lt;&lt; name;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>发生这种情况是因为 constexpr std::string 在 C++17 或更早版本中不受支持，并且在 C++20 中仅提供最低限度的支持。如果您需要 constexpr 字符串，请改用 std::string_view</p>
<h2 id="stdstring_view">std::string_view</h2>
<h3 id="stdstring_view-c17">std::string_view C++17</h3>
<p>为了解决 std::string 初始化（或复制）成本高昂的问题，C++17 引入了 std::string_view（位于 &lt;string_view&gt; 标头中）。 std::string_view 提供对现有字符串（C 风格字符串文字、std::string 或 char 数组）的只读访问，而无需制作副本</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;iostream&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;string_view&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> printSV(std::string_view str) <span style="color:#007f7f">// now a std::string_view
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>{
</span></span><span style="display:flex;"><span>    std::cout &lt;&lt; str &lt;&lt; <span style="color:#0ff;font-weight:bold">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> main()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    std::string_view s{ <span style="color:#0ff;font-weight:bold">&#34;Hello, world!&#34;</span> }; <span style="color:#007f7f">// now a std::string_view
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    printSV(s);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>当我们用 C 风格的字符串文字“Hello, world!”初始化 std::string_view s 时，s 提供对“Hello, world!”的只读访问。无需复制字符串。当我们将 s 传递给 printSV() 时，参数 str 从 s 初始化。这使我们能够通过 str 访问“Hello, world!”，不用再次复制字符串</p>
<p>当您需要只读字符串时，尤其是对于函数参数，优先使用 std::string_view 而不是 std::string</p>
<h3 id="constexpr-stdstring_view">constexpr std::string_view</h3>
<p>std::string_view 完全支持 constexpr：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;iostream&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;string_view&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> main()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">constexpr</span> std::string_view s{ <span style="color:#0ff;font-weight:bold">&#34;Hello, world!&#34;</span> };
</span></span><span style="display:flex;"><span>    std::cout &lt;&lt; s &lt;&lt; <span style="color:#0ff;font-weight:bold">&#39;\n&#39;</span>; <span style="color:#007f7f">// s will be replaced with &#34;Hello, world!&#34; at compile-time
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="stdstring--stdstring_view">std::string &amp; std::string_view</h3>
<p>可以使用 std::string 初始值设定项创建 std::string_view，并且 std::string 将隐式转换为 std::string_view：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;iostream&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;string&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;string_view&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> printSV(std::string_view str)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    std::cout &lt;&lt; str &lt;&lt; <span style="color:#0ff;font-weight:bold">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> main()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    std::string s{ <span style="color:#0ff;font-weight:bold">&#34;Hello, world&#34;</span> };
</span></span><span style="display:flex;"><span>    std::string_view sv{ s }; <span style="color:#007f7f">// Initialize a std::string_view from a std::string
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    std::cout &lt;&lt; sv &lt;&lt; <span style="color:#0ff;font-weight:bold">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    printSV(s); <span style="color:#007f7f">// implicitly convert a std::string to std::string_view
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>因为 std::string 复制了它的初始化器（这开销很大），C++ 不允许将 std::string_view 隐式转换为 std::string。但是，我们可以使用 std::string_view 初始值设定项显式创建 std::string，或者我们可以使用 static_cast 将现有的 std::string_view 转换为 std::string</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;iostream&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;string&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;string_view&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> printString(std::string str)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    std::cout &lt;&lt; str &lt;&lt; <span style="color:#0ff;font-weight:bold">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> main()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  std::string_view sv{ <span style="color:#0ff;font-weight:bold">&#34;balloon&#34;</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  std::string str{ sv }; <span style="color:#007f7f">// okay, we can create std::string using std::string_view initializer
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">// printString(sv);   // compile error: won&#39;t implicitly convert std::string_view to a std::string
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span>  printString(<span style="color:#fff;font-weight:bold">static_cast</span>&lt;std::string&gt;(sv)); <span style="color:#007f7f">// okay, we can explicitly cast a std::string_view to a std::string
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="operators操作符">Operators（操作符）</h1>
<h2 id="----运算符"><code>,</code> &amp; <code>? :</code> 运算符</h2>
<p>C++ 没有定义函数参数或运算符操作数的计算顺序</p>
<p>不要在给定语句中多次使用具有副作用的变量。如果这样做，结果可能是未定义的</p>
<p>逗号在所有运算符中的优先级最低，甚至低于赋值</p>
<p>请注意， <code>? :</code> 运算符的优先级非常低。如果除了将结果分配给变量之外做任何事情，整个 <code>? :</code> 运算符也需要用括号括起来</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std::cout &lt;&lt; ((x &gt; y) ? x : y) &lt;&lt; <span style="color:#0ff;font-weight:bold">&#39;\n&#39;</span>;
</span></span></code></pre></div><p>如果在上述情况下我们不将整个条件运算符括起来会发生什么。因为 &laquo; 运算符的优先级高于 ?: 运算符，所以语句：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>std::cout &lt;&lt; (x &gt; y) ? x : y &lt;&lt; <span style="color:#0ff;font-weight:bold">&#39;\n&#39;</span>;
</span></span></code></pre></div><p>将评估为：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>(std::cout &lt;&lt; (x &gt; y)) ? x : y &lt;&lt; <span style="color:#0ff;font-weight:bold">&#39;\n&#39;</span>;
</span></span></code></pre></div><h2 id="比较浮点数大小">比较浮点数大小</h2>
<p>进行浮点相等的最常见方法涉及使用一个函数来查看两个数字是否几乎相同。如果它们“足够接近”，那么我们称它们相等。用于表示“足够接近”的值传统上称为 epsilon。 Epsilon 通常被定义为一个小的正数（例如 0.00000001，有时写作 1e-8）</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;cmath&gt; // for std::abs()</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// epsilon is an absolute value
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">bool</span> approximatelyEqualAbs(<span style="color:#fff;font-weight:bold">double</span> a, <span style="color:#fff;font-weight:bold">double</span> b, <span style="color:#fff;font-weight:bold">double</span> absEpsilon)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// if the distance between a and b is less than absEpsilon, then a and b are &#34;close enough&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">return</span> std::abs(a - b) &lt;= absEpsilon;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>虽然这个功能可以工作，但不是很好。 0.00001 的 epsilon 适用于 1.0 左右的输入，对于 0.0000001 左右的输入太大，对于 10,000 这样的输入太小</p>
<p>著名计算机科学家唐纳德·高德纳 (Donald Knuth) 在他的著作“计算机编程的艺术，第二卷：半数值算法 (Addison-Wesley, 1969)”一书中提出了以下方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;algorithm&gt; // std::max</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;cmath&gt; // std::abs</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// return true if the difference between a and b is within epsilon percent of the larger of a and b
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">bool</span> approximatelyEqualRel(<span style="color:#fff;font-weight:bold">double</span> a, <span style="color:#fff;font-weight:bold">double</span> b, <span style="color:#fff;font-weight:bold">double</span> relEpsilon)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> (std::abs(a - b) &lt;= (std::max(std::abs(a), std::abs(b)) * relEpsilon));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在这种情况下，epsilon 不是绝对数字，而是相对于 a 或 b 的大小。在 &lt;= 运算符的左侧，std::abs(a - b) 告诉我们 a 和 b 之间的距离为正数。在 &lt;= 运算符的右侧，我们需要计算我们愿意接受的“足够接近”的最大值。为此，该算法选择 a 和 b 中较大的一个（作为数字总体大小的粗略指标），然后将其乘以 relEpsilon。在此函数中，relEpsilon 表示百分比。例如，如果我们想说“足够接近”意味着 a 和 b 在 a 和 b 中较大者的 1% 以内，我们传入 0.01 (1% = 1/100 = 0.01) 的 relEpsilon。 relEpsilon 的值可以根据情况调整为最合适的值（例如，0.002 的 epsilon 表示在 0.2% 以内）</p>
<p>要执行不等式 (!=) 而不是相等，只需调用此函数并使用逻辑 NOT 运算符 (!) 翻转结果：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">if</span> (!approximatelyEqualRel(a, b, <span style="color:#ff0;font-weight:bold">0.001</span>))
</span></span><span style="display:flex;"><span>    std::cout &lt;&lt; a &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34; is not equal to &#34;</span> &lt;&lt; b &lt;&lt; <span style="color:#0ff;font-weight:bold">&#39;\n&#39;</span>;
</span></span></code></pre></div><p>虽然 approximatelyEqualRel() 函数适用于大多数情况，但它并不完美，尤其是当数字接近零时：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;algorithm&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;cmath&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;iostream&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// return true if the difference between a and b is within epsilon percent of the larger of a and b
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">bool</span> approximatelyEqualRel(<span style="color:#fff;font-weight:bold">double</span> a, <span style="color:#fff;font-weight:bold">double</span> b, <span style="color:#fff;font-weight:bold">double</span> relEpsilon)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">return</span> (std::abs(a - b) &lt;= (std::max(std::abs(a), std::abs(b)) * relEpsilon));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> main()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#007f7f">// a is really close to 1.0, but has rounding errors, so it&#39;s slightly smaller than 1.0
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>	<span style="color:#fff;font-weight:bold">double</span> a{ <span style="color:#ff0;font-weight:bold">0.1</span> + <span style="color:#ff0;font-weight:bold">0.1</span> + <span style="color:#ff0;font-weight:bold">0.1</span> + <span style="color:#ff0;font-weight:bold">0.1</span> + <span style="color:#ff0;font-weight:bold">0.1</span> + <span style="color:#ff0;font-weight:bold">0.1</span> + <span style="color:#ff0;font-weight:bold">0.1</span> + <span style="color:#ff0;font-weight:bold">0.1</span> + <span style="color:#ff0;font-weight:bold">0.1</span> + <span style="color:#ff0;font-weight:bold">0.1</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#007f7f">// First, let&#39;s compare a (almost 1.0) to 1.0.
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>	std::cout &lt;&lt; approximatelyEqualRel(a, <span style="color:#ff0;font-weight:bold">1.0</span>, <span style="color:#ff0;font-weight:bold">1e-8</span>) &lt;&lt; <span style="color:#0ff;font-weight:bold">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#007f7f">// Second, let&#39;s compare a-1.0 (almost 0.0) to 0.0
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>	std::cout &lt;&lt; approximatelyEqualRel(a-<span style="color:#ff0;font-weight:bold">1.0</span>, <span style="color:#ff0;font-weight:bold">0.0</span>, <span style="color:#ff0;font-weight:bold">1e-8</span>) &lt;&lt; <span style="color:#0ff;font-weight:bold">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这会返回：</p>
<pre tabindex="0"><code>1
0
</code></pre><p>避免这种情况的一种方法是同时使用绝对 epsilon（如我们在第一种方法中所做的）和相对 epsilon（如我们在 Knuth 的方法中所做的）：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#007f7f">// return true if the difference between a and b is less than absEpsilon, or within relEpsilon percent of the larger of a and b
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">bool</span> approximatelyEqualAbsRel(<span style="color:#fff;font-weight:bold">double</span> a, <span style="color:#fff;font-weight:bold">double</span> b, <span style="color:#fff;font-weight:bold">double</span> absEpsilon, <span style="color:#fff;font-weight:bold">double</span> relEpsilon)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// Check if the numbers are really close -- needed when comparing numbers near zero.
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">double</span> diff{ std::abs(a - b) };
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span> (diff &lt;= absEpsilon)
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">true</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// Otherwise fall back to Knuth&#39;s algorithm
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">return</span> (diff &lt;= (std::max(std::abs(a), std::abs(b)) * relEpsilon));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在这个算法中，我们首先检查 a 和 b 在绝对值上是否接近，这处理了 a 和 b 都接近于零的情况。 absEpsilon 参数应设置为非常小的值（例如 1e-12）。如果失败，则我们使用相对 epsilon 回退到 Knuth 的算法</p>
<p>浮点数的比较是一个困难的话题，并且没有适用于所有情况的“一刀切”算法。但是，absEpsilon 为 1e-12 和 relEpsilon 为 1e-8 的 approximatesEqualAbsRel() 应该足以处理您将遇到的大多数情况</p>
<h2 id="逻辑-xor-运算符">逻辑 XOR 运算符</h2>
<p>C++ 不提供逻辑 XOR 运算符。与逻辑或或逻辑与不同，逻辑异或不能进行短路评估。因此，从逻辑 OR 和逻辑 AND 运算符中创建逻辑 XOR 运算符具有挑战性。但是，您可以使用不等运算符 (!=) 轻松模拟逻辑 XOR：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">if</span> (a != b) ... <span style="color:#007f7f">// a XOR b, assuming a and b are Booleans
</span></span></span></code></pre></div><p>这可以扩展到多个操作数，如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">if</span> (a != b != c != d) ... <span style="color:#007f7f">// a XOR b XOR c XOR d, assuming a, b, c, and d are Booleans
</span></span></span></code></pre></div><p>请注意，上述 XOR 模式仅在操作数为布尔值（而非整数）时才有效。如果您需要一种适用于非布尔操作数的逻辑 XOR 形式，您可以将它们静态转换为布尔值：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">if</span> (<span style="color:#fff;font-weight:bold">static_cast</span>&lt;<span style="color:#fff;font-weight:bold">bool</span>&gt;(a) != <span style="color:#fff;font-weight:bold">static_cast</span>&lt;<span style="color:#fff;font-weight:bold">bool</span>&gt;(b) != <span style="color:#fff;font-weight:bold">static_cast</span>&lt;<span style="color:#fff;font-weight:bold">bool</span>&gt;(c) != <span style="color:#fff;font-weight:bold">static_cast</span>&lt;<span style="color:#fff;font-weight:bold">bool</span>&gt;(d)) ... <span style="color:#007f7f">// a XOR b XOR c XOR d, for any type that can be converted to bool
</span></span></span></code></pre></div><h1 id="位操作">位操作</h1>
<h2 id="位标志-and-位操作-via-stdbitset">位标志 and 位操作 via std::bitset</h2>
<p>要定义一组位标志，我们通常会使用适当大小的无符号整数（8 位、16 位、32 位等……取决于我们有多少标志），或 std::bitset</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;bitset&gt; // for std::bitset</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold"></span>
</span></span><span style="display:flex;"><span>std::bitset&lt;<span style="color:#ff0;font-weight:bold">8</span>&gt; mybitset {}; <span style="color:#007f7f">// 8 bits in size means room for 8 flags
</span></span></span></code></pre></div><p>位操作是您应该明确使用无符号整数（或 std::bitset）的少数情况之一</p>
<p>std::bitset 提供了 4 个可用于位操作的关键函数：</p>
<ul>
<li>test() 允许我们查询某个位是 0 还是 1</li>
<li>set() 允许我们打开一个位（如果位已经打开，这将不执行任何操作）</li>
<li>reset() 允许我们关闭一个位（如果该位已经关闭，这将不执行任何操作）</li>
<li>flip() 允许我们将位值从 0 翻转为 1，反之亦然</li>
</ul>
<p>这些函数中的每一个都将我们要操作的位的位置作为它们唯一的参数</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;bitset&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;iostream&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> main()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    std::bitset&lt;<span style="color:#ff0;font-weight:bold">8</span>&gt; bits{ <span style="color:#ff0;font-weight:bold">0b0000&#39;0101</span> }; <span style="color:#007f7f">// we need 8 bits, start with bit pattern 0000 0101
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    bits.set(<span style="color:#ff0;font-weight:bold">3</span>); <span style="color:#007f7f">// set bit position 3 to 1 (now we have 0000 1101)
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    bits.flip(<span style="color:#ff0;font-weight:bold">4</span>); <span style="color:#007f7f">// flip bit 4 (now we have 0001 1101)
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    bits.reset(<span style="color:#ff0;font-weight:bold">4</span>); <span style="color:#007f7f">// set bit 4 back to 0 (now we have 0000 1101)
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span>    std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;All the bits: &#34;</span> &lt;&lt; bits &lt;&lt; <span style="color:#0ff;font-weight:bold">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;Bit 3 has value: &#34;</span> &lt;&lt; bits.test(<span style="color:#ff0;font-weight:bold">3</span>) &lt;&lt; <span style="color:#0ff;font-weight:bold">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;Bit 4 has value: &#34;</span> &lt;&lt; bits.test(<span style="color:#ff0;font-weight:bold">4</span>) &lt;&lt; <span style="color:#0ff;font-weight:bold">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="按位运算符">按位运算符</h2>
<p>
<div class="post-img-view">
<a data-fancybox="gallery" href="https://bu.dusays.com/2022/11/27/638344de90243.png">
<img src="https://bu.dusays.com/2022/11/27/638344de90243.png" alt=""  />
</a>
</div>


为避免意外，请使用无符号操作数或 std::bitset 的按位运算符</p>
<p>在计算按位 XOR 时，如果一列中有奇数个 1 位，则该列的结果为 1</p>
<h2 id="位掩码">位掩码</h2>
<p>位掩码是一组预定义的位，用于选择哪些特定位将被后续操作修改。位掩码阻止按位运算符接触我们不想修改的位，并允许访问我们确实想要修改的位</p>
<p>最简单的一组位掩码是为每个位位置定义一个位掩码。我们用 0 来屏蔽我们不关心的位，用 1 来表示我们想要修改的位</p>
<p>尽管位掩码可以是文字，但它们通常被定义为符号常量，因此可以为它们指定一个有意义的名称并易于重用</p>
<h3 id="在-c14-中定义位掩码">在 C++14 中定义位掩码</h3>
<p>因为 C++14 支持二进制文字，所以定义这些位掩码很容易：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;cstdint&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask0{ <span style="color:#ff0;font-weight:bold">0b0000&#39;0001</span> }; <span style="color:#007f7f">// represents bit 0
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask1{ <span style="color:#ff0;font-weight:bold">0b0000&#39;0010</span> }; <span style="color:#007f7f">// represents bit 1
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask2{ <span style="color:#ff0;font-weight:bold">0b0000&#39;0100</span> }; <span style="color:#007f7f">// represents bit 2
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask3{ <span style="color:#ff0;font-weight:bold">0b0000&#39;1000</span> }; <span style="color:#007f7f">// represents bit 3
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask4{ <span style="color:#ff0;font-weight:bold">0b0001&#39;0000</span> }; <span style="color:#007f7f">// represents bit 4
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask5{ <span style="color:#ff0;font-weight:bold">0b0010&#39;0000</span> }; <span style="color:#007f7f">// represents bit 5
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask6{ <span style="color:#ff0;font-weight:bold">0b0100&#39;0000</span> }; <span style="color:#007f7f">// represents bit 6
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask7{ <span style="color:#ff0;font-weight:bold">0b1000&#39;0000</span> }; <span style="color:#007f7f">// represents bit 7
</span></span></span></code></pre></div><h3 id="在-c11-或更早版本中定义位掩码">在 C++11 或更早版本中定义位掩码</h3>
<p>由于 C++11 不支持二进制文字，我们必须使用其他方法来设置符号常量</p>
<p>第一种方法是使用十六进制文字：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask0{ <span style="color:#ff0;font-weight:bold">0x01</span> }; <span style="color:#007f7f">// hex for 0000 0001
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask1{ <span style="color:#ff0;font-weight:bold">0x02</span> }; <span style="color:#007f7f">// hex for 0000 0010
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask2{ <span style="color:#ff0;font-weight:bold">0x04</span> }; <span style="color:#007f7f">// hex for 0000 0100
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask3{ <span style="color:#ff0;font-weight:bold">0x08</span> }; <span style="color:#007f7f">// hex for 0000 1000
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask4{ <span style="color:#ff0;font-weight:bold">0x10</span> }; <span style="color:#007f7f">// hex for 0001 0000
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask5{ <span style="color:#ff0;font-weight:bold">0x20</span> }; <span style="color:#007f7f">// hex for 0010 0000
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask6{ <span style="color:#ff0;font-weight:bold">0x40</span> }; <span style="color:#007f7f">// hex for 0100 0000
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask7{ <span style="color:#ff0;font-weight:bold">0x80</span> }; <span style="color:#007f7f">// hex for 1000 0000
</span></span></span></code></pre></div><p>另一种更简单的方法是使用左移运算符将一位移动到正确的位置：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask0{ <span style="color:#ff0;font-weight:bold">1</span> &lt;&lt; <span style="color:#ff0;font-weight:bold">0</span> }; <span style="color:#007f7f">// 0000 0001
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask1{ <span style="color:#ff0;font-weight:bold">1</span> &lt;&lt; <span style="color:#ff0;font-weight:bold">1</span> }; <span style="color:#007f7f">// 0000 0010
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask2{ <span style="color:#ff0;font-weight:bold">1</span> &lt;&lt; <span style="color:#ff0;font-weight:bold">2</span> }; <span style="color:#007f7f">// 0000 0100
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask3{ <span style="color:#ff0;font-weight:bold">1</span> &lt;&lt; <span style="color:#ff0;font-weight:bold">3</span> }; <span style="color:#007f7f">// 0000 1000
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask4{ <span style="color:#ff0;font-weight:bold">1</span> &lt;&lt; <span style="color:#ff0;font-weight:bold">4</span> }; <span style="color:#007f7f">// 0001 0000
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask5{ <span style="color:#ff0;font-weight:bold">1</span> &lt;&lt; <span style="color:#ff0;font-weight:bold">5</span> }; <span style="color:#007f7f">// 0010 0000
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask6{ <span style="color:#ff0;font-weight:bold">1</span> &lt;&lt; <span style="color:#ff0;font-weight:bold">6</span> }; <span style="color:#007f7f">// 0100 0000
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask7{ <span style="color:#ff0;font-weight:bold">1</span> &lt;&lt; <span style="color:#ff0;font-weight:bold">7</span> }; <span style="color:#007f7f">// 1000 0000
</span></span></span></code></pre></div><h3 id="testing-a-bit">Testing a bit</h3>
<p>要确定某个位是开还是关，我们使用 <code>&amp;</code> 结合相应位的位掩码：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;cstdint&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;iostream&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> main()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask0{ <span style="color:#ff0;font-weight:bold">0b0000&#39;0001</span> }; <span style="color:#007f7f">// represents bit 0
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>	<span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask1{ <span style="color:#ff0;font-weight:bold">0b0000&#39;0010</span> }; <span style="color:#007f7f">// represents bit 1
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>	<span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask2{ <span style="color:#ff0;font-weight:bold">0b0000&#39;0100</span> }; <span style="color:#007f7f">// represents bit 2
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>	<span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask3{ <span style="color:#ff0;font-weight:bold">0b0000&#39;1000</span> }; <span style="color:#007f7f">// represents bit 3
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>	<span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask4{ <span style="color:#ff0;font-weight:bold">0b0001&#39;0000</span> }; <span style="color:#007f7f">// represents bit 4
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>	<span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask5{ <span style="color:#ff0;font-weight:bold">0b0010&#39;0000</span> }; <span style="color:#007f7f">// represents bit 5
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>	<span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask6{ <span style="color:#ff0;font-weight:bold">0b0100&#39;0000</span> }; <span style="color:#007f7f">// represents bit 6
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>	<span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask7{ <span style="color:#ff0;font-weight:bold">0b1000&#39;0000</span> }; <span style="color:#007f7f">// represents bit 7
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span>	std::<span style="color:#fff;font-weight:bold">uint8_t</span> flags{ <span style="color:#ff0;font-weight:bold">0b0000&#39;0101</span> }; <span style="color:#007f7f">// 8 bits in size means room for 8 flags
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span>	std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;bit 0 is &#34;</span> &lt;&lt; ((flags &amp; mask0) ? <span style="color:#0ff;font-weight:bold">&#34;on</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span> : <span style="color:#0ff;font-weight:bold">&#34;off</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>);
</span></span><span style="display:flex;"><span>	std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;bit 1 is &#34;</span> &lt;&lt; ((flags &amp; mask1) ? <span style="color:#0ff;font-weight:bold">&#34;on</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span> : <span style="color:#0ff;font-weight:bold">&#34;off</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="setting-a-bit">Setting a bit</h3>
<p>要设置（打开）位，我们将按位或等于（运算符 <code>|=</code>）与相应位的位掩码结合使用：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;cstdint&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;iostream&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> main()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask0{ <span style="color:#ff0;font-weight:bold">0b0000&#39;0001</span> }; <span style="color:#007f7f">// represents bit 0
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask1{ <span style="color:#ff0;font-weight:bold">0b0000&#39;0010</span> }; <span style="color:#007f7f">// represents bit 1
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask2{ <span style="color:#ff0;font-weight:bold">0b0000&#39;0100</span> }; <span style="color:#007f7f">// represents bit 2
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask3{ <span style="color:#ff0;font-weight:bold">0b0000&#39;1000</span> }; <span style="color:#007f7f">// represents bit 3
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask4{ <span style="color:#ff0;font-weight:bold">0b0001&#39;0000</span> }; <span style="color:#007f7f">// represents bit 4
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask5{ <span style="color:#ff0;font-weight:bold">0b0010&#39;0000</span> }; <span style="color:#007f7f">// represents bit 5
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask6{ <span style="color:#ff0;font-weight:bold">0b0100&#39;0000</span> }; <span style="color:#007f7f">// represents bit 6
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask7{ <span style="color:#ff0;font-weight:bold">0b1000&#39;0000</span> }; <span style="color:#007f7f">// represents bit 7
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span>    std::<span style="color:#fff;font-weight:bold">uint8_t</span> flags{ <span style="color:#ff0;font-weight:bold">0b0000&#39;0101</span> }; <span style="color:#007f7f">// 8 bits in size means room for 8 flags
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span>    std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;bit 1 is &#34;</span> &lt;&lt; ((flags &amp; mask1) ? <span style="color:#0ff;font-weight:bold">&#34;on</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span> : <span style="color:#0ff;font-weight:bold">&#34;off</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    flags |= mask1; <span style="color:#007f7f">// turn on bit 1
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span>    std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;bit 1 is &#34;</span> &lt;&lt; ((flags &amp; mask1) ? <span style="color:#0ff;font-weight:bold">&#34;on</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span> : <span style="color:#0ff;font-weight:bold">&#34;off</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们还可以使用按位或同时打开多个位：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>flags |= (mask4 | mask5); <span style="color:#007f7f">// turn bits 4 and 5 on at the same time
</span></span></span></code></pre></div><h3 id="resetting-a-bit">Resetting a bit</h3>
<p>要清除位（关闭），我们同时使用 <code>&amp;=</code> 和 <code>~</code> ：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;cstdint&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;iostream&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> main()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask0{ <span style="color:#ff0;font-weight:bold">0b0000&#39;0001</span> }; <span style="color:#007f7f">// represents bit 0
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask1{ <span style="color:#ff0;font-weight:bold">0b0000&#39;0010</span> }; <span style="color:#007f7f">// represents bit 1
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask2{ <span style="color:#ff0;font-weight:bold">0b0000&#39;0100</span> }; <span style="color:#007f7f">// represents bit 2
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask3{ <span style="color:#ff0;font-weight:bold">0b0000&#39;1000</span> }; <span style="color:#007f7f">// represents bit 3
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask4{ <span style="color:#ff0;font-weight:bold">0b0001&#39;0000</span> }; <span style="color:#007f7f">// represents bit 4
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask5{ <span style="color:#ff0;font-weight:bold">0b0010&#39;0000</span> }; <span style="color:#007f7f">// represents bit 5
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask6{ <span style="color:#ff0;font-weight:bold">0b0100&#39;0000</span> }; <span style="color:#007f7f">// represents bit 6
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask7{ <span style="color:#ff0;font-weight:bold">0b1000&#39;0000</span> }; <span style="color:#007f7f">// represents bit 7
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span>    std::<span style="color:#fff;font-weight:bold">uint8_t</span> flags{ <span style="color:#ff0;font-weight:bold">0b0000&#39;0101</span> }; <span style="color:#007f7f">// 8 bits in size means room for 8 flags
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span>    std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;bit 2 is &#34;</span> &lt;&lt; ((flags &amp; mask2) ? <span style="color:#0ff;font-weight:bold">&#34;on</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span> : <span style="color:#0ff;font-weight:bold">&#34;off</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    flags &amp;= ~mask2; <span style="color:#007f7f">// turn off bit 2
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span>    std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;bit 2 is &#34;</span> &lt;&lt; ((flags &amp; mask2) ? <span style="color:#0ff;font-weight:bold">&#34;on</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span> : <span style="color:#0ff;font-weight:bold">&#34;off</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们可以同时关闭多个位：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>flags &amp;= ~(mask4 | mask5); <span style="color:#007f7f">// turn bits 4 and 5 off at the same time
</span></span></span></code></pre></div><h3 id="flipping-a-bit">Flipping a bit</h3>
<p>要切换位状态，我们使用 <code>^=</code>：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;cstdint&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;iostream&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> main()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask0{ <span style="color:#ff0;font-weight:bold">0b0000&#39;0001</span> }; <span style="color:#007f7f">// represents bit 0
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask1{ <span style="color:#ff0;font-weight:bold">0b0000&#39;0010</span> }; <span style="color:#007f7f">// represents bit 1
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask2{ <span style="color:#ff0;font-weight:bold">0b0000&#39;0100</span> }; <span style="color:#007f7f">// represents bit 2
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask3{ <span style="color:#ff0;font-weight:bold">0b0000&#39;1000</span> }; <span style="color:#007f7f">// represents bit 3
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask4{ <span style="color:#ff0;font-weight:bold">0b0001&#39;0000</span> }; <span style="color:#007f7f">// represents bit 4
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask5{ <span style="color:#ff0;font-weight:bold">0b0010&#39;0000</span> }; <span style="color:#007f7f">// represents bit 5
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask6{ <span style="color:#ff0;font-weight:bold">0b0100&#39;0000</span> }; <span style="color:#007f7f">// represents bit 6
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">constexpr</span> std::<span style="color:#fff;font-weight:bold">uint8_t</span> mask7{ <span style="color:#ff0;font-weight:bold">0b1000&#39;0000</span> }; <span style="color:#007f7f">// represents bit 7
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span>    std::<span style="color:#fff;font-weight:bold">uint8_t</span> flags{ <span style="color:#ff0;font-weight:bold">0b0000&#39;0101</span> }; <span style="color:#007f7f">// 8 bits in size means room for 8 flags
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span>    std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;bit 2 is &#34;</span> &lt;&lt; ((flags &amp; mask2) ? <span style="color:#0ff;font-weight:bold">&#34;on</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span> : <span style="color:#0ff;font-weight:bold">&#34;off</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>);
</span></span><span style="display:flex;"><span>    flags ^= mask2; <span style="color:#007f7f">// flip bit 2
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;bit 2 is &#34;</span> &lt;&lt; ((flags &amp; mask2) ? <span style="color:#0ff;font-weight:bold">&#34;on</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span> : <span style="color:#0ff;font-weight:bold">&#34;off</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>);
</span></span><span style="display:flex;"><span>    flags ^= mask2; <span style="color:#007f7f">// flip bit 2
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;bit 2 is &#34;</span> &lt;&lt; ((flags &amp; mask2) ? <span style="color:#0ff;font-weight:bold">&#34;on</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span> : <span style="color:#0ff;font-weight:bold">&#34;off</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我们可以同时翻转多个位：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>flags ^= (mask4 | mask5); <span style="color:#007f7f">// flip bits 4 and 5 at the same time
</span></span></span></code></pre></div><h2 id="位掩码和-stdbitset">位掩码和 std::bitset</h2>
<p>std::bitset 支持全套位运算符。因此，尽管使用函数（测试、设置、重置和翻转）修改单个位更容易，但如果需要，您可以使用按位运算符和位掩码</p>
<p>函数只允许您一次修改单个位。按位运算符允许您一次修改多个位</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;cstdint&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;iostream&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;bitset&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> main()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">constexpr</span> std::bitset&lt;<span style="color:#ff0;font-weight:bold">8</span>&gt; mask0{ <span style="color:#ff0;font-weight:bold">0b0000&#39;0001</span> }; <span style="color:#007f7f">// represents bit 0
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>	<span style="color:#fff;font-weight:bold">constexpr</span> std::bitset&lt;<span style="color:#ff0;font-weight:bold">8</span>&gt; mask1{ <span style="color:#ff0;font-weight:bold">0b0000&#39;0010</span> }; <span style="color:#007f7f">// represents bit 1
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>	<span style="color:#fff;font-weight:bold">constexpr</span> std::bitset&lt;<span style="color:#ff0;font-weight:bold">8</span>&gt; mask2{ <span style="color:#ff0;font-weight:bold">0b0000&#39;0100</span> }; <span style="color:#007f7f">// represents bit 2
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>	<span style="color:#fff;font-weight:bold">constexpr</span> std::bitset&lt;<span style="color:#ff0;font-weight:bold">8</span>&gt; mask3{ <span style="color:#ff0;font-weight:bold">0b0000&#39;1000</span> }; <span style="color:#007f7f">// represents bit 3
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>	<span style="color:#fff;font-weight:bold">constexpr</span> std::bitset&lt;<span style="color:#ff0;font-weight:bold">8</span>&gt; mask4{ <span style="color:#ff0;font-weight:bold">0b0001&#39;0000</span> }; <span style="color:#007f7f">// represents bit 4
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>	<span style="color:#fff;font-weight:bold">constexpr</span> std::bitset&lt;<span style="color:#ff0;font-weight:bold">8</span>&gt; mask5{ <span style="color:#ff0;font-weight:bold">0b0010&#39;0000</span> }; <span style="color:#007f7f">// represents bit 5
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>	<span style="color:#fff;font-weight:bold">constexpr</span> std::bitset&lt;<span style="color:#ff0;font-weight:bold">8</span>&gt; mask6{ <span style="color:#ff0;font-weight:bold">0b0100&#39;0000</span> }; <span style="color:#007f7f">// represents bit 6
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>	<span style="color:#fff;font-weight:bold">constexpr</span> std::bitset&lt;<span style="color:#ff0;font-weight:bold">8</span>&gt; mask7{ <span style="color:#ff0;font-weight:bold">0b1000&#39;0000</span> }; <span style="color:#007f7f">// represents bit 7
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span>	std::bitset&lt;<span style="color:#ff0;font-weight:bold">8</span>&gt; flags{ <span style="color:#ff0;font-weight:bold">0b0000&#39;0101</span> }; <span style="color:#007f7f">// 8 bits in size means room for 8 flags
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>	std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;bit 1 is &#34;</span> &lt;&lt; (flags.test(<span style="color:#ff0;font-weight:bold">1</span>) ? <span style="color:#0ff;font-weight:bold">&#34;on</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span> : <span style="color:#0ff;font-weight:bold">&#34;off</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>);
</span></span><span style="display:flex;"><span>	std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;bit 2 is &#34;</span> &lt;&lt; (flags.test(<span style="color:#ff0;font-weight:bold">2</span>) ? <span style="color:#0ff;font-weight:bold">&#34;on</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span> : <span style="color:#0ff;font-weight:bold">&#34;off</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	flags ^= (mask1 | mask2); <span style="color:#007f7f">// flip bits 1 and 2
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>	std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;bit 1 is &#34;</span> &lt;&lt; (flags.test(<span style="color:#ff0;font-weight:bold">1</span>) ? <span style="color:#0ff;font-weight:bold">&#34;on</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span> : <span style="color:#0ff;font-weight:bold">&#34;off</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>);
</span></span><span style="display:flex;"><span>	std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;bit 2 is &#34;</span> &lt;&lt; (flags.test(<span style="color:#ff0;font-weight:bold">2</span>) ? <span style="color:#0ff;font-weight:bold">&#34;on</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span> : <span style="color:#0ff;font-weight:bold">&#34;off</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	flags |= (mask1 | mask2); <span style="color:#007f7f">// turn bits 1 and 2 on
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>	std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;bit 1 is &#34;</span> &lt;&lt; (flags.test(<span style="color:#ff0;font-weight:bold">1</span>) ? <span style="color:#0ff;font-weight:bold">&#34;on</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span> : <span style="color:#0ff;font-weight:bold">&#34;off</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>);
</span></span><span style="display:flex;"><span>	std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;bit 2 is &#34;</span> &lt;&lt; (flags.test(<span style="color:#ff0;font-weight:bold">2</span>) ? <span style="color:#0ff;font-weight:bold">&#34;on</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span> : <span style="color:#0ff;font-weight:bold">&#34;off</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	flags &amp;= ~(mask1 | mask2); <span style="color:#007f7f">// turn bits 1 and 2 off
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>	std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;bit 1 is &#34;</span> &lt;&lt; (flags.test(<span style="color:#ff0;font-weight:bold">1</span>) ? <span style="color:#0ff;font-weight:bold">&#34;on</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span> : <span style="color:#0ff;font-weight:bold">&#34;off</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>);
</span></span><span style="display:flex;"><span>	std::cout &lt;&lt; <span style="color:#0ff;font-weight:bold">&#34;bit 2 is &#34;</span> &lt;&lt; (flags.test(<span style="color:#ff0;font-weight:bold">2</span>) ? <span style="color:#0ff;font-weight:bold">&#34;on</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span> : <span style="color:#0ff;font-weight:bold">&#34;off</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="summary">Summary</h2>
<ol>
<li>query bit states</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">if</span> (flags &amp; option4) ... <span style="color:#007f7f">// if option4 is set, do something
</span></span></span></code></pre></div><ol start="2">
<li>set bits (turn on)</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>flags |= option4; <span style="color:#007f7f">// turn option 4 on.
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>flags |= (option4 | option5); <span style="color:#007f7f">// turn options 4 and 5 on.
</span></span></span></code></pre></div><ol start="3">
<li>clear bits (turn off)</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>flags &amp;= ~option4; <span style="color:#007f7f">// turn option 4 off
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>flags &amp;= ~(option4 | option5); <span style="color:#007f7f">// turn options 4 and 5 off
</span></span></span></code></pre></div><ol start="4">
<li>flip bit states</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>flags ^= option4; <span style="color:#007f7f">// flip option4 from on to off, or vice versa
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>flags ^= (option4 | option5); <span style="color:#007f7f">// flip options 4 and 5
</span></span></span></code></pre></div><h1 id="运算符重载">运算符重载</h1>
<h2 id="何时使用普通函数友元函数或成员函数重载运算符">何时使用普通函数、友元函数或成员函数重载运算符</h2>
<ol>
<li>在处理不修改左操作数的二元运算符（例如 operator+）时，通常首选普通或友元函数版本，因为它适用于所有参数类型（即使左操作数不是类对象，或者是一个不可修改的类）。普通或友元函数版本具有“对称”的额外好处，因为所有操作数都成为显式参数（而不是左操作数成为 <code>*this</code> 而右操作数成为显式参数）</li>
<li>在处理确实修改左操作数的二元运算符时（例如 operator+=），通常首选成员函数版本。在这些情况下，最左边的操作数将始终是类类型，并且让被修改的对象成为 <code>*this</code> 指向的对象是很自然的。因为最右边的操作数成为一个显式参数，所以不会混淆谁正在修改和谁正在评估</li>
<li>一元运算符通常也作为成员函数重载，因为成员函数版本没有参数</li>
<li>以下经验法则可以帮助您确定哪种形式最适合给定情况：
<ol>
<li>如果要重载赋值 (=)、下标 ([])、函数调用 (()) 或成员选择 (-&gt;)，请将其作为成员函数进行重载</li>
<li>如果要重载一元运算符，请将其作为成员函数</li>
<li>如果要重载不修改其左操作数的二元运算符（例如 operator+），请将其作为普通函数（首选）或友元函数</li>
<li>如果您正在重载修改其左操作数的二元运算符，但您不能将成员添加到左操作数的类定义中（例如，operator&laquo;，它有一个 ostream 类型的左操作数），请像往常一样这样做函数（首选）或友元函数</li>
<li>如果您正在重载修改其左操作数的二元运算符（例如 operator+=），并且您可以修改左操作数的定义，请将其作为成员函数进行</li>
</ol>
</li>
</ol>
<h2 id="最小化比较冗余">最小化比较冗余</h2>
<p>也就是说我们只需要实现<code>operator==</code>和<code>operator&lt;</code>的逻辑，其他四个比较运算符就可以根据这两个来定义了！这是一个更新的 <code>Cents</code> 示例，说明了这一点：</p>
<pre tabindex="0"><code>#include &lt;iostream&gt;

class Cents
{
private:
    int m_cents;

public:
    Cents(int cents)
        : m_cents{ cents }
    {}

    friend bool operator== (const Cents&amp; c1, const Cents&amp; c2) { return c1.m_cents == c2.m_cents; };
    friend bool operator!= (const Cents&amp; c1, const Cents&amp; c2) { return !(operator==(c1, c2)); };

    friend bool operator&lt; (const Cents&amp; c1, const Cents&amp; c2) { return c1.m_cents &lt; c2.m_cents; };
    friend bool operator&gt; (const Cents&amp; c1, const Cents&amp; c2) { return operator&lt;(c2, c1); };

    friend bool operator&lt;= (const Cents&amp; c1, const Cents&amp; c2) { return !(operator&gt;(c1, c2)); };
    friend bool operator&gt;= (const Cents&amp; c1, const Cents&amp; c2) { return !(operator&lt;(c1, c2)); };

};

int main()
{
    Cents dime{ 10 };
    Cents nickel{ 5 };

    if (nickel &gt; dime)
        std::cout &lt;&lt; &#34;a nickel is greater than a dime.\n&#34;;
    if (nickel &gt;= dime)
        std::cout &lt;&lt; &#34;a nickel is greater than or equal to a dime.\n&#34;;
    if (nickel &lt; dime)
        std::cout &lt;&lt; &#34;a dime is greater than a nickel.\n&#34;;
    if (nickel &lt;= dime)
        std::cout &lt;&lt; &#34;a dime is greater than or equal to a nickel.\n&#34;;
    if (nickel == dime)
        std::cout &lt;&lt; &#34;a dime is equal to a nickel.\n&#34;;
    if (nickel != dime)
        std::cout &lt;&lt; &#34;a dime is not equal to a nickel.\n&#34;;

    return 0;
}
</code></pre><p>这样，如果我们需要更改某些内容，我们只需要更新 operator== 和 operator&lt; 而不是所有六个比较运算符！</p>
<h1 id="浅拷贝与深拷贝">浅拷贝与深拷贝</h1>
<p>编译器提供的默认复制构造函数和默认赋值运算符如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;cassert&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;iostream&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">class</span> Fraction
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">private</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> m_numerator { <span style="color:#ff0;font-weight:bold">0</span> };
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> m_denominator { <span style="color:#ff0;font-weight:bold">1</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// Default constructor
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    Fraction(<span style="color:#fff;font-weight:bold">int</span> numerator = <span style="color:#ff0;font-weight:bold">0</span>, <span style="color:#fff;font-weight:bold">int</span> denominator = <span style="color:#ff0;font-weight:bold">1</span>)
</span></span><span style="display:flex;"><span>        : m_numerator{ numerator }
</span></span><span style="display:flex;"><span>        , m_denominator{ denominator }
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        assert(denominator != <span style="color:#ff0;font-weight:bold">0</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// Possible implementation of implicit copy constructor
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    Fraction(<span style="color:#fff;font-weight:bold">const</span> Fraction&amp; f)
</span></span><span style="display:flex;"><span>        : m_numerator{ f.m_numerator }
</span></span><span style="display:flex;"><span>        , m_denominator{ f.m_denominator }
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// Possible implementation of implicit assignment operator
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    Fraction&amp; <span style="color:#fff;font-weight:bold">operator</span>= (<span style="color:#fff;font-weight:bold">const</span> Fraction&amp; fraction)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// self-assignment guard
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">if</span> (<span style="color:#fff;font-weight:bold">this</span> == &amp;fraction)
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">return</span> *<span style="color:#fff;font-weight:bold">this</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// do the copy
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        m_numerator = fraction.m_numerator;
</span></span><span style="display:flex;"><span>        m_denominator = fraction.m_denominator;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// return the existing object so we can chain this operator
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">return</span> *<span style="color:#fff;font-weight:bold">this</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">friend</span> std::ostream&amp; <span style="color:#fff;font-weight:bold">operator</span>&lt;&lt;(std::ostream&amp; out, <span style="color:#fff;font-weight:bold">const</span> Fraction&amp; f1)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>	out &lt;&lt; f1.m_numerator &lt;&lt; <span style="color:#0ff;font-weight:bold">&#39;/&#39;</span> &lt;&lt; f1.m_denominator;
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">return</span> out;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>请注意，因为这些默认版本可以很好地复制此类，所以在这种情况下真的没有理由编写我们自己的这些函数版本</p>
<p>然而，在设计处理动态分配内存的类时，成员（浅）复制会给我们带来很多麻烦！这是因为指针的浅拷贝只是复制指针的地址——它不分配任何内存或复制指向的内容！</p>
<p>深拷贝为副本分配内存，然后复制实际值，以便副本位于与源不同的内存中。这样，副本和来源是截然不同的，不会以任何方式相互影响。进行深度复制需要我们编写自己的复制构造函数和重载赋值运算符。</p>
<p>默认复制构造函数和默认赋值运算符执行浅拷贝，这适用于不包含动态分配变量的类。<br>
具有动态分配变量的类需要有一个复制构造函数和赋值运算符来执行深复制。<br>
喜欢使用标准库中的类而不是自己进行内存管理。</p>
<p><strong>深拷贝</strong>为副本分配内存，然后复制实际值，以便副本位于与源不同的内存中。这样，副本和来源是截然不同的，不会以任何方式相互影响。进行深度复制需要我们编写自己的复制构造函数和重载赋值运算符。</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#007f7f">// assumes m_data is initialized
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">void</span> MyString::deepCopy(<span style="color:#fff;font-weight:bold">const</span> MyString&amp; source)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// first we need to deallocate any value that this string is holding!
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">delete</span>[] m_data;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// because m_length is not a pointer, we can shallow copy it
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    m_length = source.m_length;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// m_data is a pointer, so we need to deep copy it if it is non-null
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">if</span> (source.m_data)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// allocate memory for our copy
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        m_data = <span style="color:#fff;font-weight:bold">new</span> <span style="color:#fff;font-weight:bold">char</span>[m_length];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// do the copy
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i{ <span style="color:#ff0;font-weight:bold">0</span> }; i &lt; m_length; ++i)
</span></span><span style="display:flex;"><span>            m_data[i] = source.m_data[i];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">else</span>
</span></span><span style="display:flex;"><span>        m_data = <span style="color:#fff;font-weight:bold">nullptr</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// Copy constructor
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>MyString::MyString(<span style="color:#fff;font-weight:bold">const</span> MyString&amp; source)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    deepCopy(source);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这比简单的浅拷贝要复杂得多！</p>
<p>现在让我们做重载的赋值运算符。重载的赋值运算符有点棘手：</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#007f7f">// Assignment operator
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>MyString&amp; MyString::<span style="color:#fff;font-weight:bold">operator</span>=(<span style="color:#fff;font-weight:bold">const</span> MyString&amp; source)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// check for self-assignment
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">if</span> (<span style="color:#fff;font-weight:bold">this</span> != &amp;source)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// now do the deep copy
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        deepCopy(source);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> *<span style="color:#fff;font-weight:bold">this</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>]]></content:encoded>
    </item>
    
  </channel>
</rss>
