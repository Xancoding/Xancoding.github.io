<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>C&#43;&#43; on Xan&#39;s Blog</title>
    <link>https://xancoding.cn/tags/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on Xan&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 29 May 2023 17:24:38 +0800</lastBuildDate><atom:link href="https://xancoding.cn/tags/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>C&#43;&#43; Project</title>
      <link>https://xancoding.cn/posts/2023-05-29-17-24-38/</link>
      <pubDate>Mon, 29 May 2023 17:24:38 +0800</pubDate>
      
      <guid>https://xancoding.cn/posts/2023-05-29-17-24-38/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1bd4y1D7on/?spm_id_from=333.788&amp;amp;vd_source=ae16ff6478eb15c1b87880540263910b&#34;&gt;# C/C++项目实战（前置知识）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 单例模式&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; 工厂模式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.yuque.com/jackyao/ifeq8i/vyigt9?#%20%E3%80%8AC/C++%E5%88%B7%E9%A2%98%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%E3%80%8B&#34;&gt;# C/C++刷题常用技巧&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;a href=&#34;https://www.bilibili.com/video/BV1XB4y1b7Fy/?spm_id_from=333.788&amp;amp;vd_source=ae16ff6478eb15c1b87880540263910b&#34;&gt;# C/C++项目实战（数据库）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;a href=&#34;https://github.com/SYaoJun/CPPInterview/blob/master/Basic/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.md&#34;&gt;# 数据库原理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;大纲&#34;&gt;大纲&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-markdown&#34; data-lang=&#34;markdown&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;1.&lt;/span&gt; 开发环境
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; Git     # 版本管理工具
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; Cmake   # 代码构建工具，管理源文件和依赖
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; Gcc     # 编译器
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; Clion   # 编辑器
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; Postman # 模拟客户端
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; MySQL(navicat)   # 在 docker Container 中起一个 mySQL 数据库，并可以在 navicat 中进行可视化操作
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; Docker  # 部署
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;1.&lt;/span&gt; 目录结构
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; build   # 项目编译目录
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; debug 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; release 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; include # .h 头文件目录
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; src     # .cpp  源文件目录
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; docs    # 需求设计文档
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; others
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;2.&lt;/span&gt; 设计模式
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; 单例模式
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; 构造函数私有
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; 实例只有一份
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; 工厂模式
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; 一个类别对应一个工厂
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; 不需要亲自创建对象，只需要从工厂中去取
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;3.&lt;/span&gt; 数据库
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; MySQL 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; 关系型
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; 支持事务
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; 行锁
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; 支持种存储引擎InnoDB，MyISAM，Memory
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;-&lt;/span&gt; B+树索引
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;init-project&#34;&gt;init-project&lt;/h1&gt;
&lt;p&gt;
&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://bu.dusays.com/2023/05/29/64748c8482b68.png&#34;&gt;
&lt;img src=&#34;https://bu.dusays.com/2023/05/29/64748c8482b68.png&#34; alt=&#34;3.png&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;h2 id=&#34;build&#34;&gt;build&lt;/h2&gt;
&lt;p&gt;添加 &lt;code&gt;Release&lt;/code&gt; 模块，并将 &lt;code&gt;Debug&lt;/code&gt; 和 &lt;code&gt;Release&lt;/code&gt; 模块移至 &lt;code&gt;build&lt;/code&gt; 目录下

&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://bu.dusays.com/2023/05/29/64748ec74bc6c.png&#34;&gt;
&lt;img src=&#34;https://bu.dusays.com/2023/05/29/64748ec74bc6c.png&#34; alt=&#34;1.png&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;



&lt;div class=&#34;post-img-view&#34;&gt;
&lt;a data-fancybox=&#34;gallery&#34; href=&#34;https://bu.dusays.com/2023/05/29/64748ec74bc31.png&#34;&gt;
&lt;img src=&#34;https://bu.dusays.com/2023/05/29/64748ec74bc31.png&#34; alt=&#34;2.png&#34;  /&gt;
&lt;/a&gt;
&lt;/div&gt;

&lt;/p&gt;
&lt;h2 id=&#34;include&#34;&gt;include&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;User.h&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;//  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;// Created by 24398 on 2023/5/29.  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;//  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#ifndef NEW_PROJECT_USER_H  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#define NEW_PROJECT_USER_H  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;# include &amp;lt;string&amp;gt;  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;class&lt;/span&gt; User {  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;private&lt;/span&gt;:  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; age{};  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std::string name{};  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;public&lt;/span&gt;:  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std::string get_name();  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;User(std::string name_);  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#endif &lt;/span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;//NEW_PROJECT_USER_H
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;src&#34;&gt;src&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;main.cpp&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;lt;iostream&amp;gt;  &lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;#34;User.h&amp;#34;  &lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main() {  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;auto&lt;/span&gt; *user = &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;new&lt;/span&gt; User(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34;John&amp;#34;&lt;/span&gt;);  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std::cout &amp;lt;&amp;lt; user-&amp;gt;get_name() &amp;lt;&amp;lt; std::endl;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;User.cpp&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;//  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;// Created by 24398 on 2023/5/29.  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;//  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&amp;#34;User.h&amp;#34;  &lt;/span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0;font-weight:bold&#34;&gt;&lt;/span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;User::User(std::string name_): name(name_){};  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;std::string User::get_name() {  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;this&lt;/span&gt;-&amp;gt;name;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;cmakeliststxt&#34;&gt;CMakelists.txt&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Cmake&#34; data-lang=&#34;Cmake&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;cmake_minimum_required&lt;/span&gt;(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;VERSION&lt;/span&gt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;3.25&lt;/span&gt;)  &lt;span style=&#34;color:#f00&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;project&lt;/span&gt;(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;new_project&lt;/span&gt;)  &lt;span style=&#34;color:#f00&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;# C++ 17  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;set&lt;/span&gt;(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;CMAKE_CXX_STANDARD&lt;/span&gt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;17&lt;/span&gt;)  &lt;span style=&#34;color:#f00&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;# 添加头文件  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;include_directories&lt;/span&gt;(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;include&lt;/span&gt;)  &lt;span style=&#34;color:#f00&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;# 添加源文件  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;aux_source_directory&lt;/span&gt;(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;./src&lt;/span&gt; &lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;DIR_SRCS&lt;/span&gt;)  &lt;span style=&#34;color:#f00&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#f00&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;# 所有需要编译的可执行文件  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;add_executable&lt;/span&gt;(&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;new_project&lt;/span&gt; ${DIR_SRCS})&lt;span style=&#34;color:#f00&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;include_directories([AFTER|BEFORE] [SYSTEM] directory1 [directory2 ...])&lt;/code&gt;&lt;br&gt;
在这个例子中，命令&lt;code&gt;include_directories(include)&lt;/code&gt;表示你想将&lt;code&gt;include&lt;/code&gt;目录添加到包含路径中。这意味着编译器在编译源文件时会在&lt;code&gt;include&lt;/code&gt;目录中搜索头文件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;aux_source_directory(&amp;lt;dir&amp;gt; &amp;lt;variable&amp;gt;)&lt;/code&gt;&lt;br&gt;
在这个例子中，命令&lt;code&gt;aux_source_directory(src DIR_SRCS)&lt;/code&gt;表示你想从&lt;code&gt;./src&lt;/code&gt;目录收集所有的源文件，并将它们赋值给变量&lt;code&gt;DIR_SRCS&lt;/code&gt;。&lt;/p&gt;
</description>
      <content:encoded><![CDATA[<ul>
<li><a href="https://www.bilibili.com/video/BV1bd4y1D7on/?spm_id_from=333.788&amp;vd_source=ae16ff6478eb15c1b87880540263910b"># C/C++项目实战（前置知识）</a>
<ul>
<li><input disabled="" type="checkbox"> 单例模式</li>
<li><input disabled="" type="checkbox"> 工厂模式</li>
</ul>
</li>
<li><a href="https://www.yuque.com/jackyao/ifeq8i/vyigt9?#%20%E3%80%8AC/C++%E5%88%B7%E9%A2%98%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%E3%80%8B"># C/C++刷题常用技巧</a></li>
<li><input disabled="" type="checkbox"> <a href="https://www.bilibili.com/video/BV1XB4y1b7Fy/?spm_id_from=333.788&amp;vd_source=ae16ff6478eb15c1b87880540263910b"># C/C++项目实战（数据库）</a></li>
<li><input disabled="" type="checkbox"> <a href="https://github.com/SYaoJun/CPPInterview/blob/master/Basic/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86.md"># 数据库原理</a></li>
</ul>
<h1 id="大纲">大纲</h1>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-markdown" data-lang="markdown"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">1.</span> 开发环境
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">-</span> Git     # 版本管理工具
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">-</span> Cmake   # 代码构建工具，管理源文件和依赖
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">-</span> Gcc     # 编译器
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">-</span> Clion   # 编辑器
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">-</span> Postman # 模拟客户端
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">-</span> MySQL(navicat)   # 在 docker Container 中起一个 mySQL 数据库，并可以在 navicat 中进行可视化操作
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">-</span> Docker  # 部署
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">1.</span> 目录结构
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">-</span> build   # 项目编译目录
</span></span><span style="display:flex;"><span>		<span style="color:#fff;font-weight:bold">-</span> debug 
</span></span><span style="display:flex;"><span>		<span style="color:#fff;font-weight:bold">-</span> release 
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">-</span> include # .h 头文件目录
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">-</span> src     # .cpp  源文件目录
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">-</span> docs    # 需求设计文档
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">-</span> others
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">2.</span> 设计模式
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">-</span> 单例模式
</span></span><span style="display:flex;"><span>		<span style="color:#fff;font-weight:bold">-</span> 构造函数私有
</span></span><span style="display:flex;"><span>		<span style="color:#fff;font-weight:bold">-</span> 实例只有一份
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">-</span> 工厂模式
</span></span><span style="display:flex;"><span>		<span style="color:#fff;font-weight:bold">-</span> 一个类别对应一个工厂
</span></span><span style="display:flex;"><span>		<span style="color:#fff;font-weight:bold">-</span> 不需要亲自创建对象，只需要从工厂中去取
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">3.</span> 数据库
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">-</span> MySQL 
</span></span><span style="display:flex;"><span>		<span style="color:#fff;font-weight:bold">-</span> 关系型
</span></span><span style="display:flex;"><span>		<span style="color:#fff;font-weight:bold">-</span> 支持事务
</span></span><span style="display:flex;"><span>		<span style="color:#fff;font-weight:bold">-</span> 行锁
</span></span><span style="display:flex;"><span>		<span style="color:#fff;font-weight:bold">-</span> 支持种存储引擎InnoDB，MyISAM，Memory
</span></span><span style="display:flex;"><span>		<span style="color:#fff;font-weight:bold">-</span> B+树索引
</span></span></code></pre></div><h1 id="init-project">init-project</h1>
<p>
<div class="post-img-view">
<a data-fancybox="gallery" href="https://bu.dusays.com/2023/05/29/64748c8482b68.png">
<img src="https://bu.dusays.com/2023/05/29/64748c8482b68.png" alt="3.png"  />
</a>
</div>

</p>
<h2 id="build">build</h2>
<p>添加 <code>Release</code> 模块，并将 <code>Debug</code> 和 <code>Release</code> 模块移至 <code>build</code> 目录下

<div class="post-img-view">
<a data-fancybox="gallery" href="https://bu.dusays.com/2023/05/29/64748ec74bc6c.png">
<img src="https://bu.dusays.com/2023/05/29/64748ec74bc6c.png" alt="1.png"  />
</a>
</div>



<div class="post-img-view">
<a data-fancybox="gallery" href="https://bu.dusays.com/2023/05/29/64748ec74bc31.png">
<img src="https://bu.dusays.com/2023/05/29/64748ec74bc31.png" alt="2.png"  />
</a>
</div>

</p>
<h2 id="include">include</h2>
<p><code>User.h</code></p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#007f7f">//  
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">// Created by 24398 on 2023/5/29.  
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">//  
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>  
</span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#ifndef NEW_PROJECT_USER_H  
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#define NEW_PROJECT_USER_H  
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold"># include &lt;string&gt;  
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold"></span>  
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">class</span> User {  
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">private</span>:  
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> age{};  
</span></span><span style="display:flex;"><span>std::string name{};  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span>:  
</span></span><span style="display:flex;"><span>std::string get_name();  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>User(std::string name_);  
</span></span><span style="display:flex;"><span>};  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#endif </span><span style="color:#007f7f">//NEW_PROJECT_USER_H
</span></span></span></code></pre></div><h2 id="src">src</h2>
<p><code>main.cpp</code></p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;iostream&gt;  </span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&#34;User.h&#34;  </span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold"></span>  
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> main() {  
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">auto</span> *user = <span style="color:#fff;font-weight:bold">new</span> User(<span style="color:#0ff;font-weight:bold">&#34;John&#34;</span>);  
</span></span><span style="display:flex;"><span>std::cout &lt;&lt; user-&gt;get_name() &lt;&lt; std::endl;  
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>User.cpp</code></p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#007f7f">//  
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">// Created by 24398 on 2023/5/29.  
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">//  
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&#34;User.h&#34;  </span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold"></span>  
</span></span><span style="display:flex;"><span>User::User(std::string name_): name(name_){};  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>std::string User::get_name() {  
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">this</span>-&gt;name;  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="cmakeliststxt">CMakelists.txt</h2>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Cmake" data-lang="Cmake"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">cmake_minimum_required</span>(<span style="color:#0ff;font-weight:bold">VERSION</span> <span style="color:#0ff;font-weight:bold">3.25</span>)  <span style="color:#f00">
</span></span></span><span style="display:flex;"><span><span style="color:#f00"></span><span style="color:#fff;font-weight:bold">project</span>(<span style="color:#0ff;font-weight:bold">new_project</span>)  <span style="color:#f00">
</span></span></span><span style="display:flex;"><span><span style="color:#f00"></span>  <span style="color:#f00">
</span></span></span><span style="display:flex;"><span><span style="color:#f00"></span><span style="color:#007f7f"># C++ 17  
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">set</span>(<span style="color:#0ff;font-weight:bold">CMAKE_CXX_STANDARD</span> <span style="color:#0ff;font-weight:bold">17</span>)  <span style="color:#f00">
</span></span></span><span style="display:flex;"><span><span style="color:#f00"></span><span style="color:#007f7f"># 添加头文件  
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">include_directories</span>(<span style="color:#0ff;font-weight:bold">include</span>)  <span style="color:#f00">
</span></span></span><span style="display:flex;"><span><span style="color:#f00"></span>  <span style="color:#f00">
</span></span></span><span style="display:flex;"><span><span style="color:#f00"></span><span style="color:#007f7f"># 添加源文件  
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">aux_source_directory</span>(<span style="color:#0ff;font-weight:bold">./src</span> <span style="color:#0ff;font-weight:bold">DIR_SRCS</span>)  <span style="color:#f00">
</span></span></span><span style="display:flex;"><span><span style="color:#f00"></span>  <span style="color:#f00">
</span></span></span><span style="display:flex;"><span><span style="color:#f00"></span><span style="color:#007f7f"># 所有需要编译的可执行文件  
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">add_executable</span>(<span style="color:#0ff;font-weight:bold">new_project</span> ${DIR_SRCS})<span style="color:#f00">
</span></span></span></code></pre></div><p><code>include_directories([AFTER|BEFORE] [SYSTEM] directory1 [directory2 ...])</code><br>
在这个例子中，命令<code>include_directories(include)</code>表示你想将<code>include</code>目录添加到包含路径中。这意味着编译器在编译源文件时会在<code>include</code>目录中搜索头文件。</p>
<p><code>aux_source_directory(&lt;dir&gt; &lt;variable&gt;)</code><br>
在这个例子中，命令<code>aux_source_directory(src DIR_SRCS)</code>表示你想从<code>./src</code>目录收集所有的源文件，并将它们赋值给变量<code>DIR_SRCS</code>。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>C&#43;&#43;中的Sort函数与Priority_queue优先队列</title>
      <link>https://xancoding.cn/posts/2023-04-24-14-17-47/</link>
      <pubDate>Mon, 24 Apr 2023 14:17:47 +0800</pubDate>
      
      <guid>https://xancoding.cn/posts/2023-04-24-14-17-47/</guid>
      <description>&lt;p&gt;当待排列的元素为一个对象时，我们既可以通过自定义比较函数，也可以通过重载运算符来达到目的。&lt;br&gt;
下面我以在对象中重载运算符来达到排序的目的展开说明。&lt;br&gt;
下面是针对 &lt;code&gt;sort函数&lt;/code&gt; 和 &lt;code&gt;Priority_queue优先队列&lt;/code&gt;，关于重载运算符所需要注意的要点&lt;/p&gt;
&lt;h1 id=&#34;结构体排序&#34;&gt;结构体排序&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;struct&lt;/span&gt; node{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; a, b;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#007f7f&#34;&gt;// 从小到大排序
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;operator&lt;/span&gt; &amp;lt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;const&lt;/span&gt; node&amp;amp; node_)&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;const&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt;(a != node_.a) &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; a &amp;lt; node_.a;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; b &amp;lt; node_.b;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main(){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    vector&amp;lt;node&amp;gt; tt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    tt.push_back({&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;5&lt;/span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    tt.push_back({&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;3&lt;/span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    sort(tt.begin(), tt.end());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;auto&lt;/span&gt; &amp;amp;node: tt){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        cout&amp;lt;&amp;lt;node.a&amp;lt;&amp;lt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;node.b&amp;lt;&amp;lt;endl;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;执行结果：
1 5
2 3
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;优先队列自定义排序&#34;&gt;优先队列自定义排序&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;struct&lt;/span&gt; node{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; a, b;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#007f7f&#34;&gt;// 在优先队列中，跟排序的规则是反的，这里是指a大的排在前面，a相同时，b大的排在前面
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#007f7f&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;operator&lt;/span&gt; &amp;lt; (&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;const&lt;/span&gt; node&amp;amp; node_)&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;const&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;if&lt;/span&gt;(a != node_.a) &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; a &amp;lt; node_.a;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; b &amp;lt; node_.b;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;int&lt;/span&gt; main(){
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    priority_queue&amp;lt;node&amp;gt; pq;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    pq.push({&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;5&lt;/span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    pq.push({&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;3&lt;/span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    pq.push({&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;5&lt;/span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;while&lt;/span&gt;(!pq.empty()) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        cout&amp;lt;&amp;lt;pq.top().a&amp;lt;&amp;lt;&lt;span style=&#34;color:#0ff;font-weight:bold&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt;&amp;lt;&amp;lt;pq.top().b&amp;lt;&amp;lt;endl;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        pq.pop();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#fff;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ff0;font-weight:bold&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;执行结果： 
2 5
2 3
1 5
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;sort函数&#34;&gt;Sort函数&lt;/h1&gt;
&lt;p&gt;sort函数在默认情况下使用&lt;code&gt;std::less&lt;/code&gt;作为比较函数类，而&lt;code&gt;std::less&lt;/code&gt;定义了小于号&lt;code&gt;&amp;lt;&lt;/code&gt;运算符的重载。因此，在sort函数中如果不指定自定义的比较函数对象，就默认使用&lt;code&gt;std::less&lt;/code&gt;来进行排序，即升序排序。如果要实现降序排序，则需要提供自定义的比较函数对象，或者使用&lt;code&gt;std::greater&lt;/code&gt;作为比较函数类。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sort&lt;/code&gt;函数并不能直接重载大于号运算符。&lt;code&gt;sort&lt;/code&gt;函数默认使用小于号运算符来对元素进行排序，因此在对对象进行排序时，我们通常会&lt;strong&gt;重载小于号运算符&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当第一个元素 &amp;lt; 第二个元素时，为&lt;code&gt;true&lt;/code&gt;，则最终的排序结果为升序&lt;/p&gt;
&lt;p&gt;同理，当我把 &lt;code&gt;this-&amp;gt;age &amp;lt; other.age&lt;/code&gt; 修改为 &lt;code&gt;this-&amp;gt;age &amp;gt; other.age&lt;/code&gt;时，说明当第一个元素 &amp;gt; 第二个元素时，为&lt;code&gt;true&lt;/code&gt;，则结果为降序&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;  
#include &amp;lt;vector&amp;gt;  
using namespace std;  
  
// 定义一个自定义对象  
class Person {  
public:  
string name;  
int age;  
Person(string name, int age) {  
this-&amp;gt;name = name;  
this-&amp;gt;age = age;  
}  
  
// 第一个元素 &amp;lt; 第二个元素，true，升序  
bool operator&amp;lt; (const Person&amp;amp; other) const  
{  
return this-&amp;gt;age &amp;lt; other.age;  
}  
};  
  
int main() {  
// 创建一组Person对象并排序  
Person p1(&amp;#34;Alice&amp;#34;, 25);  
Person p2(&amp;#34;Bob&amp;#34;, 30);  
Person p3(&amp;#34;Charlie&amp;#34;, 20);  
  
vector&amp;lt;Person&amp;gt; people = {p1, p2, p3};  
sort(people.begin(), people.end());  
  
for (auto &amp;amp;p: people)  
{  
cout &amp;lt;&amp;lt; &amp;#34;Name:&amp;#34; &amp;lt;&amp;lt; p.name &amp;lt;&amp;lt; &amp;#39;\t&amp;#39; &amp;lt;&amp;lt; &amp;#34;Age:&amp;#34; &amp;lt;&amp;lt; p.age &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;  
}  
  
return 0;  
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Name:Charlie    Age:20
Name:Alice      Age:25
Name:Bob        Age:30
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过下述代码，我们可以在调用&lt;code&gt;sort&lt;/code&gt;时将比较函数类从默认的&lt;code&gt;std::less&lt;/code&gt;改为&lt;code&gt;std::greater&lt;/code&gt;，实现降序排序&amp;ndash;前提是记得在对象中重载大于运算符，否则编译器将会报错！！！&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sort(people.begin(), people.end(), greater&amp;lt;&amp;gt;());
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;priority_queue堆优先队列&#34;&gt;Priority_queue堆优先队列&lt;/h1&gt;
&lt;p&gt;堆是一种数据结构，可以用数组或树实现，常用于实现优先队列、排序算法等。&lt;/p&gt;
&lt;p&gt;优先队列（priority queue）就是堆（heap）的一种应用。&lt;/p&gt;
&lt;p&gt;C++中的优先队列实现就是堆优先队列，底层使用堆来实现。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;std::priority_queue&lt;/code&gt;是一个模板类，它的模板参数有三个，分别是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;T&lt;/code&gt;：指定队列中存储的元素类型。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Container&lt;/code&gt;：指定用于存储元素的容器类型，默认是&lt;code&gt;std::vector&amp;lt;T&amp;gt;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Compare&lt;/code&gt;：指定用于比较元素优先级的比较函数类型，默认是&lt;code&gt;std::less&amp;lt;T&amp;gt;&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;std::less&amp;lt;T&amp;gt;&lt;/code&gt;和&lt;code&gt;std::greater&amp;lt;T&amp;gt;&lt;/code&gt;是STL中预定义的两个比较函数类，分别表示小于和大于。它们重载了小于号运算符&lt;code&gt;&amp;lt;&lt;/code&gt;和大于号运算符&lt;code&gt;&amp;gt;&lt;/code&gt;，用于比较元素的优先级。因此，当我们在定义&lt;code&gt;std::priority_queue&lt;/code&gt;时，使用&lt;code&gt;std::less&amp;lt;T&amp;gt;&lt;/code&gt;作为比较函数类时，实际上是默认按照小于号进行比较元素优先级；而使用&lt;code&gt;std::greater&amp;lt;T&amp;gt;&lt;/code&gt;作为比较函数类时，则是按照大于号进行比较元素优先级。&lt;/p&gt;
&lt;p&gt;如果在使用&lt;code&gt;std::less&amp;lt;T&amp;gt;&lt;/code&gt;作为比较函数类时，重载大于号&lt;code&gt;&amp;gt;&lt;/code&gt;，或者在使用&lt;code&gt;std::greater&amp;lt;T&amp;gt;&lt;/code&gt;作为比较函数类时，重载小于号&lt;code&gt;&amp;lt;&lt;/code&gt;，都会导致编译错误，因为这些比较函数类内部的比较操作都是用小于号&lt;code&gt;&amp;lt;&lt;/code&gt;或者大于号&lt;code&gt;&amp;gt;&lt;/code&gt;实现的，而你重载了不符合预期的运算符，导致编译器无法正确地进行比较操作。&lt;/p&gt;
&lt;p&gt;在C++中，优先队列可以通过指定比较函数来控制是使用大根堆还是小根堆。如果使用 std::greater&amp;lt;&amp;gt; 作为比较函数，则意味着使用小根堆，即优先级高的元素会被放在队列的顶部；如果使用 std::less&amp;lt;&amp;gt; 作为比较函数，则意味着使用大根堆，即优先级高的元素会被放在队列的底部。&lt;/p&gt;
&lt;p&gt;堆中元素之间的优先级关系，这是通过定义比较函数来实现的，比较函数中使用 &lt;code&gt;greater&amp;lt;&amp;gt;&lt;/code&gt; 表示元素之间的优先级关系为第一个参数视为较小的元素；使用 &lt;code&gt;less&amp;lt;&amp;gt;&lt;/code&gt; 表示元素之间的优先级关系为第一个参数视为较大的元素。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;greater&amp;lt;&amp;gt;&lt;/code&gt; 作为比较函数时，会将元素之间的优先级关系视为第一个参数较小，也就是说，若 &lt;code&gt;greater&amp;lt;&amp;gt;&lt;/code&gt; 作为比较函数返回 true，则表示第二个参数优先级高于第一个参数，应当排在第一个参数之前。因此，这里的“将第一个参数视为较小的元素”指的是将第一个参数作为比较时的较小值，从而实现小根堆的效果。&lt;/p&gt;
&lt;p&gt;在一个二元比较函数中，第一个参数一般是被比较的左侧参数，第二个参数是被比较的右侧参数。比如在 &lt;code&gt;operator&amp;gt;&lt;/code&gt; 函数中，第一个参数就是使用 &lt;code&gt;&amp;gt;&lt;/code&gt; 运算符的左侧参数，第二个参数是右侧参数。在优先队列中，第一个参数也就是堆顶元素。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;  
#include &amp;lt;queue&amp;gt;  
#include &amp;lt;functional&amp;gt;  
using namespace std;  
  
class Person {  
public:  
string name;  
int age;  
  
Person(string name, int age) : name(name), age(age) {}  
  
bool operator&amp;gt;(const Person&amp;amp; other) const {  
return age &amp;gt; other.age;  
}  
};  
  
int main() {  
priority_queue&amp;lt;Person, vector&amp;lt;Person&amp;gt;, greater&amp;lt;&amp;gt;&amp;gt; pq;  
  
// 插入元素  
pq.push(Person(&amp;#34;张三&amp;#34;, 20));  
pq.push(Person(&amp;#34;李四&amp;#34;, 30));  
pq.push(Person(&amp;#34;王五&amp;#34;, 25));  
  
cout &amp;lt;&amp;lt; &amp;#34;这是一个小根堆！！！\n&amp;#34;;  
while (!pq.empty())  
{  
auto&amp;amp; p = pq.top();  
cout &amp;lt;&amp;lt; &amp;#34;Name:&amp;#34; &amp;lt;&amp;lt; p.name &amp;lt;&amp;lt; &amp;#39;\t&amp;#39; &amp;lt;&amp;lt; &amp;#34;Age:&amp;#34; &amp;lt;&amp;lt; p.age &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;  
pq.pop();  
}  
  
return 0;  
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;这是一个小根堆！！！
Name:张三       Age:20
Name:王五       Age:25
Name:李四       Age:30
&lt;/code&gt;&lt;/pre&gt;</description>
      <content:encoded><![CDATA[<p>当待排列的元素为一个对象时，我们既可以通过自定义比较函数，也可以通过重载运算符来达到目的。<br>
下面我以在对象中重载运算符来达到排序的目的展开说明。<br>
下面是针对 <code>sort函数</code> 和 <code>Priority_queue优先队列</code>，关于重载运算符所需要注意的要点</p>
<h1 id="结构体排序">结构体排序</h1>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">struct</span> node{
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> a, b;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 从小到大排序
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">bool</span> <span style="color:#fff;font-weight:bold">operator</span> &lt; (<span style="color:#fff;font-weight:bold">const</span> node&amp; node_)<span style="color:#fff;font-weight:bold">const</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">if</span>(a != node_.a) <span style="color:#fff;font-weight:bold">return</span> a &lt; node_.a;
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> b &lt; node_.b;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> main(){
</span></span><span style="display:flex;"><span>    vector&lt;node&gt; tt;
</span></span><span style="display:flex;"><span>    tt.push_back({<span style="color:#ff0;font-weight:bold">1</span>,<span style="color:#ff0;font-weight:bold">5</span>});
</span></span><span style="display:flex;"><span>    tt.push_back({<span style="color:#ff0;font-weight:bold">2</span>,<span style="color:#ff0;font-weight:bold">3</span>});
</span></span><span style="display:flex;"><span>    sort(tt.begin(), tt.end());
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span>(<span style="color:#fff;font-weight:bold">auto</span> &amp;node: tt){
</span></span><span style="display:flex;"><span>        cout&lt;&lt;node.a&lt;&lt;<span style="color:#0ff;font-weight:bold">&#34; &#34;</span>&lt;&lt;node.b&lt;&lt;endl;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code>执行结果：
1 5
2 3
</code></pre><h1 id="优先队列自定义排序">优先队列自定义排序</h1>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">struct</span> node{
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> a, b;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 在优先队列中，跟排序的规则是反的，这里是指a大的排在前面，a相同时，b大的排在前面
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">bool</span> <span style="color:#fff;font-weight:bold">operator</span> &lt; (<span style="color:#fff;font-weight:bold">const</span> node&amp; node_)<span style="color:#fff;font-weight:bold">const</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">if</span>(a != node_.a) <span style="color:#fff;font-weight:bold">return</span> a &lt; node_.a;
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> b &lt; node_.b;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> main(){
</span></span><span style="display:flex;"><span>    priority_queue&lt;node&gt; pq;
</span></span><span style="display:flex;"><span>    pq.push({<span style="color:#ff0;font-weight:bold">1</span>,<span style="color:#ff0;font-weight:bold">5</span>});
</span></span><span style="display:flex;"><span>    pq.push({<span style="color:#ff0;font-weight:bold">2</span>,<span style="color:#ff0;font-weight:bold">3</span>});
</span></span><span style="display:flex;"><span>    pq.push({<span style="color:#ff0;font-weight:bold">2</span>,<span style="color:#ff0;font-weight:bold">5</span>});
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">while</span>(!pq.empty()) {
</span></span><span style="display:flex;"><span>        cout&lt;&lt;pq.top().a&lt;&lt;<span style="color:#0ff;font-weight:bold">&#34; &#34;</span>&lt;&lt;pq.top().b&lt;&lt;endl;
</span></span><span style="display:flex;"><span>        pq.pop();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><pre tabindex="0"><code>执行结果： 
2 5
2 3
1 5
</code></pre><h1 id="sort函数">Sort函数</h1>
<p>sort函数在默认情况下使用<code>std::less</code>作为比较函数类，而<code>std::less</code>定义了小于号<code>&lt;</code>运算符的重载。因此，在sort函数中如果不指定自定义的比较函数对象，就默认使用<code>std::less</code>来进行排序，即升序排序。如果要实现降序排序，则需要提供自定义的比较函数对象，或者使用<code>std::greater</code>作为比较函数类。</p>
<p><code>sort</code>函数并不能直接重载大于号运算符。<code>sort</code>函数默认使用小于号运算符来对元素进行排序，因此在对对象进行排序时，我们通常会<strong>重载小于号运算符</strong>。</p>
<p>当第一个元素 &lt; 第二个元素时，为<code>true</code>，则最终的排序结果为升序</p>
<p>同理，当我把 <code>this-&gt;age &lt; other.age</code> 修改为 <code>this-&gt;age &gt; other.age</code>时，说明当第一个元素 &gt; 第二个元素时，为<code>true</code>，则结果为降序</p>
<pre tabindex="0"><code>#include &lt;iostream&gt;  
#include &lt;vector&gt;  
using namespace std;  
  
// 定义一个自定义对象  
class Person {  
public:  
string name;  
int age;  
Person(string name, int age) {  
this-&gt;name = name;  
this-&gt;age = age;  
}  
  
// 第一个元素 &lt; 第二个元素，true，升序  
bool operator&lt; (const Person&amp; other) const  
{  
return this-&gt;age &lt; other.age;  
}  
};  
  
int main() {  
// 创建一组Person对象并排序  
Person p1(&#34;Alice&#34;, 25);  
Person p2(&#34;Bob&#34;, 30);  
Person p3(&#34;Charlie&#34;, 20);  
  
vector&lt;Person&gt; people = {p1, p2, p3};  
sort(people.begin(), people.end());  
  
for (auto &amp;p: people)  
{  
cout &lt;&lt; &#34;Name:&#34; &lt;&lt; p.name &lt;&lt; &#39;\t&#39; &lt;&lt; &#34;Age:&#34; &lt;&lt; p.age &lt;&lt; &#39;\n&#39;;  
}  
  
return 0;  
}
</code></pre><p>输出结果：</p>
<pre tabindex="0"><code>Name:Charlie    Age:20
Name:Alice      Age:25
Name:Bob        Age:30
</code></pre><p>通过下述代码，我们可以在调用<code>sort</code>时将比较函数类从默认的<code>std::less</code>改为<code>std::greater</code>，实现降序排序&ndash;前提是记得在对象中重载大于运算符，否则编译器将会报错！！！</p>
<pre tabindex="0"><code>sort(people.begin(), people.end(), greater&lt;&gt;());
</code></pre><h1 id="priority_queue堆优先队列">Priority_queue堆优先队列</h1>
<p>堆是一种数据结构，可以用数组或树实现，常用于实现优先队列、排序算法等。</p>
<p>优先队列（priority queue）就是堆（heap）的一种应用。</p>
<p>C++中的优先队列实现就是堆优先队列，底层使用堆来实现。</p>
<p><code>std::priority_queue</code>是一个模板类，它的模板参数有三个，分别是：</p>
<ol>
<li><code>T</code>：指定队列中存储的元素类型。</li>
<li><code>Container</code>：指定用于存储元素的容器类型，默认是<code>std::vector&lt;T&gt;</code>。</li>
<li><code>Compare</code>：指定用于比较元素优先级的比较函数类型，默认是<code>std::less&lt;T&gt;</code>。</li>
</ol>
<p><code>std::less&lt;T&gt;</code>和<code>std::greater&lt;T&gt;</code>是STL中预定义的两个比较函数类，分别表示小于和大于。它们重载了小于号运算符<code>&lt;</code>和大于号运算符<code>&gt;</code>，用于比较元素的优先级。因此，当我们在定义<code>std::priority_queue</code>时，使用<code>std::less&lt;T&gt;</code>作为比较函数类时，实际上是默认按照小于号进行比较元素优先级；而使用<code>std::greater&lt;T&gt;</code>作为比较函数类时，则是按照大于号进行比较元素优先级。</p>
<p>如果在使用<code>std::less&lt;T&gt;</code>作为比较函数类时，重载大于号<code>&gt;</code>，或者在使用<code>std::greater&lt;T&gt;</code>作为比较函数类时，重载小于号<code>&lt;</code>，都会导致编译错误，因为这些比较函数类内部的比较操作都是用小于号<code>&lt;</code>或者大于号<code>&gt;</code>实现的，而你重载了不符合预期的运算符，导致编译器无法正确地进行比较操作。</p>
<p>在C++中，优先队列可以通过指定比较函数来控制是使用大根堆还是小根堆。如果使用 std::greater&lt;&gt; 作为比较函数，则意味着使用小根堆，即优先级高的元素会被放在队列的顶部；如果使用 std::less&lt;&gt; 作为比较函数，则意味着使用大根堆，即优先级高的元素会被放在队列的底部。</p>
<p>堆中元素之间的优先级关系，这是通过定义比较函数来实现的，比较函数中使用 <code>greater&lt;&gt;</code> 表示元素之间的优先级关系为第一个参数视为较小的元素；使用 <code>less&lt;&gt;</code> 表示元素之间的优先级关系为第一个参数视为较大的元素。</p>
<p>使用 <code>greater&lt;&gt;</code> 作为比较函数时，会将元素之间的优先级关系视为第一个参数较小，也就是说，若 <code>greater&lt;&gt;</code> 作为比较函数返回 true，则表示第二个参数优先级高于第一个参数，应当排在第一个参数之前。因此，这里的“将第一个参数视为较小的元素”指的是将第一个参数作为比较时的较小值，从而实现小根堆的效果。</p>
<p>在一个二元比较函数中，第一个参数一般是被比较的左侧参数，第二个参数是被比较的右侧参数。比如在 <code>operator&gt;</code> 函数中，第一个参数就是使用 <code>&gt;</code> 运算符的左侧参数，第二个参数是右侧参数。在优先队列中，第一个参数也就是堆顶元素。</p>
<pre tabindex="0"><code>#include &lt;iostream&gt;  
#include &lt;queue&gt;  
#include &lt;functional&gt;  
using namespace std;  
  
class Person {  
public:  
string name;  
int age;  
  
Person(string name, int age) : name(name), age(age) {}  
  
bool operator&gt;(const Person&amp; other) const {  
return age &gt; other.age;  
}  
};  
  
int main() {  
priority_queue&lt;Person, vector&lt;Person&gt;, greater&lt;&gt;&gt; pq;  
  
// 插入元素  
pq.push(Person(&#34;张三&#34;, 20));  
pq.push(Person(&#34;李四&#34;, 30));  
pq.push(Person(&#34;王五&#34;, 25));  
  
cout &lt;&lt; &#34;这是一个小根堆！！！\n&#34;;  
while (!pq.empty())  
{  
auto&amp; p = pq.top();  
cout &lt;&lt; &#34;Name:&#34; &lt;&lt; p.name &lt;&lt; &#39;\t&#39; &lt;&lt; &#34;Age:&#34; &lt;&lt; p.age &lt;&lt; &#39;\n&#39;;  
pq.pop();  
}  
  
return 0;  
}
</code></pre><p>输出结果：</p>
<pre tabindex="0"><code>这是一个小根堆！！！
Name:张三       Age:20
Name:王五       Age:25
Name:李四       Age:30
</code></pre>]]></content:encoded>
    </item>
    
  </channel>
</rss>
